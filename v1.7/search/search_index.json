{
    "docs": [
        {
            "location": "/", 
            "text": "Traefik is a modern HTTP reverse proxy and load balancer that makes deploying microservices easy.\nTraefik integrates with your existing infrastructure components (\nDocker\n, \nSwarm mode\n, \nKubernetes\n, \nMarathon\n, \nConsul\n, \nEtcd\n, \nRancher\n, \nAmazon ECS\n, ...) and configures itself automatically and dynamically.\nPointing Traefik at your orchestrator should be the \nonly\n configuration step you need.\n\n\nOverview\n\n\nImagine that you have deployed a bunch of microservices with the help of an orchestrator (like Swarm or Kubernetes) or a service registry (like etcd or consul).\nNow you want users to access these microservices, and you need a reverse proxy.\n\n\nTraditional reverse-proxies require that you configure \neach\n route that will connect paths and subdomains to \neach\n microservice.\nIn an environment where you add, remove, kill, upgrade, or scale your services \nmany\n times a day, the task of keeping the routes up to date becomes tedious.\n\n\nThis is when Traefik can help you!\n\n\nTraefik listens to your service registry/orchestrator API and instantly generates the routes so your microservices are connected to the outside world -- without further intervention from your part.\n\n\nRun Traefik and let it do the work for you!\n\n\n(But if you'd rather configure some of your routes manually, Traefik supports that too!)\n\n\n\n\nFeatures\n\n\n\n\nContinuously updates its configuration (No restarts!)\n\n\nSupports multiple load balancing algorithms\n\n\nProvides HTTPS to your microservices by leveraging \nLet's Encrypt\n (wildcard certificates support)\n\n\nCircuit breakers, retry\n\n\nHigh Availability with cluster mode (beta)\n\n\nSee the magic through its clean web UI\n\n\nWebsocket, HTTP/2, GRPC ready\n\n\nProvides metrics (Rest, Prometheus, Datadog, Statsd, InfluxDB)\n\n\nKeeps access logs (JSON, CLF)\n\n\nFast\n\n\nExposes a Rest API\n\n\nPackaged as a single binary file (made with \u2764\ufe0f with go) and available as a \ntiny\n \nofficial\n docker image\n\n\n\n\nSupported Providers\n\n\n\n\nDocker\n / \nSwarm mode\n\n\nKubernetes\n\n\nMesos\n / \nMarathon\n\n\nRancher\n (API, Metadata)\n\n\nAzure Service Fabric\n\n\nConsul Catalog\n\n\nConsul\n / \nEtcd\n / \nZookeeper\n / \nBoltDB\n\n\nEureka\n\n\nAmazon ECS\n\n\nAmazon DynamoDB\n\n\nFile\n\n\nRest\n\n\n\n\nThe Traefik Quickstart (Using Docker)\n\n\nIn this quickstart, we'll use \nDocker compose\n to create our demo infrastructure.\n\n\nTo save some time, you can clone \nTraefik's repository\n and use the quickstart files located in the \nexamples/quickstart\n directory.\n\n\n1 \u2014 Launch Traefik \u2014 Tell It to Listen to Docker\n\n\nCreate a \ndocker-compose.yml\n file where you will define a \nreverse-proxy\n service that uses the official Traefik image:\n\n\nversion: '3'\n\nservices:\n  reverse-proxy:\n    image: traefik:v1.7 # The official Traefik docker image\n    command: --api --docker # Enables the web UI and tells Traefik to listen to docker\n    ports:\n      - \n80:80\n     # The HTTP port\n      - \n8080:8080\n # The Web UI (enabled by --api)\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock # So that Traefik can listen to the Docker events\n\n\n\n\n\n\nWarning\n\n\nEnabling the Web UI with the \n--api\n flag might expose configuration elements. You can read more about this on the \nAPI/Dashboard's Security section\n.\n\n\n\n\nThat's it. Now you can launch Traefik!\n\n\nStart your \nreverse-proxy\n with the following command:\n\n\ndocker-compose up -d reverse-proxy\n\n\n\n\nYou can open a browser and go to \nhttp://localhost:8080\n to see Traefik's dashboard (we'll go back there once we have launched a service in step 2).\n\n\n2 \u2014 Launch a Service \u2014 Traefik Detects It and Creates a Route for You\n\n\nNow that we have a Traefik instance up and running, we will deploy new services.\n\n\nEdit your \ndocker-compose.yml\n file and add the following at the end of your file.\n\n\n# ...\n  whoami:\n    image: containous/whoami # A container that exposes an API to show its IP address\n    labels:\n      - \ntraefik.frontend.rule=Host:whoami.docker.localhost\n\n\n\n\n\nThe above defines \nwhoami\n: a simple web service that outputs information about the machine it is deployed on (its IP address, host, and so on).\n\n\nStart the \nwhoami\n service with the following command:\n\n\ndocker-compose up -d whoami\n\n\n\n\nGo back to your browser (\nhttp://localhost:8080\n) and see that Traefik has automatically detected the new container and updated its own configuration.\n\n\nWhen Traefik detects new services, it creates the corresponding routes so you can call them ... \nlet's see!\n  (Here, we're using curl)\n\n\ncurl -H Host:whoami.docker.localhost http://127.0.0.1\n\n\n\n\nShows the following output:\n\n\nHostname: 8656c8ddca6c\nIP: 172.27.0.3\n#...\n\n\n\n\n3 \u2014 Launch More Instances \u2014 Traefik Load Balances Them\n\n\nRun more instances of your \nwhoami\n service with the following command:\n\n\ndocker-compose scale whoami=2\n\n\n\n\nGo back to your browser (\nhttp://localhost:8080\n) and see that Traefik has automatically detected the new instance of the container.\n\n\nFinally, see that Traefik load-balances between the two instances of your services by running twice the following command:\n\n\ncurl -H Host:whoami.docker.localhost http://127.0.0.1\n\n\n\n\nThe output will show alternatively one of the followings:\n\n\nHostname: 8656c8ddca6c\nIP: 172.27.0.3\n#...\n\n\n\n\nHostname: 8458f154e1f1\nIP: 172.27.0.4\n# ...\n\n\n\n\n4 \u2014 Enjoy Traefik's Magic\n\n\nNow that you have a basic understanding of how Traefik can automatically create the routes to your services and load balance them, it might be time to dive into \nthe documentation\n and let Traefik work for you!\nWhatever your infrastructure is, there is probably \nan available Traefik provider\n that will do the job.\n\n\nOur recommendation would be to see for yourself how simple it is to enable HTTPS with \nTraefik's let's encrypt integration\n using the dedicated \nuser guide\n.\n\n\nResources\n\n\nHere is a talk given by \nEmile Vauge\n at GopherCon 2017.\nYou will learn Traefik basics in less than 10 minutes.\n\n\n\n\nHere is a talk given by \nEd Robinson\n at \nContainerCamp UK\n conference.\nYou will learn fundamental Traefik features and see some demos with Kubernetes.\n\n\n\n\nDownloads\n\n\nThe Official Binary File\n\n\nYou can grab the latest binary from the \nreleases\n page and just run it with the \nsample configuration file\n:\n\n\n./traefik -c traefik.toml\n\n\n\n\nThe Official Docker Image\n\n\nUsing the tiny Docker image:\n\n\ndocker run -d -p 8080:8080 -p 80:80 -v $PWD/traefik.toml:/etc/traefik/traefik.toml traefik\n\n\n\n\nSecurity\n\n\nSecurity Advisories\n\n\nWe strongly advise you to join our mailing list to be aware of the latest announcements from our security team. You can subscribe sending a mail to security+subscribe@traefik.io or on \nthe online viewer\n.\n\n\nCVE\n\n\nReported vulnerabilities can be found on \n\ncve.mitre.org\n.\n\n\nReport a Vulnerability\n\n\nWe want to keep Traefik safe for everyone.\nIf you've discovered a security vulnerability in Traefik, we appreciate your help in disclosing it to us in a responsible manner, using \nthis form\n.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#overview", 
            "text": "Imagine that you have deployed a bunch of microservices with the help of an orchestrator (like Swarm or Kubernetes) or a service registry (like etcd or consul).\nNow you want users to access these microservices, and you need a reverse proxy.  Traditional reverse-proxies require that you configure  each  route that will connect paths and subdomains to  each  microservice.\nIn an environment where you add, remove, kill, upgrade, or scale your services  many  times a day, the task of keeping the routes up to date becomes tedious.  This is when Traefik can help you!  Traefik listens to your service registry/orchestrator API and instantly generates the routes so your microservices are connected to the outside world -- without further intervention from your part.  Run Traefik and let it do the work for you!  (But if you'd rather configure some of your routes manually, Traefik supports that too!)", 
            "title": "Overview"
        }, 
        {
            "location": "/#features", 
            "text": "Continuously updates its configuration (No restarts!)  Supports multiple load balancing algorithms  Provides HTTPS to your microservices by leveraging  Let's Encrypt  (wildcard certificates support)  Circuit breakers, retry  High Availability with cluster mode (beta)  See the magic through its clean web UI  Websocket, HTTP/2, GRPC ready  Provides metrics (Rest, Prometheus, Datadog, Statsd, InfluxDB)  Keeps access logs (JSON, CLF)  Fast  Exposes a Rest API  Packaged as a single binary file (made with \u2764\ufe0f with go) and available as a  tiny   official  docker image", 
            "title": "Features"
        }, 
        {
            "location": "/#supported-providers", 
            "text": "Docker  /  Swarm mode  Kubernetes  Mesos  /  Marathon  Rancher  (API, Metadata)  Azure Service Fabric  Consul Catalog  Consul  /  Etcd  /  Zookeeper  /  BoltDB  Eureka  Amazon ECS  Amazon DynamoDB  File  Rest", 
            "title": "Supported Providers"
        }, 
        {
            "location": "/#the-traefik-quickstart-using-docker", 
            "text": "In this quickstart, we'll use  Docker compose  to create our demo infrastructure.  To save some time, you can clone  Traefik's repository  and use the quickstart files located in the  examples/quickstart  directory.", 
            "title": "The Traefik Quickstart (Using Docker)"
        }, 
        {
            "location": "/#1-launch-traefik-tell-it-to-listen-to-docker", 
            "text": "Create a  docker-compose.yml  file where you will define a  reverse-proxy  service that uses the official Traefik image:  version: '3'\n\nservices:\n  reverse-proxy:\n    image: traefik:v1.7 # The official Traefik docker image\n    command: --api --docker # Enables the web UI and tells Traefik to listen to docker\n    ports:\n      -  80:80      # The HTTP port\n      -  8080:8080  # The Web UI (enabled by --api)\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock # So that Traefik can listen to the Docker events   Warning  Enabling the Web UI with the  --api  flag might expose configuration elements. You can read more about this on the  API/Dashboard's Security section .   That's it. Now you can launch Traefik!  Start your  reverse-proxy  with the following command:  docker-compose up -d reverse-proxy  You can open a browser and go to  http://localhost:8080  to see Traefik's dashboard (we'll go back there once we have launched a service in step 2).", 
            "title": "1 \u2014 Launch Traefik \u2014 Tell It to Listen to Docker"
        }, 
        {
            "location": "/#2-launch-a-service-traefik-detects-it-and-creates-a-route-for-you", 
            "text": "Now that we have a Traefik instance up and running, we will deploy new services.  Edit your  docker-compose.yml  file and add the following at the end of your file.  # ...\n  whoami:\n    image: containous/whoami # A container that exposes an API to show its IP address\n    labels:\n      -  traefik.frontend.rule=Host:whoami.docker.localhost   The above defines  whoami : a simple web service that outputs information about the machine it is deployed on (its IP address, host, and so on).  Start the  whoami  service with the following command:  docker-compose up -d whoami  Go back to your browser ( http://localhost:8080 ) and see that Traefik has automatically detected the new container and updated its own configuration.  When Traefik detects new services, it creates the corresponding routes so you can call them ...  let's see!   (Here, we're using curl)  curl -H Host:whoami.docker.localhost http://127.0.0.1  Shows the following output:  Hostname: 8656c8ddca6c\nIP: 172.27.0.3\n#...", 
            "title": "2 \u2014 Launch a Service \u2014 Traefik Detects It and Creates a Route for You"
        }, 
        {
            "location": "/#3-launch-more-instances-traefik-load-balances-them", 
            "text": "Run more instances of your  whoami  service with the following command:  docker-compose scale whoami=2  Go back to your browser ( http://localhost:8080 ) and see that Traefik has automatically detected the new instance of the container.  Finally, see that Traefik load-balances between the two instances of your services by running twice the following command:  curl -H Host:whoami.docker.localhost http://127.0.0.1  The output will show alternatively one of the followings:  Hostname: 8656c8ddca6c\nIP: 172.27.0.3\n#...  Hostname: 8458f154e1f1\nIP: 172.27.0.4\n# ...", 
            "title": "3 \u2014 Launch More Instances \u2014 Traefik Load Balances Them"
        }, 
        {
            "location": "/#4-enjoy-traefiks-magic", 
            "text": "Now that you have a basic understanding of how Traefik can automatically create the routes to your services and load balance them, it might be time to dive into  the documentation  and let Traefik work for you!\nWhatever your infrastructure is, there is probably  an available Traefik provider  that will do the job.  Our recommendation would be to see for yourself how simple it is to enable HTTPS with  Traefik's let's encrypt integration  using the dedicated  user guide .", 
            "title": "4 \u2014 Enjoy Traefik's Magic"
        }, 
        {
            "location": "/#resources", 
            "text": "Here is a talk given by  Emile Vauge  at GopherCon 2017.\nYou will learn Traefik basics in less than 10 minutes.   Here is a talk given by  Ed Robinson  at  ContainerCamp UK  conference.\nYou will learn fundamental Traefik features and see some demos with Kubernetes.", 
            "title": "Resources"
        }, 
        {
            "location": "/#downloads", 
            "text": "", 
            "title": "Downloads"
        }, 
        {
            "location": "/#the-official-binary-file", 
            "text": "You can grab the latest binary from the  releases  page and just run it with the  sample configuration file :  ./traefik -c traefik.toml", 
            "title": "The Official Binary File"
        }, 
        {
            "location": "/#the-official-docker-image", 
            "text": "Using the tiny Docker image:  docker run -d -p 8080:8080 -p 80:80 -v $PWD/traefik.toml:/etc/traefik/traefik.toml traefik", 
            "title": "The Official Docker Image"
        }, 
        {
            "location": "/#security", 
            "text": "", 
            "title": "Security"
        }, 
        {
            "location": "/#security-advisories", 
            "text": "We strongly advise you to join our mailing list to be aware of the latest announcements from our security team. You can subscribe sending a mail to security+subscribe@traefik.io or on  the online viewer .", 
            "title": "Security Advisories"
        }, 
        {
            "location": "/#cve", 
            "text": "Reported vulnerabilities can be found on  cve.mitre.org .", 
            "title": "CVE"
        }, 
        {
            "location": "/#report-a-vulnerability", 
            "text": "We want to keep Traefik safe for everyone.\nIf you've discovered a security vulnerability in Traefik, we appreciate your help in disclosing it to us in a responsible manner, using  this form .", 
            "title": "Report a Vulnerability"
        }, 
        {
            "location": "/basics/", 
            "text": "Basics\n\n\nConcepts\n\n\nLet's take our example from the \noverview\n again:\n\n\n\n\nImagine that you have deployed a bunch of microservices on your infrastructure. You probably used a service registry (like etcd or consul) and/or an orchestrator (swarm, Mesos/Marathon) to manage all these services.\nIf you want your users to access some of your microservices from the Internet, you will have to use a reverse proxy and configure it using virtual hosts or prefix paths:\n\n\n\n\ndomain \napi.domain.com\n will point the microservice \napi\n in your private network\n\n\npath \ndomain.com/web\n will point the microservice \nweb\n in your private network\n\n\ndomain \nbackoffice.domain.com\n will point the microservices \nbackoffice\n in your private network, load-balancing between your multiple instances\n\n\n\n\n\n\n\n\nLet's zoom on Traefik and have an overview of its internal architecture:\n\n\n\n\n\n\nIncoming requests end on \nentrypoints\n, as the name suggests, they are the network entry points into Traefik (listening port, SSL, traffic redirection...).\n\n\nTraffic is then forwarded to a matching \nfrontend\n. A frontend defines routes from \nentrypoints\n to \nbackends\n.\nRoutes are created using requests fields (\nHost\n, \nPath\n, \nHeaders\n...) and can match or not a request.\n\n\nThe \nfrontend\n will then send the request to a \nbackend\n. A backend can be composed by one or more \nservers\n, and by a load-balancing strategy.\n\n\nFinally, the \nserver\n will forward the request to the corresponding microservice in the private network.\n\n\n\n\nEntrypoints\n\n\nEntrypoints are the network entry points into Traefik.\nThey can be defined using:\n\n\n\n\na port (80, 443...)\n\n\nSSL (Certificates, Keys, authentication with a client certificate signed by a trusted CA...)\n\n\nredirection to another entrypoint (redirect \nHTTP\n to \nHTTPS\n)\n\n\n\n\nHere is an example of entrypoints definition:\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n    [entryPoints.http.redirect]\n    entryPoint = \nhttps\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile = \ntests/traefik.crt\n\n      keyFile = \ntests/traefik.key\n\n\n\n\n\n\n\nTwo entrypoints are defined \nhttp\n and \nhttps\n.\n\n\nhttp\n listens on port \n80\n and \nhttps\n on port \n443\n.\n\n\nWe enable SSL on \nhttps\n by giving a certificate and a key.\n\n\nWe also redirect all the traffic from entrypoint \nhttp\n to \nhttps\n.\n\n\n\n\nAnd here is another example with client certificate authentication:\n\n\n[entryPoints]\n  [entryPoints.https]\n  address = \n:443\n\n  [entryPoints.https.tls]\n    [entryPoints.https.tls.ClientCA]\n    files = [\ntests/clientca1.crt\n, \ntests/clientca2.crt\n]\n    optional = false\n    [[entryPoints.https.tls.certificates]]\n    certFile = \ntests/traefik.crt\n\n    keyFile = \ntests/traefik.key\n\n\n\n\n\n\n\nWe enable SSL on \nhttps\n by giving a certificate and a key.\n\n\nOne or several files containing Certificate Authorities in PEM format are added.\n\n\nIt is possible to have multiple CA:s in the same file or keep them in separate files.\n\n\n\n\nFrontends\n\n\nA frontend consists of a set of rules that determine how incoming requests are forwarded from an entrypoint to a backend.\n\n\nRules may be classified in one of two groups: Modifiers and matchers.\n\n\nModifiers\n\n\nModifier rules only modify the request. They do not have any impact on routing decisions being made.\n\n\nFollowing is the list of existing modifier rules:\n\n\n\n\nAddPrefix: /products\n: Add path prefix to the existing request path prior to forwarding the request to the backend.\n\n\nReplacePath: /serverless-path\n: Replaces the path and adds the old path to the \nX-Replaced-Path\n header. Useful for mapping to AWS Lambda or Google Cloud Functions.\n\n\nReplacePathRegex: ^/api/v2/(.*) /api/$1\n: Replaces the path with a regular expression and adds the old path to the \nX-Replaced-Path\n header. Separate the regular expression and the replacement by a space.\n\n\n\n\nMatchers\n\n\nMatcher rules determine if a particular request should be forwarded to a backend.\n\n\nThe associativity rule is the following:\n\n\n\n\n,\n is the \nOR\n operator (works \nonly inside a matcher\n, ex: \nHost:foo.com,bar.com\n).\n\n\ni.e., forward a request if any rule matches.\n\n\nDoes not work for \nHeaders\n and \nHeadersRegexp\n.\n\n\n\n\n\n\n;\n is the \nAND\n operator (works \nonly between matchers\n, ex: \nHost:foo.com;Path:/bar\n) \n\n\ni.e., forward a request if all rules match\n\n\n\n\n\n\n\n\nFollowing is the list of existing matcher rules along with examples:\n\n\n\n\n\n\n\n\nMatcher\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nHeaders: Content-Type, application/json\n\n\nMatch HTTP header. It accepts a comma-separated key/value pair where both key and value must be literals.\n\n\n\n\n\n\nHeadersRegexp: Content-Type, application/(text/json)\n\n\nMatch HTTP header. It accepts a comma-separated key/value pair where the key must be a literal and the value may be a literal or a regular expression.\n\n\n\n\n\n\nHost: traefik.io, www.traefik.io\n\n\nMatch request host. It accepts a sequence of literal hosts.\n\n\n\n\n\n\nHostRegexp: traefik.io, {subdomain:[a-z]+}.traefik.io\n\n\nMatch request host. It accepts a sequence of literal and regular expression hosts.\n\n\n\n\n\n\nMethod: GET, POST, PUT\n\n\nMatch request HTTP method. It accepts a sequence of HTTP methods.\n\n\n\n\n\n\nPath: /products/, /articles/{category}/{id:[0-9]+}\n\n\nMatch exact request path. It accepts a sequence of literal and regular expression paths.\n\n\n\n\n\n\nPathStrip: /products/\n\n\nMatch exact path and strip off the path prior to forwarding the request to the backend. It accepts a sequence of literal paths.\n\n\n\n\n\n\nPathStripRegex: /articles/{category}/{id:[0-9]+}\n\n\nMatch exact path and strip off the path prior to forwarding the request to the backend. It accepts a sequence of literal and regular expression paths.\n\n\n\n\n\n\nPathPrefix: /products/, /articles/{category}/{id:[0-9]+}\n\n\nMatch request prefix path. It accepts a sequence of literal and regular expression prefix paths.\n\n\n\n\n\n\nPathPrefixStrip: /products/\n\n\nMatch request prefix path and strip off the path prefix prior to forwarding the request to the backend. It accepts a sequence of literal prefix paths. Starting with Traefik 1.3, the stripped prefix path will be available in the \nX-Forwarded-Prefix\n header.\n\n\n\n\n\n\nPathPrefixStripRegex: /articles/{category}/{id:[0-9]+}\n\n\nMatch request prefix path and strip off the path prefix prior to forwarding the request to the backend. It accepts a sequence of literal and regular expression prefix paths. Starting with Traefik 1.3, the stripped prefix path will be available in the \nX-Forwarded-Prefix\n header.\n\n\n\n\n\n\nQuery: foo=bar, bar=baz\n\n\nMatch Query String parameters. It accepts a sequence of key=value pairs.\n\n\n\n\n\n\n\n\nIn order to use regular expressions with Host and Path matchers, you must declare an arbitrarily named variable followed by the colon-separated regular expression, all enclosed in curly braces. Any pattern supported by \nGo's regexp package\n may be used (example: \n/posts/{id:[0-9]+}\n).\n\n\n\n\nNote\n\n\nThe variable has no special meaning; however, it is required by the \ngorilla/mux\n dependency which embeds the regular expression and defines the syntax.\n\n\n\n\nYou can optionally enable \npassHostHeader\n to forward client \nHost\n header to the backend.\nYou can also optionally configure the \npassTLSClientCert\n option to pass the Client certificates to the backend in a specific header.\n\n\nPath Matcher Usage Guidelines\n\n\nThis section explains when to use the various path matchers.\n\n\nUse \nPath\n if your backend listens on the exact path only. For instance, \nPath: /products\n would match \n/products\n but not \n/products/shoes\n.\n\n\nUse a \n*Prefix*\n matcher if your backend listens on a particular base path but also serves requests on sub-paths.\nFor instance, \nPathPrefix: /products\n would match \n/products\n but also \n/products/shoes\n and \n/products/shirts\n.\nSince the path is forwarded as-is, your backend is expected to listen on \n/products\n.\n\n\nUse a \n*Strip\n matcher if your backend listens on the root path (\n/\n) but should be routeable on a specific prefix.\nFor instance, \nPathPrefixStrip: /products\n would match \n/products\n but also \n/products/shoes\n and \n/products/shirts\n.\n\nSince the path is stripped prior to forwarding, your backend is expected to listen on \n/\n.\n\nIf your backend is serving assets (e.g., images or Javascript files), chances are it must return properly constructed relative URLs.\n\nContinuing on the example, the backend should return \n/products/shoes/image.png\n (and not \n/images.png\n which Traefik would likely not be able to associate with the same backend).\n\nThe \nX-Forwarded-Prefix\n header (available since Traefik 1.3) can be queried to build such URLs dynamically.\n\n\nInstead of distinguishing your backends by path only, you can add a Host matcher to the mix.\nThat way, namespacing of your backends happens on the basis of hosts in addition to paths.\n\n\nExamples\n\n\nHere is an example of frontends definition:\n\n\n[frontends]\n  [frontends.frontend1]\n  backend = \nbackend2\n\n    [frontends.frontend1.routes.test_1]\n    rule = \nHost:test.localhost,test2.localhost\n\n  [frontends.frontend2]\n  backend = \nbackend1\n\n  passHostHeader = true\n  [frontends.frontend2.passTLSClientCert]\n    pem = true\n  priority = 10\n  entrypoints = [\nhttps\n] # overrides defaultEntryPoints\n    [frontends.frontend2.routes.test_1]\n    rule = \nHostRegexp:localhost,{subdomain:[a-z]+}.localhost\n\n  [frontends.frontend3]\n  backend = \nbackend2\n\n    [frontends.frontend3.routes.test_1]\n    rule = \nHost:test3.localhost;Path:/test\n\n\n\n\n\n\n\nThree frontends are defined: \nfrontend1\n, \nfrontend2\n and \nfrontend3\n\n\nfrontend1\n will forward the traffic to the \nbackend2\n if the rule \nHost:test.localhost,test2.localhost\n is matched\n\n\nfrontend2\n will forward the traffic to the \nbackend1\n if the rule \nHostRegexp:localhost,{subdomain:[a-z]+}.localhost\n is matched (forwarding client \nHost\n header to the backend)\n\n\nfrontend3\n will forward the traffic to the \nbackend2\n if the rules \nHost:test3.localhost\n \nAND\n \nPath:/test\n are matched\n\n\n\n\nCombining multiple rules\n\n\nAs seen in the previous example, you can combine multiple rules.\nIn TOML file, you can use multiple routes:\n\n\n  [frontends.frontend3]\n  backend = \nbackend2\n\n    [frontends.frontend3.routes.test_1]\n    rule = \nHost:test3.localhost\n\n    [frontends.frontend3.routes.test_2]\n    rule = \nPath:/test\n\n\n\n\n\nHere \nfrontend3\n will forward the traffic to the \nbackend2\n if the rules \nHost:test3.localhost\n \nAND\n \nPath:/test\n are matched.\n\n\nYou can also use the notation using a \n;\n separator, same result:\n\n\n  [frontends.frontend3]\n  backend = \nbackend2\n\n    [frontends.frontend3.routes.test_1]\n    rule = \nHost:test3.localhost;Path:/test\n\n\n\n\n\nFinally, you can create a rule to bind multiple domains or Path to a frontend, using the \n,\n separator:\n\n\n [frontends.frontend2]\n    [frontends.frontend2.routes.test_1]\n    rule = \nHost:test1.localhost,test2.localhost\n\n  [frontends.frontend3]\n  backend = \nbackend2\n\n    [frontends.frontend3.routes.test_1]\n    rule = \nPath:/test1,/test2\n\n\n\n\n\nRules Order\n\n\nWhen combining \nModifier\n rules with \nMatcher\n rules, it is important to remember that \nModifier\n rules \nALWAYS\n apply after the \nMatcher\n rules.\n\n\nThe following rules are both \nMatchers\n and \nModifiers\n, so the \nMatcher\n portion of the rule will apply first, and the \nModifier\n will apply later.\n\n\n\n\nPathStrip\n\n\nPathStripRegex\n\n\nPathPrefixStrip\n\n\nPathPrefixStripRegex\n\n\n\n\nModifiers\n will be applied in a pre-determined order regardless of their order in the \nrule\n configuration section.\n\n\n\n\nPathStrip\n\n\nPathPrefixStrip\n\n\nPathStripRegex\n\n\nPathPrefixStripRegex\n\n\nAddPrefix\n\n\nReplacePath\n\n\n\n\nPriorities\n\n\nBy default, routes will be sorted (in descending order) using rules length (to avoid path overlap):\n- \nPathPrefix:/foo;Host:foo.com\n (length == 28) will be matched before \nPathPrefixStrip:/foobar\n (length == 23) will be matched before \nPathPrefix:/foo,/bar\n (length == 20).\n\n- A priority value of 0 will be ignored, so the default value will be calculated (rules length).\n\n\nYou can customize priority by frontend. The priority value override the rule length during sorting:\n\n\n  [frontends]\n    [frontends.frontend1]\n    backend = \nbackend1\n\n    priority = 20\n    passHostHeader = true\n      [frontends.frontend1.routes.test_1]\n      rule = \nPathPrefix:/to\n\n    [frontends.frontend2]\n    backend = \nbackend2\n\n    passHostHeader = true\n      [frontends.frontend2.routes.test_1]\n      rule = \nPathPrefix:/toto\n\n\n\n\n\nHere, \nfrontend1\n will be matched before \nfrontend2\n (\n20 \n 16\n).\n\n\nCustom headers\n\n\nCustom headers can be configured through the frontends, to add headers to either requests or responses that match the frontend's rules.\nThis allows for setting headers such as \nX-Script-Name\n to be added to the request, or custom headers to be added to the response.\n\n\n\n\nWarning\n\n\nIf the custom header name is the same as one header name of the request or response, it will be replaced.\n\n\n\n\nIn this example, all matches to the path \n/cheese\n will have the \nX-Script-Name\n header added to the proxied request and the \nX-Custom-Response-Header\n header added to the response.\n\n\n[frontends]\n  [frontends.frontend1]\n  backend = \nbackend1\n\n    [frontends.frontend1.headers.customresponseheaders]\n    X-Custom-Response-Header = \nTrue\n\n    [frontends.frontend1.headers.customrequestheaders]\n    X-Script-Name = \ntest\n\n    [frontends.frontend1.routes.test_1]\n    rule = \nPathPrefixStrip:/cheese\n\n\n\n\n\nIn this second  example, all matches to the path \n/cheese\n will have the \nX-Script-Name\n header added to the proxied request, the \nX-Custom-Request-Header\n header removed from the request, and the \nX-Custom-Response-Header\n header removed from the response.\n\n\n[frontends]\n  [frontends.frontend1]\n  backend = \nbackend1\n\n    [frontends.frontend1.headers.customresponseheaders]\n    X-Custom-Response-Header = \n\n    [frontends.frontend1.headers.customrequestheaders]\n    X-Script-Name = \ntest\n\n    X-Custom-Request-Header = \n\n    [frontends.frontend1.routes.test_1]\n    rule = \nPathPrefixStrip:/cheese\n\n\n\n\n\nSecurity headers\n\n\nSecurity related headers (HSTS headers, SSL redirection, Browser XSS filter, etc) can be added and configured per frontend in a similar manner to the custom headers above.\nThis functionality allows for some easy security features to quickly be set.\n\n\nAn example of some of the security headers:\n\n\n[frontends]\n  [frontends.frontend1]\n  backend = \nbackend1\n\n    [frontends.frontend1.headers]\n    FrameDeny = true\n    [frontends.frontend1.routes.test_1]\n    rule = \nPathPrefixStrip:/cheddar\n\n  [frontends.frontend2]\n  backend = \nbackend2\n\n    [frontends.frontend2.headers]\n    SSLRedirect = true\n    [frontends.frontend2.routes.test_1]\n    rule = \nPathPrefixStrip:/stilton\n\n\n\n\n\nIn this example, traffic routed through the first frontend will have the \nX-Frame-Options\n header set to \nDENY\n, and the second will only allow HTTPS request through, otherwise will return a 301 HTTPS redirect.\n\n\n\n\nNote\n\n\nThe detailed documentation for those security headers can be found in \nunrolled/secure\n.\n\n\n\n\nBackends\n\n\nA backend is responsible to load-balance the traffic coming from one or more frontends to a set of http servers.\n\n\nServers\n\n\nServers are simply defined using a \nurl\n. You can also apply a custom \nweight\n to each server (this will be used by load-balancing).\n\n\n\n\nNote\n\n\nPaths in \nurl\n are ignored. Use \nModifier\n to specify paths instead.\n\n\n\n\nHere is an example of backends and servers definition:\n\n\n[backends]\n  [backends.backend1]\n    # ...\n    [backends.backend1.servers.server1]\n    url = \nhttp://172.17.0.2:80\n\n    weight = 10\n    [backends.backend1.servers.server2]\n    url = \nhttp://172.17.0.3:80\n\n    weight = 1\n  [backends.backend2]\n    # ...\n    [backends.backend2.servers.server1]\n    url = \nhttps://172.17.0.4:443\n\n    weight = 1\n    [backends.backend2.servers.server2]\n    url = \nhttps://172.17.0.5:443\n\n    weight = 2\n  [backends.backend3]\n    # ...\n    [backends.backend3.servers.server1]\n    url = \nh2c://172.17.0.6:80\n\n    weight = 1\n\n\n\n\n\n\nTwo backends are defined: \nbackend1\n and \nbackend2\n\n\nbackend1\n will forward the traffic to two servers: \n172.17.0.2:80\n with weight \n10\n and \n172.17.0.3:80\n with weight \n1\n.\n\n\nbackend2\n will forward the traffic to two servers: \n172.17.0.4:443\n with weight \n1\n and \n172.17.0.5:443\n with weight \n2\n both using TLS.\n\n\nbackend3\n will forward the traffic to: \n172.17.0.6:80\n with weight \n1\n using HTTP2 without TLS.\n\n\n\n\nLoad-balancing\n\n\nVarious methods of load-balancing are supported:\n\n\n\n\nwrr\n: Weighted Round Robin.\n\n\ndrr\n: Dynamic Round Robin: increases weights on servers that perform better than others.\n    It also rolls back to original weights if the servers have changed.\n\n\n\n\nCircuit breakers\n\n\nA circuit breaker can also be applied to a backend, preventing high loads on failing servers.\nInitial state is Standby. CB observes the statistics and does not modify the request.\nIn case the condition matches, CB enters Tripped state, where it responds with predefined code or redirects to another frontend.\nOnce Tripped timer expires, CB enters Recovering state and resets all stats.\nIn case the condition does not match and recovery timer expires, CB enters Standby state.\n\n\nIt can be configured using:\n\n\n\n\nMethods: \nLatencyAtQuantileMS\n, \nNetworkErrorRatio\n, \nResponseCodeRatio\n\n\nOperators:  \nAND\n, \nOR\n, \nEQ\n, \nNEQ\n, \nLT\n, \nLE\n, \nGT\n, \nGE\n\n\n\n\nFor example:\n\n\n\n\nNetworkErrorRatio() \n 0.5\n: watch error ratio over 10 second sliding window for a frontend.\n\n\nLatencyAtQuantileMS(50.0) \n 50\n:  watch latency at quantile in milliseconds.\n\n\nResponseCodeRatio(500, 600, 0, 600) \n 0.5\n: ratio of response codes in ranges [500-600) and [0-600).\n\n\n\n\nHere is an example of backends and servers definition:\n\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.circuitbreaker]\n    expression = \nNetworkErrorRatio() \n 0.5\n\n    [backends.backend1.servers.server1]\n    url = \nhttp://172.17.0.2:80\n\n    weight = 10\n    [backends.backend1.servers.server2]\n    url = \nhttp://172.17.0.3:80\n\n    weight = 1\n\n\n\n\n\n\nbackend1\n will forward the traffic to two servers: \nhttp://172.17.0.2:80\"\n with weight \n10\n and \nhttp://172.17.0.3:80\n with weight \n1\n using default \nwrr\n load-balancing strategy.\n\n\na circuit breaker is added on \nbackend1\n using the expression \nNetworkErrorRatio() \n 0.5\n: watch error ratio over 10 second sliding window\n\n\n\n\nMaximum connections\n\n\nTo proactively prevent backends from being overwhelmed with high load, a maximum connection limit can also be applied to each backend.\n\n\nMaximum connections can be configured by specifying an integer value for \nmaxconn.amount\n and \nmaxconn.extractorfunc\n which is a strategy used to determine how to categorize requests in order to evaluate the maximum connections.\n\n\nFor example:\n\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.maxconn]\n       amount = 10\n       extractorfunc = \nrequest.host\n\n   # ...\n\n\n\n\n\n\nbackend1\n will return \nHTTP code 429 Too Many Requests\n if there are already 10 requests in progress for the same Host header.\n\n\nAnother possible value for \nextractorfunc\n is \nclient.ip\n which will categorize requests based on client source ip.\n\n\nLastly \nextractorfunc\n can take the value of \nrequest.header.ANY_HEADER\n which will categorize requests based on \nANY_HEADER\n that you provide.\n\n\n\n\nSticky sessions\n\n\nSticky sessions are supported with both load balancers.\n\nWhen sticky sessions are enabled, a cookie is set on the initial request.\nThe default cookie name is an abbreviation of a sha1 (ex: \n_1d52e\n).\nOn subsequent requests, the client will be directed to the backend stored in the cookie if it is still healthy.\nIf not, a new backend will be assigned.\n\n\n[backends]\n  [backends.backend1]\n    # Enable sticky session\n    [backends.backend1.loadbalancer.stickiness]\n\n    # Customize the cookie name\n    #\n    # Optional\n    # Default: a sha1 (6 chars)\n    #\n    #  cookieName = \nmy_cookie\n\n\n\n\n\nThe deprecated way:\n\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.loadbalancer]\n      sticky = true\n\n\n\n\nHealth Check\n\n\nA health check can be configured in order to remove a backend from LB rotation as long as it keeps returning HTTP status codes other than \n2xx\n or \n3xx\n to HTTP GET requests periodically carried out by Traefik.\n\nThe check is defined by a path appended to the backend URL and an interval (given in a format understood by \ntime.ParseDuration\n) specifying how often the health check should be executed (the default being 30 seconds).\nEach backend must respond to the health check within 5 seconds.\n\nBy default, the port of the backend server is used, however, this may be overridden.\n\n\nA recovering backend returning \n2xx\n or \n3xx\n responses again is being returned to the LB rotation pool.\n\n\nFor example:\n\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.healthcheck]\n    path = \n/health\n\n    interval = \n10s\n\n\n\n\n\nTo use a different port for the health check:\n\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.healthcheck]\n    path = \n/health\n\n    interval = \n10s\n\n    port = 8080\n\n\n\n\nTo use a different scheme for the health check:\n\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.healthcheck]\n    path = \n/health\n\n    interval = \n10s\n\n    scheme = \nhttp\n\n\n\n\n\nAdditional http headers and hostname to health check request can be specified, for instance:\n\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.healthcheck]\n    path = \n/health\n\n    interval = \n10s\n\n    hostname = \nmyhost.com\n\n    port = 8080\n      [backends.backend1.healthcheck.headers]\n      My-Custom-Header = \nfoo\n\n      My-Header = \nbar\n\n\n\n\n\nConfiguration\n\n\nTraefik's configuration has two parts:\n\n\n\n\nThe \nstatic Traefik configuration\n which is loaded only at the beginning.\n\n\nThe \ndynamic Traefik configuration\n which can be hot-reloaded (no need to restart the process).\n\n\n\n\nStatic Traefik configuration\n\n\nThe static configuration is the global configuration which is setting up connections to configuration backends and entrypoints.\n\n\nTraefik can be configured using many configuration sources with the following precedence order.\nEach item takes precedence over the item below it:\n\n\n\n\nKey-value store\n\n\nArguments\n\n\nConfiguration file\n\n\nDefault\n\n\n\n\nIt means that arguments override configuration file, and key-value store overrides arguments.\n\n\n\n\nNote\n\n\nthe provider-enabling argument parameters (e.g., \n--docker\n) set all default values for the specific provider.\n\nIt must not be used if a configuration source with less precedence wants to set a non-default provider value.\n\n\n\n\nConfiguration file\n\n\nBy default, Traefik will try to find a \ntraefik.toml\n in the following places:\n\n\n\n\n/etc/traefik/\n\n\n$HOME/.traefik/\n\n\n.\n \nthe working directory\n\n\n\n\nYou can override this by setting a \nconfigFile\n argument:\n\n\ntraefik --configFile=foo/bar/myconfigfile.toml\n\n\n\n\nPlease refer to the \nglobal configuration\n section to get documentation on it.\n\n\nArguments\n\n\nEach argument (and command) is described in the help section:\n\n\ntraefik --help\n\n\n\n\nNote that all default values will be displayed as well.\n\n\nKey-value stores\n\n\nTraefik supports several Key-value stores:\n\n\n\n\nConsul\n\n\netcd\n\n\nZooKeeper\n\n\nboltdb\n\n\n\n\nPlease refer to the \nUser Guide Key-value store configuration\n section to get documentation on it.\n\n\nDynamic Traefik configuration\n\n\nThe dynamic configuration concerns :\n\n\n\n\nFrontends\n\n\nBackends\n\n\nServers\n\n\nHTTPS Certificates\n\n\n\n\nTraefik can hot-reload those rules which could be provided by \nmultiple configuration backends\n.\n\n\nWe only need to enable \nwatch\n option to make Traefik watch configuration backend changes and generate its configuration automatically.\nRoutes to services will be created and updated instantly at any changes.\n\n\nPlease refer to the \nconfiguration backends\n section to get documentation on it.\n\n\nCommands\n\n\ntraefik\n\n\nUsage:\n\n\ntraefik [command] [--flag=flag_argument]\n\n\n\n\nList of Traefik available\u00a0commands with description :\n\n\n\n\nversion\n : Print\u00a0version\n\n\nstoreconfig\n : Store the static Traefik configuration into a Key-value stores.\u00a0Please refer to the \nStore Traefik configuration\n section to get documentation on it.\n\n\nbug\n: The easiest way to submit a pre-filled issue.\n\n\nhealthcheck\n: Calls Traefik \n/ping\n to check health.\n\n\n\n\nEach command may have related flags.\n\n\nAll those related flags will be displayed with :\n\n\ntraefik [command] --help\n\n\n\n\nEach command is described at the beginning of the help section:\n\n\ntraefik --help\n\n# or\n\ndocker run traefik[:version] --help\n# ex: docker run traefik:1.5 --help\n\n\n\n\nCommand: bug\n\n\nHere is the easiest way to submit a pre-filled issue on \nTraefik GitHub\n.\n\n\ntraefik bug\n\n\n\n\nWatch \nthis demo\n.\n\n\nCommand: healthcheck\n\n\nThis command allows to check the health of Traefik. Its exit status is \n0\n if Traefik is healthy and \n1\n if it is unhealthy.\n\n\nThis can be used with Docker \nHEALTHCHECK\n instruction or any other health check orchestration mechanism.\n\n\n\n\nNote\n\n\nThe \nping\n must be enabled to allow the \nhealthcheck\n command to call \n/ping\n.\n\n\n\n\ntraefik healthcheck\n\n\n\n\nOK: http://:8082/ping\n\n\n\n\nCollected Data\n\n\nThis feature is disabled by default.\n\n\nYou can read the public proposal on this topic \nhere\n.\n\n\nWhy ?\n\n\nIn order to help us learn more about how Traefik is being used and improve it, we collect anonymous usage statistics from running instances.\nThose data help us prioritize our developments and focus on what's more important (for example, which configuration backend is used and which is not used).\n\n\nWhat ?\n\n\nOnce a day (the first call begins 10 minutes after the start of Traefik), we collect:\n\n\n\n\nthe Traefik version\n\n\na hash of the configuration\n\n\nan \nanonymous version\n of the static configuration:\n\n\ntoken, user name, password, URL, IP, domain, email, etc, are removed\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nWe do not collect the dynamic configuration (frontends \n backends).\n\n\n\n\n\n\nNote\n\n\nWe do not collect data behind the scenes to run advertising programs or to sell such data to third-party.\n\n\n\n\nHere is an example\n\n\n\n\nSource configuration:\n\n\n\n\n[entryPoints]\n    [entryPoints.http]\n       address = \n:80\n\n\n[api]\n\n[Docker]\n  endpoint = \ntcp://10.10.10.10:2375\n\n  domain = \nfoo.bir\n\n  exposedByDefault = true\n  swarmMode = true\n\n  [Docker.TLS]\n    ca = \ndockerCA\n\n    cert = \ndockerCert\n\n    key = \ndockerKey\n\n    insecureSkipVerify = true\n\n[ECS]\n  domain = \nfoo.bar\n\n  exposedByDefault = true\n  clusters = [\nfoo-bar\n]\n  region = \nus-west-2\n\n  accessKeyID = \nAccessKeyID\n\n  secretAccessKey = \nSecretAccessKey\n\n\n\n\n\n\n\nObfuscated and anonymous configuration:\n\n\n\n\n[entryPoints]\n    [entryPoints.http]\n       address = \n:80\n\n\n[api]\n\n[Docker]\n  endpoint = \nxxxx\n\n  domain = \nxxxx\n\n  exposedByDefault = true\n  swarmMode = true\n\n  [Docker.TLS]\n    ca = \nxxxx\n\n    cert = \nxxxx\n\n    key = \nxxxx\n\n    insecureSkipVerify = false\n\n[ECS]\n  domain = \nxxxx\n\n  exposedByDefault = true\n  clusters = []\n  region = \nus-west-2\n\n  accessKeyID = \nxxxx\n\n  secretAccessKey = \nxxxx\n\n\n\n\n\nShow me the code !\n\n\nIf you want to dig into more details, here is the source code of the collecting system: \ncollector.go\n\n\nBy default we anonymize all configuration fields, except fields tagged with \nexport=true\n.\n\n\nHow to enable this ?\n\n\nYou can enable the collecting system by:\n\n\n\n\nadding this line in the configuration TOML file:\n\n\n\n\n# Send anonymous usage data\n#\n# Optional\n# Default: false\n#\nsendAnonymousUsage = true\n\n\n\n\n\n\nadding this flag in the CLI:\n\n\n\n\n./traefik --sendAnonymousUsage=true", 
            "title": "Basics"
        }, 
        {
            "location": "/basics/#basics", 
            "text": "", 
            "title": "Basics"
        }, 
        {
            "location": "/basics/#concepts", 
            "text": "Let's take our example from the  overview  again:   Imagine that you have deployed a bunch of microservices on your infrastructure. You probably used a service registry (like etcd or consul) and/or an orchestrator (swarm, Mesos/Marathon) to manage all these services.\nIf you want your users to access some of your microservices from the Internet, you will have to use a reverse proxy and configure it using virtual hosts or prefix paths:   domain  api.domain.com  will point the microservice  api  in your private network  path  domain.com/web  will point the microservice  web  in your private network  domain  backoffice.domain.com  will point the microservices  backoffice  in your private network, load-balancing between your multiple instances     Let's zoom on Traefik and have an overview of its internal architecture:    Incoming requests end on  entrypoints , as the name suggests, they are the network entry points into Traefik (listening port, SSL, traffic redirection...).  Traffic is then forwarded to a matching  frontend . A frontend defines routes from  entrypoints  to  backends .\nRoutes are created using requests fields ( Host ,  Path ,  Headers ...) and can match or not a request.  The  frontend  will then send the request to a  backend . A backend can be composed by one or more  servers , and by a load-balancing strategy.  Finally, the  server  will forward the request to the corresponding microservice in the private network.", 
            "title": "Concepts"
        }, 
        {
            "location": "/basics/#entrypoints", 
            "text": "Entrypoints are the network entry points into Traefik.\nThey can be defined using:   a port (80, 443...)  SSL (Certificates, Keys, authentication with a client certificate signed by a trusted CA...)  redirection to another entrypoint (redirect  HTTP  to  HTTPS )   Here is an example of entrypoints definition:  [entryPoints]\n  [entryPoints.http]\n  address =  :80 \n    [entryPoints.http.redirect]\n    entryPoint =  https \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile =  tests/traefik.crt \n      keyFile =  tests/traefik.key    Two entrypoints are defined  http  and  https .  http  listens on port  80  and  https  on port  443 .  We enable SSL on  https  by giving a certificate and a key.  We also redirect all the traffic from entrypoint  http  to  https .   And here is another example with client certificate authentication:  [entryPoints]\n  [entryPoints.https]\n  address =  :443 \n  [entryPoints.https.tls]\n    [entryPoints.https.tls.ClientCA]\n    files = [ tests/clientca1.crt ,  tests/clientca2.crt ]\n    optional = false\n    [[entryPoints.https.tls.certificates]]\n    certFile =  tests/traefik.crt \n    keyFile =  tests/traefik.key    We enable SSL on  https  by giving a certificate and a key.  One or several files containing Certificate Authorities in PEM format are added.  It is possible to have multiple CA:s in the same file or keep them in separate files.", 
            "title": "Entrypoints"
        }, 
        {
            "location": "/basics/#frontends", 
            "text": "A frontend consists of a set of rules that determine how incoming requests are forwarded from an entrypoint to a backend.  Rules may be classified in one of two groups: Modifiers and matchers.", 
            "title": "Frontends"
        }, 
        {
            "location": "/basics/#modifiers", 
            "text": "Modifier rules only modify the request. They do not have any impact on routing decisions being made.  Following is the list of existing modifier rules:   AddPrefix: /products : Add path prefix to the existing request path prior to forwarding the request to the backend.  ReplacePath: /serverless-path : Replaces the path and adds the old path to the  X-Replaced-Path  header. Useful for mapping to AWS Lambda or Google Cloud Functions.  ReplacePathRegex: ^/api/v2/(.*) /api/$1 : Replaces the path with a regular expression and adds the old path to the  X-Replaced-Path  header. Separate the regular expression and the replacement by a space.", 
            "title": "Modifiers"
        }, 
        {
            "location": "/basics/#matchers", 
            "text": "Matcher rules determine if a particular request should be forwarded to a backend.  The associativity rule is the following:   ,  is the  OR  operator (works  only inside a matcher , ex:  Host:foo.com,bar.com ).  i.e., forward a request if any rule matches.  Does not work for  Headers  and  HeadersRegexp .    ;  is the  AND  operator (works  only between matchers , ex:  Host:foo.com;Path:/bar )   i.e., forward a request if all rules match     Following is the list of existing matcher rules along with examples:     Matcher  Description      Headers: Content-Type, application/json  Match HTTP header. It accepts a comma-separated key/value pair where both key and value must be literals.    HeadersRegexp: Content-Type, application/(text/json)  Match HTTP header. It accepts a comma-separated key/value pair where the key must be a literal and the value may be a literal or a regular expression.    Host: traefik.io, www.traefik.io  Match request host. It accepts a sequence of literal hosts.    HostRegexp: traefik.io, {subdomain:[a-z]+}.traefik.io  Match request host. It accepts a sequence of literal and regular expression hosts.    Method: GET, POST, PUT  Match request HTTP method. It accepts a sequence of HTTP methods.    Path: /products/, /articles/{category}/{id:[0-9]+}  Match exact request path. It accepts a sequence of literal and regular expression paths.    PathStrip: /products/  Match exact path and strip off the path prior to forwarding the request to the backend. It accepts a sequence of literal paths.    PathStripRegex: /articles/{category}/{id:[0-9]+}  Match exact path and strip off the path prior to forwarding the request to the backend. It accepts a sequence of literal and regular expression paths.    PathPrefix: /products/, /articles/{category}/{id:[0-9]+}  Match request prefix path. It accepts a sequence of literal and regular expression prefix paths.    PathPrefixStrip: /products/  Match request prefix path and strip off the path prefix prior to forwarding the request to the backend. It accepts a sequence of literal prefix paths. Starting with Traefik 1.3, the stripped prefix path will be available in the  X-Forwarded-Prefix  header.    PathPrefixStripRegex: /articles/{category}/{id:[0-9]+}  Match request prefix path and strip off the path prefix prior to forwarding the request to the backend. It accepts a sequence of literal and regular expression prefix paths. Starting with Traefik 1.3, the stripped prefix path will be available in the  X-Forwarded-Prefix  header.    Query: foo=bar, bar=baz  Match Query String parameters. It accepts a sequence of key=value pairs.     In order to use regular expressions with Host and Path matchers, you must declare an arbitrarily named variable followed by the colon-separated regular expression, all enclosed in curly braces. Any pattern supported by  Go's regexp package  may be used (example:  /posts/{id:[0-9]+} ).   Note  The variable has no special meaning; however, it is required by the  gorilla/mux  dependency which embeds the regular expression and defines the syntax.   You can optionally enable  passHostHeader  to forward client  Host  header to the backend.\nYou can also optionally configure the  passTLSClientCert  option to pass the Client certificates to the backend in a specific header.", 
            "title": "Matchers"
        }, 
        {
            "location": "/basics/#path-matcher-usage-guidelines", 
            "text": "This section explains when to use the various path matchers.  Use  Path  if your backend listens on the exact path only. For instance,  Path: /products  would match  /products  but not  /products/shoes .  Use a  *Prefix*  matcher if your backend listens on a particular base path but also serves requests on sub-paths.\nFor instance,  PathPrefix: /products  would match  /products  but also  /products/shoes  and  /products/shirts .\nSince the path is forwarded as-is, your backend is expected to listen on  /products .  Use a  *Strip  matcher if your backend listens on the root path ( / ) but should be routeable on a specific prefix.\nFor instance,  PathPrefixStrip: /products  would match  /products  but also  /products/shoes  and  /products/shirts . \nSince the path is stripped prior to forwarding, your backend is expected to listen on  / . \nIf your backend is serving assets (e.g., images or Javascript files), chances are it must return properly constructed relative URLs. \nContinuing on the example, the backend should return  /products/shoes/image.png  (and not  /images.png  which Traefik would likely not be able to associate with the same backend). \nThe  X-Forwarded-Prefix  header (available since Traefik 1.3) can be queried to build such URLs dynamically.  Instead of distinguishing your backends by path only, you can add a Host matcher to the mix.\nThat way, namespacing of your backends happens on the basis of hosts in addition to paths.", 
            "title": "Path Matcher Usage Guidelines"
        }, 
        {
            "location": "/basics/#examples", 
            "text": "Here is an example of frontends definition:  [frontends]\n  [frontends.frontend1]\n  backend =  backend2 \n    [frontends.frontend1.routes.test_1]\n    rule =  Host:test.localhost,test2.localhost \n  [frontends.frontend2]\n  backend =  backend1 \n  passHostHeader = true\n  [frontends.frontend2.passTLSClientCert]\n    pem = true\n  priority = 10\n  entrypoints = [ https ] # overrides defaultEntryPoints\n    [frontends.frontend2.routes.test_1]\n    rule =  HostRegexp:localhost,{subdomain:[a-z]+}.localhost \n  [frontends.frontend3]\n  backend =  backend2 \n    [frontends.frontend3.routes.test_1]\n    rule =  Host:test3.localhost;Path:/test    Three frontends are defined:  frontend1 ,  frontend2  and  frontend3  frontend1  will forward the traffic to the  backend2  if the rule  Host:test.localhost,test2.localhost  is matched  frontend2  will forward the traffic to the  backend1  if the rule  HostRegexp:localhost,{subdomain:[a-z]+}.localhost  is matched (forwarding client  Host  header to the backend)  frontend3  will forward the traffic to the  backend2  if the rules  Host:test3.localhost   AND   Path:/test  are matched", 
            "title": "Examples"
        }, 
        {
            "location": "/basics/#combining-multiple-rules", 
            "text": "As seen in the previous example, you can combine multiple rules.\nIn TOML file, you can use multiple routes:    [frontends.frontend3]\n  backend =  backend2 \n    [frontends.frontend3.routes.test_1]\n    rule =  Host:test3.localhost \n    [frontends.frontend3.routes.test_2]\n    rule =  Path:/test   Here  frontend3  will forward the traffic to the  backend2  if the rules  Host:test3.localhost   AND   Path:/test  are matched.  You can also use the notation using a  ;  separator, same result:    [frontends.frontend3]\n  backend =  backend2 \n    [frontends.frontend3.routes.test_1]\n    rule =  Host:test3.localhost;Path:/test   Finally, you can create a rule to bind multiple domains or Path to a frontend, using the  ,  separator:   [frontends.frontend2]\n    [frontends.frontend2.routes.test_1]\n    rule =  Host:test1.localhost,test2.localhost \n  [frontends.frontend3]\n  backend =  backend2 \n    [frontends.frontend3.routes.test_1]\n    rule =  Path:/test1,/test2", 
            "title": "Combining multiple rules"
        }, 
        {
            "location": "/basics/#rules-order", 
            "text": "When combining  Modifier  rules with  Matcher  rules, it is important to remember that  Modifier  rules  ALWAYS  apply after the  Matcher  rules.  The following rules are both  Matchers  and  Modifiers , so the  Matcher  portion of the rule will apply first, and the  Modifier  will apply later.   PathStrip  PathStripRegex  PathPrefixStrip  PathPrefixStripRegex   Modifiers  will be applied in a pre-determined order regardless of their order in the  rule  configuration section.   PathStrip  PathPrefixStrip  PathStripRegex  PathPrefixStripRegex  AddPrefix  ReplacePath", 
            "title": "Rules Order"
        }, 
        {
            "location": "/basics/#priorities", 
            "text": "By default, routes will be sorted (in descending order) using rules length (to avoid path overlap):\n-  PathPrefix:/foo;Host:foo.com  (length == 28) will be matched before  PathPrefixStrip:/foobar  (length == 23) will be matched before  PathPrefix:/foo,/bar  (length == 20). \n- A priority value of 0 will be ignored, so the default value will be calculated (rules length).  You can customize priority by frontend. The priority value override the rule length during sorting:    [frontends]\n    [frontends.frontend1]\n    backend =  backend1 \n    priority = 20\n    passHostHeader = true\n      [frontends.frontend1.routes.test_1]\n      rule =  PathPrefix:/to \n    [frontends.frontend2]\n    backend =  backend2 \n    passHostHeader = true\n      [frontends.frontend2.routes.test_1]\n      rule =  PathPrefix:/toto   Here,  frontend1  will be matched before  frontend2  ( 20   16 ).", 
            "title": "Priorities"
        }, 
        {
            "location": "/basics/#custom-headers", 
            "text": "Custom headers can be configured through the frontends, to add headers to either requests or responses that match the frontend's rules.\nThis allows for setting headers such as  X-Script-Name  to be added to the request, or custom headers to be added to the response.   Warning  If the custom header name is the same as one header name of the request or response, it will be replaced.   In this example, all matches to the path  /cheese  will have the  X-Script-Name  header added to the proxied request and the  X-Custom-Response-Header  header added to the response.  [frontends]\n  [frontends.frontend1]\n  backend =  backend1 \n    [frontends.frontend1.headers.customresponseheaders]\n    X-Custom-Response-Header =  True \n    [frontends.frontend1.headers.customrequestheaders]\n    X-Script-Name =  test \n    [frontends.frontend1.routes.test_1]\n    rule =  PathPrefixStrip:/cheese   In this second  example, all matches to the path  /cheese  will have the  X-Script-Name  header added to the proxied request, the  X-Custom-Request-Header  header removed from the request, and the  X-Custom-Response-Header  header removed from the response.  [frontends]\n  [frontends.frontend1]\n  backend =  backend1 \n    [frontends.frontend1.headers.customresponseheaders]\n    X-Custom-Response-Header =  \n    [frontends.frontend1.headers.customrequestheaders]\n    X-Script-Name =  test \n    X-Custom-Request-Header =  \n    [frontends.frontend1.routes.test_1]\n    rule =  PathPrefixStrip:/cheese", 
            "title": "Custom headers"
        }, 
        {
            "location": "/basics/#security-headers", 
            "text": "Security related headers (HSTS headers, SSL redirection, Browser XSS filter, etc) can be added and configured per frontend in a similar manner to the custom headers above.\nThis functionality allows for some easy security features to quickly be set.  An example of some of the security headers:  [frontends]\n  [frontends.frontend1]\n  backend =  backend1 \n    [frontends.frontend1.headers]\n    FrameDeny = true\n    [frontends.frontend1.routes.test_1]\n    rule =  PathPrefixStrip:/cheddar \n  [frontends.frontend2]\n  backend =  backend2 \n    [frontends.frontend2.headers]\n    SSLRedirect = true\n    [frontends.frontend2.routes.test_1]\n    rule =  PathPrefixStrip:/stilton   In this example, traffic routed through the first frontend will have the  X-Frame-Options  header set to  DENY , and the second will only allow HTTPS request through, otherwise will return a 301 HTTPS redirect.   Note  The detailed documentation for those security headers can be found in  unrolled/secure .", 
            "title": "Security headers"
        }, 
        {
            "location": "/basics/#backends", 
            "text": "A backend is responsible to load-balance the traffic coming from one or more frontends to a set of http servers.", 
            "title": "Backends"
        }, 
        {
            "location": "/basics/#servers", 
            "text": "Servers are simply defined using a  url . You can also apply a custom  weight  to each server (this will be used by load-balancing).   Note  Paths in  url  are ignored. Use  Modifier  to specify paths instead.   Here is an example of backends and servers definition:  [backends]\n  [backends.backend1]\n    # ...\n    [backends.backend1.servers.server1]\n    url =  http://172.17.0.2:80 \n    weight = 10\n    [backends.backend1.servers.server2]\n    url =  http://172.17.0.3:80 \n    weight = 1\n  [backends.backend2]\n    # ...\n    [backends.backend2.servers.server1]\n    url =  https://172.17.0.4:443 \n    weight = 1\n    [backends.backend2.servers.server2]\n    url =  https://172.17.0.5:443 \n    weight = 2\n  [backends.backend3]\n    # ...\n    [backends.backend3.servers.server1]\n    url =  h2c://172.17.0.6:80 \n    weight = 1   Two backends are defined:  backend1  and  backend2  backend1  will forward the traffic to two servers:  172.17.0.2:80  with weight  10  and  172.17.0.3:80  with weight  1 .  backend2  will forward the traffic to two servers:  172.17.0.4:443  with weight  1  and  172.17.0.5:443  with weight  2  both using TLS.  backend3  will forward the traffic to:  172.17.0.6:80  with weight  1  using HTTP2 without TLS.", 
            "title": "Servers"
        }, 
        {
            "location": "/basics/#load-balancing", 
            "text": "Various methods of load-balancing are supported:   wrr : Weighted Round Robin.  drr : Dynamic Round Robin: increases weights on servers that perform better than others.\n    It also rolls back to original weights if the servers have changed.", 
            "title": "Load-balancing"
        }, 
        {
            "location": "/basics/#circuit-breakers", 
            "text": "A circuit breaker can also be applied to a backend, preventing high loads on failing servers.\nInitial state is Standby. CB observes the statistics and does not modify the request.\nIn case the condition matches, CB enters Tripped state, where it responds with predefined code or redirects to another frontend.\nOnce Tripped timer expires, CB enters Recovering state and resets all stats.\nIn case the condition does not match and recovery timer expires, CB enters Standby state.  It can be configured using:   Methods:  LatencyAtQuantileMS ,  NetworkErrorRatio ,  ResponseCodeRatio  Operators:   AND ,  OR ,  EQ ,  NEQ ,  LT ,  LE ,  GT ,  GE   For example:   NetworkErrorRatio()   0.5 : watch error ratio over 10 second sliding window for a frontend.  LatencyAtQuantileMS(50.0)   50 :  watch latency at quantile in milliseconds.  ResponseCodeRatio(500, 600, 0, 600)   0.5 : ratio of response codes in ranges [500-600) and [0-600).   Here is an example of backends and servers definition:  [backends]\n  [backends.backend1]\n    [backends.backend1.circuitbreaker]\n    expression =  NetworkErrorRatio()   0.5 \n    [backends.backend1.servers.server1]\n    url =  http://172.17.0.2:80 \n    weight = 10\n    [backends.backend1.servers.server2]\n    url =  http://172.17.0.3:80 \n    weight = 1   backend1  will forward the traffic to two servers:  http://172.17.0.2:80\"  with weight  10  and  http://172.17.0.3:80  with weight  1  using default  wrr  load-balancing strategy.  a circuit breaker is added on  backend1  using the expression  NetworkErrorRatio()   0.5 : watch error ratio over 10 second sliding window", 
            "title": "Circuit breakers"
        }, 
        {
            "location": "/basics/#maximum-connections", 
            "text": "To proactively prevent backends from being overwhelmed with high load, a maximum connection limit can also be applied to each backend.  Maximum connections can be configured by specifying an integer value for  maxconn.amount  and  maxconn.extractorfunc  which is a strategy used to determine how to categorize requests in order to evaluate the maximum connections.  For example:  [backends]\n  [backends.backend1]\n    [backends.backend1.maxconn]\n       amount = 10\n       extractorfunc =  request.host \n   # ...   backend1  will return  HTTP code 429 Too Many Requests  if there are already 10 requests in progress for the same Host header.  Another possible value for  extractorfunc  is  client.ip  which will categorize requests based on client source ip.  Lastly  extractorfunc  can take the value of  request.header.ANY_HEADER  which will categorize requests based on  ANY_HEADER  that you provide.", 
            "title": "Maximum connections"
        }, 
        {
            "location": "/basics/#sticky-sessions", 
            "text": "Sticky sessions are supported with both load balancers. \nWhen sticky sessions are enabled, a cookie is set on the initial request.\nThe default cookie name is an abbreviation of a sha1 (ex:  _1d52e ).\nOn subsequent requests, the client will be directed to the backend stored in the cookie if it is still healthy.\nIf not, a new backend will be assigned.  [backends]\n  [backends.backend1]\n    # Enable sticky session\n    [backends.backend1.loadbalancer.stickiness]\n\n    # Customize the cookie name\n    #\n    # Optional\n    # Default: a sha1 (6 chars)\n    #\n    #  cookieName =  my_cookie   The deprecated way:  [backends]\n  [backends.backend1]\n    [backends.backend1.loadbalancer]\n      sticky = true", 
            "title": "Sticky sessions"
        }, 
        {
            "location": "/basics/#health-check", 
            "text": "A health check can be configured in order to remove a backend from LB rotation as long as it keeps returning HTTP status codes other than  2xx  or  3xx  to HTTP GET requests periodically carried out by Traefik. \nThe check is defined by a path appended to the backend URL and an interval (given in a format understood by  time.ParseDuration ) specifying how often the health check should be executed (the default being 30 seconds).\nEach backend must respond to the health check within 5 seconds. \nBy default, the port of the backend server is used, however, this may be overridden.  A recovering backend returning  2xx  or  3xx  responses again is being returned to the LB rotation pool.  For example:  [backends]\n  [backends.backend1]\n    [backends.backend1.healthcheck]\n    path =  /health \n    interval =  10s   To use a different port for the health check:  [backends]\n  [backends.backend1]\n    [backends.backend1.healthcheck]\n    path =  /health \n    interval =  10s \n    port = 8080  To use a different scheme for the health check:  [backends]\n  [backends.backend1]\n    [backends.backend1.healthcheck]\n    path =  /health \n    interval =  10s \n    scheme =  http   Additional http headers and hostname to health check request can be specified, for instance:  [backends]\n  [backends.backend1]\n    [backends.backend1.healthcheck]\n    path =  /health \n    interval =  10s \n    hostname =  myhost.com \n    port = 8080\n      [backends.backend1.healthcheck.headers]\n      My-Custom-Header =  foo \n      My-Header =  bar", 
            "title": "Health Check"
        }, 
        {
            "location": "/basics/#configuration", 
            "text": "Traefik's configuration has two parts:   The  static Traefik configuration  which is loaded only at the beginning.  The  dynamic Traefik configuration  which can be hot-reloaded (no need to restart the process).", 
            "title": "Configuration"
        }, 
        {
            "location": "/basics/#static-traefik-configuration", 
            "text": "The static configuration is the global configuration which is setting up connections to configuration backends and entrypoints.  Traefik can be configured using many configuration sources with the following precedence order.\nEach item takes precedence over the item below it:   Key-value store  Arguments  Configuration file  Default   It means that arguments override configuration file, and key-value store overrides arguments.   Note  the provider-enabling argument parameters (e.g.,  --docker ) set all default values for the specific provider. \nIt must not be used if a configuration source with less precedence wants to set a non-default provider value.", 
            "title": "Static Traefik configuration"
        }, 
        {
            "location": "/basics/#configuration-file", 
            "text": "By default, Traefik will try to find a  traefik.toml  in the following places:   /etc/traefik/  $HOME/.traefik/  .   the working directory   You can override this by setting a  configFile  argument:  traefik --configFile=foo/bar/myconfigfile.toml  Please refer to the  global configuration  section to get documentation on it.", 
            "title": "Configuration file"
        }, 
        {
            "location": "/basics/#arguments", 
            "text": "Each argument (and command) is described in the help section:  traefik --help  Note that all default values will be displayed as well.", 
            "title": "Arguments"
        }, 
        {
            "location": "/basics/#key-value-stores", 
            "text": "Traefik supports several Key-value stores:   Consul  etcd  ZooKeeper  boltdb   Please refer to the  User Guide Key-value store configuration  section to get documentation on it.", 
            "title": "Key-value stores"
        }, 
        {
            "location": "/basics/#dynamic-traefik-configuration", 
            "text": "The dynamic configuration concerns :   Frontends  Backends  Servers  HTTPS Certificates   Traefik can hot-reload those rules which could be provided by  multiple configuration backends .  We only need to enable  watch  option to make Traefik watch configuration backend changes and generate its configuration automatically.\nRoutes to services will be created and updated instantly at any changes.  Please refer to the  configuration backends  section to get documentation on it.", 
            "title": "Dynamic Traefik configuration"
        }, 
        {
            "location": "/basics/#commands", 
            "text": "", 
            "title": "Commands"
        }, 
        {
            "location": "/basics/#traefik", 
            "text": "Usage:  traefik [command] [--flag=flag_argument]  List of Traefik available\u00a0commands with description :   version  : Print\u00a0version  storeconfig  : Store the static Traefik configuration into a Key-value stores.\u00a0Please refer to the  Store Traefik configuration  section to get documentation on it.  bug : The easiest way to submit a pre-filled issue.  healthcheck : Calls Traefik  /ping  to check health.   Each command may have related flags.  All those related flags will be displayed with :  traefik [command] --help  Each command is described at the beginning of the help section:  traefik --help\n\n# or\n\ndocker run traefik[:version] --help\n# ex: docker run traefik:1.5 --help", 
            "title": "traefik"
        }, 
        {
            "location": "/basics/#command-bug", 
            "text": "Here is the easiest way to submit a pre-filled issue on  Traefik GitHub .  traefik bug  Watch  this demo .", 
            "title": "Command: bug"
        }, 
        {
            "location": "/basics/#command-healthcheck", 
            "text": "This command allows to check the health of Traefik. Its exit status is  0  if Traefik is healthy and  1  if it is unhealthy.  This can be used with Docker  HEALTHCHECK  instruction or any other health check orchestration mechanism.   Note  The  ping  must be enabled to allow the  healthcheck  command to call  /ping .   traefik healthcheck  OK: http://:8082/ping", 
            "title": "Command: healthcheck"
        }, 
        {
            "location": "/basics/#collected-data", 
            "text": "This feature is disabled by default.  You can read the public proposal on this topic  here .", 
            "title": "Collected Data"
        }, 
        {
            "location": "/basics/#why", 
            "text": "In order to help us learn more about how Traefik is being used and improve it, we collect anonymous usage statistics from running instances.\nThose data help us prioritize our developments and focus on what's more important (for example, which configuration backend is used and which is not used).", 
            "title": "Why ?"
        }, 
        {
            "location": "/basics/#what", 
            "text": "Once a day (the first call begins 10 minutes after the start of Traefik), we collect:   the Traefik version  a hash of the configuration  an  anonymous version  of the static configuration:  token, user name, password, URL, IP, domain, email, etc, are removed      Note  We do not collect the dynamic configuration (frontends   backends).    Note  We do not collect data behind the scenes to run advertising programs or to sell such data to third-party.", 
            "title": "What ?"
        }, 
        {
            "location": "/basics/#here-is-an-example", 
            "text": "Source configuration:   [entryPoints]\n    [entryPoints.http]\n       address =  :80 \n\n[api]\n\n[Docker]\n  endpoint =  tcp://10.10.10.10:2375 \n  domain =  foo.bir \n  exposedByDefault = true\n  swarmMode = true\n\n  [Docker.TLS]\n    ca =  dockerCA \n    cert =  dockerCert \n    key =  dockerKey \n    insecureSkipVerify = true\n\n[ECS]\n  domain =  foo.bar \n  exposedByDefault = true\n  clusters = [ foo-bar ]\n  region =  us-west-2 \n  accessKeyID =  AccessKeyID \n  secretAccessKey =  SecretAccessKey    Obfuscated and anonymous configuration:   [entryPoints]\n    [entryPoints.http]\n       address =  :80 \n\n[api]\n\n[Docker]\n  endpoint =  xxxx \n  domain =  xxxx \n  exposedByDefault = true\n  swarmMode = true\n\n  [Docker.TLS]\n    ca =  xxxx \n    cert =  xxxx \n    key =  xxxx \n    insecureSkipVerify = false\n\n[ECS]\n  domain =  xxxx \n  exposedByDefault = true\n  clusters = []\n  region =  us-west-2 \n  accessKeyID =  xxxx \n  secretAccessKey =  xxxx", 
            "title": "Here is an example"
        }, 
        {
            "location": "/basics/#show-me-the-code", 
            "text": "If you want to dig into more details, here is the source code of the collecting system:  collector.go  By default we anonymize all configuration fields, except fields tagged with  export=true .", 
            "title": "Show me the code !"
        }, 
        {
            "location": "/basics/#how-to-enable-this", 
            "text": "You can enable the collecting system by:   adding this line in the configuration TOML file:   # Send anonymous usage data\n#\n# Optional\n# Default: false\n#\nsendAnonymousUsage = true   adding this flag in the CLI:   ./traefik --sendAnonymousUsage=true", 
            "title": "How to enable this ?"
        }, 
        {
            "location": "/configuration/commons/", 
            "text": "Global Configuration\n\n\nMain Section\n\n\n# DEPRECATED - for general usage instruction see [lifeCycle.graceTimeOut].\n#\n# If both the deprecated option and the new one are given, the deprecated one\n# takes precedence.\n# A value of zero is equivalent to omitting the parameter, causing\n# [lifeCycle.graceTimeOut] to be effective. Pass zero to the new option in\n# order to disable the grace period.\n#\n# Optional\n# Default: \n0s\n\n#\n# graceTimeOut = \n10s\n\n\n# Enable debug mode.\n# This will install HTTP handlers to expose Go expvars under /debug/vars and\n# pprof profiling data under /debug/pprof/.\n# The log level will be set to DEBUG unless `logLevel` is specified.\n#\n# Optional\n# Default: false\n#\n# debug = true\n\n# Periodically check if a new version has been released.\n#\n# Optional\n# Default: true\n#\n# checkNewVersion = false\n\n# Tells traefik whether it should keep the trailing slashes in the paths (e.g. /paths/) or redirect to the no trailing slash paths instead (/paths).\n#\n# Optional\n# Default: false\n#\n# keepTrailingSlash = false\n\n# Providers throttle duration.\n#\n# Optional\n# Default: \n2s\n\n#\n# providersThrottleDuration = \n2s\n\n\n# Controls the maximum idle (keep-alive) connections to keep per-host.\n#\n# Optional\n# Default: 200\n#\n# maxIdleConnsPerHost = 200\n\n# If set to true invalid SSL certificates are accepted for backends.\n# This disables detection of man-in-the-middle attacks so should only be used on secure backend networks.\n#\n# Optional\n# Default: false\n#\n# insecureSkipVerify = true\n\n# Register Certificates in the rootCA.\n#\n# Optional\n# Default: []\n#\n# rootCAs = [ \n/mycert.cert\n ]\n\n# Entrypoints to be used by frontends that do not specify any entrypoint.\n# Each frontend can specify its own entrypoints.\n#\n# Optional\n# Default: [\nhttp\n]\n#\n# defaultEntryPoints = [\nhttp\n, \nhttps\n]\n\n# Allow the use of 0 as server weight.\n# - false: a weight 0 means internally a weight of 1.\n# - true: a weight 0 means internally a weight of 0 (a server with a weight of 0 is removed from the available servers).\n#\n# Optional\n# Default: false\n#\n# AllowMinWeightZero = true\n\n\n\n\n\n\n\n\ngraceTimeOut\n: Duration to give active requests a chance to finish before Traefik stops.\n\nCan be provided in a format supported by \ntime.ParseDuration\n or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.\n\n\nNote:\n in this time frame no new requests are accepted.\n\n\n\n\n\n\nprovidersThrottleDuration\n: Providers throttle duration: minimum duration in seconds between 2 events from providers before applying a new configuration.\nIt avoids unnecessary reloads if multiples events are sent in a short amount of time.\n\nCan be provided in a format supported by \ntime.ParseDuration\n or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.\n\n\n\n\n\n\nmaxIdleConnsPerHost\n: Controls the maximum idle (keep-alive) connections to keep per-host.\n\nIf zero, \nDefaultMaxIdleConnsPerHost\n from the Go standard library net/http module is used.\nIf you encounter 'too many open files' errors, you can either increase this value or change the \nulimit\n.\n\n\n\n\n\n\ninsecureSkipVerify\n : If set to true invalid SSL certificates are accepted for backends.\n\n\nNote:\n This disables detection of man-in-the-middle attacks so should only be used on secure backend networks.\n\n\n\n\n\n\nrootCAs\n: Register Certificates in the RootCA. This certificates will be use for backends calls.\n\n\nNote\n You can use file path or cert content directly\n\n\n\n\n\n\ndefaultEntryPoints\n: Entrypoints to be used by frontends that do not specify any entrypoint.\n\nEach frontend can specify its own entrypoints.\n\n\n\n\n\n\nkeepTrailingSlash\n: Tells Tr\u00e6fik whether it should keep the trailing slashes that might be present in the paths of incoming requests (true), or if it should redirect to the slashless version of the URL (default behavior: false) \n\n\n\n\n\n\n\n\nNote\n\n\nBeware that the value of \nkeepTrailingSlash\n can have a significant impact on the way your frontend rules are interpreted.\nThe table below tries to sum up several behaviors depending on requests/configurations. \nThe current default behavior is deprecated and kept for compatibility reasons. \nAs a consequence, we encourage you to set \nkeepTrailingSlash\n to true.\n\n\n\n\n\n\n\n\nIncoming request\n\n\nkeepTrailingSlash\n\n\nPath:{value}\n\n\nBehavior\n\n\n\n\n\n\n\n\n\n\nhttp://foo.com/path/\n\n\nfalse\n\n\nPath:/path/\n\n\nProceeds with the request\n\n\n\n\n\n\nhttp://foo.com/path/\n\n\nfalse\n\n\nPath:/path\n\n\n301 to http://foo.com/path\n\n\n\n\n\n\nhttp://foo.com/path\n\n\nfalse\n\n\nPath:/path/\n\n\nProceeds with the request\n\n\n\n\n\n\nhttp://foo.com/path\n\n\nfalse\n\n\nPath:/path\n\n\nProceeds with the request\n\n\n\n\n\n\nhttp://foo.com/path/\n\n\ntrue\n\n\nPath:/path/\n\n\nProceeds with the request\n\n\n\n\n\n\nhttp://foo.com/path/\n\n\ntrue\n\n\nPath:/path\n\n\n404\n\n\n\n\n\n\nhttp://foo.com/path\n\n\ntrue\n\n\nPath:/path/\n\n\n404\n\n\n\n\n\n\nhttp://foo.com/path\n\n\ntrue\n\n\nPath:/path\n\n\nProceeds with the request\n\n\n\n\n\n\n\n\n\n\nConstraints\n\n\nIn a micro-service architecture, with a central service discovery, setting constraints limits Traefik scope to a smaller number of routes.\n\n\nTraefik filters services according to service attributes/tags set in your providers.\n\n\nSupported filters:\n\n\n\n\ntag\n\n\n\n\nSimple\n\n\n# Simple matching constraint\nconstraints = [\ntag==api\n]\n\n# Simple mismatching constraint\nconstraints = [\ntag!=api\n]\n\n# Globbing\nconstraints = [\ntag==us-*\n]\n\n\n\n\nMultiple\n\n\n# Multiple constraints\n#   - \ntag==\n must match with at least one tag\n#   - \ntag!=\n must match with none of tags\nconstraints = [\ntag!=us-*\n, \ntag!=asia-*\n]\n\n\n\n\nprovider-specific\n\n\nSupported Providers:\n\n\n\n\nDocker\n\n\nConsul K/V\n\n\nBoltDB\n\n\nZookeeper\n\n\nECS\n\n\nEtcd\n\n\nConsul Catalog\n\n\nRancher\n\n\nMarathon\n\n\nKubernetes (using a provider-specific mechanism based on label selectors)\n\n\n\n\n# Provider-specific constraint\n[consulCatalog]\n# ...\nconstraints = [\ntag==api\n]\n\n# Provider-specific constraint\n[marathon]\n# ...\nconstraints = [\ntag==api\n, \ntag!=v*-beta\n]\n\n\n\n\nCustom Error pages\n\n\nCustom error pages can be returned, in lieu of the default, according to frontend-configured ranges of HTTP Status codes.\n\n\nIn the example below, if a 503 status is returned from the frontend \"website\", the custom error page at http://2.3.4.5/503.html is returned with the actual status code set in the HTTP header.\n\n\n\n\nNote\n\n\nThe \n503.html\n page itself is not hosted on Traefik, but some other infrastructure.\n\n\n\n\n[frontends]\n  [frontends.website]\n  backend = \nwebsite\n\n  [frontends.website.errors]\n    [frontends.website.errors.network]\n    status = [\n500-599\n]\n    backend = \nerror\n\n    query = \n/{status}.html\n\n  [frontends.website.routes.website]\n  rule = \nHost: website.mydomain.com\n\n\n[backends]\n  [backends.website]\n    [backends.website.servers.website]\n    url = \nhttps://1.2.3.4\n\n  [backends.error]\n    [backends.error.servers.error]\n    url = \nhttp://2.3.4.5\n\n\n\n\n\nIn the above example, the error page rendered was based on the status code.\nInstead, the query parameter can also be set to some generic error page like so: \nquery = \"/500s.html\"\n\n\nNow the \n500s.html\n error page is returned for the configured code range.\nThe configured status code ranges are inclusive; that is, in the above example, the \n500s.html\n page will be returned for status codes \n500\n through, and including, \n599\n.\n\n\nRate limiting\n\n\nRate limiting can be configured per frontend.\n\nMultiple sets of rates can be added to each frontend, but the time periods must be unique.\n\n\n[frontends]\n    [frontends.frontend1]\n      # ...\n      [frontends.frontend1.ratelimit]\n        extractorfunc = \nclient.ip\n\n          [frontends.frontend1.ratelimit.rateset.rateset1]\n            period = \n10s\n\n            average = 100\n            burst = 200\n          [frontends.frontend1.ratelimit.rateset.rateset2]\n            period = \n3s\n\n            average = 5\n            burst = 10\n\n\n\n\nIn the above example, frontend1 is configured to limit requests by the client's ip address.\n\nA sustained rate of 100 requests every 10 seconds (10 req/s) is allowed for rateset1, and 5 requests every 3 seconds (~1.67 req/s) for rateset2.\n\nIn addition, these can \"burst\" up to 200 and 10 in each period respectively.\n\n\nAnother way to describe the above parameters, is to use the \nleaky bucket\n analogy:\nfor rateset1, the size of the bucket is 200 drops, and it is leaking at a rate of 10 drop/s.\nIf the incoming rate of drops falling into the bucket gets high enough that the bucket gets filled,\nany subsequent drop overflows out of the bucket (i.e. the request is discarded).\nThis situation holds until the incoming rate gets low enough again, and remains that way, for the water level in the bucket to go down.\n\n\nValid values for \nextractorfunc\n are:\n  * \nclient.ip\n\n  * \nrequest.host\n\n  * \nrequest.header.\nheader name\n\n\nBuffering\n\n\nIn some cases request/buffering can be enabled for a specific backend.\nBy enabling this, Traefik will read the entire request into memory (possibly buffering large requests into disk) and will reject requests that are over a specified limit.\nThis may help services deal with large data (multipart/form-data for example) more efficiently and should minimise time spent when sending data to a backend server.\n\n\nFor more information please check \noxy/buffer\n documentation.\n\n\nExample configuration:\n\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.buffering]\n      maxRequestBodyBytes = 10485760  \n      memRequestBodyBytes = 2097152  \n      maxResponseBodyBytes = 10485760\n      memResponseBodyBytes = 2097152\n      retryExpression = \nIsNetworkError() \n Attempts() \n= 2\n\n\n\n\n\nRetry Configuration\n\n\n# Enable retry sending request if network error\n[retry]\n\n# Number of attempts\n#\n# Optional\n# Default: (number servers in backend) -1\n#\n# attempts = 3\n\n\n\n\nHealth Check Configuration\n\n\n# Enable custom health check options.\n[healthcheck]\n\n# Set the default health check interval.\n#\n# Optional\n# Default: \n30s\n\n#\n# interval = \n30s\n\n\n\n\n\n\n\ninterval\n set the default health check interval.\n\nWill only be effective if health check paths are defined.\n\nGiven provider-specific support, the value may be overridden on a per-backend basis.\n\nCan be provided in a format supported by \ntime.ParseDuration\n or as raw values (digits).\n\nIf no units are provided, the value is parsed assuming seconds.\n\n\n\n\nLife Cycle\n\n\nControls the behavior of Traefik during the shutdown phase.\n\n\n[lifeCycle]\n\n# Duration to keep accepting requests prior to initiating the graceful\n# termination period (as defined by the `graceTimeOut` option). This\n# option is meant to give downstream load-balancers sufficient time to\n# take Traefik out of rotation.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n# The zero duration disables the request accepting grace period, i.e.,\n# Traefik will immediately proceed to the grace period.\n#\n# Optional\n# Default: 0\n#\n# requestAcceptGraceTimeout = \n10s\n\n\n# Duration to give active requests a chance to finish before Traefik stops.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n# Note: in this time frame no new requests are accepted.\n#\n# Optional\n# Default: \n10s\n\n#\n# graceTimeOut = \n10s\n\n\n\n\n\nTimeouts\n\n\nResponding Timeouts\n\n\nrespondingTimeouts\n are timeouts for incoming requests to the Traefik instance.\n\n\n[respondingTimeouts]\n\n# readTimeout is the maximum duration for reading the entire request, including the body.\n#\n# Optional\n# Default: \n0s\n\n#\n# readTimeout = \n5s\n\n\n# writeTimeout is the maximum duration before timing out writes of the response.\n#\n# Optional\n# Default: \n0s\n\n#\n# writeTimeout = \n5s\n\n\n# idleTimeout is the maximum duration an idle (keep-alive) connection will remain idle before closing itself.\n#\n# Optional\n# Default: \n180s\n\n#\n# idleTimeout = \n360s\n\n\n\n\n\n\n\n\n\nreadTimeout\n is the maximum duration for reading the entire request, including the body.\n\nIf zero, no timeout exists.\n\nCan be provided in a format supported by \ntime.ParseDuration\n or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.\n\n\n\n\n\n\nwriteTimeout\n is the maximum duration before timing out writes of the response.\n\nIt covers the time from the end of the request header read to the end of the response write.\nIf zero, no timeout exists.\n\nCan be provided in a format supported by \ntime.ParseDuration\n or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.\n\n\n\n\n\n\nidleTimeout\n is the maximum duration an idle (keep-alive) connection will remain idle before closing itself.\n\nIf zero, no timeout exists.\n\nCan be provided in a format supported by \ntime.ParseDuration\n or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.\n\n\n\n\n\n\nForwarding Timeouts\n\n\nforwardingTimeouts\n are timeouts for requests forwarded to the backend servers.\n\n\n[forwardingTimeouts]\n\n# dialTimeout is the amount of time to wait until a connection to a backend server can be established.\n#\n# Optional\n# Default: \n30s\n\n#\n# dialTimeout = \n30s\n\n\n# responseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).\n#\n# Optional\n# Default: \n0s\n\n#\n# responseHeaderTimeout = \n0s\n\n\n\n\n\n\n\n\n\ndialTimeout\n is the amount of time to wait until a connection to a backend server can be established.\n\nIf zero, no timeout exists.\n\nCan be provided in a format supported by \ntime.ParseDuration\n or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.\n\n\n\n\n\n\nresponseHeaderTimeout\n is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).\n\nIf zero, no timeout exists.\n\nCan be provided in a format supported by \ntime.ParseDuration\n or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.\n\n\n\n\n\n\nIdle Timeout (deprecated)\n\n\nUse \nrespondingTimeouts\n instead of \nidleTimeout\n.\nIn the case both settings are configured, the deprecated option will be overwritten.\n\n\nidleTimeout\n is the maximum amount of time an idle (keep-alive) connection will remain idle before closing itself.\nThis is set to enforce closing of stale client connections.\n\n\nCan be provided in a format supported by \ntime.ParseDuration\n or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.\n\n\n# idleTimeout\n#\n# DEPRECATED - see [respondingTimeouts] section.\n#\n# Optional\n# Default: \n180s\n\n#\nidleTimeout = \n360s\n\n\n\n\n\nHost Resolver\n\n\nhostResolver\n are used for request host matching process.\n\n\n[hostResolver]\n\n# cnameFlattening is a trigger to flatten request host, assuming it is a CNAME record\n#\n# Optional\n# Default : false\n#\ncnameFlattening = true\n\n# resolvConf is dns resolving configuration file, the default is /etc/resolv.conf\n#\n# Optional\n# Default : \n/etc/resolv.conf\n\n#\n# resolvConf = \n/etc/resolv.conf\n\n\n# resolvDepth is the maximum CNAME recursive lookup\n#\n# Optional\n# Default : 5\n#\n# resolvDepth = 5\n\n\n\n\n\n\nTo allow serving secure https request and generate the SSL using ACME while \ncnameFlattening\n is active. \nThe \nacme\n configuration for \nHTTP-01\n challenge and \nonDemand\n is mandatory. \nRefer to \nACME configuration\n for more information.\n\n\n\n\nOverride Default Configuration Template\n\n\n\n\nWarning\n\n\nFor advanced users only.\n\n\n\n\nSupported by all providers except: File Provider, Web Provider and DynamoDB Provider.\n\n\n[provider_name]\n\n# Override default provider configuration template. For advanced users :)\n#\n# Optional\n# Default: \n\n#\nfilename = \ncustom_config_template.tpml\n\n\n# Enable debug logging of generated configuration template.\n#\n# Optional\n# Default: false\n#\ndebugLogGeneratedTemplate = true\n\n\n\n\nExample:\n\n\n[marathon]\nfilename = \nmy_custom_config_template.tpml\n\n\n\n\n\nThe template files can be written using functions provided by:\n\n\n\n\ngo template\n\n\nsprig library\n\n\n\n\nExample:\n\n\n[backends]\n  [backends.backend1]\n  url = \nhttp://firstserver\n\n  [backends.backend2]\n  url = \nhttp://secondserver\n\n\n{{$frontends := dict \nfrontend1\n \nbackend1\n \nfrontend2\n \nbackend2\n}}\n[frontends]\n{{range $frontend, $backend := $frontends}}\n  [frontends.{{$frontend}}]\n  backend = \n{{$backend}}\n\n{{end}}\n\n\n\n\nPass TLS Client Cert\n\n\n# Pass the escaped client cert infos selected below in a `X-Forwarded-Ssl-Client-Cert-Infos` header.\n[frontends.frontend1.passTLSClientCert]\n        pem = true\n        [frontends.frontend1.passTLSClientCert.infos]\n            notBefore = true\n            notAfter = true\n            [frontends.frontend1.passTLSClientCert.infos.subject]\n                country = true\n                domainComponent = true\n                province = true\n                locality = true\n                organization = true\n                commonName = true\n                serialNumber = true\n            [frontends.frontend1.passTLSClientCert.infos.issuer]\n                country = true\n                domainComponent = true\n                province = true\n                locality = true\n                organization = true\n                commonName = true\n                serialNumber = true\n\n\n\n\nPass TLS Client Cert \npem\n defines if the escaped pem is added to a \nX-Forwarded-Ssl-Client-Cert\n header.\n\nPass TLS Client Cert \ninfos\n defines how the certificate data are added to a \nX-Forwarded-Ssl-Client-Cert-Infos\n header.  \n\n\nThe following example shows an unescaped result that uses all the available fields:\nIf there are more than one certificate, they are separated by a \n;\n\n\nSubject=\nDC=org,DC=cheese,C=FR,C=US,ST=Cheese org state,ST=Cheese com state,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=*.cheese.com\n,Issuer=\nDC=org,DC=cheese,C=FR,C=US,ST=Signing State,ST=Signing State 2,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=Simple Signing CA 2\n,NB=1544094616,NA=1607166616,SAN=*.cheese.org,*.cheese.net,*.cheese.com,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2", 
            "title": "Commons"
        }, 
        {
            "location": "/configuration/commons/#global-configuration", 
            "text": "", 
            "title": "Global Configuration"
        }, 
        {
            "location": "/configuration/commons/#main-section", 
            "text": "# DEPRECATED - for general usage instruction see [lifeCycle.graceTimeOut].\n#\n# If both the deprecated option and the new one are given, the deprecated one\n# takes precedence.\n# A value of zero is equivalent to omitting the parameter, causing\n# [lifeCycle.graceTimeOut] to be effective. Pass zero to the new option in\n# order to disable the grace period.\n#\n# Optional\n# Default:  0s \n#\n# graceTimeOut =  10s \n\n# Enable debug mode.\n# This will install HTTP handlers to expose Go expvars under /debug/vars and\n# pprof profiling data under /debug/pprof/.\n# The log level will be set to DEBUG unless `logLevel` is specified.\n#\n# Optional\n# Default: false\n#\n# debug = true\n\n# Periodically check if a new version has been released.\n#\n# Optional\n# Default: true\n#\n# checkNewVersion = false\n\n# Tells traefik whether it should keep the trailing slashes in the paths (e.g. /paths/) or redirect to the no trailing slash paths instead (/paths).\n#\n# Optional\n# Default: false\n#\n# keepTrailingSlash = false\n\n# Providers throttle duration.\n#\n# Optional\n# Default:  2s \n#\n# providersThrottleDuration =  2s \n\n# Controls the maximum idle (keep-alive) connections to keep per-host.\n#\n# Optional\n# Default: 200\n#\n# maxIdleConnsPerHost = 200\n\n# If set to true invalid SSL certificates are accepted for backends.\n# This disables detection of man-in-the-middle attacks so should only be used on secure backend networks.\n#\n# Optional\n# Default: false\n#\n# insecureSkipVerify = true\n\n# Register Certificates in the rootCA.\n#\n# Optional\n# Default: []\n#\n# rootCAs = [  /mycert.cert  ]\n\n# Entrypoints to be used by frontends that do not specify any entrypoint.\n# Each frontend can specify its own entrypoints.\n#\n# Optional\n# Default: [ http ]\n#\n# defaultEntryPoints = [ http ,  https ]\n\n# Allow the use of 0 as server weight.\n# - false: a weight 0 means internally a weight of 1.\n# - true: a weight 0 means internally a weight of 0 (a server with a weight of 0 is removed from the available servers).\n#\n# Optional\n# Default: false\n#\n# AllowMinWeightZero = true    graceTimeOut : Duration to give active requests a chance to finish before Traefik stops. \nCan be provided in a format supported by  time.ParseDuration  or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.  Note:  in this time frame no new requests are accepted.    providersThrottleDuration : Providers throttle duration: minimum duration in seconds between 2 events from providers before applying a new configuration.\nIt avoids unnecessary reloads if multiples events are sent in a short amount of time. \nCan be provided in a format supported by  time.ParseDuration  or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.    maxIdleConnsPerHost : Controls the maximum idle (keep-alive) connections to keep per-host. \nIf zero,  DefaultMaxIdleConnsPerHost  from the Go standard library net/http module is used.\nIf you encounter 'too many open files' errors, you can either increase this value or change the  ulimit .    insecureSkipVerify  : If set to true invalid SSL certificates are accepted for backends.  Note:  This disables detection of man-in-the-middle attacks so should only be used on secure backend networks.    rootCAs : Register Certificates in the RootCA. This certificates will be use for backends calls.  Note  You can use file path or cert content directly    defaultEntryPoints : Entrypoints to be used by frontends that do not specify any entrypoint. \nEach frontend can specify its own entrypoints.    keepTrailingSlash : Tells Tr\u00e6fik whether it should keep the trailing slashes that might be present in the paths of incoming requests (true), or if it should redirect to the slashless version of the URL (default behavior: false)      Note  Beware that the value of  keepTrailingSlash  can have a significant impact on the way your frontend rules are interpreted.\nThe table below tries to sum up several behaviors depending on requests/configurations. \nThe current default behavior is deprecated and kept for compatibility reasons. \nAs a consequence, we encourage you to set  keepTrailingSlash  to true.     Incoming request  keepTrailingSlash  Path:{value}  Behavior      http://foo.com/path/  false  Path:/path/  Proceeds with the request    http://foo.com/path/  false  Path:/path  301 to http://foo.com/path    http://foo.com/path  false  Path:/path/  Proceeds with the request    http://foo.com/path  false  Path:/path  Proceeds with the request    http://foo.com/path/  true  Path:/path/  Proceeds with the request    http://foo.com/path/  true  Path:/path  404    http://foo.com/path  true  Path:/path/  404    http://foo.com/path  true  Path:/path  Proceeds with the request", 
            "title": "Main Section"
        }, 
        {
            "location": "/configuration/commons/#constraints", 
            "text": "In a micro-service architecture, with a central service discovery, setting constraints limits Traefik scope to a smaller number of routes.  Traefik filters services according to service attributes/tags set in your providers.  Supported filters:   tag", 
            "title": "Constraints"
        }, 
        {
            "location": "/configuration/commons/#simple", 
            "text": "# Simple matching constraint\nconstraints = [ tag==api ]\n\n# Simple mismatching constraint\nconstraints = [ tag!=api ]\n\n# Globbing\nconstraints = [ tag==us-* ]", 
            "title": "Simple"
        }, 
        {
            "location": "/configuration/commons/#multiple", 
            "text": "# Multiple constraints\n#   -  tag==  must match with at least one tag\n#   -  tag!=  must match with none of tags\nconstraints = [ tag!=us-* ,  tag!=asia-* ]", 
            "title": "Multiple"
        }, 
        {
            "location": "/configuration/commons/#provider-specific", 
            "text": "Supported Providers:   Docker  Consul K/V  BoltDB  Zookeeper  ECS  Etcd  Consul Catalog  Rancher  Marathon  Kubernetes (using a provider-specific mechanism based on label selectors)   # Provider-specific constraint\n[consulCatalog]\n# ...\nconstraints = [ tag==api ]\n\n# Provider-specific constraint\n[marathon]\n# ...\nconstraints = [ tag==api ,  tag!=v*-beta ]", 
            "title": "provider-specific"
        }, 
        {
            "location": "/configuration/commons/#custom-error-pages", 
            "text": "Custom error pages can be returned, in lieu of the default, according to frontend-configured ranges of HTTP Status codes.  In the example below, if a 503 status is returned from the frontend \"website\", the custom error page at http://2.3.4.5/503.html is returned with the actual status code set in the HTTP header.   Note  The  503.html  page itself is not hosted on Traefik, but some other infrastructure.   [frontends]\n  [frontends.website]\n  backend =  website \n  [frontends.website.errors]\n    [frontends.website.errors.network]\n    status = [ 500-599 ]\n    backend =  error \n    query =  /{status}.html \n  [frontends.website.routes.website]\n  rule =  Host: website.mydomain.com \n\n[backends]\n  [backends.website]\n    [backends.website.servers.website]\n    url =  https://1.2.3.4 \n  [backends.error]\n    [backends.error.servers.error]\n    url =  http://2.3.4.5   In the above example, the error page rendered was based on the status code.\nInstead, the query parameter can also be set to some generic error page like so:  query = \"/500s.html\"  Now the  500s.html  error page is returned for the configured code range.\nThe configured status code ranges are inclusive; that is, in the above example, the  500s.html  page will be returned for status codes  500  through, and including,  599 .", 
            "title": "Custom Error pages"
        }, 
        {
            "location": "/configuration/commons/#rate-limiting", 
            "text": "Rate limiting can be configured per frontend. \nMultiple sets of rates can be added to each frontend, but the time periods must be unique.  [frontends]\n    [frontends.frontend1]\n      # ...\n      [frontends.frontend1.ratelimit]\n        extractorfunc =  client.ip \n          [frontends.frontend1.ratelimit.rateset.rateset1]\n            period =  10s \n            average = 100\n            burst = 200\n          [frontends.frontend1.ratelimit.rateset.rateset2]\n            period =  3s \n            average = 5\n            burst = 10  In the above example, frontend1 is configured to limit requests by the client's ip address. \nA sustained rate of 100 requests every 10 seconds (10 req/s) is allowed for rateset1, and 5 requests every 3 seconds (~1.67 req/s) for rateset2. \nIn addition, these can \"burst\" up to 200 and 10 in each period respectively.  Another way to describe the above parameters, is to use the  leaky bucket  analogy:\nfor rateset1, the size of the bucket is 200 drops, and it is leaking at a rate of 10 drop/s.\nIf the incoming rate of drops falling into the bucket gets high enough that the bucket gets filled,\nany subsequent drop overflows out of the bucket (i.e. the request is discarded).\nThis situation holds until the incoming rate gets low enough again, and remains that way, for the water level in the bucket to go down.  Valid values for  extractorfunc  are:\n  *  client.ip \n  *  request.host \n  *  request.header. header name", 
            "title": "Rate limiting"
        }, 
        {
            "location": "/configuration/commons/#buffering", 
            "text": "In some cases request/buffering can be enabled for a specific backend.\nBy enabling this, Traefik will read the entire request into memory (possibly buffering large requests into disk) and will reject requests that are over a specified limit.\nThis may help services deal with large data (multipart/form-data for example) more efficiently and should minimise time spent when sending data to a backend server.  For more information please check  oxy/buffer  documentation.  Example configuration:  [backends]\n  [backends.backend1]\n    [backends.backend1.buffering]\n      maxRequestBodyBytes = 10485760  \n      memRequestBodyBytes = 2097152  \n      maxResponseBodyBytes = 10485760\n      memResponseBodyBytes = 2097152\n      retryExpression =  IsNetworkError()   Attempts()  = 2", 
            "title": "Buffering"
        }, 
        {
            "location": "/configuration/commons/#retry-configuration", 
            "text": "# Enable retry sending request if network error\n[retry]\n\n# Number of attempts\n#\n# Optional\n# Default: (number servers in backend) -1\n#\n# attempts = 3", 
            "title": "Retry Configuration"
        }, 
        {
            "location": "/configuration/commons/#health-check-configuration", 
            "text": "# Enable custom health check options.\n[healthcheck]\n\n# Set the default health check interval.\n#\n# Optional\n# Default:  30s \n#\n# interval =  30s    interval  set the default health check interval. \nWill only be effective if health check paths are defined. \nGiven provider-specific support, the value may be overridden on a per-backend basis. \nCan be provided in a format supported by  time.ParseDuration  or as raw values (digits). \nIf no units are provided, the value is parsed assuming seconds.", 
            "title": "Health Check Configuration"
        }, 
        {
            "location": "/configuration/commons/#life-cycle", 
            "text": "Controls the behavior of Traefik during the shutdown phase.  [lifeCycle]\n\n# Duration to keep accepting requests prior to initiating the graceful\n# termination period (as defined by the `graceTimeOut` option). This\n# option is meant to give downstream load-balancers sufficient time to\n# take Traefik out of rotation.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n# The zero duration disables the request accepting grace period, i.e.,\n# Traefik will immediately proceed to the grace period.\n#\n# Optional\n# Default: 0\n#\n# requestAcceptGraceTimeout =  10s \n\n# Duration to give active requests a chance to finish before Traefik stops.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n# Note: in this time frame no new requests are accepted.\n#\n# Optional\n# Default:  10s \n#\n# graceTimeOut =  10s", 
            "title": "Life Cycle"
        }, 
        {
            "location": "/configuration/commons/#timeouts", 
            "text": "", 
            "title": "Timeouts"
        }, 
        {
            "location": "/configuration/commons/#responding-timeouts", 
            "text": "respondingTimeouts  are timeouts for incoming requests to the Traefik instance.  [respondingTimeouts]\n\n# readTimeout is the maximum duration for reading the entire request, including the body.\n#\n# Optional\n# Default:  0s \n#\n# readTimeout =  5s \n\n# writeTimeout is the maximum duration before timing out writes of the response.\n#\n# Optional\n# Default:  0s \n#\n# writeTimeout =  5s \n\n# idleTimeout is the maximum duration an idle (keep-alive) connection will remain idle before closing itself.\n#\n# Optional\n# Default:  180s \n#\n# idleTimeout =  360s     readTimeout  is the maximum duration for reading the entire request, including the body. \nIf zero, no timeout exists. \nCan be provided in a format supported by  time.ParseDuration  or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.    writeTimeout  is the maximum duration before timing out writes of the response. \nIt covers the time from the end of the request header read to the end of the response write.\nIf zero, no timeout exists. \nCan be provided in a format supported by  time.ParseDuration  or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.    idleTimeout  is the maximum duration an idle (keep-alive) connection will remain idle before closing itself. \nIf zero, no timeout exists. \nCan be provided in a format supported by  time.ParseDuration  or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.", 
            "title": "Responding Timeouts"
        }, 
        {
            "location": "/configuration/commons/#forwarding-timeouts", 
            "text": "forwardingTimeouts  are timeouts for requests forwarded to the backend servers.  [forwardingTimeouts]\n\n# dialTimeout is the amount of time to wait until a connection to a backend server can be established.\n#\n# Optional\n# Default:  30s \n#\n# dialTimeout =  30s \n\n# responseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).\n#\n# Optional\n# Default:  0s \n#\n# responseHeaderTimeout =  0s     dialTimeout  is the amount of time to wait until a connection to a backend server can be established. \nIf zero, no timeout exists. \nCan be provided in a format supported by  time.ParseDuration  or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.    responseHeaderTimeout  is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any). \nIf zero, no timeout exists. \nCan be provided in a format supported by  time.ParseDuration  or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.", 
            "title": "Forwarding Timeouts"
        }, 
        {
            "location": "/configuration/commons/#idle-timeout-deprecated", 
            "text": "Use  respondingTimeouts  instead of  idleTimeout .\nIn the case both settings are configured, the deprecated option will be overwritten.  idleTimeout  is the maximum amount of time an idle (keep-alive) connection will remain idle before closing itself.\nThis is set to enforce closing of stale client connections.  Can be provided in a format supported by  time.ParseDuration  or as raw values (digits).\nIf no units are provided, the value is parsed assuming seconds.  # idleTimeout\n#\n# DEPRECATED - see [respondingTimeouts] section.\n#\n# Optional\n# Default:  180s \n#\nidleTimeout =  360s", 
            "title": "Idle Timeout (deprecated)"
        }, 
        {
            "location": "/configuration/commons/#host-resolver", 
            "text": "hostResolver  are used for request host matching process.  [hostResolver]\n\n# cnameFlattening is a trigger to flatten request host, assuming it is a CNAME record\n#\n# Optional\n# Default : false\n#\ncnameFlattening = true\n\n# resolvConf is dns resolving configuration file, the default is /etc/resolv.conf\n#\n# Optional\n# Default :  /etc/resolv.conf \n#\n# resolvConf =  /etc/resolv.conf \n\n# resolvDepth is the maximum CNAME recursive lookup\n#\n# Optional\n# Default : 5\n#\n# resolvDepth = 5   To allow serving secure https request and generate the SSL using ACME while  cnameFlattening  is active. \nThe  acme  configuration for  HTTP-01  challenge and  onDemand  is mandatory. \nRefer to  ACME configuration  for more information.", 
            "title": "Host Resolver"
        }, 
        {
            "location": "/configuration/commons/#override-default-configuration-template", 
            "text": "Warning  For advanced users only.   Supported by all providers except: File Provider, Web Provider and DynamoDB Provider.  [provider_name]\n\n# Override default provider configuration template. For advanced users :)\n#\n# Optional\n# Default:  \n#\nfilename =  custom_config_template.tpml \n\n# Enable debug logging of generated configuration template.\n#\n# Optional\n# Default: false\n#\ndebugLogGeneratedTemplate = true  Example:  [marathon]\nfilename =  my_custom_config_template.tpml   The template files can be written using functions provided by:   go template  sprig library   Example:  [backends]\n  [backends.backend1]\n  url =  http://firstserver \n  [backends.backend2]\n  url =  http://secondserver \n\n{{$frontends := dict  frontend1   backend1   frontend2   backend2 }}\n[frontends]\n{{range $frontend, $backend := $frontends}}\n  [frontends.{{$frontend}}]\n  backend =  {{$backend}} \n{{end}}", 
            "title": "Override Default Configuration Template"
        }, 
        {
            "location": "/configuration/commons/#pass-tls-client-cert", 
            "text": "# Pass the escaped client cert infos selected below in a `X-Forwarded-Ssl-Client-Cert-Infos` header.\n[frontends.frontend1.passTLSClientCert]\n        pem = true\n        [frontends.frontend1.passTLSClientCert.infos]\n            notBefore = true\n            notAfter = true\n            [frontends.frontend1.passTLSClientCert.infos.subject]\n                country = true\n                domainComponent = true\n                province = true\n                locality = true\n                organization = true\n                commonName = true\n                serialNumber = true\n            [frontends.frontend1.passTLSClientCert.infos.issuer]\n                country = true\n                domainComponent = true\n                province = true\n                locality = true\n                organization = true\n                commonName = true\n                serialNumber = true  Pass TLS Client Cert  pem  defines if the escaped pem is added to a  X-Forwarded-Ssl-Client-Cert  header. \nPass TLS Client Cert  infos  defines how the certificate data are added to a  X-Forwarded-Ssl-Client-Cert-Infos  header.    The following example shows an unescaped result that uses all the available fields:\nIf there are more than one certificate, they are separated by a  ;  Subject= DC=org,DC=cheese,C=FR,C=US,ST=Cheese org state,ST=Cheese com state,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=*.cheese.com ,Issuer= DC=org,DC=cheese,C=FR,C=US,ST=Signing State,ST=Signing State 2,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=Simple Signing CA 2 ,NB=1544094616,NA=1607166616,SAN=*.cheese.org,*.cheese.net,*.cheese.com,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2", 
            "title": "Pass TLS Client Cert"
        }, 
        {
            "location": "/configuration/logs/", 
            "text": "Logs Definition\n\n\nReference\n\n\nTOML\n\n\nlogLevel = \nINFO\n\n\n[traefikLog]\n  filePath = \n/path/to/traefik.log\n\n  format   = \njson\n\n\n[accessLog]\n  filePath = \n/path/to/access.log\n\n  format = \njson\n\n\n  [accessLog.filters]\n    statusCodes = [\n200\n, \n300-302\n]\n    retryAttempts = true\n    minDuration = \n10ms\n\n\n  [accessLog.fields]\n    defaultMode = \nkeep\n\n    [accessLog.fields.names]\n      \nClientUsername\n = \ndrop\n\n      # ...\n\n    [accessLog.fields.headers]\n      defaultMode = \nkeep\n\n      [accessLog.fields.headers.names]\n        \nUser-Agent\n = \nredact\n\n        \nAuthorization\n = \ndrop\n\n        \nContent-Type\n = \nkeep\n\n        # ...\n\n\n\n\nCLI\n\n\nFor more information about the CLI, see the documentation about \nTraefik command\n.\n\n\n--logLevel=\nDEBUG\n\n--traefikLog.filePath=\n/path/to/traefik.log\n\n--traefikLog.format=\njson\n\n--accessLog.filePath=\n/path/to/access.log\n\n--accessLog.format=\njson\n\n--accessLog.filters.statusCodes=\n200,300-302\n\n--accessLog.filters.retryAttempts=\ntrue\n\n--accessLog.filters.minDuration=\n10ms\n\n--accessLog.fields.defaultMode=\nkeep\n\n--accessLog.fields.names=\nUsername=drop Hostname=drop\n\n--accessLog.fields.headers.defaultMode=\nkeep\n\n--accessLog.fields.headers.names=\nUser-Agent=redact Authorization=drop Content-Type=keep\n\n\n\n\n\nTraefik Logs\n\n\nBy default the Traefik log is written to stdout in text format.\n\n\nTo write the logs into a log file specify the \nfilePath\n:\n\n\n[traefikLog]\n  filePath = \n/path/to/traefik.log\n\n\n\n\n\nTo switch to JSON format instead of standard format (\ncommon\n), specify \njson\n as the format:\n\n\n[traefikLog]\n  filePath = \n/path/to/traefik.log\n\n  format   = \njson\n\n\n\n\n\nDeprecated way (before 1.4):\n\n\n\n\nDEPRECATED\n\n\ntraefikLogsFile\n is deprecated, use \ntraefikLog\n instead.\n\n\n\n\n# Traefik logs file\n# If not defined, logs to stdout\n#\n# DEPRECATED - see [traefikLog] lower down\n# In case both traefikLogsFile and traefikLog.filePath are specified, the latter will take precedence.\n# Optional\n#\ntraefikLogsFile = \nlog/traefik.log\n\n\n\n\n\nTo customize the log level:\n\n\n# Log level\n#\n# Optional\n# Default: \nERROR\n\n#\n# Accepted values, in order of severity: \nDEBUG\n, \nINFO\n, \nWARN\n, \nERROR\n, \nFATAL\n, \nPANIC\n\n# Messages at and above the selected level will be logged.\n#\nlogLevel = \nERROR\n\n\n\n\n\nAccess Logs\n\n\nAccess logs are written when the entry \n[accessLog]\n is defined (or the command line flag \n--accesslog\n).\nBy default it writes to stdout and produces logs in the textual \nCommon Log Format (CLF)\n, extended with additional fields.\n\n\nTo enable access logs using the default settings, add the \n[accessLog]\n entry in your \ntraefik.toml\n configuration file:\n\n\n[accessLog]\n\n\n\n\nTo write the logs into a log file specify the \nfilePath\n:\n\n\n[accessLog]\nfilePath = \n/path/to/access.log\n\n\n\n\n\nTo switch to JSON format instead of \nCommon Log Format (CLF)\n, specify \njson\n as the format:\n\n\n[accessLog]\nfilePath = \n/path/to/access.log\n\nformat = \njson\n  # Default: \ncommon\n\n\n\n\n\nTo write the logs in async, specify \nbufferingSize\n as the format (must be \n0):\n\n\n[accessLog]\nfilePath = \n/path/to/access.log\n\n# Buffering Size\n#\n# Optional\n# Default: 0\n#\n# Number of access log lines to process in a buffered way.\n#\nbufferingSize = 100\n\n\n\n\nTo filter logs you can specify a set of filters which are logically \"OR-connected\". Thus, specifying multiple filters will keep more access logs than specifying only one:\n\n\n[accessLog]\nfilePath = \n/path/to/access.log\n\nformat = \njson\n  # Default: \ncommon\n\n\n  [accessLog.filters]\n\n  # statusCodes: keep access logs with status codes in the specified range\n  #\n  # Optional\n  # Default: []\n  #\n  statusCodes = [\n200\n, \n300-302\n]\n\n  # retryAttempts: keep access logs when at least one retry happened\n  #\n  # Optional\n  # Default: false\n  #\n  retryAttempts = true\n\n  # minDuration: keep access logs when request took longer than the specified duration\n  #\n  # Optional\n  # Default: 0\n  #\n  minDuration = \n10ms\n\n\n\n\n\nCLF - Common Log Format\n\n\nBy default, Traefik use the CLF (\ncommon\n) as access log format.\n\n\nremote_IP_address\n - \nclient_user_name_if_available\n [\ntimestamp\n] \nrequest_method\n \nrequest_path\n \nrequest_protocol\n \norigin_server_HTTP_status\n \norigin_server_content_size\n \nrequest_referrer\n \nrequest_user_agent\n \nnumber_of_requests_received_since_Traefik_started\n \nTraefik_frontend_name\n \nTraefik_backend_URL\n \nrequest_duration_in_ms\nms\n\n\n\n\nCustomize Fields\n\n\nYou can customize the fields written in the access logs.\nThe list of available fields is found below: \nList of All Available Fields\n.\n\n\nEach field has a \"mode\" which defines if it is written or not in the access log lines.\nThe possible values for the mode are:\n\n\n\n\nkeep\n: the field and its value are written on the access log line. This is the default behavior.\n\n\ndrop\n: the field is not written at all on the access log.\n\n\n\n\nTo customize the fields, you must:\n\n\n\n\nSwitch to the JSON format (mandatory)\n\n\nDefine the \"default mode\" for all fields (default is \nkeep\n)\n\n\nOR Define the fields which does not follow the default mode\n\n\n\n\n[accessLog]\n# Access Log Format\n#\n# Optional\n# Default: \ncommon\n\n#\n# Accepted values \ncommon\n, \njson\n\n#\nformat = \njson\n\n\n  [accessLog.fields]\n\n  # defaultMode\n  #\n  # Optional\n  # Default: \nkeep\n\n  #\n  # Accepted values \nkeep\n, \ndrop\n\n  #\n  defaultMode = \nkeep\n\n\n  # Fields map which is used to override fields defaultMode\n  [accessLog.fields.names]\n    \nClientUsername\n = \ndrop\n\n    # ...\n\n\n\n\nCustomize Headers\n\n\nAccess logs prints the headers of each request, as fields of the access log line.\nYou can customize which and how the headers are printed, likewise the other fields (see \n\"Customize Fields\" section\n).\n\n\nEach header has a \"mode\" which defines how it is written in the access log lines.\nThe possible values for the mode are:\n\n\n\n\nkeep\n: the header and its value are written on the access log line. This is the default behavior.\n\n\ndrop\n: the header is not written at all on the access log.\n\n\nredacted\n: the header is written, but its value is redacted to avoid leaking sensitive information.\n\n\n\n\nTo customize the headers, you must:\n\n\n\n\nSwitch to the JSON format (mandatory)\n\n\nDefine the \"default mode\" for all headers (default is \nkeep\n)\n\n\nOR Define the headers which does not follow the default mode\n\n\n\n\n\n\nImportant\n\n\nThe headers are written with the prefix \nrequest_\n in the access log.\nThis prefix must not be included when specifying a header in the TOML configuration.\n\n\n\n\nDo: \n\"User-Agent\" = \"drop\"\n\n\nDon't: \n\"redacted_User-Agent\" = \"drop\"\n\n\n\n\n\n\n[accessLog]\n# Access Log Format\n#\n# Optional\n# Default: \ncommon\n\n#\n# Accepted values \ncommon\n, \njson\n\n#\nformat = \njson\n\n\n  [accessLog.fields.headers]\n    # defaultMode\n    #\n    # Optional\n    # Default: \nkeep\n\n    #\n    # Accepted values \nkeep\n, \ndrop\n, \nredact\n\n    #\n    defaultMode = \nkeep\n\n    # Fields map which is used to override headers defaultMode\n    [accessLog.fields.headers.names]\n      \nUser-Agent\n = \nredact\n\n      \nAuthorization\n = \ndrop\n\n      \nContent-Type\n = \nkeep\n\n      # ...\n\n\n\n\nList of All Available Fields\n\n\n\n\n\n\n\n\nField\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStartUTC\n\n\nThe time at which request processing started.\n\n\n\n\n\n\nStartLocal\n\n\nThe local time at which request processing started.\n\n\n\n\n\n\nDuration\n\n\nThe total time taken by processing the response, including the origin server's time but not the log writing time.\n\n\n\n\n\n\nFrontendName\n\n\nThe name of the Traefik frontend.\n\n\n\n\n\n\nBackendName\n\n\nThe name of the Traefik backend.\n\n\n\n\n\n\nBackendURL\n\n\nThe URL of the Traefik backend.\n\n\n\n\n\n\nBackendAddr\n\n\nThe IP:port of the Traefik backend (extracted from \nBackendURL\n)\n\n\n\n\n\n\nClientAddr\n\n\nThe remote address in its original form (usually IP:port).\n\n\n\n\n\n\nClientHost\n\n\nThe remote IP address from which the client request was received.\n\n\n\n\n\n\nClientPort\n\n\nThe remote TCP port from which the client request was received.\n\n\n\n\n\n\nClientUsername\n\n\nThe username provided in the URL, if present.\n\n\n\n\n\n\nRequestAddr\n\n\nThe HTTP Host header (usually IP:port). This is treated as not a header by the Go API.\n\n\n\n\n\n\nRequestHost\n\n\nThe HTTP Host server name (not including port).\n\n\n\n\n\n\nRequestPort\n\n\nThe TCP port from the HTTP Host.\n\n\n\n\n\n\nRequestMethod\n\n\nThe HTTP method.\n\n\n\n\n\n\nRequestPath\n\n\nThe HTTP request URI, not including the scheme, host or port.\n\n\n\n\n\n\nRequestProtocol\n\n\nThe version of HTTP requested.\n\n\n\n\n\n\nRequestLine\n\n\nRequestMethod\n + \nRequestPath\n + \nRequestProtocol\n\n\n\n\n\n\nRequestContentSize\n\n\nThe number of bytes in the request entity (a.k.a. body) sent by the client.\n\n\n\n\n\n\nOriginDuration\n\n\nThe time taken by the origin server ('upstream') to return its response.\n\n\n\n\n\n\nOriginContentSize\n\n\nThe content length specified by the origin server, or 0 if unspecified.\n\n\n\n\n\n\nOriginStatus\n\n\nThe HTTP status code returned by the origin server. If the request was handled by this Traefik instance (e.g. with a redirect), then this value will be absent.\n\n\n\n\n\n\nOriginStatusLine\n\n\nOriginStatus\n + Status code explanation\n\n\n\n\n\n\nDownstreamStatus\n\n\nThe HTTP status code returned to the client.\n\n\n\n\n\n\nDownstreamStatusLine\n\n\nDownstreamStatus\n + Status code explanation\n\n\n\n\n\n\nDownstreamContentSize\n\n\nThe number of bytes in the response entity returned to the client. This is in addition to the \"Content-Length\" header, which may be present in the origin response.\n\n\n\n\n\n\nRequestCount\n\n\nThe number of requests received since the Traefik instance started.\n\n\n\n\n\n\nGzipRatio\n\n\nThe response body compression ratio achieved.\n\n\n\n\n\n\nOverhead\n\n\nThe processing time overhead caused by Traefik.\n\n\n\n\n\n\nRetryAttempts\n\n\nThe amount of attempts the request was retried.\n\n\n\n\n\n\n\n\nDepreciation Notice\n\n\nDeprecated way (before 1.4):\n\n\n\n\nDEPRECATED\n\n\naccessLogsFile\n is deprecated, use \naccessLog\n instead.\n\n\n\n\n# Access logs file\n#\n# DEPRECATED - see [accessLog]\n#\naccessLogsFile = \nlog/access.log\n\n\n\n\n\nLog Rotation\n\n\nTraefik will close and reopen its log files, assuming they're configured, on receipt of a USR1 signal.\nThis allows the logs to be rotated and processed by an external program, such as \nlogrotate\n.\n\n\n\n\nNote\n\n\nThis does not work on Windows due to the lack of USR signals.\n\n\n\n\nTime Zones\n\n\nThe timestamp of each log line is in UTC time by default.\n\n\nIf you want to use local timezone, you need to ensure the 3 following elements:\n\n\n\n\nProvide the timezone data into /usr/share/zoneinfo\n\n\nSet the environement variable TZ to the timezone to be used\n\n\nSpecify the field StartLocal instead of StartUTC (works on default Common Log Format (CLF) as well as JSON)\n\n\n\n\nExample using docker-compose:\n\n\nversion: '3'\n\nservices:\n  traefik:\n    image: containous/traefik:[latest stable version]\n    ports:\n      - \n80:80\n\n    environment:\n      - \nTZ=US/Alaska\n\n    command:\n      - --docker\n      - --accesslog\n      - --accesslog.fields.names=\nStartUTC=drop\n\n    volumes:\n      - \n/var/run/docker.sock:/var/run/docker.sock\n\n      - \n/usr/share/zoneinfo:/usr/share/zoneinfo:ro", 
            "title": "Logs"
        }, 
        {
            "location": "/configuration/logs/#logs-definition", 
            "text": "", 
            "title": "Logs Definition"
        }, 
        {
            "location": "/configuration/logs/#reference", 
            "text": "", 
            "title": "Reference"
        }, 
        {
            "location": "/configuration/logs/#toml", 
            "text": "logLevel =  INFO \n\n[traefikLog]\n  filePath =  /path/to/traefik.log \n  format   =  json \n\n[accessLog]\n  filePath =  /path/to/access.log \n  format =  json \n\n  [accessLog.filters]\n    statusCodes = [ 200 ,  300-302 ]\n    retryAttempts = true\n    minDuration =  10ms \n\n  [accessLog.fields]\n    defaultMode =  keep \n    [accessLog.fields.names]\n       ClientUsername  =  drop \n      # ...\n\n    [accessLog.fields.headers]\n      defaultMode =  keep \n      [accessLog.fields.headers.names]\n         User-Agent  =  redact \n         Authorization  =  drop \n         Content-Type  =  keep \n        # ...", 
            "title": "TOML"
        }, 
        {
            "location": "/configuration/logs/#cli", 
            "text": "For more information about the CLI, see the documentation about  Traefik command .  --logLevel= DEBUG \n--traefikLog.filePath= /path/to/traefik.log \n--traefikLog.format= json \n--accessLog.filePath= /path/to/access.log \n--accessLog.format= json \n--accessLog.filters.statusCodes= 200,300-302 \n--accessLog.filters.retryAttempts= true \n--accessLog.filters.minDuration= 10ms \n--accessLog.fields.defaultMode= keep \n--accessLog.fields.names= Username=drop Hostname=drop \n--accessLog.fields.headers.defaultMode= keep \n--accessLog.fields.headers.names= User-Agent=redact Authorization=drop Content-Type=keep", 
            "title": "CLI"
        }, 
        {
            "location": "/configuration/logs/#traefik-logs", 
            "text": "By default the Traefik log is written to stdout in text format.  To write the logs into a log file specify the  filePath :  [traefikLog]\n  filePath =  /path/to/traefik.log   To switch to JSON format instead of standard format ( common ), specify  json  as the format:  [traefikLog]\n  filePath =  /path/to/traefik.log \n  format   =  json   Deprecated way (before 1.4):   DEPRECATED  traefikLogsFile  is deprecated, use  traefikLog  instead.   # Traefik logs file\n# If not defined, logs to stdout\n#\n# DEPRECATED - see [traefikLog] lower down\n# In case both traefikLogsFile and traefikLog.filePath are specified, the latter will take precedence.\n# Optional\n#\ntraefikLogsFile =  log/traefik.log   To customize the log level:  # Log level\n#\n# Optional\n# Default:  ERROR \n#\n# Accepted values, in order of severity:  DEBUG ,  INFO ,  WARN ,  ERROR ,  FATAL ,  PANIC \n# Messages at and above the selected level will be logged.\n#\nlogLevel =  ERROR", 
            "title": "Traefik Logs"
        }, 
        {
            "location": "/configuration/logs/#access-logs", 
            "text": "Access logs are written when the entry  [accessLog]  is defined (or the command line flag  --accesslog ).\nBy default it writes to stdout and produces logs in the textual  Common Log Format (CLF) , extended with additional fields.  To enable access logs using the default settings, add the  [accessLog]  entry in your  traefik.toml  configuration file:  [accessLog]  To write the logs into a log file specify the  filePath :  [accessLog]\nfilePath =  /path/to/access.log   To switch to JSON format instead of  Common Log Format (CLF) , specify  json  as the format:  [accessLog]\nfilePath =  /path/to/access.log \nformat =  json   # Default:  common   To write the logs in async, specify  bufferingSize  as the format (must be  0):  [accessLog]\nfilePath =  /path/to/access.log \n# Buffering Size\n#\n# Optional\n# Default: 0\n#\n# Number of access log lines to process in a buffered way.\n#\nbufferingSize = 100  To filter logs you can specify a set of filters which are logically \"OR-connected\". Thus, specifying multiple filters will keep more access logs than specifying only one:  [accessLog]\nfilePath =  /path/to/access.log \nformat =  json   # Default:  common \n\n  [accessLog.filters]\n\n  # statusCodes: keep access logs with status codes in the specified range\n  #\n  # Optional\n  # Default: []\n  #\n  statusCodes = [ 200 ,  300-302 ]\n\n  # retryAttempts: keep access logs when at least one retry happened\n  #\n  # Optional\n  # Default: false\n  #\n  retryAttempts = true\n\n  # minDuration: keep access logs when request took longer than the specified duration\n  #\n  # Optional\n  # Default: 0\n  #\n  minDuration =  10ms", 
            "title": "Access Logs"
        }, 
        {
            "location": "/configuration/logs/#clf-common-log-format", 
            "text": "By default, Traefik use the CLF ( common ) as access log format.  remote_IP_address  -  client_user_name_if_available  [ timestamp ]  request_method   request_path   request_protocol   origin_server_HTTP_status   origin_server_content_size   request_referrer   request_user_agent   number_of_requests_received_since_Traefik_started   Traefik_frontend_name   Traefik_backend_URL   request_duration_in_ms ms", 
            "title": "CLF - Common Log Format"
        }, 
        {
            "location": "/configuration/logs/#customize-fields", 
            "text": "You can customize the fields written in the access logs.\nThe list of available fields is found below:  List of All Available Fields .  Each field has a \"mode\" which defines if it is written or not in the access log lines.\nThe possible values for the mode are:   keep : the field and its value are written on the access log line. This is the default behavior.  drop : the field is not written at all on the access log.   To customize the fields, you must:   Switch to the JSON format (mandatory)  Define the \"default mode\" for all fields (default is  keep )  OR Define the fields which does not follow the default mode   [accessLog]\n# Access Log Format\n#\n# Optional\n# Default:  common \n#\n# Accepted values  common ,  json \n#\nformat =  json \n\n  [accessLog.fields]\n\n  # defaultMode\n  #\n  # Optional\n  # Default:  keep \n  #\n  # Accepted values  keep ,  drop \n  #\n  defaultMode =  keep \n\n  # Fields map which is used to override fields defaultMode\n  [accessLog.fields.names]\n     ClientUsername  =  drop \n    # ...", 
            "title": "Customize Fields"
        }, 
        {
            "location": "/configuration/logs/#customize-headers", 
            "text": "Access logs prints the headers of each request, as fields of the access log line.\nYou can customize which and how the headers are printed, likewise the other fields (see  \"Customize Fields\" section ).  Each header has a \"mode\" which defines how it is written in the access log lines.\nThe possible values for the mode are:   keep : the header and its value are written on the access log line. This is the default behavior.  drop : the header is not written at all on the access log.  redacted : the header is written, but its value is redacted to avoid leaking sensitive information.   To customize the headers, you must:   Switch to the JSON format (mandatory)  Define the \"default mode\" for all headers (default is  keep )  OR Define the headers which does not follow the default mode    Important  The headers are written with the prefix  request_  in the access log.\nThis prefix must not be included when specifying a header in the TOML configuration.   Do:  \"User-Agent\" = \"drop\"  Don't:  \"redacted_User-Agent\" = \"drop\"    [accessLog]\n# Access Log Format\n#\n# Optional\n# Default:  common \n#\n# Accepted values  common ,  json \n#\nformat =  json \n\n  [accessLog.fields.headers]\n    # defaultMode\n    #\n    # Optional\n    # Default:  keep \n    #\n    # Accepted values  keep ,  drop ,  redact \n    #\n    defaultMode =  keep \n    # Fields map which is used to override headers defaultMode\n    [accessLog.fields.headers.names]\n       User-Agent  =  redact \n       Authorization  =  drop \n       Content-Type  =  keep \n      # ...", 
            "title": "Customize Headers"
        }, 
        {
            "location": "/configuration/logs/#list-of-all-available-fields", 
            "text": "Field  Description      StartUTC  The time at which request processing started.    StartLocal  The local time at which request processing started.    Duration  The total time taken by processing the response, including the origin server's time but not the log writing time.    FrontendName  The name of the Traefik frontend.    BackendName  The name of the Traefik backend.    BackendURL  The URL of the Traefik backend.    BackendAddr  The IP:port of the Traefik backend (extracted from  BackendURL )    ClientAddr  The remote address in its original form (usually IP:port).    ClientHost  The remote IP address from which the client request was received.    ClientPort  The remote TCP port from which the client request was received.    ClientUsername  The username provided in the URL, if present.    RequestAddr  The HTTP Host header (usually IP:port). This is treated as not a header by the Go API.    RequestHost  The HTTP Host server name (not including port).    RequestPort  The TCP port from the HTTP Host.    RequestMethod  The HTTP method.    RequestPath  The HTTP request URI, not including the scheme, host or port.    RequestProtocol  The version of HTTP requested.    RequestLine  RequestMethod  +  RequestPath  +  RequestProtocol    RequestContentSize  The number of bytes in the request entity (a.k.a. body) sent by the client.    OriginDuration  The time taken by the origin server ('upstream') to return its response.    OriginContentSize  The content length specified by the origin server, or 0 if unspecified.    OriginStatus  The HTTP status code returned by the origin server. If the request was handled by this Traefik instance (e.g. with a redirect), then this value will be absent.    OriginStatusLine  OriginStatus  + Status code explanation    DownstreamStatus  The HTTP status code returned to the client.    DownstreamStatusLine  DownstreamStatus  + Status code explanation    DownstreamContentSize  The number of bytes in the response entity returned to the client. This is in addition to the \"Content-Length\" header, which may be present in the origin response.    RequestCount  The number of requests received since the Traefik instance started.    GzipRatio  The response body compression ratio achieved.    Overhead  The processing time overhead caused by Traefik.    RetryAttempts  The amount of attempts the request was retried.", 
            "title": "List of All Available Fields"
        }, 
        {
            "location": "/configuration/logs/#depreciation-notice", 
            "text": "Deprecated way (before 1.4):   DEPRECATED  accessLogsFile  is deprecated, use  accessLog  instead.   # Access logs file\n#\n# DEPRECATED - see [accessLog]\n#\naccessLogsFile =  log/access.log", 
            "title": "Depreciation Notice"
        }, 
        {
            "location": "/configuration/logs/#log-rotation", 
            "text": "Traefik will close and reopen its log files, assuming they're configured, on receipt of a USR1 signal.\nThis allows the logs to be rotated and processed by an external program, such as  logrotate .   Note  This does not work on Windows due to the lack of USR signals.", 
            "title": "Log Rotation"
        }, 
        {
            "location": "/configuration/logs/#time-zones", 
            "text": "The timestamp of each log line is in UTC time by default.  If you want to use local timezone, you need to ensure the 3 following elements:   Provide the timezone data into /usr/share/zoneinfo  Set the environement variable TZ to the timezone to be used  Specify the field StartLocal instead of StartUTC (works on default Common Log Format (CLF) as well as JSON)   Example using docker-compose:  version: '3'\n\nservices:\n  traefik:\n    image: containous/traefik:[latest stable version]\n    ports:\n      -  80:80 \n    environment:\n      -  TZ=US/Alaska \n    command:\n      - --docker\n      - --accesslog\n      - --accesslog.fields.names= StartUTC=drop \n    volumes:\n      -  /var/run/docker.sock:/var/run/docker.sock \n      -  /usr/share/zoneinfo:/usr/share/zoneinfo:ro", 
            "title": "Time Zones"
        }, 
        {
            "location": "/configuration/entrypoints/", 
            "text": "Entry Points Definition\n\n\nReference\n\n\nTOML\n\n\ndefaultEntryPoints = [\nhttp\n, \nhttps\n]\n\n# ...\n# ...\n\n[entryPoints]\n  [entryPoints.http]\n    address = \n:80\n\n    compress = true\n\n    [entryPoints.http.whitelist]\n      sourceRange = [\n10.42.0.0/16\n, \n152.89.1.33/32\n, \nafed:be44::/16\n]\n      useXForwardedFor = true\n\n    [entryPoints.http.tls]\n      minVersion = \nVersionTLS12\n\n      cipherSuites = [\n        \nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n,\n        \nTLS_RSA_WITH_AES_256_GCM_SHA384\n\n       ]\n      [[entryPoints.http.tls.certificates]]\n        certFile = \npath/to/my.cert\n\n        keyFile = \npath/to/my.key\n\n      [[entryPoints.http.tls.certificates]]\n        certFile = \npath/to/other.cert\n\n        keyFile = \npath/to/other.key\n\n      # ...\n      [entryPoints.http.tls.clientCA]\n        files = [\npath/to/ca1.crt\n, \npath/to/ca2.crt\n]\n        optional = false\n\n    [entryPoints.http.redirect]\n      entryPoint = \nhttps\n\n      regex = \n^http://localhost/(.*)\n\n      replacement = \nhttp://mydomain/$1\n\n      permanent = true\n\n    [entryPoints.http.auth]\n      headerField = \nX-WebAuth-User\n\n      [entryPoints.http.auth.basic]\n        removeHeader = true\n        users = [\n          \ntest:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\n,\n          \ntest2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\n,\n        ]\n        usersFile = \n/path/to/.htpasswd\n\n      [entryPoints.http.auth.digest]\n        removeHeader = true\n        users = [\n          \ntest:traefik:a2688e031edb4be6a3797f3882655c05\n,\n          \ntest2:traefik:518845800f9e2bfb1f1f740ec24f074e\n,\n        ]\n        usersFile = \n/path/to/.htdigest\n\n      [entryPoints.http.auth.forward]\n        address = \nhttps://authserver.com/auth\n\n        trustForwardHeader = true\n        authResponseHeaders = [\nX-Auth-User\n]\n        [entryPoints.http.auth.forward.tls]\n          ca = \npath/to/local.crt\n\n          caOptional = true\n          cert = \npath/to/foo.cert\n\n          key = \npath/to/foo.key\n\n          insecureSkipVerify = true\n\n    [entryPoints.http.proxyProtocol]\n      insecure = true\n      trustedIPs = [\n10.10.10.1\n, \n10.10.10.2\n]\n\n    [entryPoints.http.forwardedHeaders]\n      trustedIPs = [\n10.10.10.1\n, \n10.10.10.2\n]\n\n  [entryPoints.https]\n    # ...\n\n\n\n\nCLI\n\n\nFor more information about the CLI, see the documentation about \nTraefik command\n.\n\n\n--entryPoints='Name:http Address::80'\n--entryPoints='Name:https Address::443 TLS'\n\n\n\n\n\n\nNote\n\n\nWhitespace is used as option separator and \n,\n is used as value separator for the list.\n\nThe names of the options are case-insensitive.\n\n\n\n\nIn compose file the entrypoint syntax is different. Notice how quotes are used:\n\n\ntraefik:\n    image: traefik:v1.7\n    command:\n        - --defaultentrypoints=powpow\n        - \n--entryPoints=Name:powpow Address::42 Compress:true\n\n\n\n\n\nor\n\n\ntraefik:\n    image: traefik:v1.7\n    command: --defaultentrypoints=powpow --entryPoints='Name:powpow Address::42 Compress:true'\n\n\n\n\nAll available options:\n\n\nName:foo\nAddress::80\nTLS:/my/path/foo.cert,/my/path/foo.key;/my/path/goo.cert,/my/path/goo.key;/my/path/hoo.cert,/my/path/hoo.key\nTLS\nTLS.MinVersion:VersionTLS11\nTLS.CipherSuites:TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA384\nTLS.SniStrict:true\nTLS.DefaultCertificate.Cert:path/to/foo.cert\nTLS.DefaultCertificate.Key:path/to/foo.key\nCA:car\nCA.Optional:true\nRedirect.EntryPoint:https\nRedirect.Regex:http://localhost/(.*)\nRedirect.Replacement:http://mydomain/$1\nRedirect.Permanent:true\nCompress:true\nWhiteList.SourceRange:10.42.0.0/16,152.89.1.33/32,afed:be44::/16\nWhiteList.UseXForwardedFor:true\nProxyProtocol.TrustedIPs:192.168.0.1\nProxyProtocol.Insecure:true\nForwardedHeaders.TrustedIPs:10.0.0.3/24,20.0.0.3/24\nAuth.Basic.Users:test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\nAuth.Basic.Removeheader:true\nAuth.Digest.Users:test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\nAuth.Digest.Removeheader:true\nAuth.HeaderField:X-WebAuth-User\nAuth.Forward.Address:https://authserver.com/auth\nAuth.Forward.AuthResponseHeaders:X-Auth,X-Test,X-Secret\nAuth.Forward.TrustForwardHeader:true\nAuth.Forward.TLS.CA:path/to/local.crt\nAuth.Forward.TLS.CAOptional:true\nAuth.Forward.TLS.Cert:path/to/foo.cert\nAuth.Forward.TLS.Key:path/to/foo.key\nAuth.Forward.TLS.InsecureSkipVerify:true\n\n\n\n\nBasic\n\n\n# Entrypoints definition\n#\n# Default:\n# [entryPoints]\n#   [entryPoints.http]\n#   address = \n:80\n\n#\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n\n\n\n\nRedirect HTTP to HTTPS\n\n\nTo redirect an http entrypoint to an https entrypoint (with SNI support).\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n    [entryPoints.http.redirect]\n    entryPoint = \nhttps\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile = \nintegration/fixtures/https/snitest.com.cert\n\n      keyFile = \nintegration/fixtures/https/snitest.com.key\n\n      [[entryPoints.https.tls.certificates]]\n      certFile = \nintegration/fixtures/https/snitest.org.cert\n\n      keyFile = \nintegration/fixtures/https/snitest.org.key\n\n\n\n\n\n\n\nNote\n\n\nPlease note that \nregex\n and \nreplacement\n do not have to be set in the \nredirect\n structure if an entrypoint is defined for the redirection (they will not be used in this case).\n\n\n\n\nRewriting URL\n\n\nTo redirect an entrypoint rewriting the URL.\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n    [entryPoints.http.redirect]\n    regex = \n^http://localhost/(.*)\n\n    replacement = \nhttp://mydomain/$1\n\n\n\n\n\n\n\nNote\n\n\nPlease note that \nregex\n and \nreplacement\n do not have to be set in the \nredirect\n structure if an \nentrypoint\n is defined for the redirection (they will not be used in this case).\n\n\n\n\nCare should be taken when defining replacement expand variables: \n$1x\n is equivalent to \n${1x}\n, not \n${1}x\n (see \nRegexp.Expand\n), so use \n${1}\n syntax.\n\n\nRegular expressions and replacements can be tested using online tools such as \nGo Playground\n or the \nRegex101\n.\n\n\nTLS\n\n\nStatic Certificates\n\n\nDefine an entrypoint with SNI support.\n\n\n[entryPoints]\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile = \nintegration/fixtures/https/snitest.com.cert\n\n      keyFile = \nintegration/fixtures/https/snitest.com.key\n\n\n\n\n\n\n\nNote\n\n\nIf an empty TLS configuration is provided, default self-signed certificates are generated.\n\n\n\n\nDynamic Certificates\n\n\nIf you need to add or remove TLS certificates while Traefik is started, Dynamic TLS certificates are supported using the \nfile provider\n.\n\n\nTLS Mutual Authentication\n\n\nTLS Mutual Authentication can be \noptional\n or not.\n\n\n\n\nIf \noptional = true\n, if a certificate is provided, verifies if it is signed by a specified Certificate Authority (CA). Otherwise proceeds without any certificate.\n\n\nIf \noptional = false\n, Traefik will only accept clients that present a certificate signed by a specified Certificate Authority (CA).\n\n\n\n\n\n\nWarning\n\n\nWhile the TLS \n1.1\n and \n1.2\n RFCs specify that clients should proceed with handshaking by sending an empty list should they have no certs for the CAs specified by the server, not all do so in practice.\nUse this feature with caution should you require maximum compatibility with a wide variety of client user agents which may not strictly implement these specs.\n\n\n\n\nClientCAFiles\n can be configured with multiple \nCA:s\n in the same file or use multiple files containing one or several \nCA:s\n.\nThe \nCA:s\n has to be in PEM format.\n\n\nBy default, \nClientCAFiles\n is not optional, all clients will be required to present a valid cert. The requirement will apply to all server certs in the entrypoint.\n\n\nIn the example below both \nsnitest.com\n and \nsnitest.org\n will require client certs\n\n\n[entryPoints]\n  [entryPoints.https]\n  address = \n:443\n\n  [entryPoints.https.tls]\n    [entryPoints.https.tls.ClientCA]\n    files = [\ntests/clientca1.crt\n, \ntests/clientca2.crt\n]\n    optional = false\n    [[entryPoints.https.tls.certificates]]\n    certFile = \nintegration/fixtures/https/snitest.com.cert\n\n    keyFile = \nintegration/fixtures/https/snitest.com.key\n\n    [[entryPoints.https.tls.certificates]]\n    certFile = \nintegration/fixtures/https/snitest.org.cert\n\n    keyFile = \nintegration/fixtures/https/snitest.org.key\n\n\n\n\n\n\n\nNote\n\n\nThe deprecated argument \nClientCAFiles\n allows adding Client CA files which are mandatory.\nIf this parameter exists, the new ones are not checked.\n\n\n\n\nAuthentication\n\n\nBasic Authentication\n\n\nPasswords can be encoded in MD5, SHA1 and BCrypt: you can use \nhtpasswd\n to generate them.\n\n\nUsers can be specified directly in the TOML file, or indirectly by referencing an external file;\n if both are provided, the two are merged, with external file contents having precedence.\n\n\n# To enable basic auth on an entrypoint with 2 user/pass: test:test and test2:test2\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.http.auth.basic]\n  users = [\ntest:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\n, \ntest2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\n]\n  usersFile = \n/path/to/.htpasswd\n\n\n\n\n\nOptionally, you can:\n\n\n\n\npass authenticated user to application via headers\n\n\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.http.auth]\n    headerField = \nX-WebAuth-User\n # \n-- header for the authenticated user\n    [entryPoints.http.auth.basic]\n    users = [\ntest:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\n, \ntest2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\n]\n\n\n\n\n\n\nremove the Authorization header\n\n\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.http.auth]\n    [entryPoints.http.auth.basic]\n    removeHeader = true # \n-- remove the Authorization header\n    users = [\ntest:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\n, \ntest2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\n]\n\n\n\n\nDigest Authentication\n\n\nYou can use \nhtdigest\n to generate them.\n\n\nUsers can be specified directly in the TOML file, or indirectly by referencing an external file;\n if both are provided, the two are merged, with external file contents having precedence\n\n\n# To enable digest auth on an entrypoint with 2 user/realm/pass: test:traefik:test and test2:traefik:test2\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.http.auth.digest]\n  users = [\ntest:traefik:a2688e031edb4be6a3797f3882655c05\n, \ntest2:traefik:518845800f9e2bfb1f1f740ec24f074e\n]\n  usersFile = \n/path/to/.htdigest\n\n\n\n\n\nOptionally, you can!\n\n\n\n\npass authenticated user to application via headers.\n\n\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.http.auth]\n    headerField = \nX-WebAuth-User\n # \n-- header for the authenticated user\n    [entryPoints.http.auth.digest]\n    users = [\ntest:traefik:a2688e031edb4be6a3797f3882655c05\n, \ntest2:traefik:518845800f9e2bfb1f1f740ec24f074e\n]\n\n\n\n\n\n\nremove the Authorization header.\n\n\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.http.auth]\n    [entryPoints.http.auth.digest]\n    removeHeader = true # \n-- remove the Authorization header\n    users = [\ntest:traefik:a2688e031edb4be6a3797f3882655c05\n, \ntest2:traefik:518845800f9e2bfb1f1f740ec24f074e\n]\n\n\n\n\nForward Authentication\n\n\nThis configuration will first forward the request to \nhttp://authserver.com/auth\n.\n\n\nIf the response code is 2XX, access is granted and the original request is performed.\nOtherwise, the response from the authentication server is returned.\n\n\n[entryPoints]\n  [entryPoints.http]\n    # ...\n    # To enable forward auth on an entrypoint\n    [entryPoints.http.auth.forward]\n    address = \nhttps://authserver.com/auth\n\n\n    # Trust existing X-Forwarded-* headers.\n    # Useful with another reverse proxy in front of Traefik.\n    #\n    # Optional\n    # Default: false\n    #\n    trustForwardHeader = true\n\n    # Copy headers from the authentication server to the request.\n    #\n    # Optional\n    #\n    authResponseHeaders = [\nX-Auth-User\n, \nX-Secret\n]\n\n      # Enable forward auth TLS connection.\n      #\n      # Optional\n      #\n      [entryPoints.http.auth.forward.tls]\n      ca = \npath/to/local.crt\n\n      caOptional = true\n      cert = \npath/to/foo.cert\n\n      key = \npath/to/foo.key\n\n\n\n\n\nSpecify Minimum TLS Version\n\n\nTo specify an https entry point with a minimum TLS version, and specifying an array of cipher suites (from \ncrypto/tls\n).\n\n\n[entryPoints]\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n    minVersion = \nVersionTLS12\n\n    cipherSuites = [\n      \nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n,\n      \nTLS_RSA_WITH_AES_256_GCM_SHA384\n\n    ]\n      [[entryPoints.https.tls.certificates]]\n      certFile = \nintegration/fixtures/https/snitest.com.cert\n\n      keyFile = \nintegration/fixtures/https/snitest.com.key\n\n      [[entryPoints.https.tls.certificates]]\n      certFile = \nintegration/fixtures/https/snitest.org.cert\n\n      keyFile = \nintegration/fixtures/https/snitest.org.key\n\n\n\n\n\nStrict SNI Checking\n\n\nTo enable strict SNI checking, so that connections cannot be made if a matching certificate does not exist.\n\n\n[entryPoints]\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n    sniStrict = true\n      [[entryPoints.https.tls.certificates]]\n      certFile = \nintegration/fixtures/https/snitest.com.cert\n\n      keyFile = \nintegration/fixtures/https/snitest.com.key\n\n\n\n\n\nDefault Certificate\n\n\nTo enable a default certificate to serve, so that connections without SNI or without a matching domain will be served this certificate.\n\n\n[entryPoints]\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n    [entryPoints.https.tls.defaultCertificate]\n      certFile = \nintegration/fixtures/https/snitest.com.cert\n\n      keyFile = \nintegration/fixtures/https/snitest.com.key\n\n\n\n\n\n\n\nNote\n\n\nThere can only be one \ndefaultCertificate\n set per entrypoint.\nUse a single set of square brackets \n[ ]\n, instead of the two needed for normal certificates.\nIf no default certificate is provided, a self-signed certificate will be generated by Traefik, and used instead.\n\n\n\n\nCompression\n\n\nTo enable compression support using gzip format.\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  compress = true\n\n\n\n\nResponses are compressed when:\n\n\n\n\nThe response body is larger than \n512\n bytes\n\n\nAnd the \nAccept-Encoding\n request header contains \ngzip\n\n\nAnd the response is not already compressed, i.e. the \nContent-Encoding\n response header is not already set.\n\n\n\n\nWhite Listing\n\n\nTo enable IP white listing at the entry point level.\n\n\n[entryPoints]\n  [entryPoints.http]\n    address = \n:80\n\n\n    [entryPoints.http.whiteList]\n      sourceRange = [\n127.0.0.1/32\n, \n192.168.1.7\n]\n      # useXForwardedFor = true\n\n\n\n\nProxyProtocol\n\n\nTo enable \nProxyProtocol\n support.\nOnly IPs in \ntrustedIPs\n will lead to remote client address replacement: you should declare your load-balancer IP or CIDR range here (in testing environment, you can trust everyone using \ninsecure = true\n).\n\n\n\n\nDanger\n\n\nWhen queuing Traefik behind another load-balancer, be sure to carefully configure Proxy Protocol on both sides.\nOtherwise, it could introduce a security risk in your system by forging requests.\n\n\n\n\n[entryPoints]\n  [entryPoints.http]\n    address = \n:80\n\n\n    # Enable ProxyProtocol\n    [entryPoints.http.proxyProtocol]\n      # List of trusted IPs\n      #\n      # Required\n      # Default: []\n      #\n      trustedIPs = [\n127.0.0.1/32\n, \n192.168.1.7\n]\n\n      # Insecure mode FOR TESTING ENVIRONNEMENT ONLY\n      #\n      # Optional\n      # Default: false\n      #\n      # insecure = true\n\n\n\n\nForwarded Header\n\n\nOnly IPs in \ntrustedIPs\n will be authorized to trust the client forwarded headers (\nX-Forwarded-*\n).\n\n\n[entryPoints]\n  [entryPoints.http]\n    address = \n:80\n\n\n    # Enable Forwarded Headers\n    [entryPoints.http.forwardedHeaders]\n      # List of trusted IPs\n      #\n      # Required\n      # Default: []\n      #\n      trustedIPs = [\n127.0.0.1/32\n, \n192.168.1.7\n]", 
            "title": "EntryPoints"
        }, 
        {
            "location": "/configuration/entrypoints/#entry-points-definition", 
            "text": "", 
            "title": "Entry Points Definition"
        }, 
        {
            "location": "/configuration/entrypoints/#reference", 
            "text": "", 
            "title": "Reference"
        }, 
        {
            "location": "/configuration/entrypoints/#toml", 
            "text": "defaultEntryPoints = [ http ,  https ]\n\n# ...\n# ...\n\n[entryPoints]\n  [entryPoints.http]\n    address =  :80 \n    compress = true\n\n    [entryPoints.http.whitelist]\n      sourceRange = [ 10.42.0.0/16 ,  152.89.1.33/32 ,  afed:be44::/16 ]\n      useXForwardedFor = true\n\n    [entryPoints.http.tls]\n      minVersion =  VersionTLS12 \n      cipherSuites = [\n         TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 ,\n         TLS_RSA_WITH_AES_256_GCM_SHA384 \n       ]\n      [[entryPoints.http.tls.certificates]]\n        certFile =  path/to/my.cert \n        keyFile =  path/to/my.key \n      [[entryPoints.http.tls.certificates]]\n        certFile =  path/to/other.cert \n        keyFile =  path/to/other.key \n      # ...\n      [entryPoints.http.tls.clientCA]\n        files = [ path/to/ca1.crt ,  path/to/ca2.crt ]\n        optional = false\n\n    [entryPoints.http.redirect]\n      entryPoint =  https \n      regex =  ^http://localhost/(.*) \n      replacement =  http://mydomain/$1 \n      permanent = true\n\n    [entryPoints.http.auth]\n      headerField =  X-WebAuth-User \n      [entryPoints.http.auth.basic]\n        removeHeader = true\n        users = [\n           test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ ,\n           test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 ,\n        ]\n        usersFile =  /path/to/.htpasswd \n      [entryPoints.http.auth.digest]\n        removeHeader = true\n        users = [\n           test:traefik:a2688e031edb4be6a3797f3882655c05 ,\n           test2:traefik:518845800f9e2bfb1f1f740ec24f074e ,\n        ]\n        usersFile =  /path/to/.htdigest \n      [entryPoints.http.auth.forward]\n        address =  https://authserver.com/auth \n        trustForwardHeader = true\n        authResponseHeaders = [ X-Auth-User ]\n        [entryPoints.http.auth.forward.tls]\n          ca =  path/to/local.crt \n          caOptional = true\n          cert =  path/to/foo.cert \n          key =  path/to/foo.key \n          insecureSkipVerify = true\n\n    [entryPoints.http.proxyProtocol]\n      insecure = true\n      trustedIPs = [ 10.10.10.1 ,  10.10.10.2 ]\n\n    [entryPoints.http.forwardedHeaders]\n      trustedIPs = [ 10.10.10.1 ,  10.10.10.2 ]\n\n  [entryPoints.https]\n    # ...", 
            "title": "TOML"
        }, 
        {
            "location": "/configuration/entrypoints/#cli", 
            "text": "For more information about the CLI, see the documentation about  Traefik command .  --entryPoints='Name:http Address::80'\n--entryPoints='Name:https Address::443 TLS'   Note  Whitespace is used as option separator and  ,  is used as value separator for the list. \nThe names of the options are case-insensitive.   In compose file the entrypoint syntax is different. Notice how quotes are used:  traefik:\n    image: traefik:v1.7\n    command:\n        - --defaultentrypoints=powpow\n        -  --entryPoints=Name:powpow Address::42 Compress:true   or  traefik:\n    image: traefik:v1.7\n    command: --defaultentrypoints=powpow --entryPoints='Name:powpow Address::42 Compress:true'", 
            "title": "CLI"
        }, 
        {
            "location": "/configuration/entrypoints/#all-available-options", 
            "text": "Name:foo\nAddress::80\nTLS:/my/path/foo.cert,/my/path/foo.key;/my/path/goo.cert,/my/path/goo.key;/my/path/hoo.cert,/my/path/hoo.key\nTLS\nTLS.MinVersion:VersionTLS11\nTLS.CipherSuites:TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA384\nTLS.SniStrict:true\nTLS.DefaultCertificate.Cert:path/to/foo.cert\nTLS.DefaultCertificate.Key:path/to/foo.key\nCA:car\nCA.Optional:true\nRedirect.EntryPoint:https\nRedirect.Regex:http://localhost/(.*)\nRedirect.Replacement:http://mydomain/$1\nRedirect.Permanent:true\nCompress:true\nWhiteList.SourceRange:10.42.0.0/16,152.89.1.33/32,afed:be44::/16\nWhiteList.UseXForwardedFor:true\nProxyProtocol.TrustedIPs:192.168.0.1\nProxyProtocol.Insecure:true\nForwardedHeaders.TrustedIPs:10.0.0.3/24,20.0.0.3/24\nAuth.Basic.Users:test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\nAuth.Basic.Removeheader:true\nAuth.Digest.Users:test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\nAuth.Digest.Removeheader:true\nAuth.HeaderField:X-WebAuth-User\nAuth.Forward.Address:https://authserver.com/auth\nAuth.Forward.AuthResponseHeaders:X-Auth,X-Test,X-Secret\nAuth.Forward.TrustForwardHeader:true\nAuth.Forward.TLS.CA:path/to/local.crt\nAuth.Forward.TLS.CAOptional:true\nAuth.Forward.TLS.Cert:path/to/foo.cert\nAuth.Forward.TLS.Key:path/to/foo.key\nAuth.Forward.TLS.InsecureSkipVerify:true", 
            "title": "All available options:"
        }, 
        {
            "location": "/configuration/entrypoints/#basic", 
            "text": "# Entrypoints definition\n#\n# Default:\n# [entryPoints]\n#   [entryPoints.http]\n#   address =  :80 \n#\n[entryPoints]\n  [entryPoints.http]\n  address =  :80", 
            "title": "Basic"
        }, 
        {
            "location": "/configuration/entrypoints/#redirect-http-to-https", 
            "text": "To redirect an http entrypoint to an https entrypoint (with SNI support).  [entryPoints]\n  [entryPoints.http]\n  address =  :80 \n    [entryPoints.http.redirect]\n    entryPoint =  https \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile =  integration/fixtures/https/snitest.com.cert \n      keyFile =  integration/fixtures/https/snitest.com.key \n      [[entryPoints.https.tls.certificates]]\n      certFile =  integration/fixtures/https/snitest.org.cert \n      keyFile =  integration/fixtures/https/snitest.org.key    Note  Please note that  regex  and  replacement  do not have to be set in the  redirect  structure if an entrypoint is defined for the redirection (they will not be used in this case).", 
            "title": "Redirect HTTP to HTTPS"
        }, 
        {
            "location": "/configuration/entrypoints/#rewriting-url", 
            "text": "To redirect an entrypoint rewriting the URL.  [entryPoints]\n  [entryPoints.http]\n  address =  :80 \n    [entryPoints.http.redirect]\n    regex =  ^http://localhost/(.*) \n    replacement =  http://mydomain/$1    Note  Please note that  regex  and  replacement  do not have to be set in the  redirect  structure if an  entrypoint  is defined for the redirection (they will not be used in this case).   Care should be taken when defining replacement expand variables:  $1x  is equivalent to  ${1x} , not  ${1}x  (see  Regexp.Expand ), so use  ${1}  syntax.  Regular expressions and replacements can be tested using online tools such as  Go Playground  or the  Regex101 .", 
            "title": "Rewriting URL"
        }, 
        {
            "location": "/configuration/entrypoints/#tls", 
            "text": "", 
            "title": "TLS"
        }, 
        {
            "location": "/configuration/entrypoints/#static-certificates", 
            "text": "Define an entrypoint with SNI support.  [entryPoints]\n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile =  integration/fixtures/https/snitest.com.cert \n      keyFile =  integration/fixtures/https/snitest.com.key    Note  If an empty TLS configuration is provided, default self-signed certificates are generated.", 
            "title": "Static Certificates"
        }, 
        {
            "location": "/configuration/entrypoints/#dynamic-certificates", 
            "text": "If you need to add or remove TLS certificates while Traefik is started, Dynamic TLS certificates are supported using the  file provider .", 
            "title": "Dynamic Certificates"
        }, 
        {
            "location": "/configuration/entrypoints/#tls-mutual-authentication", 
            "text": "TLS Mutual Authentication can be  optional  or not.   If  optional = true , if a certificate is provided, verifies if it is signed by a specified Certificate Authority (CA). Otherwise proceeds without any certificate.  If  optional = false , Traefik will only accept clients that present a certificate signed by a specified Certificate Authority (CA).    Warning  While the TLS  1.1  and  1.2  RFCs specify that clients should proceed with handshaking by sending an empty list should they have no certs for the CAs specified by the server, not all do so in practice.\nUse this feature with caution should you require maximum compatibility with a wide variety of client user agents which may not strictly implement these specs.   ClientCAFiles  can be configured with multiple  CA:s  in the same file or use multiple files containing one or several  CA:s .\nThe  CA:s  has to be in PEM format.  By default,  ClientCAFiles  is not optional, all clients will be required to present a valid cert. The requirement will apply to all server certs in the entrypoint.  In the example below both  snitest.com  and  snitest.org  will require client certs  [entryPoints]\n  [entryPoints.https]\n  address =  :443 \n  [entryPoints.https.tls]\n    [entryPoints.https.tls.ClientCA]\n    files = [ tests/clientca1.crt ,  tests/clientca2.crt ]\n    optional = false\n    [[entryPoints.https.tls.certificates]]\n    certFile =  integration/fixtures/https/snitest.com.cert \n    keyFile =  integration/fixtures/https/snitest.com.key \n    [[entryPoints.https.tls.certificates]]\n    certFile =  integration/fixtures/https/snitest.org.cert \n    keyFile =  integration/fixtures/https/snitest.org.key    Note  The deprecated argument  ClientCAFiles  allows adding Client CA files which are mandatory.\nIf this parameter exists, the new ones are not checked.", 
            "title": "TLS Mutual Authentication"
        }, 
        {
            "location": "/configuration/entrypoints/#authentication", 
            "text": "", 
            "title": "Authentication"
        }, 
        {
            "location": "/configuration/entrypoints/#basic-authentication", 
            "text": "Passwords can be encoded in MD5, SHA1 and BCrypt: you can use  htpasswd  to generate them.  Users can be specified directly in the TOML file, or indirectly by referencing an external file;\n if both are provided, the two are merged, with external file contents having precedence.  # To enable basic auth on an entrypoint with 2 user/pass: test:test and test2:test2\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.http.auth.basic]\n  users = [ test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ ,  test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 ]\n  usersFile =  /path/to/.htpasswd   Optionally, you can:   pass authenticated user to application via headers   [entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.http.auth]\n    headerField =  X-WebAuth-User  #  -- header for the authenticated user\n    [entryPoints.http.auth.basic]\n    users = [ test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ ,  test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 ]   remove the Authorization header   [entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.http.auth]\n    [entryPoints.http.auth.basic]\n    removeHeader = true #  -- remove the Authorization header\n    users = [ test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ ,  test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 ]", 
            "title": "Basic Authentication"
        }, 
        {
            "location": "/configuration/entrypoints/#digest-authentication", 
            "text": "You can use  htdigest  to generate them.  Users can be specified directly in the TOML file, or indirectly by referencing an external file;\n if both are provided, the two are merged, with external file contents having precedence  # To enable digest auth on an entrypoint with 2 user/realm/pass: test:traefik:test and test2:traefik:test2\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.http.auth.digest]\n  users = [ test:traefik:a2688e031edb4be6a3797f3882655c05 ,  test2:traefik:518845800f9e2bfb1f1f740ec24f074e ]\n  usersFile =  /path/to/.htdigest   Optionally, you can!   pass authenticated user to application via headers.   [entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.http.auth]\n    headerField =  X-WebAuth-User  #  -- header for the authenticated user\n    [entryPoints.http.auth.digest]\n    users = [ test:traefik:a2688e031edb4be6a3797f3882655c05 ,  test2:traefik:518845800f9e2bfb1f1f740ec24f074e ]   remove the Authorization header.   [entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.http.auth]\n    [entryPoints.http.auth.digest]\n    removeHeader = true #  -- remove the Authorization header\n    users = [ test:traefik:a2688e031edb4be6a3797f3882655c05 ,  test2:traefik:518845800f9e2bfb1f1f740ec24f074e ]", 
            "title": "Digest Authentication"
        }, 
        {
            "location": "/configuration/entrypoints/#forward-authentication", 
            "text": "This configuration will first forward the request to  http://authserver.com/auth .  If the response code is 2XX, access is granted and the original request is performed.\nOtherwise, the response from the authentication server is returned.  [entryPoints]\n  [entryPoints.http]\n    # ...\n    # To enable forward auth on an entrypoint\n    [entryPoints.http.auth.forward]\n    address =  https://authserver.com/auth \n\n    # Trust existing X-Forwarded-* headers.\n    # Useful with another reverse proxy in front of Traefik.\n    #\n    # Optional\n    # Default: false\n    #\n    trustForwardHeader = true\n\n    # Copy headers from the authentication server to the request.\n    #\n    # Optional\n    #\n    authResponseHeaders = [ X-Auth-User ,  X-Secret ]\n\n      # Enable forward auth TLS connection.\n      #\n      # Optional\n      #\n      [entryPoints.http.auth.forward.tls]\n      ca =  path/to/local.crt \n      caOptional = true\n      cert =  path/to/foo.cert \n      key =  path/to/foo.key", 
            "title": "Forward Authentication"
        }, 
        {
            "location": "/configuration/entrypoints/#specify-minimum-tls-version", 
            "text": "To specify an https entry point with a minimum TLS version, and specifying an array of cipher suites (from  crypto/tls ).  [entryPoints]\n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n    minVersion =  VersionTLS12 \n    cipherSuites = [\n       TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 ,\n       TLS_RSA_WITH_AES_256_GCM_SHA384 \n    ]\n      [[entryPoints.https.tls.certificates]]\n      certFile =  integration/fixtures/https/snitest.com.cert \n      keyFile =  integration/fixtures/https/snitest.com.key \n      [[entryPoints.https.tls.certificates]]\n      certFile =  integration/fixtures/https/snitest.org.cert \n      keyFile =  integration/fixtures/https/snitest.org.key", 
            "title": "Specify Minimum TLS Version"
        }, 
        {
            "location": "/configuration/entrypoints/#strict-sni-checking", 
            "text": "To enable strict SNI checking, so that connections cannot be made if a matching certificate does not exist.  [entryPoints]\n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n    sniStrict = true\n      [[entryPoints.https.tls.certificates]]\n      certFile =  integration/fixtures/https/snitest.com.cert \n      keyFile =  integration/fixtures/https/snitest.com.key", 
            "title": "Strict SNI Checking"
        }, 
        {
            "location": "/configuration/entrypoints/#default-certificate", 
            "text": "To enable a default certificate to serve, so that connections without SNI or without a matching domain will be served this certificate.  [entryPoints]\n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n    [entryPoints.https.tls.defaultCertificate]\n      certFile =  integration/fixtures/https/snitest.com.cert \n      keyFile =  integration/fixtures/https/snitest.com.key    Note  There can only be one  defaultCertificate  set per entrypoint.\nUse a single set of square brackets  [ ] , instead of the two needed for normal certificates.\nIf no default certificate is provided, a self-signed certificate will be generated by Traefik, and used instead.", 
            "title": "Default Certificate"
        }, 
        {
            "location": "/configuration/entrypoints/#compression", 
            "text": "To enable compression support using gzip format.  [entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  compress = true  Responses are compressed when:   The response body is larger than  512  bytes  And the  Accept-Encoding  request header contains  gzip  And the response is not already compressed, i.e. the  Content-Encoding  response header is not already set.", 
            "title": "Compression"
        }, 
        {
            "location": "/configuration/entrypoints/#white-listing", 
            "text": "To enable IP white listing at the entry point level.  [entryPoints]\n  [entryPoints.http]\n    address =  :80 \n\n    [entryPoints.http.whiteList]\n      sourceRange = [ 127.0.0.1/32 ,  192.168.1.7 ]\n      # useXForwardedFor = true", 
            "title": "White Listing"
        }, 
        {
            "location": "/configuration/entrypoints/#proxyprotocol", 
            "text": "To enable  ProxyProtocol  support.\nOnly IPs in  trustedIPs  will lead to remote client address replacement: you should declare your load-balancer IP or CIDR range here (in testing environment, you can trust everyone using  insecure = true ).   Danger  When queuing Traefik behind another load-balancer, be sure to carefully configure Proxy Protocol on both sides.\nOtherwise, it could introduce a security risk in your system by forging requests.   [entryPoints]\n  [entryPoints.http]\n    address =  :80 \n\n    # Enable ProxyProtocol\n    [entryPoints.http.proxyProtocol]\n      # List of trusted IPs\n      #\n      # Required\n      # Default: []\n      #\n      trustedIPs = [ 127.0.0.1/32 ,  192.168.1.7 ]\n\n      # Insecure mode FOR TESTING ENVIRONNEMENT ONLY\n      #\n      # Optional\n      # Default: false\n      #\n      # insecure = true", 
            "title": "ProxyProtocol"
        }, 
        {
            "location": "/configuration/entrypoints/#forwarded-header", 
            "text": "Only IPs in  trustedIPs  will be authorized to trust the client forwarded headers ( X-Forwarded-* ).  [entryPoints]\n  [entryPoints.http]\n    address =  :80 \n\n    # Enable Forwarded Headers\n    [entryPoints.http.forwardedHeaders]\n      # List of trusted IPs\n      #\n      # Required\n      # Default: []\n      #\n      trustedIPs = [ 127.0.0.1/32 ,  192.168.1.7 ]", 
            "title": "Forwarded Header"
        }, 
        {
            "location": "/configuration/acme/", 
            "text": "ACME (Let's Encrypt) Configuration\n\n\nSee \nLet's Encrypt examples\n and \nDocker \n Let's Encrypt user guide\n as well.\n\n\nConfiguration\n\n\n# Sample entrypoint configuration when using ACME.\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n\n\n\n\n# Enable ACME (Let's Encrypt): automatic SSL.\n[acme]\n\n# Email address used for registration.\n#\n# Required\n#\nemail = \ntest@traefik.io\n\n\n# File used for certificates storage.\n#\n# Optional (Deprecated)\n#\n#storageFile = \nacme.json\n\n\n# File or key used for certificates storage.\n#\n# Required\n#\nstorage = \nacme.json\n\n# or `storage = \ntraefik/acme/account\n` if using KV store.\n\n# Entrypoint to proxy acme apply certificates to.\n#\n# Required\n#\nentryPoint = \nhttps\n\n\n# Deprecated, replaced by [acme.dnsChallenge].\n#\n# Optional.\n#\n# dnsProvider = \ndigitalocean\n\n\n# Deprecated, replaced by [acme.dnsChallenge.delayBeforeCheck].\n#\n# Optional\n# Default: 0\n#\n# delayDontCheckDNS = 0\n\n# If true, display debug log messages from the acme client library.\n#\n# Optional\n# Default: false\n#\n# acmeLogging = true\n\n# If true, override certificates in key-value store when using storeconfig.\n#\n# Optional\n# Default: false\n#\n# overrideCertificates = true\n\n# Deprecated. Enable on demand certificate generation.\n#\n# Optional\n# Default: false\n#\n# onDemand = true\n\n# Enable certificate generation on frontends host rules.\n#\n# Optional\n# Default: false\n#\n# onHostRule = true\n\n# CA server to use.\n# Uncomment the line to use Let's Encrypt's staging server,\n# leave commented to go to prod.\n#\n# Optional\n# Default: \nhttps://acme-v02.api.letsencrypt.org/directory\n\n#\n# caServer = \nhttps://acme-staging-v02.api.letsencrypt.org/directory\n\n\n# KeyType to use.\n#\n# Optional\n# Default: \nRSA4096\n\n#\n# Available values : \nEC256\n, \nEC384\n, \nRSA2048\n, \nRSA4096\n, \nRSA8192\n\n#\n# KeyType = \nRSA4096\n\n\n# Use a TLS-ALPN-01 ACME challenge.\n#\n# Optional (but recommended)\n#\n[acme.tlsChallenge]\n\n# Use a HTTP-01 ACME challenge.\n#\n# Optional\n#\n# [acme.httpChallenge]\n\n  # EntryPoint to use for the HTTP-01 challenges.\n  #\n  # Required\n  #\n  # entryPoint = \nhttp\n\n\n# Use a DNS-01 ACME challenge rather than HTTP-01 challenge.\n# Note: mandatory for wildcard certificate generation.\n#\n# Optional\n#\n# [acme.dnsChallenge]\n\n  # DNS provider used.\n  #\n  # Required\n  #\n  # provider = \ndigitalocean\n\n\n  # By default, the provider will verify the TXT DNS challenge record before letting ACME verify.\n  # If delayBeforeCheck is greater than zero, this check is delayed for the configured duration in seconds.\n  # Useful if internal networks block external DNS queries.\n  #\n  # Optional\n  # Default: 0\n  #\n  # delayBeforeCheck = 0\n\n  # Use following DNS servers to resolve the FQDN authority.\n  #\n  # Optional\n  # Default: empty\n  #\n  # resolvers = [\n1.1.1.1:53\n, \n8.8.8.8:53\n]\n\n  # Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready.\n  #\n  # NOT RECOMMENDED:\n  # Increase the risk of reaching Let's Encrypt's rate limits.\n  #\n  # Optional\n  # Default: false\n  #\n  # disablePropagationCheck = true\n\n# Domains list.\n# Only domains defined here can generate wildcard certificates.\n# The certificates for these domains are negotiated at traefik startup only.\n#\n# [[acme.domains]]\n#   main = \nlocal1.com\n\n#   sans = [\ntest1.local1.com\n, \ntest2.local1.com\n]\n# [[acme.domains]]\n#   main = \nlocal2.com\n\n# [[acme.domains]]\n#   main = \n*.local3.com\n\n#   sans = [\nlocal3.com\n, \ntest1.test1.local3.com\n]\n\n\n\n\ncaServer\n\n\nThe CA server to use.\n\n\nThis example shows the usage of Let's Encrypt's staging server:\n\n\n[acme]\n# ...\ncaServer = \nhttps://acme-staging-v02.api.letsencrypt.org/directory\n\n# ...\n\n\n\n\nACME Challenge\n\n\ntlsChallenge\n\n\nUse the \nTLS-ALPN-01\n challenge to generate and renew ACME certificates by provisioning a TLS certificate.\n\n\n[acme]\n# ...\nentryPoint = \nhttps\n\n[acme.tlsChallenge]\n\n\n\n\n\n\nNote\n\n\nIf the \nTLS-ALPN-01\n challenge is used, \nacme.entryPoint\n has to be reachable by Let's Encrypt through port 443.\nThis is a Let's Encrypt limitation as described on the \ncommunity forum\n.\n\n\n\n\nhttpChallenge\n\n\nUse the \nHTTP-01\n challenge to generate and renew ACME certificates by provisioning a HTTP resource under a well-known URI.\n\n\nRedirection is fully compatible with the \nHTTP-01\n challenge.\n\n\n[acme]\n# ...\nentryPoint = \nhttps\n\n[acme.httpChallenge]\n  entryPoint = \nhttp\n\n\n\n\n\n\n\nNote\n\n\nIf the \nHTTP-01\n challenge is used, \nacme.httpChallenge.entryPoint\n has to be defined and reachable by Let's Encrypt through port 80.\nThis is a Let's Encrypt limitation as described on the \ncommunity forum\n.\n\n\n\n\nentryPoint\n\n\nSpecify the entryPoint to use during the challenges.\n\n\ndefaultEntryPoints = [\nhttp\n, \nhttps\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n# ...\n\n[acme]\n  # ...\n  entryPoint = \nhttps\n\n  [acme.httpChallenge]\n    entryPoint = \nhttp\n\n\n\n\n\n\n\nNote\n\n\nacme.httpChallenge.entryPoint\n has to be reachable through port 80. It's a Let's Encrypt limitation as described on the \ncommunity forum\n.\n\n\n\n\ndnsChallenge\n\n\nUse the \nDNS-01\n challenge to generate and renew ACME certificates by provisioning a DNS record.\n\n\n[acme]\n# ...\n[acme.dnsChallenge]\n  provider = \ndigitalocean\n\n  delayBeforeCheck = 0\n# ...\n\n\n\n\ndelayBeforeCheck\n\n\nBy default, the \nprovider\n will verify the TXT DNS challenge record before letting ACME verify.\nIf \ndelayBeforeCheck\n is greater than zero, this check is delayed for the configured duration in seconds.\n\n\nUseful if internal networks block external DNS queries.\n\n\n\n\nNote\n\n\nA \nprovider\n is mandatory.\n\n\n\n\nprovider\n\n\nHere is a list of supported \nprovider\ns, that can automate the DNS verification, along with the required environment variables and their \nwildcard \n root domain support\n for each.\nDo not hesitate to complete it.\nEvery lego environment variable can be overridden by their respective \n_FILE\n counterpart, which should have a filepath to a file that contains the secret as its value.\nFor example, \nCF_API_EMAIL_FILE=/run/secrets/traefik_cf-api-email\n could be used to provide a Cloudflare API email address as a Docker secret named \ntraefik_cf-api-email\n.\n\n\n\n\n\n\n\n\nProvider Name\n\n\nProvider Code\n\n\nEnvironment Variables\n\n\nWildcard \n Root Domain Support\n\n\n\n\n\n\n\n\n\n\nACME DNS\n\n\nacme-dns\n\n\nACME_DNS_API_BASE\n, \nACME_DNS_STORAGE_PATH\n\n\nNot tested yet\n\n\n\n\n\n\nAlibaba Cloud\n\n\nalidns\n\n\nALICLOUD_ACCESS_KEY\n, \nALICLOUD_SECRET_KEY\n, \nALICLOUD_REGION_ID\n\n\nNot tested yet\n\n\n\n\n\n\nAuroradns\n\n\nauroradns\n\n\nAURORA_USER_ID\n, \nAURORA_KEY\n, \nAURORA_ENDPOINT\n\n\nNot tested yet\n\n\n\n\n\n\nAzure\n\n\nazure\n\n\nAZURE_CLIENT_ID\n, \nAZURE_CLIENT_SECRET\n, \nAZURE_SUBSCRIPTION_ID\n, \nAZURE_TENANT_ID\n, \nAZURE_RESOURCE_GROUP\n, \n[AZURE_METADATA_ENDPOINT]\n\n\nNot tested yet\n\n\n\n\n\n\nBindman\n\n\nbindman\n\n\nBINDMAN_MANAGER_ADDRESS\n\n\nYES\n\n\n\n\n\n\nBlue Cat\n\n\nbluecat\n\n\nBLUECAT_SERVER_URL\n, \nBLUECAT_USER_NAME\n, \nBLUECAT_PASSWORD\n, \nBLUECAT_CONFIG_NAME\n, \nBLUECAT_DNS_VIEW\n\n\nNot tested yet\n\n\n\n\n\n\nClouDNS\n\n\ncloudns\n\n\nCLOUDNS_AUTH_ID\n, \nCLOUDNS_AUTH_PASSWORD\n\n\nYES\n\n\n\n\n\n\nCloudflare\n\n\ncloudflare\n\n\nCF_API_EMAIL\n, \nCF_API_KEY\n - The \nGlobal API Key\n needs to be used, not the \nOrigin CA Key\n\n\nYES\n\n\n\n\n\n\nCloudXNS\n\n\ncloudxns\n\n\nCLOUDXNS_API_KEY\n, \nCLOUDXNS_SECRET_KEY\n\n\nNot tested yet\n\n\n\n\n\n\nConoHa\n\n\nconoha\n\n\nCONOHA_TENANT_ID\n, \nCONOHA_API_USERNAME\n, \nCONOHA_API_PASSWORD\n\n\nYES\n\n\n\n\n\n\nDigitalOcean\n\n\ndigitalocean\n\n\nDO_AUTH_TOKEN\n\n\nYES\n\n\n\n\n\n\nDNSimple\n\n\ndnsimple\n\n\nDNSIMPLE_OAUTH_TOKEN\n, \nDNSIMPLE_BASE_URL\n\n\nYES\n\n\n\n\n\n\nDNS Made Easy\n\n\ndnsmadeeasy\n\n\nDNSMADEEASY_API_KEY\n, \nDNSMADEEASY_API_SECRET\n, \nDNSMADEEASY_SANDBOX\n\n\nNot tested yet\n\n\n\n\n\n\nDNSPod\n\n\ndnspod\n\n\nDNSPOD_API_KEY\n\n\nNot tested yet\n\n\n\n\n\n\nDomain Offensive (do.de)\n\n\ndode\n\n\nDODE_TOKEN\n\n\nYES\n\n\n\n\n\n\nDreamHost\n\n\ndreamhost\n\n\nDREAMHOST_API_KEY\n\n\nYES\n\n\n\n\n\n\nDuck DNS\n\n\nduckdns\n\n\nDUCKDNS_TOKEN\n\n\nYES\n\n\n\n\n\n\nDyn\n\n\ndyn\n\n\nDYN_CUSTOMER_NAME\n, \nDYN_USER_NAME\n, \nDYN_PASSWORD\n\n\nNot tested yet\n\n\n\n\n\n\nEasyDNS\n\n\neasydns\n\n\nEASYDNS_TOKEN\n, \nEASYDNS_KEY\n\n\nYES\n\n\n\n\n\n\nExternal Program\n\n\nexec\n\n\nEXEC_PATH\n\n\nYES\n\n\n\n\n\n\nExoscale\n\n\nexoscale\n\n\nEXOSCALE_API_KEY\n, \nEXOSCALE_API_SECRET\n, \nEXOSCALE_ENDPOINT\n\n\nYES\n\n\n\n\n\n\nFast DNS\n\n\nfastdns\n\n\nAKAMAI_CLIENT_TOKEN\n,  \nAKAMAI_CLIENT_SECRET\n,  \nAKAMAI_ACCESS_TOKEN\n\n\nYES\n\n\n\n\n\n\nGandi\n\n\ngandi\n\n\nGANDI_API_KEY\n\n\nNot tested yet\n\n\n\n\n\n\nGandi v5\n\n\ngandiv5\n\n\nGANDIV5_API_KEY\n\n\nYES\n\n\n\n\n\n\nGlesys\n\n\nglesys\n\n\nGLESYS_API_USER\n, \nGLESYS_API_KEY\n, \nGLESYS_DOMAIN\n\n\nNot tested yet\n\n\n\n\n\n\nGoDaddy\n\n\ngodaddy\n\n\nGODADDY_API_KEY\n, \nGODADDY_API_SECRET\n\n\nNot tested yet\n\n\n\n\n\n\nGoogle Cloud DNS\n\n\ngcloud\n\n\nGCE_PROJECT\n, Application Default Credentials (2) (3), [\nGCE_SERVICE_ACCOUNT_FILE\n]\n\n\nYES\n\n\n\n\n\n\nhosting.de\n\n\nhostingde\n\n\nHOSTINGDE_API_KEY\n, \nHOSTINGDE_ZONE_NAME\n\n\nYES\n\n\n\n\n\n\nHTTP request\n\n\nhttpreq\n\n\nHTTPREQ_ENDPOINT\n, \nHTTPREQ_MODE\n, \nHTTPREQ_USERNAME\n, \nHTTPREQ_PASSWORD\n (1)\n\n\nYES\n\n\n\n\n\n\nIIJ\n\n\niij\n\n\nIIJ_API_ACCESS_KEY\n, \nIIJ_API_SECRET_KEY\n, \nIIJ_DO_SERVICE_CODE\n\n\nNot tested yet\n\n\n\n\n\n\nINWX\n\n\ninwx\n\n\nINWX_USERNAME\n, \nINWX_PASSWORD\n\n\nYES\n\n\n\n\n\n\nJoker.com\n\n\njoker\n\n\nJOKER_API_KEY\n or \nJOKER_USERNAME\n, \nJOKER_PASSWORD\n\n\nYES\n\n\n\n\n\n\nLightsail\n\n\nlightsail\n\n\nAWS_ACCESS_KEY_ID\n, \nAWS_SECRET_ACCESS_KEY\n, \nDNS_ZONE\n\n\nNot tested yet\n\n\n\n\n\n\nLinode\n\n\nlinode\n\n\nLINODE_API_KEY\n\n\nNot tested yet\n\n\n\n\n\n\nLinode v4\n\n\nlinodev4\n\n\nLINODE_TOKEN\n\n\nNot tested yet\n\n\n\n\n\n\nmanual\n\n\n-\n\n\nnone, but you need to run Traefik interactively, turn on \nacmeLogging\n to see instructions and press \nEnter\n.\n\n\nYES\n\n\n\n\n\n\nMyDNS.jp\n\n\nmydnsjp\n\n\nMYDNSJP_MASTER_ID\n, \nMYDNSJP_PASSWORD\n\n\nYES\n\n\n\n\n\n\nNamecheap\n\n\nnamecheap\n\n\nNAMECHEAP_API_USER\n, \nNAMECHEAP_API_KEY\n\n\nYES\n\n\n\n\n\n\nNamesilo\n\n\nnamesilo\n\n\nNAMESILO_API_KEY\n\n\nYES\n\n\n\n\n\n\nname.com\n\n\nnamedotcom\n\n\nNAMECOM_USERNAME\n, \nNAMECOM_API_TOKEN\n, \nNAMECOM_SERVER\n\n\nNot tested yet\n\n\n\n\n\n\nNetcup\n\n\nnetcup\n\n\nNETCUP_CUSTOMER_NUMBER\n, \nNETCUP_API_KEY\n, \nNETCUP_API_PASSWORD\n\n\nNot tested yet\n\n\n\n\n\n\nNIFCloud\n\n\nnifcloud\n\n\nNIFCLOUD_ACCESS_KEY_ID\n, \nNIFCLOUD_SECRET_ACCESS_KEY\n\n\nNot tested yet\n\n\n\n\n\n\nNs1\n\n\nns1\n\n\nNS1_API_KEY\n\n\nNot tested yet\n\n\n\n\n\n\nOpen Telekom Cloud\n\n\notc\n\n\nOTC_DOMAIN_NAME\n, \nOTC_USER_NAME\n, \nOTC_PASSWORD\n, \nOTC_PROJECT_NAME\n, \nOTC_IDENTITY_ENDPOINT\n\n\nNot tested yet\n\n\n\n\n\n\nOVH\n\n\novh\n\n\nOVH_ENDPOINT\n, \nOVH_APPLICATION_KEY\n, \nOVH_APPLICATION_SECRET\n, \nOVH_CONSUMER_KEY\n\n\nYES\n\n\n\n\n\n\nOpenstack Designate\n\n\ndesignate\n\n\nOS_AUTH_URL\n, \nOS_USERNAME\n, \nOS_PASSWORD\n, \nOS_TENANT_NAME\n, \nOS_REGION_NAME\n\n\nYES\n\n\n\n\n\n\nOracle Cloud\n\n\noraclecloud\n\n\nOCI_COMPARTMENT_OCID\n, \nOCI_PRIVKEY_FILE\n, \nOCI_PRIVKEY_PASS\n, \nOCI_PUBKEY_FINGERPRINT\n, \nOCI_REGION\n, \nOCI_TENANCY_OCID\n, \nOCI_USER_OCID\n\n\nYES\n\n\n\n\n\n\nPowerDNS\n\n\npdns\n\n\nPDNS_API_KEY\n, \nPDNS_API_URL\n\n\nNot tested yet\n\n\n\n\n\n\nRackspace\n\n\nrackspace\n\n\nRACKSPACE_USER\n, \nRACKSPACE_API_KEY\n\n\nNot tested yet\n\n\n\n\n\n\nRFC2136\n\n\nrfc2136\n\n\nRFC2136_TSIG_KEY\n, \nRFC2136_TSIG_SECRET\n, \nRFC2136_TSIG_ALGORITHM\n, \nRFC2136_NAMESERVER\n\n\nNot tested yet\n\n\n\n\n\n\nRoute 53\n\n\nroute53\n\n\nAWS_ACCESS_KEY_ID\n, \nAWS_SECRET_ACCESS_KEY\n, \n[AWS_REGION]\n, \n[AWS_HOSTED_ZONE_ID]\n or a configured user/instance IAM profile.\n\n\nYES\n\n\n\n\n\n\nSakura Cloud\n\n\nsakuracloud\n\n\nSAKURACLOUD_ACCESS_TOKEN\n, \nSAKURACLOUD_ACCESS_TOKEN_SECRET\n\n\nNot tested yet\n\n\n\n\n\n\nSelectel\n\n\nselectel\n\n\nSELECTEL_API_TOKEN\n\n\nYES\n\n\n\n\n\n\nStackpath\n\n\nstackpath\n\n\nSTACKPATH_CLIENT_ID\n, \nSTACKPATH_CLIENT_SECRET\n, \nSTACKPATH_STACK_ID\n\n\nNot tested yet\n\n\n\n\n\n\nTransIP\n\n\ntransip\n\n\nTRANSIP_ACCOUNT_NAME\n, \nTRANSIP_PRIVATE_KEY_PATH\n\n\nYES\n\n\n\n\n\n\nVegaDNS\n\n\nvegadns\n\n\nSECRET_VEGADNS_KEY\n, \nSECRET_VEGADNS_SECRET\n, \nVEGADNS_URL\n\n\nNot tested yet\n\n\n\n\n\n\nVersio\n\n\nversio\n\n\nVERSIO_USERNAME\n, \nVERSIO_PASSWORD\n\n\nYES\n\n\n\n\n\n\nVscale\n\n\nvscale\n\n\nVSCALE_API_TOKEN\n\n\nYES\n\n\n\n\n\n\nVULTR\n\n\nvultr\n\n\nVULTR_API_KEY\n\n\nYES\n\n\n\n\n\n\nZone.ee\n\n\nzoneee\n\n\nZONEEE_API_USER\n, \nZONEEE_API_KEY\n\n\nYES\n\n\n\n\n\n\n\n\n\n\n(1): more information about the HTTP message format can be found \nhere\n\n\n(2): https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application\n\n\n(3): https://github.com/golang/oauth2/blob/36a7019397c4c86cf59eeab3bc0d188bac444277/google/default.go#L61-L76\n\n\n\n\nresolvers\n\n\nUse custom DNS servers to resolve the FQDN authority.\n\n\n[acme]\n# ...\n[acme.dnsChallenge]\n  # ...\n  resolvers = [\n1.1.1.1:53\n, \n8.8.8.8:53\n]\n\n\n\n\ndomains\n\n\nYou can provide SANs (alternative domains) to each main domain.\nAll domains must have A/AAAA records pointing to Traefik.\nEach domain \n SAN will lead to a certificate request.\n\n\n\n\nNote\n\n\nThe certificates for the domains listed in \nacme.domains\n are negotiated at traefik startup only.\n\n\n\n\n[acme]\n# ...\n[[acme.domains]]\n  main = \nlocal1.com\n\n  sans = [\ntest1.local1.com\n, \ntest2.local1.com\n]\n[[acme.domains]]\n  main = \nlocal2.com\n\n[[acme.domains]]\n  main = \n*.local3.com\n\n  sans = [\nlocal3.com\n, \ntest1.test1.local3.com\n]\n# ...\n\n\n\n\n\n\nWarning\n\n\nTake note that Let's Encrypt applies \nrate limiting\n.\n\n\n\n\n\n\nNote\n\n\nWildcard certificates can only be verified through a \nDNS-01\n challenge.\n\n\n\n\nWildcard Domains\n\n\nACME V2\n allows wildcard certificate support.\nAs described in \nLet's Encrypt's post\n wildcard certificates can only be generated through a \nDNS-01\n challenge\n.\n\n\n[acme]\n# ...\n[[acme.domains]]\n  main = \n*.local1.com\n\n  sans = [\nlocal1.com\n]\n# ...\n\n\n\n\nIt is not possible to request a double wildcard certificate for a domain (for example \n*.*.local.com\n).\nMost likely the root domain should receive a certificate too, so it needs to be specified as SAN and 2 \nDNS-01\n challenges are executed.\nIn this case the generated DNS TXT record for both domains is the same.\nEven though this behaviour is \nDNS RFC\n compliant, it can lead to problems as all DNS providers keep DNS records cached for a certain time (TTL) and this TTL can be superior to the challenge timeout making the \nDNS-01\n challenge fail.\nThe Traefik ACME client library \nLEGO\n supports some but not all DNS providers to work around this issue.\nThe \nprovider\n table\n indicates if they allow generating certificates for a wildcard domain and its root domain.\n\n\nonDemand\n (Deprecated)\n\n\n\n\nDEPRECATED\n\n\nThis option is deprecated.\n\n\n\n\n[acme]\n# ...\nonDemand = true\n# ...\n\n\n\n\nEnable on demand certificate generation.\n\n\nThis will request certificates from Let's Encrypt during the first TLS handshake for host names that do not yet have certificates.\n\n\n\n\nWarning\n\n\nTLS handshakes are slow when requesting a host name certificate for the first time. This can lead to DoS attacks!\n\n\n\n\n\n\nWarning\n\n\nTake note that Let's Encrypt applies \nrate limiting\n.\n\n\n\n\nonHostRule\n\n\n[acme]\n# ...\nonHostRule = true\n# ...\n\n\n\n\nEnable certificate generation on frontend \nHost\n rules (for frontends wired to the \nacme.entryPoint\n).\n\n\nThis will request a certificate from Let's Encrypt for each frontend with a Host rule.\n\n\nFor example, the rule \nHost:test1.traefik.io,test2.traefik.io\n will request a certificate with main domain \ntest1.traefik.io\n and SAN \ntest2.traefik.io\n.\n\n\n\n\nWarning\n\n\nonHostRule\n option can not be used to generate wildcard certificates.\nRefer to \nwildcard generation\n for further information.\n\n\n\n\nstorage\n\n\nThe \nstorage\n option sets the location where your ACME certificates are saved to.\n\n\n[acme]\n# ...\nstorage = \nacme.json\n\n# ...\n\n\n\n\nThe value can refer to two kinds of storage:\n\n\n\n\na JSON file\n\n\na KV store entry\n\n\n\n\n\n\nDEPRECATED\n\n\nstorage\n replaces \nstorageFile\n which is deprecated.\n\n\n\n\n\n\nNote\n\n\nDuring migration to a KV store use both \nstorageFile\n and \nstorage\n to migrate ACME certificates too. See \nstoreconfig\n subcommand\n for further information.\n\n\n\n\nAs a File\n\n\nACME certificates can be stored in a JSON file that needs to have file mode \n600\n.\n\n\nIn Docker you can either mount the JSON file or the folder containing it:\n\n\ndocker run -v \n/my/host/acme.json:acme.json\n traefik\n\n\n\n\ndocker run -v \n/my/host/acme:/etc/traefik/acme\n traefik\n\n\n\n\n\n\nWarning\n\n\nThis file cannot be shared across multiple instances of Traefik at the same time. Please use a \nKV Store entry\n instead.\n\n\n\n\nAs a Key Value Store Entry\n\n\nACME certificates can be stored in a KV Store entry. This kind of storage is \nmandatory in cluster mode\n.\n\n\nstorage = \ntraefik/acme/account\n\n\n\n\n\nBecause KV stores (like Consul) have limited entry size the certificates list is compressed before it is saved as KV store entry.\n\n\n\n\nNote\n\n\nIt is possible to store up to approximately 100 ACME certificates in Consul.\n\n\n\n\nACME v2 Migration\n\n\nDuring migration from ACME v1 to ACME v2, using a storage file, a backup of the original file is created in the same place as the latter (with a \n.bak\n extension).\n\n\nFor example: if \nacme.storage\n's value is \n/etc/traefik/acme/acme.json\n, the backup file will be \n/etc/traefik/acme/acme.json.bak\n.\n\n\n\n\nNote\n\n\nWhen Traefik is launched in a container, the storage file's parent directory needs to be mounted to be able to access the backup file on the host.\nOtherwise the backup file will be deleted when the container is stopped. Traefik will only generate it once!\n\n\n\n\ndnsProvider\n (Deprecated)\n\n\n\n\nDEPRECATED\n\n\nThis option is deprecated. Please use \ndnsChallenge.provider\n instead.\n\n\n\n\ndelayDontCheckDNS\n (Deprecated)\n\n\n\n\nDEPRECATED\n\n\nThis option is deprecated. Please use \ndnsChallenge.delayBeforeCheck\n instead.\n\n\n\n\nFallbacks\n\n\nIf Let's Encrypt is not reachable, these certificates will be used:\n\n\n\n\nACME certificates already generated before downtime\n\n\nExpired ACME certificates\n\n\nProvided certificates\n\n\n\n\n\n\nNote\n\n\nFor new (sub)domains which need Let's Encrypt authentification, the default Traefik certificate will be used until Traefik is restarted.", 
            "title": "Let's Encrypt"
        }, 
        {
            "location": "/configuration/acme/#acme-lets-encrypt-configuration", 
            "text": "See  Let's Encrypt examples  and  Docker   Let's Encrypt user guide  as well.", 
            "title": "ACME (Let's Encrypt) Configuration"
        }, 
        {
            "location": "/configuration/acme/#configuration", 
            "text": "# Sample entrypoint configuration when using ACME.\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]  # Enable ACME (Let's Encrypt): automatic SSL.\n[acme]\n\n# Email address used for registration.\n#\n# Required\n#\nemail =  test@traefik.io \n\n# File used for certificates storage.\n#\n# Optional (Deprecated)\n#\n#storageFile =  acme.json \n\n# File or key used for certificates storage.\n#\n# Required\n#\nstorage =  acme.json \n# or `storage =  traefik/acme/account ` if using KV store.\n\n# Entrypoint to proxy acme apply certificates to.\n#\n# Required\n#\nentryPoint =  https \n\n# Deprecated, replaced by [acme.dnsChallenge].\n#\n# Optional.\n#\n# dnsProvider =  digitalocean \n\n# Deprecated, replaced by [acme.dnsChallenge.delayBeforeCheck].\n#\n# Optional\n# Default: 0\n#\n# delayDontCheckDNS = 0\n\n# If true, display debug log messages from the acme client library.\n#\n# Optional\n# Default: false\n#\n# acmeLogging = true\n\n# If true, override certificates in key-value store when using storeconfig.\n#\n# Optional\n# Default: false\n#\n# overrideCertificates = true\n\n# Deprecated. Enable on demand certificate generation.\n#\n# Optional\n# Default: false\n#\n# onDemand = true\n\n# Enable certificate generation on frontends host rules.\n#\n# Optional\n# Default: false\n#\n# onHostRule = true\n\n# CA server to use.\n# Uncomment the line to use Let's Encrypt's staging server,\n# leave commented to go to prod.\n#\n# Optional\n# Default:  https://acme-v02.api.letsencrypt.org/directory \n#\n# caServer =  https://acme-staging-v02.api.letsencrypt.org/directory \n\n# KeyType to use.\n#\n# Optional\n# Default:  RSA4096 \n#\n# Available values :  EC256 ,  EC384 ,  RSA2048 ,  RSA4096 ,  RSA8192 \n#\n# KeyType =  RSA4096 \n\n# Use a TLS-ALPN-01 ACME challenge.\n#\n# Optional (but recommended)\n#\n[acme.tlsChallenge]\n\n# Use a HTTP-01 ACME challenge.\n#\n# Optional\n#\n# [acme.httpChallenge]\n\n  # EntryPoint to use for the HTTP-01 challenges.\n  #\n  # Required\n  #\n  # entryPoint =  http \n\n# Use a DNS-01 ACME challenge rather than HTTP-01 challenge.\n# Note: mandatory for wildcard certificate generation.\n#\n# Optional\n#\n# [acme.dnsChallenge]\n\n  # DNS provider used.\n  #\n  # Required\n  #\n  # provider =  digitalocean \n\n  # By default, the provider will verify the TXT DNS challenge record before letting ACME verify.\n  # If delayBeforeCheck is greater than zero, this check is delayed for the configured duration in seconds.\n  # Useful if internal networks block external DNS queries.\n  #\n  # Optional\n  # Default: 0\n  #\n  # delayBeforeCheck = 0\n\n  # Use following DNS servers to resolve the FQDN authority.\n  #\n  # Optional\n  # Default: empty\n  #\n  # resolvers = [ 1.1.1.1:53 ,  8.8.8.8:53 ]\n\n  # Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready.\n  #\n  # NOT RECOMMENDED:\n  # Increase the risk of reaching Let's Encrypt's rate limits.\n  #\n  # Optional\n  # Default: false\n  #\n  # disablePropagationCheck = true\n\n# Domains list.\n# Only domains defined here can generate wildcard certificates.\n# The certificates for these domains are negotiated at traefik startup only.\n#\n# [[acme.domains]]\n#   main =  local1.com \n#   sans = [ test1.local1.com ,  test2.local1.com ]\n# [[acme.domains]]\n#   main =  local2.com \n# [[acme.domains]]\n#   main =  *.local3.com \n#   sans = [ local3.com ,  test1.test1.local3.com ]", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/acme/#caserver", 
            "text": "The CA server to use.  This example shows the usage of Let's Encrypt's staging server:  [acme]\n# ...\ncaServer =  https://acme-staging-v02.api.letsencrypt.org/directory \n# ...", 
            "title": "caServer"
        }, 
        {
            "location": "/configuration/acme/#acme-challenge", 
            "text": "", 
            "title": "ACME Challenge"
        }, 
        {
            "location": "/configuration/acme/#tlschallenge", 
            "text": "Use the  TLS-ALPN-01  challenge to generate and renew ACME certificates by provisioning a TLS certificate.  [acme]\n# ...\nentryPoint =  https \n[acme.tlsChallenge]   Note  If the  TLS-ALPN-01  challenge is used,  acme.entryPoint  has to be reachable by Let's Encrypt through port 443.\nThis is a Let's Encrypt limitation as described on the  community forum .", 
            "title": "tlsChallenge"
        }, 
        {
            "location": "/configuration/acme/#httpchallenge", 
            "text": "Use the  HTTP-01  challenge to generate and renew ACME certificates by provisioning a HTTP resource under a well-known URI.  Redirection is fully compatible with the  HTTP-01  challenge.  [acme]\n# ...\nentryPoint =  https \n[acme.httpChallenge]\n  entryPoint =  http    Note  If the  HTTP-01  challenge is used,  acme.httpChallenge.entryPoint  has to be defined and reachable by Let's Encrypt through port 80.\nThis is a Let's Encrypt limitation as described on the  community forum .", 
            "title": "httpChallenge"
        }, 
        {
            "location": "/configuration/acme/#entrypoint", 
            "text": "Specify the entryPoint to use during the challenges.  defaultEntryPoints = [ http ,  https ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n# ...\n\n[acme]\n  # ...\n  entryPoint =  https \n  [acme.httpChallenge]\n    entryPoint =  http    Note  acme.httpChallenge.entryPoint  has to be reachable through port 80. It's a Let's Encrypt limitation as described on the  community forum .", 
            "title": "entryPoint"
        }, 
        {
            "location": "/configuration/acme/#dnschallenge", 
            "text": "Use the  DNS-01  challenge to generate and renew ACME certificates by provisioning a DNS record.  [acme]\n# ...\n[acme.dnsChallenge]\n  provider =  digitalocean \n  delayBeforeCheck = 0\n# ...", 
            "title": "dnsChallenge"
        }, 
        {
            "location": "/configuration/acme/#delaybeforecheck", 
            "text": "By default, the  provider  will verify the TXT DNS challenge record before letting ACME verify.\nIf  delayBeforeCheck  is greater than zero, this check is delayed for the configured duration in seconds.  Useful if internal networks block external DNS queries.   Note  A  provider  is mandatory.", 
            "title": "delayBeforeCheck"
        }, 
        {
            "location": "/configuration/acme/#provider", 
            "text": "Here is a list of supported  provider s, that can automate the DNS verification, along with the required environment variables and their  wildcard   root domain support  for each.\nDo not hesitate to complete it.\nEvery lego environment variable can be overridden by their respective  _FILE  counterpart, which should have a filepath to a file that contains the secret as its value.\nFor example,  CF_API_EMAIL_FILE=/run/secrets/traefik_cf-api-email  could be used to provide a Cloudflare API email address as a Docker secret named  traefik_cf-api-email .     Provider Name  Provider Code  Environment Variables  Wildcard   Root Domain Support      ACME DNS  acme-dns  ACME_DNS_API_BASE ,  ACME_DNS_STORAGE_PATH  Not tested yet    Alibaba Cloud  alidns  ALICLOUD_ACCESS_KEY ,  ALICLOUD_SECRET_KEY ,  ALICLOUD_REGION_ID  Not tested yet    Auroradns  auroradns  AURORA_USER_ID ,  AURORA_KEY ,  AURORA_ENDPOINT  Not tested yet    Azure  azure  AZURE_CLIENT_ID ,  AZURE_CLIENT_SECRET ,  AZURE_SUBSCRIPTION_ID ,  AZURE_TENANT_ID ,  AZURE_RESOURCE_GROUP ,  [AZURE_METADATA_ENDPOINT]  Not tested yet    Bindman  bindman  BINDMAN_MANAGER_ADDRESS  YES    Blue Cat  bluecat  BLUECAT_SERVER_URL ,  BLUECAT_USER_NAME ,  BLUECAT_PASSWORD ,  BLUECAT_CONFIG_NAME ,  BLUECAT_DNS_VIEW  Not tested yet    ClouDNS  cloudns  CLOUDNS_AUTH_ID ,  CLOUDNS_AUTH_PASSWORD  YES    Cloudflare  cloudflare  CF_API_EMAIL ,  CF_API_KEY  - The  Global API Key  needs to be used, not the  Origin CA Key  YES    CloudXNS  cloudxns  CLOUDXNS_API_KEY ,  CLOUDXNS_SECRET_KEY  Not tested yet    ConoHa  conoha  CONOHA_TENANT_ID ,  CONOHA_API_USERNAME ,  CONOHA_API_PASSWORD  YES    DigitalOcean  digitalocean  DO_AUTH_TOKEN  YES    DNSimple  dnsimple  DNSIMPLE_OAUTH_TOKEN ,  DNSIMPLE_BASE_URL  YES    DNS Made Easy  dnsmadeeasy  DNSMADEEASY_API_KEY ,  DNSMADEEASY_API_SECRET ,  DNSMADEEASY_SANDBOX  Not tested yet    DNSPod  dnspod  DNSPOD_API_KEY  Not tested yet    Domain Offensive (do.de)  dode  DODE_TOKEN  YES    DreamHost  dreamhost  DREAMHOST_API_KEY  YES    Duck DNS  duckdns  DUCKDNS_TOKEN  YES    Dyn  dyn  DYN_CUSTOMER_NAME ,  DYN_USER_NAME ,  DYN_PASSWORD  Not tested yet    EasyDNS  easydns  EASYDNS_TOKEN ,  EASYDNS_KEY  YES    External Program  exec  EXEC_PATH  YES    Exoscale  exoscale  EXOSCALE_API_KEY ,  EXOSCALE_API_SECRET ,  EXOSCALE_ENDPOINT  YES    Fast DNS  fastdns  AKAMAI_CLIENT_TOKEN ,   AKAMAI_CLIENT_SECRET ,   AKAMAI_ACCESS_TOKEN  YES    Gandi  gandi  GANDI_API_KEY  Not tested yet    Gandi v5  gandiv5  GANDIV5_API_KEY  YES    Glesys  glesys  GLESYS_API_USER ,  GLESYS_API_KEY ,  GLESYS_DOMAIN  Not tested yet    GoDaddy  godaddy  GODADDY_API_KEY ,  GODADDY_API_SECRET  Not tested yet    Google Cloud DNS  gcloud  GCE_PROJECT , Application Default Credentials (2) (3), [ GCE_SERVICE_ACCOUNT_FILE ]  YES    hosting.de  hostingde  HOSTINGDE_API_KEY ,  HOSTINGDE_ZONE_NAME  YES    HTTP request  httpreq  HTTPREQ_ENDPOINT ,  HTTPREQ_MODE ,  HTTPREQ_USERNAME ,  HTTPREQ_PASSWORD  (1)  YES    IIJ  iij  IIJ_API_ACCESS_KEY ,  IIJ_API_SECRET_KEY ,  IIJ_DO_SERVICE_CODE  Not tested yet    INWX  inwx  INWX_USERNAME ,  INWX_PASSWORD  YES    Joker.com  joker  JOKER_API_KEY  or  JOKER_USERNAME ,  JOKER_PASSWORD  YES    Lightsail  lightsail  AWS_ACCESS_KEY_ID ,  AWS_SECRET_ACCESS_KEY ,  DNS_ZONE  Not tested yet    Linode  linode  LINODE_API_KEY  Not tested yet    Linode v4  linodev4  LINODE_TOKEN  Not tested yet    manual  -  none, but you need to run Traefik interactively, turn on  acmeLogging  to see instructions and press  Enter .  YES    MyDNS.jp  mydnsjp  MYDNSJP_MASTER_ID ,  MYDNSJP_PASSWORD  YES    Namecheap  namecheap  NAMECHEAP_API_USER ,  NAMECHEAP_API_KEY  YES    Namesilo  namesilo  NAMESILO_API_KEY  YES    name.com  namedotcom  NAMECOM_USERNAME ,  NAMECOM_API_TOKEN ,  NAMECOM_SERVER  Not tested yet    Netcup  netcup  NETCUP_CUSTOMER_NUMBER ,  NETCUP_API_KEY ,  NETCUP_API_PASSWORD  Not tested yet    NIFCloud  nifcloud  NIFCLOUD_ACCESS_KEY_ID ,  NIFCLOUD_SECRET_ACCESS_KEY  Not tested yet    Ns1  ns1  NS1_API_KEY  Not tested yet    Open Telekom Cloud  otc  OTC_DOMAIN_NAME ,  OTC_USER_NAME ,  OTC_PASSWORD ,  OTC_PROJECT_NAME ,  OTC_IDENTITY_ENDPOINT  Not tested yet    OVH  ovh  OVH_ENDPOINT ,  OVH_APPLICATION_KEY ,  OVH_APPLICATION_SECRET ,  OVH_CONSUMER_KEY  YES    Openstack Designate  designate  OS_AUTH_URL ,  OS_USERNAME ,  OS_PASSWORD ,  OS_TENANT_NAME ,  OS_REGION_NAME  YES    Oracle Cloud  oraclecloud  OCI_COMPARTMENT_OCID ,  OCI_PRIVKEY_FILE ,  OCI_PRIVKEY_PASS ,  OCI_PUBKEY_FINGERPRINT ,  OCI_REGION ,  OCI_TENANCY_OCID ,  OCI_USER_OCID  YES    PowerDNS  pdns  PDNS_API_KEY ,  PDNS_API_URL  Not tested yet    Rackspace  rackspace  RACKSPACE_USER ,  RACKSPACE_API_KEY  Not tested yet    RFC2136  rfc2136  RFC2136_TSIG_KEY ,  RFC2136_TSIG_SECRET ,  RFC2136_TSIG_ALGORITHM ,  RFC2136_NAMESERVER  Not tested yet    Route 53  route53  AWS_ACCESS_KEY_ID ,  AWS_SECRET_ACCESS_KEY ,  [AWS_REGION] ,  [AWS_HOSTED_ZONE_ID]  or a configured user/instance IAM profile.  YES    Sakura Cloud  sakuracloud  SAKURACLOUD_ACCESS_TOKEN ,  SAKURACLOUD_ACCESS_TOKEN_SECRET  Not tested yet    Selectel  selectel  SELECTEL_API_TOKEN  YES    Stackpath  stackpath  STACKPATH_CLIENT_ID ,  STACKPATH_CLIENT_SECRET ,  STACKPATH_STACK_ID  Not tested yet    TransIP  transip  TRANSIP_ACCOUNT_NAME ,  TRANSIP_PRIVATE_KEY_PATH  YES    VegaDNS  vegadns  SECRET_VEGADNS_KEY ,  SECRET_VEGADNS_SECRET ,  VEGADNS_URL  Not tested yet    Versio  versio  VERSIO_USERNAME ,  VERSIO_PASSWORD  YES    Vscale  vscale  VSCALE_API_TOKEN  YES    VULTR  vultr  VULTR_API_KEY  YES    Zone.ee  zoneee  ZONEEE_API_USER ,  ZONEEE_API_KEY  YES      (1): more information about the HTTP message format can be found  here  (2): https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application  (3): https://github.com/golang/oauth2/blob/36a7019397c4c86cf59eeab3bc0d188bac444277/google/default.go#L61-L76", 
            "title": "provider"
        }, 
        {
            "location": "/configuration/acme/#resolvers", 
            "text": "Use custom DNS servers to resolve the FQDN authority.  [acme]\n# ...\n[acme.dnsChallenge]\n  # ...\n  resolvers = [ 1.1.1.1:53 ,  8.8.8.8:53 ]", 
            "title": "resolvers"
        }, 
        {
            "location": "/configuration/acme/#domains", 
            "text": "You can provide SANs (alternative domains) to each main domain.\nAll domains must have A/AAAA records pointing to Traefik.\nEach domain   SAN will lead to a certificate request.   Note  The certificates for the domains listed in  acme.domains  are negotiated at traefik startup only.   [acme]\n# ...\n[[acme.domains]]\n  main =  local1.com \n  sans = [ test1.local1.com ,  test2.local1.com ]\n[[acme.domains]]\n  main =  local2.com \n[[acme.domains]]\n  main =  *.local3.com \n  sans = [ local3.com ,  test1.test1.local3.com ]\n# ...   Warning  Take note that Let's Encrypt applies  rate limiting .    Note  Wildcard certificates can only be verified through a  DNS-01  challenge.", 
            "title": "domains"
        }, 
        {
            "location": "/configuration/acme/#wildcard-domains", 
            "text": "ACME V2  allows wildcard certificate support.\nAs described in  Let's Encrypt's post  wildcard certificates can only be generated through a  DNS-01  challenge .  [acme]\n# ...\n[[acme.domains]]\n  main =  *.local1.com \n  sans = [ local1.com ]\n# ...  It is not possible to request a double wildcard certificate for a domain (for example  *.*.local.com ).\nMost likely the root domain should receive a certificate too, so it needs to be specified as SAN and 2  DNS-01  challenges are executed.\nIn this case the generated DNS TXT record for both domains is the same.\nEven though this behaviour is  DNS RFC  compliant, it can lead to problems as all DNS providers keep DNS records cached for a certain time (TTL) and this TTL can be superior to the challenge timeout making the  DNS-01  challenge fail.\nThe Traefik ACME client library  LEGO  supports some but not all DNS providers to work around this issue.\nThe  provider  table  indicates if they allow generating certificates for a wildcard domain and its root domain.", 
            "title": "Wildcard Domains"
        }, 
        {
            "location": "/configuration/acme/#ondemand-deprecated", 
            "text": "DEPRECATED  This option is deprecated.   [acme]\n# ...\nonDemand = true\n# ...  Enable on demand certificate generation.  This will request certificates from Let's Encrypt during the first TLS handshake for host names that do not yet have certificates.   Warning  TLS handshakes are slow when requesting a host name certificate for the first time. This can lead to DoS attacks!    Warning  Take note that Let's Encrypt applies  rate limiting .", 
            "title": "onDemand (Deprecated)"
        }, 
        {
            "location": "/configuration/acme/#onhostrule", 
            "text": "[acme]\n# ...\nonHostRule = true\n# ...  Enable certificate generation on frontend  Host  rules (for frontends wired to the  acme.entryPoint ).  This will request a certificate from Let's Encrypt for each frontend with a Host rule.  For example, the rule  Host:test1.traefik.io,test2.traefik.io  will request a certificate with main domain  test1.traefik.io  and SAN  test2.traefik.io .   Warning  onHostRule  option can not be used to generate wildcard certificates.\nRefer to  wildcard generation  for further information.", 
            "title": "onHostRule"
        }, 
        {
            "location": "/configuration/acme/#storage", 
            "text": "The  storage  option sets the location where your ACME certificates are saved to.  [acme]\n# ...\nstorage =  acme.json \n# ...  The value can refer to two kinds of storage:   a JSON file  a KV store entry    DEPRECATED  storage  replaces  storageFile  which is deprecated.    Note  During migration to a KV store use both  storageFile  and  storage  to migrate ACME certificates too. See  storeconfig  subcommand  for further information.", 
            "title": "storage"
        }, 
        {
            "location": "/configuration/acme/#as-a-file", 
            "text": "ACME certificates can be stored in a JSON file that needs to have file mode  600 .  In Docker you can either mount the JSON file or the folder containing it:  docker run -v  /my/host/acme.json:acme.json  traefik  docker run -v  /my/host/acme:/etc/traefik/acme  traefik   Warning  This file cannot be shared across multiple instances of Traefik at the same time. Please use a  KV Store entry  instead.", 
            "title": "As a File"
        }, 
        {
            "location": "/configuration/acme/#as-a-key-value-store-entry", 
            "text": "ACME certificates can be stored in a KV Store entry. This kind of storage is  mandatory in cluster mode .  storage =  traefik/acme/account   Because KV stores (like Consul) have limited entry size the certificates list is compressed before it is saved as KV store entry.   Note  It is possible to store up to approximately 100 ACME certificates in Consul.", 
            "title": "As a Key Value Store Entry"
        }, 
        {
            "location": "/configuration/acme/#acme-v2-migration", 
            "text": "During migration from ACME v1 to ACME v2, using a storage file, a backup of the original file is created in the same place as the latter (with a  .bak  extension).  For example: if  acme.storage 's value is  /etc/traefik/acme/acme.json , the backup file will be  /etc/traefik/acme/acme.json.bak .   Note  When Traefik is launched in a container, the storage file's parent directory needs to be mounted to be able to access the backup file on the host.\nOtherwise the backup file will be deleted when the container is stopped. Traefik will only generate it once!", 
            "title": "ACME v2 Migration"
        }, 
        {
            "location": "/configuration/acme/#dnsprovider-deprecated", 
            "text": "DEPRECATED  This option is deprecated. Please use  dnsChallenge.provider  instead.", 
            "title": "dnsProvider (Deprecated)"
        }, 
        {
            "location": "/configuration/acme/#delaydontcheckdns-deprecated", 
            "text": "DEPRECATED  This option is deprecated. Please use  dnsChallenge.delayBeforeCheck  instead.", 
            "title": "delayDontCheckDNS (Deprecated)"
        }, 
        {
            "location": "/configuration/acme/#fallbacks", 
            "text": "If Let's Encrypt is not reachable, these certificates will be used:   ACME certificates already generated before downtime  Expired ACME certificates  Provided certificates    Note  For new (sub)domains which need Let's Encrypt authentification, the default Traefik certificate will be used until Traefik is restarted.", 
            "title": "Fallbacks"
        }, 
        {
            "location": "/configuration/api/", 
            "text": "API Definition\n\n\nConfiguration\n\n\n# API definition\n# Warning: Enabling API will expose Traefik's configuration.\n# It is not recommended in production,\n# unless secured by authentication and authorizations\n[api]\n  # Name of the related entry point\n  #\n  # Optional\n  # Default: \ntraefik\n\n  #\n  entryPoint = \ntraefik\n\n\n  # Enable Dashboard\n  #\n  # Optional\n  # Default: true\n  #\n  dashboard = true\n\n  # Enable debug mode.\n  # This will install HTTP handlers to expose Go expvars under /debug/vars and\n  # pprof profiling data under /debug/pprof/.\n  # Additionally, the log level will be set to DEBUG.\n  #\n  # Optional\n  # Default: false\n  #\n  debug = true\n\n\n\n\nFor more customization, see \nentry points\n documentation and the examples below.\n\n\nDashboard (Web UI)\n\n\n\n\n\n\nSecurity\n\n\nEnabling the API will expose all configuration elements,\nincluding sensitive data.\n\n\nIt is not recommended in production,\nunless secured by authentication and authorizations.\n\n\nA good sane default (but not exhaustive) set of recommendations\nwould be to apply the following protection mechanism:\n\n\n\n\nAt application level:\n enabling HTTP \nBasic Authentication\n\n\nAt transport level:\n NOT exposing publicly the API's port,\nkeeping it restricted over internal networks\n(restricted networks as in https://en.wikipedia.org/wiki/Principle_of_least_privilege).\n\n\n\n\nAPI\n\n\n\n\n\n\n\n\nPath\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n/\n\n\nGET\n\n\nProvides a simple HTML frontend of Traefik\n\n\n\n\n\n\n/cluster/leader\n\n\nGET\n\n\nJSON leader true/false response\n\n\n\n\n\n\n/health\n\n\nGET\n\n\nJSON health metrics\n\n\n\n\n\n\n/api\n\n\nGET\n\n\nConfiguration for all providers\n\n\n\n\n\n\n/api/providers\n\n\nGET\n\n\nProviders\n\n\n\n\n\n\n/api/providers/{provider}\n\n\nGET\n, \nPUT\n\n\nGet or update provider (1)\n\n\n\n\n\n\n/api/providers/{provider}/backends\n\n\nGET\n\n\nList backends\n\n\n\n\n\n\n/api/providers/{provider}/backends/{backend}\n\n\nGET\n\n\nGet backend\n\n\n\n\n\n\n/api/providers/{provider}/backends/{backend}/servers\n\n\nGET\n\n\nList servers in backend\n\n\n\n\n\n\n/api/providers/{provider}/backends/{backend}/servers/{server}\n\n\nGET\n\n\nGet a server in a backend\n\n\n\n\n\n\n/api/providers/{provider}/frontends\n\n\nGET\n\n\nList frontends\n\n\n\n\n\n\n/api/providers/{provider}/frontends/{frontend}\n\n\nGET\n\n\nGet a frontend\n\n\n\n\n\n\n/api/providers/{provider}/frontends/{frontend}/routes\n\n\nGET\n\n\nList routes in a frontend\n\n\n\n\n\n\n/api/providers/{provider}/frontends/{frontend}/routes/{route}\n\n\nGET\n\n\nGet a route in a frontend\n\n\n\n\n\n\n\n\n1\n See \nRest\n for more information.\n\n\n\n\nWarning\n\n\nFor compatibility reason, when you activate the rest provider, you can use \nweb\n or \nrest\n as \nprovider\n value.\nBut be careful, in the configuration for all providers the key is still \nweb\n.\n\n\n\n\nAddress / Port\n\n\nYou can define a custom address/port like this:\n\n\ndefaultEntryPoints = [\nhttp\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n\n  [entryPoints.foo]\n  address = \n:8082\n\n\n  [entryPoints.bar]\n  address = \n:8083\n\n\n[ping]\nentryPoint = \nfoo\n\n\n[api]\nentryPoint = \nbar\n\n\n\n\n\nIn the above example, you would access a regular path, dashboard, and health-check as follows:\n\n\n\n\nRegular path: \nhttp://hostname:80/path\n\n\nDashboard: \nhttp://hostname:8083/\n\n\nPing URL: \nhttp://hostname:8082/ping\n\n\n\n\nIn the above example, it is \nvery\n important to create a named dedicated entry point, and do \nnot\n include it in \ndefaultEntryPoints\n.\nOtherwise, you are likely to expose \nall\n services via that entry point.\n\n\nCustom Path\n\n\nYou can define a custom path like this:\n\n\ndefaultEntryPoints = [\nhttp\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n\n  [entryPoints.foo]\n  address = \n:8080\n\n\n  [entryPoints.bar]\n  address = \n:8081\n\n\n# Activate API and Dashboard\n[api]\nentryPoint = \nbar\n\ndashboard = true\n\n[file]\n  [backends]\n    [backends.backend1]\n      [backends.backend1.servers.server1]\n      url = \nhttp://127.0.0.1:8081\n\n\n  [frontends]\n    [frontends.frontend1]\n    entryPoints = [\nfoo\n]\n    backend = \nbackend1\n\n      [frontends.frontend1.routes.test_1]\n      rule = \nPathPrefixStrip:/yourprefix;PathPrefix:/yourprefix\n\n\n\n\n\nAuthentication\n\n\nYou can define the authentication like this:\n\n\ndefaultEntryPoints = [\nhttp\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n\n [entryPoints.foo]\n   address=\n:8080\n\n   [entryPoints.foo.auth]\n     [entryPoints.foo.auth.basic]\n       users = [\n         \ntest:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\n,\n         \ntest2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\n,\n       ]\n\n[api]\nentrypoint=\nfoo\n\n\n\n\n\nFor more information, see \nentry points\n .\n\n\nProvider call example\n\n\ncurl -s \nhttp://localhost:8080/api\n | jq .\n\n\n\n\n{\n  \nfile\n: {\n    \nfrontends\n: {\n      \nfrontend2\n: {\n        \nroutes\n: {\n          \ntest_2\n: {\n            \nrule\n: \nPath:/test\n\n          }\n        },\n        \nbackend\n: \nbackend1\n\n      },\n      \nfrontend1\n: {\n        \nroutes\n: {\n          \ntest_1\n: {\n            \nrule\n: \nHost:test.localhost\n\n          }\n        },\n        \nbackend\n: \nbackend2\n\n      }\n    },\n    \nbackends\n: {\n      \nbackend2\n: {\n        \nloadBalancer\n: {\n          \nmethod\n: \ndrr\n\n        },\n        \nservers\n: {\n          \nserver2\n: {\n            \nweight\n: 2,\n            \nURL\n: \nhttp://172.17.0.5:80\n\n          },\n          \nserver1\n: {\n            \nweight\n: 1,\n            \nurl\n: \nhttp://172.17.0.4:80\n\n          }\n        }\n      },\n      \nbackend1\n: {\n        \nloadBalancer\n: {\n          \nmethod\n: \nwrr\n\n        },\n        \ncircuitBreaker\n: {\n          \nexpression\n: \nNetworkErrorRatio() \n 0.5\n\n        },\n        \nservers\n: {\n          \nserver2\n: {\n            \nweight\n: 1,\n            \nurl\n: \nhttp://172.17.0.3:80\n\n          },\n          \nserver1\n: {\n            \nweight\n: 10,\n            \nurl\n: \nhttp://172.17.0.2:80\n\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\nCluster Leadership\n\n\ncurl -s \nhttp://localhost:8080/cluster/leader\n | jq .\n\n\n\n\n HTTP/1.1 200 OK\n\n Content-Type: application/json; charset=UTF-8\n\n Date: xxx\n\n Content-Length: 15\n\n\n\n\nIf the given node is not a cluster leader, an HTTP status of \n429-Too-Many-Requests\n will be returned.\n\n\n{\n  // current leadership status of the queried node\n  \nleader\n: true\n}\n\n\n\n\nHealth\n\n\ncurl -s \nhttp://localhost:8080/health\n | jq .\n\n\n\n\n{\n  // Traefik PID\n  \npid\n: 2458,\n  // Traefik server uptime (formated time)\n  \nuptime\n: \n39m6.885931127s\n,\n  //  Traefik server uptime in seconds\n  \nuptime_sec\n: 2346.885931127,\n  // current server date\n  \ntime\n: \n2015-10-07 18:32:24.362238909 +0200 CEST\n,\n  // current server date in seconds\n  \nunixtime\n: 1444235544,\n  // count HTTP response status code in realtime\n  \nstatus_code_count\n: {\n    \n502\n: 1\n  },\n  // count HTTP response status code since Traefik started\n  \ntotal_status_code_count\n: {\n    \n200\n: 7,\n    \n404\n: 21,\n    \n502\n: 13\n  },\n  // count HTTP response\n  \ncount\n: 1,\n  // count HTTP response\n  \ntotal_count\n: 41,\n  // sum of all response time (formated time)\n  \ntotal_response_time\n: \n35.456865605s\n,\n  // sum of all response time in seconds\n  \ntotal_response_time_sec\n: 35.456865605,\n  // average response time (formated time)\n  \naverage_response_time\n: \n864.8016ms\n,\n  // average response time in seconds\n  \naverage_response_time_sec\n: 0.8648016000000001,\n\n  // request statistics [requires --api.statistics to be set]\n  // ten most recent requests with 4xx and 5xx status codes\n  \nrecent_errors\n: [\n    {\n      // status code\n      \nstatus_code\n: 500,\n      // description of status code\n      \nstatus\n: \nInternal Server Error\n,\n      // request HTTP method\n      \nmethod\n: \nGET\n,\n      // request hostname\n      \nhost\n: \nlocalhost\n,\n      // request path\n      \npath\n: \n/path\n,\n      // RFC 3339 formatted date/time\n      \ntime\n: \n2016-10-21T16:59:15.418495872-07:00\n\n    }\n  ]\n}\n\n\n\n\nDashboard Statistics\n\n\nYou can control how the Traefik's internal metrics are shown in the Dashboard.\n\n\nIf you want to export internal metrics to different monitoring systems,\nplease check the page \nMetrics\n.\n\n\n[api]\n  # ...\n\n  # Enable more detailed statistics.\n  [api.statistics]\n\n    # Number of recent errors logged.\n    #\n    # Default: 10\n    #\n    recentErrors = 10\n\n  # ...\n\n\n\n\n\n\n\n\n\n\nPath\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n/metrics\n\n\nGET\n\n\nExport internal metrics", 
            "title": "API / Dashboard"
        }, 
        {
            "location": "/configuration/api/#api-definition", 
            "text": "", 
            "title": "API Definition"
        }, 
        {
            "location": "/configuration/api/#configuration", 
            "text": "# API definition\n# Warning: Enabling API will expose Traefik's configuration.\n# It is not recommended in production,\n# unless secured by authentication and authorizations\n[api]\n  # Name of the related entry point\n  #\n  # Optional\n  # Default:  traefik \n  #\n  entryPoint =  traefik \n\n  # Enable Dashboard\n  #\n  # Optional\n  # Default: true\n  #\n  dashboard = true\n\n  # Enable debug mode.\n  # This will install HTTP handlers to expose Go expvars under /debug/vars and\n  # pprof profiling data under /debug/pprof/.\n  # Additionally, the log level will be set to DEBUG.\n  #\n  # Optional\n  # Default: false\n  #\n  debug = true  For more customization, see  entry points  documentation and the examples below.", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/api/#dashboard-web-ui", 
            "text": "", 
            "title": "Dashboard (Web UI)"
        }, 
        {
            "location": "/configuration/api/#security", 
            "text": "Enabling the API will expose all configuration elements,\nincluding sensitive data.  It is not recommended in production,\nunless secured by authentication and authorizations.  A good sane default (but not exhaustive) set of recommendations\nwould be to apply the following protection mechanism:   At application level:  enabling HTTP  Basic Authentication  At transport level:  NOT exposing publicly the API's port,\nkeeping it restricted over internal networks\n(restricted networks as in https://en.wikipedia.org/wiki/Principle_of_least_privilege).", 
            "title": "Security"
        }, 
        {
            "location": "/configuration/api/#api", 
            "text": "Path  Method  Description      /  GET  Provides a simple HTML frontend of Traefik    /cluster/leader  GET  JSON leader true/false response    /health  GET  JSON health metrics    /api  GET  Configuration for all providers    /api/providers  GET  Providers    /api/providers/{provider}  GET ,  PUT  Get or update provider (1)    /api/providers/{provider}/backends  GET  List backends    /api/providers/{provider}/backends/{backend}  GET  Get backend    /api/providers/{provider}/backends/{backend}/servers  GET  List servers in backend    /api/providers/{provider}/backends/{backend}/servers/{server}  GET  Get a server in a backend    /api/providers/{provider}/frontends  GET  List frontends    /api/providers/{provider}/frontends/{frontend}  GET  Get a frontend    /api/providers/{provider}/frontends/{frontend}/routes  GET  List routes in a frontend    /api/providers/{provider}/frontends/{frontend}/routes/{route}  GET  Get a route in a frontend     1  See  Rest  for more information.   Warning  For compatibility reason, when you activate the rest provider, you can use  web  or  rest  as  provider  value.\nBut be careful, in the configuration for all providers the key is still  web .", 
            "title": "API"
        }, 
        {
            "location": "/configuration/api/#address-port", 
            "text": "You can define a custom address/port like this:  defaultEntryPoints = [ http ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n\n  [entryPoints.foo]\n  address =  :8082 \n\n  [entryPoints.bar]\n  address =  :8083 \n\n[ping]\nentryPoint =  foo \n\n[api]\nentryPoint =  bar   In the above example, you would access a regular path, dashboard, and health-check as follows:   Regular path:  http://hostname:80/path  Dashboard:  http://hostname:8083/  Ping URL:  http://hostname:8082/ping   In the above example, it is  very  important to create a named dedicated entry point, and do  not  include it in  defaultEntryPoints .\nOtherwise, you are likely to expose  all  services via that entry point.", 
            "title": "Address / Port"
        }, 
        {
            "location": "/configuration/api/#custom-path", 
            "text": "You can define a custom path like this:  defaultEntryPoints = [ http ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n\n  [entryPoints.foo]\n  address =  :8080 \n\n  [entryPoints.bar]\n  address =  :8081 \n\n# Activate API and Dashboard\n[api]\nentryPoint =  bar \ndashboard = true\n\n[file]\n  [backends]\n    [backends.backend1]\n      [backends.backend1.servers.server1]\n      url =  http://127.0.0.1:8081 \n\n  [frontends]\n    [frontends.frontend1]\n    entryPoints = [ foo ]\n    backend =  backend1 \n      [frontends.frontend1.routes.test_1]\n      rule =  PathPrefixStrip:/yourprefix;PathPrefix:/yourprefix", 
            "title": "Custom Path"
        }, 
        {
            "location": "/configuration/api/#authentication", 
            "text": "You can define the authentication like this:  defaultEntryPoints = [ http ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n\n [entryPoints.foo]\n   address= :8080 \n   [entryPoints.foo.auth]\n     [entryPoints.foo.auth.basic]\n       users = [\n          test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ ,\n          test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 ,\n       ]\n\n[api]\nentrypoint= foo   For more information, see  entry points  .", 
            "title": "Authentication"
        }, 
        {
            "location": "/configuration/api/#provider-call-example", 
            "text": "curl -s  http://localhost:8080/api  | jq .  {\n   file : {\n     frontends : {\n       frontend2 : {\n         routes : {\n           test_2 : {\n             rule :  Path:/test \n          }\n        },\n         backend :  backend1 \n      },\n       frontend1 : {\n         routes : {\n           test_1 : {\n             rule :  Host:test.localhost \n          }\n        },\n         backend :  backend2 \n      }\n    },\n     backends : {\n       backend2 : {\n         loadBalancer : {\n           method :  drr \n        },\n         servers : {\n           server2 : {\n             weight : 2,\n             URL :  http://172.17.0.5:80 \n          },\n           server1 : {\n             weight : 1,\n             url :  http://172.17.0.4:80 \n          }\n        }\n      },\n       backend1 : {\n         loadBalancer : {\n           method :  wrr \n        },\n         circuitBreaker : {\n           expression :  NetworkErrorRatio()   0.5 \n        },\n         servers : {\n           server2 : {\n             weight : 1,\n             url :  http://172.17.0.3:80 \n          },\n           server1 : {\n             weight : 10,\n             url :  http://172.17.0.2:80 \n          }\n        }\n      }\n    }\n  }\n}", 
            "title": "Provider call example"
        }, 
        {
            "location": "/configuration/api/#cluster-leadership", 
            "text": "curl -s  http://localhost:8080/cluster/leader  | jq .   HTTP/1.1 200 OK  Content-Type: application/json; charset=UTF-8  Date: xxx  Content-Length: 15  If the given node is not a cluster leader, an HTTP status of  429-Too-Many-Requests  will be returned.  {\n  // current leadership status of the queried node\n   leader : true\n}", 
            "title": "Cluster Leadership"
        }, 
        {
            "location": "/configuration/api/#health", 
            "text": "curl -s  http://localhost:8080/health  | jq .  {\n  // Traefik PID\n   pid : 2458,\n  // Traefik server uptime (formated time)\n   uptime :  39m6.885931127s ,\n  //  Traefik server uptime in seconds\n   uptime_sec : 2346.885931127,\n  // current server date\n   time :  2015-10-07 18:32:24.362238909 +0200 CEST ,\n  // current server date in seconds\n   unixtime : 1444235544,\n  // count HTTP response status code in realtime\n   status_code_count : {\n     502 : 1\n  },\n  // count HTTP response status code since Traefik started\n   total_status_code_count : {\n     200 : 7,\n     404 : 21,\n     502 : 13\n  },\n  // count HTTP response\n   count : 1,\n  // count HTTP response\n   total_count : 41,\n  // sum of all response time (formated time)\n   total_response_time :  35.456865605s ,\n  // sum of all response time in seconds\n   total_response_time_sec : 35.456865605,\n  // average response time (formated time)\n   average_response_time :  864.8016ms ,\n  // average response time in seconds\n   average_response_time_sec : 0.8648016000000001,\n\n  // request statistics [requires --api.statistics to be set]\n  // ten most recent requests with 4xx and 5xx status codes\n   recent_errors : [\n    {\n      // status code\n       status_code : 500,\n      // description of status code\n       status :  Internal Server Error ,\n      // request HTTP method\n       method :  GET ,\n      // request hostname\n       host :  localhost ,\n      // request path\n       path :  /path ,\n      // RFC 3339 formatted date/time\n       time :  2016-10-21T16:59:15.418495872-07:00 \n    }\n  ]\n}", 
            "title": "Health"
        }, 
        {
            "location": "/configuration/api/#dashboard-statistics", 
            "text": "You can control how the Traefik's internal metrics are shown in the Dashboard.  If you want to export internal metrics to different monitoring systems,\nplease check the page  Metrics .  [api]\n  # ...\n\n  # Enable more detailed statistics.\n  [api.statistics]\n\n    # Number of recent errors logged.\n    #\n    # Default: 10\n    #\n    recentErrors = 10\n\n  # ...     Path  Method  Description      /metrics  GET  Export internal metrics", 
            "title": "Dashboard Statistics"
        }, 
        {
            "location": "/configuration/backends/boltdb/", 
            "text": "BoltDB Provider\n\n\nTraefik can be configured to use BoltDB as a provider.\n\n\n################################################################\n# BoltDB Provider\n################################################################\n\n# Enable BoltDB Provider.\n[boltdb]\n\n# BoltDB file.\n#\n# Required\n# Default: \n127.0.0.1:4001\n\n#\nendpoint = \n/my.db\n\n\n# Enable watch BoltDB changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Prefix used for KV store.\n#\n# Optional\n# Default: \n/traefik\n\n#\nprefix = \n/traefik\n\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\nfilename = \nboltdb.tmpl\n\n\n# Use BoltDB user/pass authentication.\n#\n# Optional\n#\n# username = foo\n# password = bar\n\n# Enable BoltDB TLS connection.\n#\n# Optional\n#\n#    [boltdb.tls]\n#    ca = \n/etc/ssl/ca.crt\n\n#    cert = \n/etc/ssl/boltdb.crt\n\n#    key = \n/etc/ssl/boltdb.key\n\n#    insecureSkipVerify = true\n\n\n\n\nTo enable constraints see \nprovider-specific constraints section\n.", 
            "title": "BoltDB"
        }, 
        {
            "location": "/configuration/backends/boltdb/#boltdb-provider", 
            "text": "Traefik can be configured to use BoltDB as a provider.  ################################################################\n# BoltDB Provider\n################################################################\n\n# Enable BoltDB Provider.\n[boltdb]\n\n# BoltDB file.\n#\n# Required\n# Default:  127.0.0.1:4001 \n#\nendpoint =  /my.db \n\n# Enable watch BoltDB changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Prefix used for KV store.\n#\n# Optional\n# Default:  /traefik \n#\nprefix =  /traefik \n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\nfilename =  boltdb.tmpl \n\n# Use BoltDB user/pass authentication.\n#\n# Optional\n#\n# username = foo\n# password = bar\n\n# Enable BoltDB TLS connection.\n#\n# Optional\n#\n#    [boltdb.tls]\n#    ca =  /etc/ssl/ca.crt \n#    cert =  /etc/ssl/boltdb.crt \n#    key =  /etc/ssl/boltdb.key \n#    insecureSkipVerify = true  To enable constraints see  provider-specific constraints section .", 
            "title": "BoltDB Provider"
        }, 
        {
            "location": "/configuration/backends/consul/", 
            "text": "Consul Key-Value Provider\n\n\nTraefik can be configured to use Consul as a provider.\n\n\n################################################################\n# Consul KV Provider\n################################################################\n\n# Enable Consul KV Provider.\n[consul]\n\n# Consul server endpoint.\n#\n# Required\n# Default: \n127.0.0.1:8500\n\n#\nendpoint = \n127.0.0.1:8500\n\n\n# Enable watch Consul changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Prefix used for KV store.\n#\n# Optional\n# Default: traefik\n#\nprefix = \ntraefik\n\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename = \nconsul.tmpl\n\n\n# Use Consul user/pass authentication.\n#\n# Optional\n#\n# username = foo\n# password = bar\n\n# Enable Consul TLS connection.\n#\n# Optional\n#\n#    [consul.tls]\n#    ca = \n/etc/ssl/ca.crt\n\n#    cert = \n/etc/ssl/consul.crt\n\n#    key = \n/etc/ssl/consul.key\n\n#    insecureSkipVerify = true\n\n\n\n\nTo enable constraints see \nprovider-specific constraints section\n.\n\n\nPlease refer to the \nKey Value storage structure\n section to get documentation on Traefik KV structure.", 
            "title": "Consul"
        }, 
        {
            "location": "/configuration/backends/consul/#consul-key-value-provider", 
            "text": "Traefik can be configured to use Consul as a provider.  ################################################################\n# Consul KV Provider\n################################################################\n\n# Enable Consul KV Provider.\n[consul]\n\n# Consul server endpoint.\n#\n# Required\n# Default:  127.0.0.1:8500 \n#\nendpoint =  127.0.0.1:8500 \n\n# Enable watch Consul changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Prefix used for KV store.\n#\n# Optional\n# Default: traefik\n#\nprefix =  traefik \n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename =  consul.tmpl \n\n# Use Consul user/pass authentication.\n#\n# Optional\n#\n# username = foo\n# password = bar\n\n# Enable Consul TLS connection.\n#\n# Optional\n#\n#    [consul.tls]\n#    ca =  /etc/ssl/ca.crt \n#    cert =  /etc/ssl/consul.crt \n#    key =  /etc/ssl/consul.key \n#    insecureSkipVerify = true  To enable constraints see  provider-specific constraints section .  Please refer to the  Key Value storage structure  section to get documentation on Traefik KV structure.", 
            "title": "Consul Key-Value Provider"
        }, 
        {
            "location": "/configuration/backends/consulcatalog/", 
            "text": "Consul Catalog Provider\n\n\nTraefik can be configured to use service discovery catalog of Consul as a provider.\n\n\n################################################################\n# Consul Catalog Provider\n################################################################\n\n# Enable Consul Catalog Provider.\n[consulCatalog]\n\n# Consul server endpoint.\n#\n# Required\n# Default: \n127.0.0.1:8500\n\n#\nendpoint = \n127.0.0.1:8500\n\n\n# Expose Consul catalog services by default in Traefik.\n#\n# Optional\n# Default: true\n#\nexposedByDefault = false\n\n# Allow Consul server to serve the catalog reads regardless of whether it is the leader.\n#\n# Optional\n# Default: false\n#\nstale = false\n\n# Default base domain used for the frontend rules.\n#\n# Optional\n#\ndomain = \nconsul.localhost\n\n\n# Keep a Consul node only if all checks status are passing\n# If true, only the Consul nodes with checks status 'passing' will be kept.\n# if false, only the Consul nodes with checks status 'passing' or 'warning' will be kept.\n#\n# Optional\n# Default: true\n#\nstrictChecks = true\n\n# Prefix for Consul catalog tags.\n#\n# Optional\n# Default: \ntraefik\n\n#\nprefix = \ntraefik\n\n\n# Default frontEnd Rule for Consul services.\n#\n# The format is a Go Template with:\n# - \n.ServiceName\n, \n.Domain\n and \n.Attributes\n available\n# - \ngetTag(name, tags, defaultValue)\n, \nhasTag(name, tags)\n and \ngetAttribute(name, tags, defaultValue)\n functions are available\n# - \ngetAttribute(...)\n function uses prefixed tag names based on \nprefix\n value\n#\n# Optional\n# Default: \nHost:{{.ServiceName}}.{{.Domain}}\n\n#\n#frontEndRule = \nHost:{{.ServiceName}}.{{.Domain}}\n\n\n# Enable Consul catalog TLS connection.\n#\n# Optional\n#\n#    [consulCatalog.tls]\n#    ca = \n/etc/ssl/ca.crt\n\n#    cert = \n/etc/ssl/consul.crt\n\n#    key = \n/etc/ssl/consul.key\n\n#    insecureSkipVerify = true\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename = \nconsulcatalog.tmpl\n\n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# - \n1\n: previous template version (must be used only with older custom templates, see \nfilename\n)\n# - \n2\n: current template version (must be used to force template version when \nfilename\n is used)\n#\n# templateVersion = 2\n\n\n\n\nThis provider will create routes matching on hostname based on the service name used in Consul.\n\n\nTo enable constraints see \nprovider-specific constraints section\n.\n\n\nTags\n\n\nAdditional settings can be defined using Consul Catalog tags.\n\n\n\n\nNote\n\n\nThe default prefix is \ntraefik\n.\n\n\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprefix\n.enable=false\n\n\nDisables this container in Traefik.\n\n\n\n\n\n\nprefix\n.protocol=https\n\n\nOverrides the default \nhttp\n protocol.\n\n\n\n\n\n\nprefix\n.weight=10\n\n\nAssigns this weight to the container.\n\n\n\n\n\n\ntraefik.backend.buffering.maxRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.maxResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.retryExpression=EXPR\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\nprefix\n.backend.circuitbreaker.expression=EXPR\n\n\nCreates a \ncircuit breaker\n to be used against the backend. ex: \nNetworkErrorRatio() \n 0.\n\n\n\n\n\n\nprefix\n.backend.responseForwarding.flushInterval=10ms\n\n\nDefines the interval between two flushes when forwarding response from backend to client.\n\n\n\n\n\n\nprefix\n.backend.healthcheck.path=/health\n\n\nEnables health check for the backend, hitting the container at \npath\n.\n\n\n\n\n\n\nprefix\n.backend.healthcheck.interval=1s\n\n\nDefines the health check interval.\n\n\n\n\n\n\nprefix\n.backend.healthcheck.port=8080\n\n\nSets a different port for the health check.\n\n\n\n\n\n\ntraefik.backend.healthcheck.scheme=http\n\n\nOverrides the server URL scheme.\n\n\n\n\n\n\nprefix\n.backend.healthcheck.hostname=foobar.com\n\n\nDefines the health check hostname.\n\n\n\n\n\n\nprefix\n.backend.healthcheck.headers=EXPR\n\n\nDefines the health check request headers \nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\nprefix\n.backend.loadbalancer.method=drr\n\n\nOverrides the default \nwrr\n load balancer algorithm.\n\n\n\n\n\n\nprefix\n.backend.loadbalancer.stickiness=true\n\n\nEnables backend sticky sessions.\n\n\n\n\n\n\nprefix\n.backend.loadbalancer.stickiness.cookieName=NAME\n\n\nSets the cookie name manually for sticky sessions.\n\n\n\n\n\n\nprefix\n.backend.loadbalancer.sticky=true\n\n\nEnables backend sticky sessions. (DEPRECATED)\n\n\n\n\n\n\nprefix\n.backend.maxconn.amount=10\n\n\nSets a maximum number of connections to the backend.\nMust be used in conjunction with the below label to take effect.\n\n\n\n\n\n\nprefix\n.backend.maxconn.extractorfunc=client.ip\n\n\nSets the function to be used against the request to determine what to limit maximum connections to the backend by.\nMust be used in conjunction with the above label to take effect.\n\n\n\n\n\n\nprefix\n.frontend.auth.basic=EXPR\n\n\nSets basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n (DEPRECATED).\n\n\n\n\n\n\nprefix\n.frontend.auth.basic.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\nprefix\n.frontend.auth.basic.users=EXPR\n\n\nSets basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n.\n\n\n\n\n\n\nprefix\n.frontend.auth.basic.usersFile=/path/.htpasswd\n\n\nSets basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\nprefix\n.frontend.auth.digest.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\nprefix\n.frontend.auth.digest.users=EXPR\n\n\nSets digest authentication to this frontend in CSV format: \nUser:Realm:Hash,User:Realm:Hash\n.\n\n\n\n\n\n\nprefix\n.frontend.auth.digest.usersFile=/path/.htdigest\n\n\nSets digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\nprefix\n.frontend.auth.forward.address=https://example.com\n\n\nSets the URL of the authentication server.\n\n\n\n\n\n\nprefix\n.frontend.auth.forward.authResponseHeaders=EXPR\n\n\nSets the forward authentication authResponseHeaders in CSV format: \nX-Auth-User,X-Auth-Header\n\n\n\n\n\n\nprefix\n.frontend.auth.forward.tls.ca=/path/ca.pem\n\n\nSets the Certificate Authority (CA) for the TLS connection with the authentication server.\n\n\n\n\n\n\nprefix\n.frontend.auth.forward.tls.caOptional=true\n\n\nChecks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).\n\n\n\n\n\n\nprefix\n.frontend.auth.forward.tls.cert=/path/server.pem\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\nprefix\n.frontend.auth.forward.tls.insecureSkipVerify=true\n\n\nIf set to true invalid SSL certificates are accepted.\n\n\n\n\n\n\nprefix\n.frontend.auth.forward.tls.key=/path/server.key\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\nprefix\n.frontend.auth.forward.trustForwardHeader=true\n\n\nTrusts X-Forwarded-* headers.\n\n\n\n\n\n\nprefix\n.frontend.auth.headerField=X-WebAuth-User\n\n\nSets the header used to pass the authenticated user to the application.\n\n\n\n\n\n\nprefix\n.frontend.entryPoints=http,https\n\n\nAssigns this frontend to entry points \nhttp\n and \nhttps\n.\nOverrides \ndefaultEntryPoints\n\n\n\n\n\n\nprefix\n.frontend.errors.\nname\n.backend=NAME\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\nprefix\n.frontend.errors.\nname\n.query=PATH\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\nprefix\n.frontend.errors.\nname\n.status=RANGE\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\nprefix\n.frontend.passHostHeader=true\n\n\nForwards client \nHost\n header to the backend.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.issuer.commonName=true\n\n\nAdd the issuer.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.issuer.country=true\n\n\nAdd the issuer.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.issuer.domainComponent=true\n\n\nAdd the issuer.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.issuer.locality=true\n\n\nAdd the issuer.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.issuer.organization=true\n\n\nAdd the issuer.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.issuer.province=true\n\n\nAdd the issuer.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.issuer.serialNumber=true\n\n\nAdd the subject.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.notAfter=true\n\n\nAdd the noAfter field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.notBefore=true\n\n\nAdd the noBefore field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.sans=true\n\n\nAdd the sans field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.subject.commonName=true\n\n\nAdd the subject.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.subject.country=true\n\n\nAdd the subject.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.subject.domainComponent=true\n\n\nAdd the subject.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.subject.locality=true\n\n\nAdd the subject.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.subject.organization=true\n\n\nAdd the subject.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.subject.province=true\n\n\nAdd the subject.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.infos.subject.serialNumber=true\n\n\nAdd the subject.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSClientCert.pem=true\n\n\nPass the escaped pem in the \nX-Forwarded-Ssl-Client-Cert\n header.\n\n\n\n\n\n\nprefix\n.frontend.passTLSCert=true\n\n\nForwards TLS Client certificates to the backend.\n\n\n\n\n\n\nprefix\n.frontend.priority=10\n\n\nOverrides default frontend priority.\n\n\n\n\n\n\nprefix\n.frontend.rateLimit.extractorFunc=EXP\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\nprefix\n.frontend.rateLimit.rateSet.\nname\n.period=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\nprefix\n.frontend.rateLimit.rateSet.\nname\n.average=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\nprefix\n.frontend.rateLimit.rateSet.\nname\n.burst=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\nprefix\n.frontend.redirect.entryPoint=https\n\n\nEnables Redirect to another entryPoint to this frontend (e.g. HTTPS).\n\n\n\n\n\n\nprefix\n.frontend.redirect.regex=^http://localhost/(.*)\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.replacement\n.\n\n\n\n\n\n\nprefix\n.frontend.redirect.replacement=http://mydomain/$1\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.regex\n.\n\n\n\n\n\n\nprefix\n.frontend.redirect.permanent=true\n\n\nReturns 301 instead of 302.\n\n\n\n\n\n\nprefix\n.frontend.rule=EXPR\n\n\nOverrides the default frontend rule. Default: \nHost:{{.ServiceName}}.{{.Domain}}\n.\n\n\n\n\n\n\nprefix\n.frontend.whiteList.sourceRange=RANGE\n\n\nSets a list of IP-Ranges which are allowed to access.\nAn unset or empty list allows all Source-IPs to access. If one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.\n\n\n\n\n\n\nprefix\n.frontend.whiteList.useXForwardedFor=true\n\n\nUses \nX-Forwarded-For\n header as valid source of IP for the white list.\n\n\n\n\n\n\n\n\nMultiple frontends for a single service\n\n\nIf you need to support multiple frontends for a service, for example when having multiple \nrules\n that can't be combined, specify them as follows:\n\n\nprefix\n.frontends.A.rule=Host:A:PathPrefix:/A\n\nprefix\n.frontends.B.rule=Host:B:PathPrefix:/\n\n\n\n\nA\n and \nB\n here are just arbitrary names, they can be anything. You can use any setting that applies to \nprefix\n.frontend\n from the table above.\n\n\nCustom Headers\n\n\n\n\nNote\n\n\nThe default prefix is \ntraefik\n.\n\n\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprefix\n.frontend.headers.customRequestHeaders=EXPR\n\n\nProvides the container with custom request headers that will be appended to each request forwarded to the container.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\nprefix\n.frontend.headers.customResponseHeaders=EXPR\n\n\nAppends the headers to each response returned by the container, before forwarding the response to the client.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\nNote\n\n\nThe default prefix is \ntraefik\n.\n\n\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprefix\n.frontend.headers.allowedHosts=EXPR\n\n\nProvides a list of allowed hosts that requests will be processed.\nFormat: \nHost1,Host2\n\n\n\n\n\n\nprefix\n.frontend.headers.browserXSSFilter=true\n\n\nAdds the X-XSS-Protection header with the value \n1; mode=block\n.\n\n\n\n\n\n\nprefix\n.frontend.headers.contentSecurityPolicy=VALUE\n\n\nAdds CSP Header with the custom value.\n\n\n\n\n\n\nprefix\n.frontend.headers.contentTypeNosniff=true\n\n\nAdds the \nX-Content-Type-Options\n header with the value \nnosniff\n.\n\n\n\n\n\n\nprefix\n.frontend.headers.customBrowserXSSValue=VALUE\n\n\nSet custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.\n\n\n\n\n\n\nprefix\n.frontend.headers.customFrameOptionsValue=VALUE\n\n\nOverrides the \nX-Frame-Options\n header with the custom value.\n\n\n\n\n\n\nprefix\n.frontend.headers.forceSTSHeader=false\n\n\nAdds the STS  header to non-SSL requests.\n\n\n\n\n\n\nprefix\n.frontend.headers.frameDeny=false\n\n\nAdds the \nX-Frame-Options\n header with the value of \nDENY\n.\n\n\n\n\n\n\nprefix\n.frontend.headers.hostsProxyHeaders=EXPR\n\n\nProvides a list of headers that the proxied hostname may be stored.\nFormat: \nHEADER1,HEADER2\n\n\n\n\n\n\nprefix\n.frontend.headers.isDevelopment=false\n\n\nThis will cause the \nAllowedHosts\n, \nSSLRedirect\n, and \nSTSSeconds\n/\nSTSIncludeSubdomains\n options to be ignored during development.\nWhen deploying to production, be sure to set this to false.\n\n\n\n\n\n\nprefix\n.frontend.headers.publicKey=VALUE\n\n\nAdds HPKP header.\n\n\n\n\n\n\nprefix\n.frontend.headers.referrerPolicy=VALUE\n\n\nAdds referrer policy  header.\n\n\n\n\n\n\nprefix\n.frontend.headers.SSLRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent.\n\n\n\n\n\n\nprefix\n.frontend.headers.SSLTemporaryRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.\n\n\n\n\n\n\nprefix\n.frontend.headers.SSLHost=HOST\n\n\nThis setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.\n\n\n\n\n\n\nprefix\n.frontend.headers.SSLForceHost=true\n\n\nIf \nSSLForceHost\n is \ntrue\n and \nSSLHost\n is set, requests will be forced to use \nSSLHost\n even the ones that are already using SSL. Default is false.\n\n\n\n\n\n\nprefix\n.frontend.headers.SSLProxyHeaders=EXPR\n\n\nHeader combinations that would signify a proper SSL Request (Such as \nX-Forwarded-For:https\n).\nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\nprefix\n.frontend.headers.STSSeconds=315360000\n\n\nSets the max-age of the STS header.\n\n\n\n\n\n\nprefix\n.frontend.headers.STSIncludeSubdomains=true\n\n\nAdds the \nIncludeSubdomains\n section of the STS  header.\n\n\n\n\n\n\nprefix\n.frontend.headers.STSPreload=true\n\n\nAdds the preload flag to the STS  header.\n\n\n\n\n\n\n\n\nExamples\n\n\nIf you want that Traefik uses Consul tags correctly you need to defined them like that:\n\n\ntraefik.enable=true\ntraefik.tags=api\ntraefik.tags=external\n\n\n\n\nIf the prefix defined in Traefik configuration is \nbla\n, tags need to be defined like that:\n\n\nbla.enable=true\nbla.tags=api\nbla.tags=external", 
            "title": "Consul Catalog"
        }, 
        {
            "location": "/configuration/backends/consulcatalog/#consul-catalog-provider", 
            "text": "Traefik can be configured to use service discovery catalog of Consul as a provider.  ################################################################\n# Consul Catalog Provider\n################################################################\n\n# Enable Consul Catalog Provider.\n[consulCatalog]\n\n# Consul server endpoint.\n#\n# Required\n# Default:  127.0.0.1:8500 \n#\nendpoint =  127.0.0.1:8500 \n\n# Expose Consul catalog services by default in Traefik.\n#\n# Optional\n# Default: true\n#\nexposedByDefault = false\n\n# Allow Consul server to serve the catalog reads regardless of whether it is the leader.\n#\n# Optional\n# Default: false\n#\nstale = false\n\n# Default base domain used for the frontend rules.\n#\n# Optional\n#\ndomain =  consul.localhost \n\n# Keep a Consul node only if all checks status are passing\n# If true, only the Consul nodes with checks status 'passing' will be kept.\n# if false, only the Consul nodes with checks status 'passing' or 'warning' will be kept.\n#\n# Optional\n# Default: true\n#\nstrictChecks = true\n\n# Prefix for Consul catalog tags.\n#\n# Optional\n# Default:  traefik \n#\nprefix =  traefik \n\n# Default frontEnd Rule for Consul services.\n#\n# The format is a Go Template with:\n# -  .ServiceName ,  .Domain  and  .Attributes  available\n# -  getTag(name, tags, defaultValue) ,  hasTag(name, tags)  and  getAttribute(name, tags, defaultValue)  functions are available\n# -  getAttribute(...)  function uses prefixed tag names based on  prefix  value\n#\n# Optional\n# Default:  Host:{{.ServiceName}}.{{.Domain}} \n#\n#frontEndRule =  Host:{{.ServiceName}}.{{.Domain}} \n\n# Enable Consul catalog TLS connection.\n#\n# Optional\n#\n#    [consulCatalog.tls]\n#    ca =  /etc/ssl/ca.crt \n#    cert =  /etc/ssl/consul.crt \n#    key =  /etc/ssl/consul.key \n#    insecureSkipVerify = true\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename =  consulcatalog.tmpl \n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# -  1 : previous template version (must be used only with older custom templates, see  filename )\n# -  2 : current template version (must be used to force template version when  filename  is used)\n#\n# templateVersion = 2  This provider will create routes matching on hostname based on the service name used in Consul.  To enable constraints see  provider-specific constraints section .", 
            "title": "Consul Catalog Provider"
        }, 
        {
            "location": "/configuration/backends/consulcatalog/#tags", 
            "text": "Additional settings can be defined using Consul Catalog tags.   Note  The default prefix is  traefik .      Label  Description      prefix .enable=false  Disables this container in Traefik.    prefix .protocol=https  Overrides the default  http  protocol.    prefix .weight=10  Assigns this weight to the container.    traefik.backend.buffering.maxRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.maxResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.retryExpression=EXPR  See  buffering  section.    prefix .backend.circuitbreaker.expression=EXPR  Creates a  circuit breaker  to be used against the backend. ex:  NetworkErrorRatio()   0.    prefix .backend.responseForwarding.flushInterval=10ms  Defines the interval between two flushes when forwarding response from backend to client.    prefix .backend.healthcheck.path=/health  Enables health check for the backend, hitting the container at  path .    prefix .backend.healthcheck.interval=1s  Defines the health check interval.    prefix .backend.healthcheck.port=8080  Sets a different port for the health check.    traefik.backend.healthcheck.scheme=http  Overrides the server URL scheme.    prefix .backend.healthcheck.hostname=foobar.com  Defines the health check hostname.    prefix .backend.healthcheck.headers=EXPR  Defines the health check request headers  Format:   HEADER:value HEADER2:value2    prefix .backend.loadbalancer.method=drr  Overrides the default  wrr  load balancer algorithm.    prefix .backend.loadbalancer.stickiness=true  Enables backend sticky sessions.    prefix .backend.loadbalancer.stickiness.cookieName=NAME  Sets the cookie name manually for sticky sessions.    prefix .backend.loadbalancer.sticky=true  Enables backend sticky sessions. (DEPRECATED)    prefix .backend.maxconn.amount=10  Sets a maximum number of connections to the backend. Must be used in conjunction with the below label to take effect.    prefix .backend.maxconn.extractorfunc=client.ip  Sets the function to be used against the request to determine what to limit maximum connections to the backend by. Must be used in conjunction with the above label to take effect.    prefix .frontend.auth.basic=EXPR  Sets basic authentication to this frontend in CSV format:  User:Hash,User:Hash  (DEPRECATED).    prefix .frontend.auth.basic.removeHeader=true  If set to  true , removes the  Authorization  header.    prefix .frontend.auth.basic.users=EXPR  Sets basic authentication to this frontend in CSV format:  User:Hash,User:Hash .    prefix .frontend.auth.basic.usersFile=/path/.htpasswd  Sets basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    prefix .frontend.auth.digest.removeHeader=true  If set to  true , removes the  Authorization  header.    prefix .frontend.auth.digest.users=EXPR  Sets digest authentication to this frontend in CSV format:  User:Realm:Hash,User:Realm:Hash .    prefix .frontend.auth.digest.usersFile=/path/.htdigest  Sets digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    prefix .frontend.auth.forward.address=https://example.com  Sets the URL of the authentication server.    prefix .frontend.auth.forward.authResponseHeaders=EXPR  Sets the forward authentication authResponseHeaders in CSV format:  X-Auth-User,X-Auth-Header    prefix .frontend.auth.forward.tls.ca=/path/ca.pem  Sets the Certificate Authority (CA) for the TLS connection with the authentication server.    prefix .frontend.auth.forward.tls.caOptional=true  Checks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).    prefix .frontend.auth.forward.tls.cert=/path/server.pem  Sets the Certificate for the TLS connection with the authentication server.    prefix .frontend.auth.forward.tls.insecureSkipVerify=true  If set to true invalid SSL certificates are accepted.    prefix .frontend.auth.forward.tls.key=/path/server.key  Sets the Certificate for the TLS connection with the authentication server.    prefix .frontend.auth.forward.trustForwardHeader=true  Trusts X-Forwarded-* headers.    prefix .frontend.auth.headerField=X-WebAuth-User  Sets the header used to pass the authenticated user to the application.    prefix .frontend.entryPoints=http,https  Assigns this frontend to entry points  http  and  https . Overrides  defaultEntryPoints    prefix .frontend.errors. name .backend=NAME  See  custom error pages  section.    prefix .frontend.errors. name .query=PATH  See  custom error pages  section.    prefix .frontend.errors. name .status=RANGE  See  custom error pages  section.    prefix .frontend.passHostHeader=true  Forwards client  Host  header to the backend.    prefix .frontend.passTLSClientCert.infos.issuer.commonName=true  Add the issuer.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.issuer.country=true  Add the issuer.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.issuer.domainComponent=true  Add the issuer.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.issuer.locality=true  Add the issuer.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.issuer.organization=true  Add the issuer.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.issuer.province=true  Add the issuer.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.issuer.serialNumber=true  Add the subject.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.notAfter=true  Add the noAfter field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.notBefore=true  Add the noBefore field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.sans=true  Add the sans field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.subject.commonName=true  Add the subject.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.subject.country=true  Add the subject.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.subject.domainComponent=true  Add the subject.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.subject.locality=true  Add the subject.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.subject.organization=true  Add the subject.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.subject.province=true  Add the subject.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.infos.subject.serialNumber=true  Add the subject.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    prefix .frontend.passTLSClientCert.pem=true  Pass the escaped pem in the  X-Forwarded-Ssl-Client-Cert  header.    prefix .frontend.passTLSCert=true  Forwards TLS Client certificates to the backend.    prefix .frontend.priority=10  Overrides default frontend priority.    prefix .frontend.rateLimit.extractorFunc=EXP  See  rate limiting  section.    prefix .frontend.rateLimit.rateSet. name .period=6  See  rate limiting  section.    prefix .frontend.rateLimit.rateSet. name .average=6  See  rate limiting  section.    prefix .frontend.rateLimit.rateSet. name .burst=6  See  rate limiting  section.    prefix .frontend.redirect.entryPoint=https  Enables Redirect to another entryPoint to this frontend (e.g. HTTPS).    prefix .frontend.redirect.regex=^http://localhost/(.*)  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.replacement .    prefix .frontend.redirect.replacement=http://mydomain/$1  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.regex .    prefix .frontend.redirect.permanent=true  Returns 301 instead of 302.    prefix .frontend.rule=EXPR  Overrides the default frontend rule. Default:  Host:{{.ServiceName}}.{{.Domain}} .    prefix .frontend.whiteList.sourceRange=RANGE  Sets a list of IP-Ranges which are allowed to access. An unset or empty list allows all Source-IPs to access. If one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.    prefix .frontend.whiteList.useXForwardedFor=true  Uses  X-Forwarded-For  header as valid source of IP for the white list.", 
            "title": "Tags"
        }, 
        {
            "location": "/configuration/backends/consulcatalog/#multiple-frontends-for-a-single-service", 
            "text": "If you need to support multiple frontends for a service, for example when having multiple  rules  that can't be combined, specify them as follows:  prefix .frontends.A.rule=Host:A:PathPrefix:/A prefix .frontends.B.rule=Host:B:PathPrefix:/  A  and  B  here are just arbitrary names, they can be anything. You can use any setting that applies to  prefix .frontend  from the table above.", 
            "title": "Multiple frontends for a single service"
        }, 
        {
            "location": "/configuration/backends/consulcatalog/#custom-headers", 
            "text": "Note  The default prefix is  traefik .      Label  Description      prefix .frontend.headers.customRequestHeaders=EXPR  Provides the container with custom request headers that will be appended to each request forwarded to the container. Format:  HEADER:value HEADER2:value2    prefix .frontend.headers.customResponseHeaders=EXPR  Appends the headers to each response returned by the container, before forwarding the response to the client. Format:  HEADER:value HEADER2:value2", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/consulcatalog/#security-headers", 
            "text": "Note  The default prefix is  traefik .      Label  Description      prefix .frontend.headers.allowedHosts=EXPR  Provides a list of allowed hosts that requests will be processed. Format:  Host1,Host2    prefix .frontend.headers.browserXSSFilter=true  Adds the X-XSS-Protection header with the value  1; mode=block .    prefix .frontend.headers.contentSecurityPolicy=VALUE  Adds CSP Header with the custom value.    prefix .frontend.headers.contentTypeNosniff=true  Adds the  X-Content-Type-Options  header with the value  nosniff .    prefix .frontend.headers.customBrowserXSSValue=VALUE  Set custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.    prefix .frontend.headers.customFrameOptionsValue=VALUE  Overrides the  X-Frame-Options  header with the custom value.    prefix .frontend.headers.forceSTSHeader=false  Adds the STS  header to non-SSL requests.    prefix .frontend.headers.frameDeny=false  Adds the  X-Frame-Options  header with the value of  DENY .    prefix .frontend.headers.hostsProxyHeaders=EXPR  Provides a list of headers that the proxied hostname may be stored. Format:  HEADER1,HEADER2    prefix .frontend.headers.isDevelopment=false  This will cause the  AllowedHosts ,  SSLRedirect , and  STSSeconds / STSIncludeSubdomains  options to be ignored during development. When deploying to production, be sure to set this to false.    prefix .frontend.headers.publicKey=VALUE  Adds HPKP header.    prefix .frontend.headers.referrerPolicy=VALUE  Adds referrer policy  header.    prefix .frontend.headers.SSLRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent.    prefix .frontend.headers.SSLTemporaryRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.    prefix .frontend.headers.SSLHost=HOST  This setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.    prefix .frontend.headers.SSLForceHost=true  If  SSLForceHost  is  true  and  SSLHost  is set, requests will be forced to use  SSLHost  even the ones that are already using SSL. Default is false.    prefix .frontend.headers.SSLProxyHeaders=EXPR  Header combinations that would signify a proper SSL Request (Such as  X-Forwarded-For:https ). Format:   HEADER:value HEADER2:value2    prefix .frontend.headers.STSSeconds=315360000  Sets the max-age of the STS header.    prefix .frontend.headers.STSIncludeSubdomains=true  Adds the  IncludeSubdomains  section of the STS  header.    prefix .frontend.headers.STSPreload=true  Adds the preload flag to the STS  header.", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/consulcatalog/#examples", 
            "text": "If you want that Traefik uses Consul tags correctly you need to defined them like that:  traefik.enable=true\ntraefik.tags=api\ntraefik.tags=external  If the prefix defined in Traefik configuration is  bla , tags need to be defined like that:  bla.enable=true\nbla.tags=api\nbla.tags=external", 
            "title": "Examples"
        }, 
        {
            "location": "/configuration/backends/docker/", 
            "text": "Docker Provider\n\n\nTraefik can be configured to use Docker as a provider.\n\n\nDocker\n\n\n################################################################\n# Docker Provider\n################################################################\n\n# Enable Docker Provider.\n[docker]\n\n# Docker server endpoint. Can be a tcp or a unix socket endpoint.\n#\n# Required\n#\nendpoint = \nunix:///var/run/docker.sock\n\n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the \ntraefik.domain\n label on a container.\n#\n# Optional\n#\ndomain = \ndocker.localhost\n\n\n# Enable watch docker changes.\n#\n# Optional\n#\nwatch = true\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename = \ndocker.tmpl\n\n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# - \n1\n: previous template version (must be used only with older custom templates, see \nfilename\n)\n# - \n2\n: current template version (must be used to force template version when \nfilename\n is used)\n#\n# templateVersion = 2\n\n# Expose containers by default in Traefik.\n# If set to false, containers that don't have `traefik.enable=true` will be ignored.\n#\n# Optional\n# Default: true\n#\nexposedByDefault = true\n\n# Use the IP address from the binded port instead of the inner network one.\n#\n# In case no IP address is attached to the binded port (or in case \n# there is no bind), the inner network one will be used as a fallback.     \n#\n# Optional\n# Default: false\n#\nusebindportip = true\n\n# Use Swarm Mode services as data provider.\n#\n# Optional\n# Default: false\n#\nswarmMode = false\n\n# Polling interval (in seconds) for Swarm Mode.\n#\n# Optional\n# Default: 15\n#\nswarmModeRefreshSeconds = 15\n\n# Define a default docker network to use for connections to all containers.\n# Can be overridden by the traefik.docker.network label.\n#\n# Optional\n#\nnetwork = \nweb\n\n\n# Enable docker TLS connection.\n#\n# Optional\n#\n#  [docker.tls]\n#  ca = \n/etc/ssl/ca.crt\n\n#  cert = \n/etc/ssl/docker.crt\n\n#  key = \n/etc/ssl/docker.key\n\n#  insecureSkipVerify = true\n\n\n\n\nTo enable constraints see \nprovider-specific constraints section\n.\n\n\nDocker Swarm Mode\n\n\n################################################################\n# Docker Swarm Mode Provider\n################################################################\n\n# Enable Docker Provider.\n[docker]\n\n# Docker server endpoint.\n# Can be a tcp or a unix socket endpoint.\n#\n# Required\n# Default: \nunix:///var/run/docker.sock\n\n#\n# swarm classic (1.12-)\n# endpoint = \ntcp://127.0.0.1:2375\n\n# docker swarm mode (1.12+)\nendpoint = \ntcp://127.0.0.1:2377\n\n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the \ntraefik.domain\n label on a services.\n#\n# Optional\n# Default: \n\n#\ndomain = \ndocker.localhost\n\n\n# Enable watch docker changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Use Docker Swarm Mode as data provider.\n#\n# Optional\n# Default: false\n#\nswarmMode = true\n\n# Define a default docker network to use for connections to all containers.\n# Can be overridden by the traefik.docker.network label.\n#\n# Optional\n#\nnetwork = \nweb\n\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename = \ndocker.tmpl\n\n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# - \n1\n: previous template version (must be used only with older custom templates, see \nfilename\n)\n# - \n2\n: current template version (must be used to force template version when \nfilename\n is used)\n#\n# templateVersion = 2\n\n# Expose services by default in Traefik.\n#\n# Optional\n# Default: true\n#\nexposedByDefault = false\n\n# Enable docker TLS connection.\n#\n# Optional\n#\n#  [docker.tls]\n#  ca = \n/etc/ssl/ca.crt\n\n#  cert = \n/etc/ssl/docker.crt\n\n#  key = \n/etc/ssl/docker.key\n\n#  insecureSkipVerify = true\n\n\n\n\nTo enable constraints see \nprovider-specific constraints section\n.\n\n\nSecurity Considerations\n\n\nSecurity Challenge with the Docker Socket\n\n\nTraefik requires access to the docker socket to get its dynamic configuration,\nby watching the Docker API through this socket.\n\n\n\n\nImportant\n\n\nDepending on your context and your usage, accessing the Docker API without any restriction might be a security concern.\n\n\n\n\nAs explained on the Docker documentation: (\nDocker Daemon Attack Surface page\n):\n\n\n[...] only **trusted** users should be allowed to control your Docker daemon [...]\n\n\nIf the Traefik processes (handling requests from the outside world) is attacked,\nthen the attacker can access the Docker (or Swarm Mode) backend.\n\n\nAlso, when using Swarm Mode, it is mandatory to schedule Traefik's containers on the Swarm manager nodes,\nto let Traefik accessing the Docker Socket of the Swarm manager node.\n\n\nMore information about Docker's security:\n\n\n\n\nKubeCon EU 2018 Keynote, Running with Scissors, from Liz Rice\n\n\nDon't expose the Docker socket (not even to a container)\n\n\nA thread on Stack Overflow about sharing the \n/var/run/docker.sock\n file\n\n\nTo Dind or not to DinD\n\n\n\n\nWorkarounds\n\n\n\n\nImproved Security\n\n\nTraefikEE\n solves this problem by separating the control plane (connected to Docker) and the data plane (handling the requests).\n\n\n\n\nAnother possible workaround is to expose the Docker socket over TCP, instead of the default Unix socket file.\nIt allows different implementation levels of the \nAAA (Authentication, Authorization, Accounting) concepts\n, depending on your security assessment:\n\n\n\n\n\n\nAuthentication with Client Certificates as described in \nthe \"Protect the Docker daemon socket\" page of Docker's documentation\n\n\n\n\n\n\nAuthorization with the \nDocker Authorization Plugin Mechanism\n\n\n\n\n\n\nAccounting at networking level, by exposing the socket only inside a Docker private network, only available for Traefik.\n\n\n\n\n\n\nAccounting at container level, by exposing the socket on a another container than Traefik's.\n  With Swarm mode, it allows scheduling of Traefik on worker nodes, with only the \"socket exposer\" container on the manager nodes.\n\n\n\n\n\n\nAccounting at kernel level, by enforcing kernel calls with mechanisms like \nSELinux\n,\n  to only allows an identified set of actions for Traefik's process (or the \"socket exposer\" process).\n\n\n\n\n\n\nUse the following ressources to get started:\n\n\n\n\nTraefik issue GH-4174 about security with Docker socket\n\n\nInspecting Docker Activity with Socat\n\n\nLetting Traefik run on Worker Nodes\n\n\nDocker Socket Proxy from Tecnativa\n\n\n\n\nLabels: overriding default behavior\n\n\nUsing Docker with Swarm Mode\n\n\nIf you use a compose file with the Swarm mode, labels should be defined in the \ndeploy\n part of your service.\nThis behavior is only enabled for docker-compose version 3+ (\nCompose file reference\n).\n\n\nversion: \n3\n\nservices:\n  whoami:\n    deploy:\n      labels:\n        traefik.docker.network: traefik\n\n\n\n\nRequired labels:\n\n\n\n\ntraefik.frontend.rule\n\n\ntraefik.port\n - Without this the debug logs will show this service is deliberately filtered out.\n\n\ntraefik.docker.network\n - Without this a 504 may occur.\n\n\n\n\nTroubleshooting\n\n\nIf service doesn't show up in the dashboard, check the debug logs to see if the port is missing:\n\nFiltering container without port, \nSERVICE_NAME\n: port label is missing, ...')\n\n\nIf \n504 Gateway Timeout\n occurs and there are networks used, ensure that \ntraefik.docker.network\n is defined. \nThe complete name is required, meaning if the network is internal the name needs to be \nproject_name\n_\nnetwork_name\n.\n\n\nUsing Docker Compose\n\n\nIf you are intending to use only Docker Compose commands (e.g. \ndocker-compose up --scale whoami=2 -d\n), labels should be under your service, otherwise they will be ignored.\n\n\nversion: \n3\n\nservices:\n  whoami:\n    labels:\n      traefik.docker.network: traefik\n\n\n\n\nOn Containers\n\n\nLabels can be used on containers to override default behavior.\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.docker.network\n\n\nOverrides the default docker network to use for connections to the container. [1]\n\n\n\n\n\n\ntraefik.domain\n\n\nSets the default base domain for the frontend rules. For more information, check the \nContainer Labels section's of the user guide \"Let's Encrypt \n Docker\"\n\n\n\n\n\n\ntraefik.enable=false\n\n\nDisables this container in Traefik.\n\n\n\n\n\n\ntraefik.port=80\n\n\nRegisters this port. Useful when the container exposes multiples ports.\n\n\n\n\n\n\ntraefik.tags=foo,bar,myTag\n\n\nAdds Traefik tags to the Docker container/service to be used in \nconstraints\n.\n\n\n\n\n\n\ntraefik.protocol=https\n\n\nOverrides the default \nhttp\n protocol\n\n\n\n\n\n\ntraefik.weight=10\n\n\nAssigns this weight to the container\n\n\n\n\n\n\ntraefik.backend=foo\n\n\nOverrides the container name by \nfoo\n in the generated name of the backend.\n\n\n\n\n\n\ntraefik.backend.buffering.maxRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.maxResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.retryExpression=EXPR\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.circuitbreaker.expression=EXPR\n\n\nCreates a \ncircuit breaker\n to be used against the backend\n\n\n\n\n\n\ntraefik.backend.responseForwarding.flushInterval=10ms\n\n\nDefines the interval between two flushes when forwarding response from backend to client.\n\n\n\n\n\n\ntraefik.backend.healthcheck.path=/health\n\n\nEnables health check for the backend, hitting the container at \npath\n.\n\n\n\n\n\n\ntraefik.backend.healthcheck.interval=1s\n\n\nDefines the health check interval.\n\n\n\n\n\n\ntraefik.backend.healthcheck.port=8080\n\n\nSets a different port for the health check.\n\n\n\n\n\n\ntraefik.backend.healthcheck.scheme=http\n\n\nOverrides the server URL scheme.\n\n\n\n\n\n\ntraefik.backend.healthcheck.hostname=foobar.com\n\n\nDefines the health check hostname.\n\n\n\n\n\n\ntraefik.backend.healthcheck.headers=EXPR\n\n\nDefines the health check request headers \nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.backend.loadbalancer.method=drr\n\n\nOverrides the default \nwrr\n load balancer algorithm\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness=true\n\n\nEnables backend sticky sessions\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness.cookieName=NAME\n\n\nSets the cookie name manually for sticky sessions\n\n\n\n\n\n\ntraefik.backend.loadbalancer.sticky=true\n\n\nEnables backend sticky sessions (DEPRECATED)\n\n\n\n\n\n\ntraefik.backend.loadbalancer.swarm=true\n\n\nUses Swarm's inbuilt load balancer (only relevant under Swarm Mode) [3].\n\n\n\n\n\n\ntraefik.backend.maxconn.amount=10\n\n\nSets a maximum number of connections to the backend.\nMust be used in conjunction with the below label to take effect.\n\n\n\n\n\n\ntraefik.backend.maxconn.extractorfunc=client.ip\n\n\nSets the function to be used against the request to determine what to limit maximum connections to the backend by.\nMust be used in conjunction with the above label to take effect.\n\n\n\n\n\n\ntraefik.frontend.auth.basic=EXPR\n\n\nSets the basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n [2] (DEPRECATED).\n\n\n\n\n\n\ntraefik.frontend.auth.basic.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\ntraefik.frontend.auth.basic.users=EXPR\n\n\nSets the basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n [2].\n\n\n\n\n\n\ntraefik.frontend.auth.basic.usersFile=/path/.htpasswd\n\n\nSets the basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.users=EXPR\n\n\nSets the digest authentication to this frontend in CSV format: \nUser:Realm:Hash,User:Realm:Hash\n.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.usersFile=/path/.htdigest\n\n\nSets the digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.address=https://example.com\n\n\nSets the URL of the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.authResponseHeaders=EXPR\n\n\nSets the forward authentication authResponseHeaders in CSV format: \nX-Auth-User,X-Auth-Header\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.ca=/path/ca.pem\n\n\nSets the Certificate Authority (CA) for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.caOptional=true\n\n\nChecks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.cert=/path/server.pem\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.insecureSkipVerify=true\n\n\nIf set to true invalid SSL certificates are accepted.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.key=/path/server.key\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.trustForwardHeader=true\n\n\nTrusts X-Forwarded-* headers.\n\n\n\n\n\n\ntraefik.frontend.auth.headerField=X-WebAuth-User\n\n\nSets the header user to pass the authenticated user to the application.\n\n\n\n\n\n\ntraefik.frontend.entryPoints=http,https\n\n\nAssigns this frontend to entry points \nhttp\n and \nhttps\n.\nOverrides \ndefaultEntryPoints\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.backend=NAME\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.query=PATH\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.status=RANGE\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.passHostHeader=true\n\n\nForwards client \nHost\n header to the backend.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.commonName=true\n\n\nAdd the issuer.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.country=true\n\n\nAdd the issuer.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.domainComponent=true\n\n\nAdd the issuer.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.locality=true\n\n\nAdd the issuer.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.organization=true\n\n\nAdd the issuer.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.province=true\n\n\nAdd the issuer.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.serialNumber=true\n\n\nAdd the issuer.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.notAfter=true\n\n\nAdd the noAfter field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.notBefore=true\n\n\nAdd the noBefore field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.sans=true\n\n\nAdd the sans field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.commonName=true\n\n\nAdd the subject.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.country=true\n\n\nAdd the subject.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.domainComponent=true\n\n\nAdd the subject.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.locality=true\n\n\nAdd the subject.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.organization=true\n\n\nAdd the subject.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.province=true\n\n\nAdd the subject.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.serialNumber=true\n\n\nAdd the subject.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.pem=true\n\n\nPass the escaped pem in the \nX-Forwarded-Ssl-Client-Cert\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSCert=true\n\n\nForwards TLS Client certificates to the backend (DEPRECATED).\n\n\n\n\n\n\ntraefik.frontend.priority=10\n\n\nOverrides default frontend priority\n\n\n\n\n\n\ntraefik.frontend.rateLimit.extractorFunc=EXP\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.period=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.average=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.burst=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.redirect.entryPoint=https\n\n\nEnables Redirect to another entryPoint to this frontend (e.g. HTTPS)\n\n\n\n\n\n\ntraefik.frontend.redirect.regex=^http://localhost/(.*)\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.replacement\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.replacement=http://mydomain/$1\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.regex\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.permanent=true\n\n\nReturns 301 instead of 302.\n\n\n\n\n\n\ntraefik.frontend.rule=EXPR\n\n\nOverrides the default frontend rule. Default: \nHost:{containerName}.{domain}\n or \nHost:{service}.{project_name}.{domain}\n if you are using \ndocker-compose\n.\n\n\n\n\n\n\ntraefik.frontend.whiteList.sourceRange=RANGE\n\n\nSets a list of IP-Ranges which are allowed to access.\nAn unset or empty list allows all Source-IPs to access.\nIf one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.\n\n\n\n\n\n\ntraefik.frontend.whiteList.useXForwardedFor=true\n\n\nUses \nX-Forwarded-For\n header as valid source of IP for the white list.\n\n\n\n\n\n\n\n\n[1] \ntraefik.docker.network\n:\n\nIf a container is linked to several networks, be sure to set the proper network name (you can check with \ndocker inspect \ncontainer_id\n) otherwise it will randomly pick one (depending on how docker is returning them).\n\nFor instance when deploying docker \nstack\n from compose files, the compose defined networks will be prefixed with the \nstack\n name.\nOr if your service references external network use it's name instead.\n\n\n[2] \ntraefik.frontend.auth.basic.users=EXPR\n:\n\nTo create \nuser:password\n pair, it's possible to use this command:\n\n\necho $(htpasswd -nb user password) | sed -e s/\\\\$/\\\\$\\\\$/g\n.\n\nThe result will be \nuser:$$apr1$$9Cv/OMGj$$ZomWQzuQbL.3TRCS81A1g/\n, note additional symbol \n$\n makes escaping.\n\n\n[3] \ntraefik.backend.loadbalancer.swarm\n:\n\nIf you enable this option, Traefik will use the virtual IP provided by docker swarm instead of the containers IPs.\nWhich means that Traefik will not perform any kind of load balancing and will delegate this task to swarm.\n\nIt also means that Traefik will manipulate only one backend, not one backend per container.\n\n\nCustom Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.customRequestHeaders=EXPR\n\n\nProvides the container with custom request headers that will be appended to each request forwarded to the container.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.customResponseHeaders=EXPR\n\n\nAppends the headers to each response returned by the container, before forwarding the response to the client.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.allowedHosts=EXPR\n\n\nProvides a list of allowed hosts that requests will be processed.\nFormat: \nHost1,Host2\n\n\n\n\n\n\ntraefik.frontend.headers.browserXSSFilter=true\n\n\nAdds the X-XSS-Protection header with the value \n1; mode=block\n.\n\n\n\n\n\n\ntraefik.frontend.headers.contentSecurityPolicy=VALUE\n\n\nAdds CSP Header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.contentTypeNosniff=true\n\n\nAdds the \nX-Content-Type-Options\n header with the value \nnosniff\n.\n\n\n\n\n\n\ntraefik.frontend.headers.customBrowserXSSValue=VALUE\n\n\nSet custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.\n\n\n\n\n\n\ntraefik.frontend.headers.customFrameOptionsValue=VALUE\n\n\nOverrides the \nX-Frame-Options\n header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.forceSTSHeader=false\n\n\nAdds the STS  header to non-SSL requests.\n\n\n\n\n\n\ntraefik.frontend.headers.frameDeny=false\n\n\nAdds the \nX-Frame-Options\n header with the value of \nDENY\n.\n\n\n\n\n\n\ntraefik.frontend.headers.hostsProxyHeaders=EXPR\n\n\nProvides a list of headers that the proxied hostname may be stored.\nFormat: \nHEADER1,HEADER2\n\n\n\n\n\n\ntraefik.frontend.headers.isDevelopment=false\n\n\nThis will cause the \nAllowedHosts\n, \nSSLRedirect\n, and \nSTSSeconds\n/\nSTSIncludeSubdomains\n options to be ignored during development.\nWhen deploying to production, be sure to set this to false.\n\n\n\n\n\n\ntraefik.frontend.headers.publicKey=VALUE\n\n\nAdds HPKP header.\n\n\n\n\n\n\ntraefik.frontend.headers.referrerPolicy=VALUE\n\n\nAdds referrer policy  header.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLTemporaryRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLHost=HOST\n\n\nThis setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLForceHost=true\n\n\nIf \nSSLForceHost\n is \ntrue\n and \nSSLHost\n is set, requests will be forced to use \nSSLHost\n even the ones that are already using SSL. Default is false.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLProxyHeaders=EXPR\n\n\nHeader combinations that would signify a proper SSL Request (Such as \nX-Forwarded-For:https\n).\nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.STSSeconds=315360000\n\n\nSets the max-age of the STS header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSIncludeSubdomains=true\n\n\nAdds the \nIncludeSubdomains\n section of the STS  header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSPreload=true\n\n\nAdds the preload flag to the STS  header.\n\n\n\n\n\n\n\n\nOn containers with Multiple Ports (segment labels)\n\n\nSegment labels are used to define routes to a container exposing multiple ports.\nA segment is a group of labels that apply to a port exposed by a container.\nYou can define as many segments as ports exposed in a container.\n\n\nSegment labels override the default behavior.\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.backend=BACKEND\n\n\nSame as \ntraefik.backend\n\n\n\n\n\n\ntraefik.\nsegment_name\n.domain=DOMAIN\n\n\nSame as \ntraefik.domain\n\n\n\n\n\n\ntraefik.\nsegment_name\n.port=PORT\n\n\nSame as \ntraefik.port\n\n\n\n\n\n\ntraefik.\nsegment_name\n.protocol=http\n\n\nSame as \ntraefik.protocol\n\n\n\n\n\n\ntraefik.\nsegment_name\n.weight=10\n\n\nSame as \ntraefik.weight\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic=EXPR\n\n\nSame as \ntraefik.frontend.auth.basic\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.basic.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.users=EXPR\n\n\nSame as \ntraefik.frontend.auth.basic.users\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.usersFile=/path/.htpasswd\n\n\nSame as \ntraefik.frontend.auth.basic.usersFile\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.digest.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.users=EXPR\n\n\nSame as \ntraefik.frontend.auth.digest.users\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.usersFile=/path/.htdigest\n\n\nSame as \ntraefik.frontend.auth.digest.usersFile\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.address=https://example.com\n\n\nSame as \ntraefik.frontend.auth.forward.address\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.authResponseHeaders=EXPR\n\n\nSame as \ntraefik.frontend.auth.forward.authResponseHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.ca=/path/ca.pem\n\n\nSame as \ntraefik.frontend.auth.forward.tls.ca\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.caOptional=true\n\n\nSame as \ntraefik.frontend.auth.forward.tls.caOptional\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.cert=/path/server.pem\n\n\nSame as \ntraefik.frontend.auth.forward.tls.cert\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.insecureSkipVerify=true\n\n\nSame as \ntraefik.frontend.auth.forward.tls.insecureSkipVerify\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.key=/path/server.key\n\n\nSame as \ntraefik.frontend.auth.forward.tls.key\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.trustForwardHeader=true\n\n\nSame as \ntraefik.frontend.auth.forward.trustForwardHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.headerField=X-WebAuth-User\n\n\nSame as \ntraefik.frontend.auth.headerField\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.entryPoints=https\n\n\nSame as \ntraefik.frontend.entryPoints\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.backend=NAME\n\n\nSame as \ntraefik.frontend.errors.\nname\n.backend\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.query=PATH\n\n\nSame as \ntraefik.frontend.errors.\nname\n.query\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.status=RANGE\n\n\nSame as \ntraefik.frontend.errors.\nname\n.status\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passHostHeader=true\n\n\nSame as \ntraefik.frontend.passHostHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.commonName=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.commonName\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.country=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.country\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.domainComponent=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.domainComponent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.locality=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.locality\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.organization=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.organization\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.province=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.province\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.serialNumber=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.serialNumber\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.notAfter=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.notAfter\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.notBefore=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.notBefore\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.sans=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.sans\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.commonName=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.commonName\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.country=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.country\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.domainComponent=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.domainComponent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.locality=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.locality\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.organization=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.organization\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.province=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.province\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.serialNumber=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.serialNumber\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.pem=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.pem\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSCert=true\n\n\nSame as \ntraefik.frontend.passTLSCert\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.priority=10\n\n\nSame as \ntraefik.frontend.priority\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.extractorFunc=EXP\n\n\nSame as \ntraefik.frontend.rateLimit.extractorFunc\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.period=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.period\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.average=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.average\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.burst=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.burst\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.entryPoint=https\n\n\nSame as \ntraefik.frontend.redirect.entryPoint\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.regex=^http://localhost/(.*)\n\n\nSame as \ntraefik.frontend.redirect.regex\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.replacement=http://mydomain/$1\n\n\nSame as \ntraefik.frontend.redirect.replacement\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.permanent=true\n\n\nSame as \ntraefik.frontend.redirect.permanent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rule=EXP\n\n\nSame as \ntraefik.frontend.rule\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.whiteList.sourceRange=RANGE\n\n\nSame as \ntraefik.frontend.whiteList.sourceRange\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.whiteList.useXForwardedFor=true\n\n\nSame as \ntraefik.frontend.whiteList.useXForwardedFor\n\n\n\n\n\n\n\n\nCustom Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customRequestHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.customRequestHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customResponseHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.customResponseHeaders\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.allowedHosts=EXPR\n\n\nSame as \ntraefik.frontend.headers.allowedHosts\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.browserXSSFilter=true\n\n\nSame as \ntraefik.frontend.headers.browserXSSFilter\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.contentSecurityPolicy=VALUE\n\n\nSame as \ntraefik.frontend.headers.contentSecurityPolicy\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.contentTypeNosniff=true\n\n\nSame as \ntraefik.frontend.headers.contentTypeNosniff\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customBrowserXSSValue=VALUE\n\n\nSame as \ntraefik.frontend.headers.customBrowserXSSValue\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customFrameOptionsValue=VALUE\n\n\nSame as \ntraefik.frontend.headers.customFrameOptionsValue\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.forceSTSHeader=false\n\n\nSame as \ntraefik.frontend.headers.forceSTSHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.frameDeny=false\n\n\nSame as \ntraefik.frontend.headers.frameDeny\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.hostsProxyHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.hostsProxyHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.isDevelopment=false\n\n\nSame as \ntraefik.frontend.headers.isDevelopment\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.publicKey=VALUE\n\n\nSame as \ntraefik.frontend.headers.publicKey\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.referrerPolicy=VALUE\n\n\nSame as \ntraefik.frontend.headers.referrerPolicy\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLRedirect=true\n\n\nSame as \ntraefik.frontend.headers.SSLRedirect\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLTemporaryRedirect=true\n\n\nSame as \ntraefik.frontend.headers.SSLTemporaryRedirect\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLHost=HOST\n\n\nSame as \ntraefik.frontend.headers.SSLHost\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLForceHost=true\n\n\nSame as \ntraefik.frontend.headers.SSLForceHost\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLProxyHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.SSLProxyHeaders=EXPR\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSSeconds=315360000\n\n\nSame as \ntraefik.frontend.headers.STSSeconds=315360000\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSIncludeSubdomains=true\n\n\nSame as \ntraefik.frontend.headers.STSIncludeSubdomains=true\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSPreload=true\n\n\nSame as \ntraefik.frontend.headers.STSPreload=true\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nIf a label is defined both as a \ncontainer label\n and a \nsegment label\n (for example \ntraefik.\nsegment_name\n.port=PORT\n and \ntraefik.port=PORT\n ), the \nsegment label\n is used to defined the \nsegment_name\n property (\nport\n in the example).\n\n\nIt's possible to mix \ncontainer labels\n and \nsegment labels\n, in this case \ncontainer labels\n are used as default value for missing \nsegment labels\n but no frontends are going to be created with the \ncontainer labels\n.\n\n\nMore details in this \nexample\n.\n\n\n\n\n\n\nWarning\n\n\nWhen running inside a container, Traefik will need network access through:\n\n\ndocker network connect \nnetwork\n \ntraefik-container\n\n\n\n\nusebindportip\n\n\nThe default behavior of Traefik is to route requests to the IP/Port of the matching container.\nWhen setting \nusebindportip\n to true, you tell Traefik to use the IP/Port attached to the container's binding instead of the inner network IP/Port.\n\n\nWhen used in conjunction with the \ntraefik.port\n label (that tells Traefik to route requests to a specific port), Traefik tries to find a binding with \ntraefik.port\n port to select the container. If it can't find such a binding, Traefik falls back on the internal network IP of the container, but still uses the \ntraefik.port\n that is set in the label.\n\n\nBelow is a recap of the behavior of \nusebindportip\n in different situations.\n\n\n\n\n\n\n\n\ntraefik.port label\n\n\nContainer's binding\n\n\nRoutes to\n\n\n\n\n\n\n\n\n\n\n-\n\n\n-\n\n\nIntIP:IntPort\n\n\n\n\n\n\n-\n\n\nExtPort:IntPort\n\n\nIntIP:IntPort\n\n\n\n\n\n\n-\n\n\nExtIp:ExtPort:IntPort\n\n\nExtIp:ExtPort\n\n\n\n\n\n\nLblPort\n\n\n-\n\n\nIntIp:LblPort\n\n\n\n\n\n\nLblPort\n\n\nExtIp:ExtPort:LblPort\n\n\nExtIp:ExtPort\n\n\n\n\n\n\nLblPort\n\n\nExtIp:ExtPort:OtherPort\n\n\nIntIp:LblPort\n\n\n\n\n\n\nLblPort\n\n\nExtIp1:ExtPort1:IntPort1 \n ExtIp2:LblPort:IntPort2\n\n\nExtIp2:LblPort\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nIn the above table, ExtIp stands for \"external IP found in the binding\", IntIp stands for \"internal network container's IP\", ExtPort stands for \"external Port found in the binding\", and IntPort stands for \"internal network container's port.\"", 
            "title": "Docker"
        }, 
        {
            "location": "/configuration/backends/docker/#docker-provider", 
            "text": "Traefik can be configured to use Docker as a provider.", 
            "title": "Docker Provider"
        }, 
        {
            "location": "/configuration/backends/docker/#docker", 
            "text": "################################################################\n# Docker Provider\n################################################################\n\n# Enable Docker Provider.\n[docker]\n\n# Docker server endpoint. Can be a tcp or a unix socket endpoint.\n#\n# Required\n#\nendpoint =  unix:///var/run/docker.sock \n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the  traefik.domain  label on a container.\n#\n# Optional\n#\ndomain =  docker.localhost \n\n# Enable watch docker changes.\n#\n# Optional\n#\nwatch = true\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename =  docker.tmpl \n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# -  1 : previous template version (must be used only with older custom templates, see  filename )\n# -  2 : current template version (must be used to force template version when  filename  is used)\n#\n# templateVersion = 2\n\n# Expose containers by default in Traefik.\n# If set to false, containers that don't have `traefik.enable=true` will be ignored.\n#\n# Optional\n# Default: true\n#\nexposedByDefault = true\n\n# Use the IP address from the binded port instead of the inner network one.\n#\n# In case no IP address is attached to the binded port (or in case \n# there is no bind), the inner network one will be used as a fallback.     \n#\n# Optional\n# Default: false\n#\nusebindportip = true\n\n# Use Swarm Mode services as data provider.\n#\n# Optional\n# Default: false\n#\nswarmMode = false\n\n# Polling interval (in seconds) for Swarm Mode.\n#\n# Optional\n# Default: 15\n#\nswarmModeRefreshSeconds = 15\n\n# Define a default docker network to use for connections to all containers.\n# Can be overridden by the traefik.docker.network label.\n#\n# Optional\n#\nnetwork =  web \n\n# Enable docker TLS connection.\n#\n# Optional\n#\n#  [docker.tls]\n#  ca =  /etc/ssl/ca.crt \n#  cert =  /etc/ssl/docker.crt \n#  key =  /etc/ssl/docker.key \n#  insecureSkipVerify = true  To enable constraints see  provider-specific constraints section .", 
            "title": "Docker"
        }, 
        {
            "location": "/configuration/backends/docker/#docker-swarm-mode", 
            "text": "################################################################\n# Docker Swarm Mode Provider\n################################################################\n\n# Enable Docker Provider.\n[docker]\n\n# Docker server endpoint.\n# Can be a tcp or a unix socket endpoint.\n#\n# Required\n# Default:  unix:///var/run/docker.sock \n#\n# swarm classic (1.12-)\n# endpoint =  tcp://127.0.0.1:2375 \n# docker swarm mode (1.12+)\nendpoint =  tcp://127.0.0.1:2377 \n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the  traefik.domain  label on a services.\n#\n# Optional\n# Default:  \n#\ndomain =  docker.localhost \n\n# Enable watch docker changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Use Docker Swarm Mode as data provider.\n#\n# Optional\n# Default: false\n#\nswarmMode = true\n\n# Define a default docker network to use for connections to all containers.\n# Can be overridden by the traefik.docker.network label.\n#\n# Optional\n#\nnetwork =  web \n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename =  docker.tmpl \n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# -  1 : previous template version (must be used only with older custom templates, see  filename )\n# -  2 : current template version (must be used to force template version when  filename  is used)\n#\n# templateVersion = 2\n\n# Expose services by default in Traefik.\n#\n# Optional\n# Default: true\n#\nexposedByDefault = false\n\n# Enable docker TLS connection.\n#\n# Optional\n#\n#  [docker.tls]\n#  ca =  /etc/ssl/ca.crt \n#  cert =  /etc/ssl/docker.crt \n#  key =  /etc/ssl/docker.key \n#  insecureSkipVerify = true  To enable constraints see  provider-specific constraints section .", 
            "title": "Docker Swarm Mode"
        }, 
        {
            "location": "/configuration/backends/docker/#security-considerations", 
            "text": "", 
            "title": "Security Considerations"
        }, 
        {
            "location": "/configuration/backends/docker/#security-challenge-with-the-docker-socket", 
            "text": "Traefik requires access to the docker socket to get its dynamic configuration,\nby watching the Docker API through this socket.   Important  Depending on your context and your usage, accessing the Docker API without any restriction might be a security concern.   As explained on the Docker documentation: ( Docker Daemon Attack Surface page ):  [...] only **trusted** users should be allowed to control your Docker daemon [...]  If the Traefik processes (handling requests from the outside world) is attacked,\nthen the attacker can access the Docker (or Swarm Mode) backend.  Also, when using Swarm Mode, it is mandatory to schedule Traefik's containers on the Swarm manager nodes,\nto let Traefik accessing the Docker Socket of the Swarm manager node.  More information about Docker's security:   KubeCon EU 2018 Keynote, Running with Scissors, from Liz Rice  Don't expose the Docker socket (not even to a container)  A thread on Stack Overflow about sharing the  /var/run/docker.sock  file  To Dind or not to DinD", 
            "title": "Security Challenge with the Docker Socket"
        }, 
        {
            "location": "/configuration/backends/docker/#workarounds", 
            "text": "Improved Security  TraefikEE  solves this problem by separating the control plane (connected to Docker) and the data plane (handling the requests).   Another possible workaround is to expose the Docker socket over TCP, instead of the default Unix socket file.\nIt allows different implementation levels of the  AAA (Authentication, Authorization, Accounting) concepts , depending on your security assessment:    Authentication with Client Certificates as described in  the \"Protect the Docker daemon socket\" page of Docker's documentation    Authorization with the  Docker Authorization Plugin Mechanism    Accounting at networking level, by exposing the socket only inside a Docker private network, only available for Traefik.    Accounting at container level, by exposing the socket on a another container than Traefik's.\n  With Swarm mode, it allows scheduling of Traefik on worker nodes, with only the \"socket exposer\" container on the manager nodes.    Accounting at kernel level, by enforcing kernel calls with mechanisms like  SELinux ,\n  to only allows an identified set of actions for Traefik's process (or the \"socket exposer\" process).    Use the following ressources to get started:   Traefik issue GH-4174 about security with Docker socket  Inspecting Docker Activity with Socat  Letting Traefik run on Worker Nodes  Docker Socket Proxy from Tecnativa", 
            "title": "Workarounds"
        }, 
        {
            "location": "/configuration/backends/docker/#labels-overriding-default-behavior", 
            "text": "", 
            "title": "Labels: overriding default behavior"
        }, 
        {
            "location": "/configuration/backends/docker/#using-docker-with-swarm-mode", 
            "text": "If you use a compose file with the Swarm mode, labels should be defined in the  deploy  part of your service.\nThis behavior is only enabled for docker-compose version 3+ ( Compose file reference ).  version:  3 \nservices:\n  whoami:\n    deploy:\n      labels:\n        traefik.docker.network: traefik  Required labels:   traefik.frontend.rule  traefik.port  - Without this the debug logs will show this service is deliberately filtered out.  traefik.docker.network  - Without this a 504 may occur.", 
            "title": "Using Docker with Swarm Mode"
        }, 
        {
            "location": "/configuration/backends/docker/#troubleshooting", 
            "text": "If service doesn't show up in the dashboard, check the debug logs to see if the port is missing: Filtering container without port,  SERVICE_NAME : port label is missing, ...')  If  504 Gateway Timeout  occurs and there are networks used, ensure that  traefik.docker.network  is defined. \nThe complete name is required, meaning if the network is internal the name needs to be  project_name _ network_name .", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/configuration/backends/docker/#using-docker-compose", 
            "text": "If you are intending to use only Docker Compose commands (e.g.  docker-compose up --scale whoami=2 -d ), labels should be under your service, otherwise they will be ignored.  version:  3 \nservices:\n  whoami:\n    labels:\n      traefik.docker.network: traefik", 
            "title": "Using Docker Compose"
        }, 
        {
            "location": "/configuration/backends/docker/#on-containers", 
            "text": "Labels can be used on containers to override default behavior.     Label  Description      traefik.docker.network  Overrides the default docker network to use for connections to the container. [1]    traefik.domain  Sets the default base domain for the frontend rules. For more information, check the  Container Labels section's of the user guide \"Let's Encrypt   Docker\"    traefik.enable=false  Disables this container in Traefik.    traefik.port=80  Registers this port. Useful when the container exposes multiples ports.    traefik.tags=foo,bar,myTag  Adds Traefik tags to the Docker container/service to be used in  constraints .    traefik.protocol=https  Overrides the default  http  protocol    traefik.weight=10  Assigns this weight to the container    traefik.backend=foo  Overrides the container name by  foo  in the generated name of the backend.    traefik.backend.buffering.maxRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.maxResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.retryExpression=EXPR  See  buffering  section.    traefik.backend.circuitbreaker.expression=EXPR  Creates a  circuit breaker  to be used against the backend    traefik.backend.responseForwarding.flushInterval=10ms  Defines the interval between two flushes when forwarding response from backend to client.    traefik.backend.healthcheck.path=/health  Enables health check for the backend, hitting the container at  path .    traefik.backend.healthcheck.interval=1s  Defines the health check interval.    traefik.backend.healthcheck.port=8080  Sets a different port for the health check.    traefik.backend.healthcheck.scheme=http  Overrides the server URL scheme.    traefik.backend.healthcheck.hostname=foobar.com  Defines the health check hostname.    traefik.backend.healthcheck.headers=EXPR  Defines the health check request headers  Format:   HEADER:value HEADER2:value2    traefik.backend.loadbalancer.method=drr  Overrides the default  wrr  load balancer algorithm    traefik.backend.loadbalancer.stickiness=true  Enables backend sticky sessions    traefik.backend.loadbalancer.stickiness.cookieName=NAME  Sets the cookie name manually for sticky sessions    traefik.backend.loadbalancer.sticky=true  Enables backend sticky sessions (DEPRECATED)    traefik.backend.loadbalancer.swarm=true  Uses Swarm's inbuilt load balancer (only relevant under Swarm Mode) [3].    traefik.backend.maxconn.amount=10  Sets a maximum number of connections to the backend. Must be used in conjunction with the below label to take effect.    traefik.backend.maxconn.extractorfunc=client.ip  Sets the function to be used against the request to determine what to limit maximum connections to the backend by. Must be used in conjunction with the above label to take effect.    traefik.frontend.auth.basic=EXPR  Sets the basic authentication to this frontend in CSV format:  User:Hash,User:Hash  [2] (DEPRECATED).    traefik.frontend.auth.basic.removeHeader=true  If set to  true , removes the  Authorization  header.    traefik.frontend.auth.basic.users=EXPR  Sets the basic authentication to this frontend in CSV format:  User:Hash,User:Hash  [2].    traefik.frontend.auth.basic.usersFile=/path/.htpasswd  Sets the basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    traefik.frontend.auth.digest.removeHeader=true  If set to  true , removes the  Authorization  header.    traefik.frontend.auth.digest.users=EXPR  Sets the digest authentication to this frontend in CSV format:  User:Realm:Hash,User:Realm:Hash .    traefik.frontend.auth.digest.usersFile=/path/.htdigest  Sets the digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    traefik.frontend.auth.forward.address=https://example.com  Sets the URL of the authentication server.    traefik.frontend.auth.forward.authResponseHeaders=EXPR  Sets the forward authentication authResponseHeaders in CSV format:  X-Auth-User,X-Auth-Header    traefik.frontend.auth.forward.tls.ca=/path/ca.pem  Sets the Certificate Authority (CA) for the TLS connection with the authentication server.    traefik.frontend.auth.forward.tls.caOptional=true  Checks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).    traefik.frontend.auth.forward.tls.cert=/path/server.pem  Sets the Certificate for the TLS connection with the authentication server.    traefik.frontend.auth.forward.tls.insecureSkipVerify=true  If set to true invalid SSL certificates are accepted.    traefik.frontend.auth.forward.tls.key=/path/server.key  Sets the Certificate for the TLS connection with the authentication server.    traefik.frontend.auth.forward.trustForwardHeader=true  Trusts X-Forwarded-* headers.    traefik.frontend.auth.headerField=X-WebAuth-User  Sets the header user to pass the authenticated user to the application.    traefik.frontend.entryPoints=http,https  Assigns this frontend to entry points  http  and  https . Overrides  defaultEntryPoints    traefik.frontend.errors. name .backend=NAME  See  custom error pages  section.    traefik.frontend.errors. name .query=PATH  See  custom error pages  section.    traefik.frontend.errors. name .status=RANGE  See  custom error pages  section.    traefik.frontend.passHostHeader=true  Forwards client  Host  header to the backend.    traefik.frontend.passTLSClientCert.infos.issuer.commonName=true  Add the issuer.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.country=true  Add the issuer.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.domainComponent=true  Add the issuer.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.locality=true  Add the issuer.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.organization=true  Add the issuer.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.province=true  Add the issuer.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.serialNumber=true  Add the issuer.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.notAfter=true  Add the noAfter field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.notBefore=true  Add the noBefore field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.sans=true  Add the sans field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.commonName=true  Add the subject.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.country=true  Add the subject.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.domainComponent=true  Add the subject.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.locality=true  Add the subject.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.organization=true  Add the subject.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.province=true  Add the subject.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.serialNumber=true  Add the subject.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.pem=true  Pass the escaped pem in the  X-Forwarded-Ssl-Client-Cert  header.    traefik.frontend.passTLSCert=true  Forwards TLS Client certificates to the backend (DEPRECATED).    traefik.frontend.priority=10  Overrides default frontend priority    traefik.frontend.rateLimit.extractorFunc=EXP  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .period=6  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .average=6  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .burst=6  See  rate limiting  section.    traefik.frontend.redirect.entryPoint=https  Enables Redirect to another entryPoint to this frontend (e.g. HTTPS)    traefik.frontend.redirect.regex=^http://localhost/(.*)  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.replacement .    traefik.frontend.redirect.replacement=http://mydomain/$1  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.regex .    traefik.frontend.redirect.permanent=true  Returns 301 instead of 302.    traefik.frontend.rule=EXPR  Overrides the default frontend rule. Default:  Host:{containerName}.{domain}  or  Host:{service}.{project_name}.{domain}  if you are using  docker-compose .    traefik.frontend.whiteList.sourceRange=RANGE  Sets a list of IP-Ranges which are allowed to access. An unset or empty list allows all Source-IPs to access. If one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.    traefik.frontend.whiteList.useXForwardedFor=true  Uses  X-Forwarded-For  header as valid source of IP for the white list.     [1]  traefik.docker.network : \nIf a container is linked to several networks, be sure to set the proper network name (you can check with  docker inspect  container_id ) otherwise it will randomly pick one (depending on how docker is returning them). \nFor instance when deploying docker  stack  from compose files, the compose defined networks will be prefixed with the  stack  name.\nOr if your service references external network use it's name instead.  [2]  traefik.frontend.auth.basic.users=EXPR : \nTo create  user:password  pair, it's possible to use this command:  echo $(htpasswd -nb user password) | sed -e s/\\\\$/\\\\$\\\\$/g . \nThe result will be  user:$$apr1$$9Cv/OMGj$$ZomWQzuQbL.3TRCS81A1g/ , note additional symbol  $  makes escaping.  [3]  traefik.backend.loadbalancer.swarm : \nIf you enable this option, Traefik will use the virtual IP provided by docker swarm instead of the containers IPs.\nWhich means that Traefik will not perform any kind of load balancing and will delegate this task to swarm. \nIt also means that Traefik will manipulate only one backend, not one backend per container.", 
            "title": "On Containers"
        }, 
        {
            "location": "/configuration/backends/docker/#custom-headers", 
            "text": "Label  Description      traefik.frontend.headers.customRequestHeaders=EXPR  Provides the container with custom request headers that will be appended to each request forwarded to the container. Format:  HEADER:value HEADER2:value2    traefik.frontend.headers.customResponseHeaders=EXPR  Appends the headers to each response returned by the container, before forwarding the response to the client. Format:  HEADER:value HEADER2:value2", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/docker/#security-headers", 
            "text": "Label  Description      traefik.frontend.headers.allowedHosts=EXPR  Provides a list of allowed hosts that requests will be processed. Format:  Host1,Host2    traefik.frontend.headers.browserXSSFilter=true  Adds the X-XSS-Protection header with the value  1; mode=block .    traefik.frontend.headers.contentSecurityPolicy=VALUE  Adds CSP Header with the custom value.    traefik.frontend.headers.contentTypeNosniff=true  Adds the  X-Content-Type-Options  header with the value  nosniff .    traefik.frontend.headers.customBrowserXSSValue=VALUE  Set custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.    traefik.frontend.headers.customFrameOptionsValue=VALUE  Overrides the  X-Frame-Options  header with the custom value.    traefik.frontend.headers.forceSTSHeader=false  Adds the STS  header to non-SSL requests.    traefik.frontend.headers.frameDeny=false  Adds the  X-Frame-Options  header with the value of  DENY .    traefik.frontend.headers.hostsProxyHeaders=EXPR  Provides a list of headers that the proxied hostname may be stored. Format:  HEADER1,HEADER2    traefik.frontend.headers.isDevelopment=false  This will cause the  AllowedHosts ,  SSLRedirect , and  STSSeconds / STSIncludeSubdomains  options to be ignored during development. When deploying to production, be sure to set this to false.    traefik.frontend.headers.publicKey=VALUE  Adds HPKP header.    traefik.frontend.headers.referrerPolicy=VALUE  Adds referrer policy  header.    traefik.frontend.headers.SSLRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent.    traefik.frontend.headers.SSLTemporaryRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.    traefik.frontend.headers.SSLHost=HOST  This setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.    traefik.frontend.headers.SSLForceHost=true  If  SSLForceHost  is  true  and  SSLHost  is set, requests will be forced to use  SSLHost  even the ones that are already using SSL. Default is false.    traefik.frontend.headers.SSLProxyHeaders=EXPR  Header combinations that would signify a proper SSL Request (Such as  X-Forwarded-For:https ). Format:   HEADER:value HEADER2:value2    traefik.frontend.headers.STSSeconds=315360000  Sets the max-age of the STS header.    traefik.frontend.headers.STSIncludeSubdomains=true  Adds the  IncludeSubdomains  section of the STS  header.    traefik.frontend.headers.STSPreload=true  Adds the preload flag to the STS  header.", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/docker/#on-containers-with-multiple-ports-segment-labels", 
            "text": "Segment labels are used to define routes to a container exposing multiple ports.\nA segment is a group of labels that apply to a port exposed by a container.\nYou can define as many segments as ports exposed in a container.  Segment labels override the default behavior.     Label  Description      traefik. segment_name .backend=BACKEND  Same as  traefik.backend    traefik. segment_name .domain=DOMAIN  Same as  traefik.domain    traefik. segment_name .port=PORT  Same as  traefik.port    traefik. segment_name .protocol=http  Same as  traefik.protocol    traefik. segment_name .weight=10  Same as  traefik.weight    traefik. segment_name .frontend.auth.basic=EXPR  Same as  traefik.frontend.auth.basic    traefik. segment_name .frontend.auth.basic.removeHeader=true  Same as  traefik.frontend.auth.basic.removeHeader    traefik. segment_name .frontend.auth.basic.users=EXPR  Same as  traefik.frontend.auth.basic.users    traefik. segment_name .frontend.auth.basic.usersFile=/path/.htpasswd  Same as  traefik.frontend.auth.basic.usersFile    traefik. segment_name .frontend.auth.digest.removeHeader=true  Same as  traefik.frontend.auth.digest.removeHeader    traefik. segment_name .frontend.auth.digest.users=EXPR  Same as  traefik.frontend.auth.digest.users    traefik. segment_name .frontend.auth.digest.usersFile=/path/.htdigest  Same as  traefik.frontend.auth.digest.usersFile    traefik. segment_name .frontend.auth.forward.address=https://example.com  Same as  traefik.frontend.auth.forward.address    traefik. segment_name .frontend.auth.forward.authResponseHeaders=EXPR  Same as  traefik.frontend.auth.forward.authResponseHeaders    traefik. segment_name .frontend.auth.forward.tls.ca=/path/ca.pem  Same as  traefik.frontend.auth.forward.tls.ca    traefik. segment_name .frontend.auth.forward.tls.caOptional=true  Same as  traefik.frontend.auth.forward.tls.caOptional    traefik. segment_name .frontend.auth.forward.tls.cert=/path/server.pem  Same as  traefik.frontend.auth.forward.tls.cert    traefik. segment_name .frontend.auth.forward.tls.insecureSkipVerify=true  Same as  traefik.frontend.auth.forward.tls.insecureSkipVerify    traefik. segment_name .frontend.auth.forward.tls.key=/path/server.key  Same as  traefik.frontend.auth.forward.tls.key    traefik. segment_name .frontend.auth.forward.trustForwardHeader=true  Same as  traefik.frontend.auth.forward.trustForwardHeader    traefik. segment_name .frontend.auth.headerField=X-WebAuth-User  Same as  traefik.frontend.auth.headerField    traefik. segment_name .frontend.entryPoints=https  Same as  traefik.frontend.entryPoints    traefik. segment_name .frontend.errors. name .backend=NAME  Same as  traefik.frontend.errors. name .backend    traefik. segment_name .frontend.errors. name .query=PATH  Same as  traefik.frontend.errors. name .query    traefik. segment_name .frontend.errors. name .status=RANGE  Same as  traefik.frontend.errors. name .status    traefik. segment_name .frontend.passHostHeader=true  Same as  traefik.frontend.passHostHeader    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.commonName=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.commonName    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.country=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.country    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.domainComponent=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.domainComponent    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.locality=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.locality    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.organization=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.organization    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.province=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.province    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.serialNumber=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.serialNumber    traefik. segment_name .frontend.passTLSClientCert.infos.notAfter=true  Same as  traefik.frontend.passTLSClientCert.infos.notAfter    traefik. segment_name .frontend.passTLSClientCert.infos.notBefore=true  Same as  traefik.frontend.passTLSClientCert.infos.notBefore    traefik. segment_name .frontend.passTLSClientCert.infos.sans=true  Same as  traefik.frontend.passTLSClientCert.infos.sans    traefik. segment_name .frontend.passTLSClientCert.infos.subject.commonName=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.commonName    traefik. segment_name .frontend.passTLSClientCert.infos.subject.country=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.country    traefik. segment_name .frontend.passTLSClientCert.infos.subject.domainComponent=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.domainComponent    traefik. segment_name .frontend.passTLSClientCert.infos.subject.locality=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.locality    traefik. segment_name .frontend.passTLSClientCert.infos.subject.organization=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.organization    traefik. segment_name .frontend.passTLSClientCert.infos.subject.province=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.province    traefik. segment_name .frontend.passTLSClientCert.infos.subject.serialNumber=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.serialNumber    traefik. segment_name .frontend.passTLSClientCert.pem=true  Same as  traefik.frontend.passTLSClientCert.infos.pem    traefik. segment_name .frontend.passTLSCert=true  Same as  traefik.frontend.passTLSCert    traefik. segment_name .frontend.priority=10  Same as  traefik.frontend.priority    traefik. segment_name .frontend.rateLimit.extractorFunc=EXP  Same as  traefik.frontend.rateLimit.extractorFunc    traefik. segment_name .frontend.rateLimit.rateSet. name .period=6  Same as  traefik.frontend.rateLimit.rateSet. name .period    traefik. segment_name .frontend.rateLimit.rateSet. name .average=6  Same as  traefik.frontend.rateLimit.rateSet. name .average    traefik. segment_name .frontend.rateLimit.rateSet. name .burst=6  Same as  traefik.frontend.rateLimit.rateSet. name .burst    traefik. segment_name .frontend.redirect.entryPoint=https  Same as  traefik.frontend.redirect.entryPoint    traefik. segment_name .frontend.redirect.regex=^http://localhost/(.*)  Same as  traefik.frontend.redirect.regex    traefik. segment_name .frontend.redirect.replacement=http://mydomain/$1  Same as  traefik.frontend.redirect.replacement    traefik. segment_name .frontend.redirect.permanent=true  Same as  traefik.frontend.redirect.permanent    traefik. segment_name .frontend.rule=EXP  Same as  traefik.frontend.rule    traefik. segment_name .frontend.whiteList.sourceRange=RANGE  Same as  traefik.frontend.whiteList.sourceRange    traefik. segment_name .frontend.whiteList.useXForwardedFor=true  Same as  traefik.frontend.whiteList.useXForwardedFor", 
            "title": "On containers with Multiple Ports (segment labels)"
        }, 
        {
            "location": "/configuration/backends/docker/#custom-headers_1", 
            "text": "Label  Description      traefik. segment_name .frontend.headers.customRequestHeaders=EXPR  Same as  traefik.frontend.headers.customRequestHeaders    traefik. segment_name .frontend.headers.customResponseHeaders=EXPR  Same as  traefik.frontend.headers.customResponseHeaders", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/docker/#security-headers_1", 
            "text": "Label  Description      traefik. segment_name .frontend.headers.allowedHosts=EXPR  Same as  traefik.frontend.headers.allowedHosts    traefik. segment_name .frontend.headers.browserXSSFilter=true  Same as  traefik.frontend.headers.browserXSSFilter    traefik. segment_name .frontend.headers.contentSecurityPolicy=VALUE  Same as  traefik.frontend.headers.contentSecurityPolicy    traefik. segment_name .frontend.headers.contentTypeNosniff=true  Same as  traefik.frontend.headers.contentTypeNosniff    traefik. segment_name .frontend.headers.customBrowserXSSValue=VALUE  Same as  traefik.frontend.headers.customBrowserXSSValue    traefik. segment_name .frontend.headers.customFrameOptionsValue=VALUE  Same as  traefik.frontend.headers.customFrameOptionsValue    traefik. segment_name .frontend.headers.forceSTSHeader=false  Same as  traefik.frontend.headers.forceSTSHeader    traefik. segment_name .frontend.headers.frameDeny=false  Same as  traefik.frontend.headers.frameDeny    traefik. segment_name .frontend.headers.hostsProxyHeaders=EXPR  Same as  traefik.frontend.headers.hostsProxyHeaders    traefik. segment_name .frontend.headers.isDevelopment=false  Same as  traefik.frontend.headers.isDevelopment    traefik. segment_name .frontend.headers.publicKey=VALUE  Same as  traefik.frontend.headers.publicKey    traefik. segment_name .frontend.headers.referrerPolicy=VALUE  Same as  traefik.frontend.headers.referrerPolicy    traefik. segment_name .frontend.headers.SSLRedirect=true  Same as  traefik.frontend.headers.SSLRedirect    traefik. segment_name .frontend.headers.SSLTemporaryRedirect=true  Same as  traefik.frontend.headers.SSLTemporaryRedirect    traefik. segment_name .frontend.headers.SSLHost=HOST  Same as  traefik.frontend.headers.SSLHost    traefik. segment_name .frontend.headers.SSLForceHost=true  Same as  traefik.frontend.headers.SSLForceHost    traefik. segment_name .frontend.headers.SSLProxyHeaders=EXPR  Same as  traefik.frontend.headers.SSLProxyHeaders=EXPR    traefik. segment_name .frontend.headers.STSSeconds=315360000  Same as  traefik.frontend.headers.STSSeconds=315360000    traefik. segment_name .frontend.headers.STSIncludeSubdomains=true  Same as  traefik.frontend.headers.STSIncludeSubdomains=true    traefik. segment_name .frontend.headers.STSPreload=true  Same as  traefik.frontend.headers.STSPreload=true      Note  If a label is defined both as a  container label  and a  segment label  (for example  traefik. segment_name .port=PORT  and  traefik.port=PORT  ), the  segment label  is used to defined the  segment_name  property ( port  in the example).  It's possible to mix  container labels  and  segment labels , in this case  container labels  are used as default value for missing  segment labels  but no frontends are going to be created with the  container labels .  More details in this  example .    Warning  When running inside a container, Traefik will need network access through:  docker network connect  network   traefik-container", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/docker/#usebindportip", 
            "text": "The default behavior of Traefik is to route requests to the IP/Port of the matching container.\nWhen setting  usebindportip  to true, you tell Traefik to use the IP/Port attached to the container's binding instead of the inner network IP/Port.  When used in conjunction with the  traefik.port  label (that tells Traefik to route requests to a specific port), Traefik tries to find a binding with  traefik.port  port to select the container. If it can't find such a binding, Traefik falls back on the internal network IP of the container, but still uses the  traefik.port  that is set in the label.  Below is a recap of the behavior of  usebindportip  in different situations.     traefik.port label  Container's binding  Routes to      -  -  IntIP:IntPort    -  ExtPort:IntPort  IntIP:IntPort    -  ExtIp:ExtPort:IntPort  ExtIp:ExtPort    LblPort  -  IntIp:LblPort    LblPort  ExtIp:ExtPort:LblPort  ExtIp:ExtPort    LblPort  ExtIp:ExtPort:OtherPort  IntIp:LblPort    LblPort  ExtIp1:ExtPort1:IntPort1   ExtIp2:LblPort:IntPort2  ExtIp2:LblPort      Note  In the above table, ExtIp stands for \"external IP found in the binding\", IntIp stands for \"internal network container's IP\", ExtPort stands for \"external Port found in the binding\", and IntPort stands for \"internal network container's port.\"", 
            "title": "usebindportip"
        }, 
        {
            "location": "/configuration/backends/dynamodb/", 
            "text": "DynamoDB Provider\n\n\nTraefik can be configured to use Amazon DynamoDB as a provider.\n\n\nConfiguration\n\n\n################################################################\n# DynamoDB Provider\n################################################################\n\n# Enable DynamoDB Provider.\n[dynamodb]\n\n# Region to use when connecting to AWS.\n#\n# Required\n#\nregion = \nus-west-1\n\n\n# DyanmoDB Table Name.\n#\n# Optional\n# Default: \ntraefik\n\n#\ntableName = \ntraefik\n\n\n# Enable watch DynamoDB changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Polling interval (in seconds).\n#\n# Optional\n# Default: 15\n#\nrefreshSeconds = 15\n\n# Access Key ID to use when connecting to AWS.\n#\n# Optional\n#\naccessKeyID = \nabc\n\n\n# Secret Access Key to use when connecting to AWS.\n#\n# Optional\n#\nsecretAccessKey = \n123\n\n\n# Endpoint of local dynamodb instance for testing?\n#\n# Optional\n#\nendpoint = \nhttp://localhost:8080\n\n\n\n\n\nTable Items\n\n\nItems in the \ndynamodb\n table must have three attributes:\n\n\n\n\nid\n (string): The id is the primary key.\n\n\nname\n(string): The name is used as the name of the frontend or backend.\n\n\nfrontend\n or \nbackend\n (map): This attribute's structure matches exactly the structure of a Frontend or Backend type in Traefik.\n\n    See \ntypes/types.go\n for details.\n\n    The presence or absence of this attribute determines its type.\n    So an item should never have both a \nfrontend\n and a \nbackend\n attribute.", 
            "title": "DynamoDB"
        }, 
        {
            "location": "/configuration/backends/dynamodb/#dynamodb-provider", 
            "text": "Traefik can be configured to use Amazon DynamoDB as a provider.", 
            "title": "DynamoDB Provider"
        }, 
        {
            "location": "/configuration/backends/dynamodb/#configuration", 
            "text": "################################################################\n# DynamoDB Provider\n################################################################\n\n# Enable DynamoDB Provider.\n[dynamodb]\n\n# Region to use when connecting to AWS.\n#\n# Required\n#\nregion =  us-west-1 \n\n# DyanmoDB Table Name.\n#\n# Optional\n# Default:  traefik \n#\ntableName =  traefik \n\n# Enable watch DynamoDB changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Polling interval (in seconds).\n#\n# Optional\n# Default: 15\n#\nrefreshSeconds = 15\n\n# Access Key ID to use when connecting to AWS.\n#\n# Optional\n#\naccessKeyID =  abc \n\n# Secret Access Key to use when connecting to AWS.\n#\n# Optional\n#\nsecretAccessKey =  123 \n\n# Endpoint of local dynamodb instance for testing?\n#\n# Optional\n#\nendpoint =  http://localhost:8080", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/backends/dynamodb/#table-items", 
            "text": "Items in the  dynamodb  table must have three attributes:   id  (string): The id is the primary key.  name (string): The name is used as the name of the frontend or backend.  frontend  or  backend  (map): This attribute's structure matches exactly the structure of a Frontend or Backend type in Traefik. \n    See  types/types.go  for details. \n    The presence or absence of this attribute determines its type.\n    So an item should never have both a  frontend  and a  backend  attribute.", 
            "title": "Table Items"
        }, 
        {
            "location": "/configuration/backends/ecs/", 
            "text": "ECS Provider\n\n\nTraefik can be configured to use Amazon ECS as a provider.\n\n\nConfiguration\n\n\n################################################################\n# ECS Provider\n################################################################\n\n# Enable ECS Provider.\n[ecs]\n\n# ECS Cluster Name.\n#\n# DEPRECATED - Please use `clusters`.\n#\ncluster = \ndefault\n\n\n# ECS Clusters Name.\n#\n# Optional\n# Default: [\ndefault\n]\n#\nclusters = [\ndefault\n]\n\n# Enable watch ECS changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the \ntraefik.domain\n label.\n#\n# Optional\n# Default: \n\n#\ndomain = \necs.localhost\n\n\n# Enable auto discover ECS clusters.\n#\n# Optional\n# Default: false\n#\nautoDiscoverClusters = false\n\n# Polling interval (in seconds).\n#\n# Optional\n# Default: 15\n#\nrefreshSeconds = 15\n\n# Expose ECS services by default in Traefik.\n#\n# Optional\n# Default: true\n#\nexposedByDefault = false\n\n# Region to use when connecting to AWS.\n#\n# Optional\n#\nregion = \nus-east-1\n\n\n# Access Key ID to use when connecting to AWS.\n#\n# Optional\n#\naccessKeyID = \nabc\n\n\n# Secret Access Key to use when connecting to AWS.\n#\n# Optional\n#\nsecretAccessKey = \n123\n\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename = \necs.tmpl\n\n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# - \n1\n: previous template version (must be used only with older custom templates, see \nfilename\n)\n# - \n2\n: current template version (must be used to force template version when \nfilename\n is used)\n#\n# templateVersion = 2\n\n\n\n\nIf \naccessKeyID\n/\nsecretAccessKey\n is not given credentials will be resolved in the following order:\n\n\n\n\nFrom environment variables; \nAWS_ACCESS_KEY_ID\n, \nAWS_SECRET_ACCESS_KEY\n, and \nAWS_SESSION_TOKEN\n.\n\n\nShared credentials, determined by \nAWS_PROFILE\n and \nAWS_SHARED_CREDENTIALS_FILE\n, defaults to \ndefault\n and \n~/.aws/credentials\n.\n\n\nEC2 instance role or ECS task role\n\n\n\n\nTo enable constraints see \nprovider-specific constraints section\n.\n\n\nPolicy\n\n\nTraefik needs the following policy to read ECS information:\n\n\n{\n    \nVersion\n: \n2012-10-17\n,\n    \nStatement\n: [\n        {\n            \nSid\n: \nTraefikECSReadAccess\n,\n            \nEffect\n: \nAllow\n,\n            \nAction\n: [\n                \necs:ListClusters\n,\n                \necs:DescribeClusters\n,\n                \necs:ListTasks\n,\n                \necs:DescribeTasks\n,\n                \necs:DescribeContainerInstances\n,\n                \necs:DescribeTaskDefinition\n,\n                \nec2:DescribeInstances\n\n            ],\n            \nResource\n: [\n                \n*\n\n            ]\n        }\n    ]\n}\n\n\n\n\nLabels: overriding default behaviour\n\n\nLabels can be used on task containers to override default behaviour:\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.domain\n\n\nSets the default base domain for frontend rules.\n\n\n\n\n\n\ntraefik.enable=false\n\n\nDisables this container in Traefik.\n\n\n\n\n\n\ntraefik.port=80\n\n\nOverrides the default \nport\n value. Overrides \nNetworkBindings\n from Docker Container\n\n\n\n\n\n\ntraefik.protocol=https\n\n\nOverrides the default \nhttp\n protocol\n\n\n\n\n\n\ntraefik.weight=10\n\n\nAssigns this weight to the container\n\n\n\n\n\n\ntraefik.backend=foo\n\n\nOverrides the service name by \nfoo\n in the generated name of the backend.\n\n\n\n\n\n\ntraefik.backend.buffering.maxRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.maxResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.retryExpression=EXPR\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.circuitbreaker.expression=EXPR\n\n\nCreates a \ncircuit breaker\n to be used against the backend\n\n\n\n\n\n\ntraefik.backend.responseForwarding.flushInterval=10ms\n\n\nDefines the interval between two flushes when forwarding response from backend to client.\n\n\n\n\n\n\ntraefik.backend.healthcheck.path=/health\n\n\nEnables health check for the backend, hitting the container at \npath\n.\n\n\n\n\n\n\ntraefik.backend.healthcheck.interval=1s\n\n\nDefines the health check interval. (Default: 30s)\n\n\n\n\n\n\ntraefik.backend.healthcheck.scheme=http\n\n\nOverrides the server URL scheme.\n\n\n\n\n\n\ntraefik.backend.healthcheck.port=8080\n\n\nSets a different port for the health check.\n\n\n\n\n\n\ntraefik.backend.healthcheck.hostname=foobar.com\n\n\nDefines the health check hostname.\n\n\n\n\n\n\ntraefik.backend.healthcheck.headers=EXPR\n\n\nDefines the health check request headers \nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.backend.loadbalancer.method=drr\n\n\nOverrides the default \nwrr\n load balancer algorithm\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness=true\n\n\nEnables backend sticky sessions\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness.cookieName=NAME\n\n\nSets the cookie manually  name for sticky sessions\n\n\n\n\n\n\ntraefik.backend.loadbalancer.sticky=true\n\n\nEnables backend sticky sessions (DEPRECATED)\n\n\n\n\n\n\ntraefik.backend.maxconn.amount=10\n\n\nSets a maximum number of connections to the backend.\nMust be used in conjunction with the below label to take effect.\n\n\n\n\n\n\ntraefik.backend.maxconn.extractorfunc=client.ip\n\n\nSets the function to be used against the request to determine what to limit maximum connections to the backend by.\nMust be used in conjunction with the above label to take effect.\n\n\n\n\n\n\ntraefik.frontend.auth.basic=EXPR\n\n\nSets basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n (DEPRECATED).\n\n\n\n\n\n\ntraefik.frontend.auth.basic.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\ntraefik.frontend.auth.basic.users=EXPR\n\n\nSets basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n.\n\n\n\n\n\n\ntraefik.frontend.auth.basic.usersFile=/path/.htpasswd\n\n\nSets basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.users=EXPR\n\n\nSets digest authentication to this frontend in CSV format: \nUser:Realm:Hash,User:Realm:Hash\n.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.usersFile=/path/.htdigest\n\n\nSets digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.address=https://example.com\n\n\nSets the URL of the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.authResponseHeaders=EXPR\n\n\nSets the forward authentication authResponseHeaders in CSV format: \nX-Auth-User,X-Auth-Header\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.ca=/path/ca.pem\n\n\nSets the Certificate Authority (CA) for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.caOptional=true\n\n\nChecks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.cert=/path/server.pem\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.insecureSkipVerify=true\n\n\nIf set to true invalid SSL certificates are accepted.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.key=/path/server.key\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.trustForwardHeader=true\n\n\nTrusts X-Forwarded-* headers.\n\n\n\n\n\n\ntraefik.frontend.auth.headerField=X-WebAuth-User\n\n\nSets the header used to pass the authenticated user to the application.\n\n\n\n\n\n\ntraefik.frontend.auth.removeHeader=true\n\n\nIf set to true, removes the Authorization header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.commonName=true\n\n\nAdd the issuer.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.country=true\n\n\nAdd the issuer.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.domainComponent=true\n\n\nAdd the issuer.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.locality=true\n\n\nAdd the issuer.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.organization=true\n\n\nAdd the issuer.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.province=true\n\n\nAdd the issuer.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.serialNumber=true\n\n\nAdd the issuer.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.notAfter=true\n\n\nAdd the noAfter field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.notBefore=true\n\n\nAdd the noBefore field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.sans=true\n\n\nAdd the sans field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.commonName=true\n\n\nAdd the subject.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.country=true\n\n\nAdd the subject.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.domainComponent=true\n\n\nAdd the subject.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.locality=true\n\n\nAdd the subject.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.organization=true\n\n\nAdd the subject.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.province=true\n\n\nAdd the subject.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.serialNumber=true\n\n\nAdd the subject.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.pem=true\n\n\nPass the escaped pem in the \nX-Forwarded-Ssl-Client-Cert\n header.\n\n\n\n\n\n\ntraefik.frontend.entryPoints=http,https\n\n\nAssigns this frontend to entry points \nhttp\n and \nhttps\n.\nOverrides \ndefaultEntryPoints\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.backend=NAME\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.query=PATH\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.status=RANGE\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.passHostHeader=true\n\n\nForwards client \nHost\n header to the backend.\n\n\n\n\n\n\ntraefik.frontend.passTLSCert=true\n\n\nForwards TLS Client certificates to the backend.\n\n\n\n\n\n\ntraefik.frontend.priority=10\n\n\nOverrides default frontend priority\n\n\n\n\n\n\ntraefik.frontend.rateLimit.extractorFunc=EXP\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.period=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.average=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.burst=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.redirect.entryPoint=https\n\n\nEnables Redirect to another entryPoint to this frontend (e.g. HTTPS)\n\n\n\n\n\n\ntraefik.frontend.redirect.regex=^http://localhost/(.*)\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.replacement\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.replacement=http://mydomain/$1\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.regex\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.permanent=true\n\n\nReturns 301 instead of 302.\n\n\n\n\n\n\ntraefik.frontend.rule=EXPR\n\n\nOverrides the default frontend rule. Default: \nHost:{instance_name}.{domain}\n.\n\n\n\n\n\n\ntraefik.frontend.whiteList.sourceRange=RANGE\n\n\nSets a list of IP-Ranges which are allowed to access.\nAn unset or empty list allows all Source-IPs to access. If one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.\n\n\n\n\n\n\ntraefik.frontend.whiteList.useXForwardedFor=true\n\n\nUses \nX-Forwarded-For\n header as valid source of IP for the white list.\n\n\n\n\n\n\n\n\nCustom Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.customRequestHeaders=EXPR\n\n\nProvides the container with custom request headers that will be appended to each request forwarded to the container.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.customResponseHeaders=EXPR\n\n\nAppends the headers to each response returned by the container, before forwarding the response to the client.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.allowedHosts=EXPR\n\n\nProvides a list of allowed hosts that requests will be processed.\nFormat: \nHost1,Host2\n\n\n\n\n\n\ntraefik.frontend.headers.browserXSSFilter=true\n\n\nAdds the X-XSS-Protection header with the value \n1; mode=block\n.\n\n\n\n\n\n\ntraefik.frontend.headers.contentSecurityPolicy=VALUE\n\n\nAdds CSP Header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.contentTypeNosniff=true\n\n\nAdds the \nX-Content-Type-Options\n header with the value \nnosniff\n.\n\n\n\n\n\n\ntraefik.frontend.headers.customBrowserXSSValue=VALUE\n\n\nSet custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.\n\n\n\n\n\n\ntraefik.frontend.headers.customFrameOptionsValue=VALUE\n\n\nOverrides the \nX-Frame-Options\n header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.forceSTSHeader=false\n\n\nAdds the STS  header to non-SSL requests.\n\n\n\n\n\n\ntraefik.frontend.headers.frameDeny=false\n\n\nAdds the \nX-Frame-Options\n header with the value of \nDENY\n.\n\n\n\n\n\n\ntraefik.frontend.headers.hostsProxyHeaders=EXPR\n\n\nProvides a list of headers that the proxied hostname may be stored.\nFormat: \nHEADER1,HEADER2\n\n\n\n\n\n\ntraefik.frontend.headers.publicKey=VALUE\n\n\nAdds HPKP header.\n\n\n\n\n\n\ntraefik.frontend.headers.referrerPolicy=VALUE\n\n\nAdds referrer policy  header.\n\n\n\n\n\n\ntraefik.frontend.headers.isDevelopment=false\n\n\nThis will cause the \nAllowedHosts\n, \nSSLRedirect\n, and \nSTSSeconds\n/\nSTSIncludeSubdomains\n options to be ignored during development.\nWhen deploying to production, be sure to set this to false.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLTemporaryRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLHost=HOST\n\n\nThis setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLForceHost=true\n\n\nIf \nSSLForceHost\n is \ntrue\n and \nSSLHost\n is set, requests will be forced to use \nSSLHost\n even the ones that are already using SSL. Default is false.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLProxyHeaders=EXPR\n\n\nHeader combinations that would signify a proper SSL Request (Such as \nX-Forwarded-For:https\n).\nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.STSSeconds=315360000\n\n\nSets the max-age of the STS header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSIncludeSubdomains=true\n\n\nAdds the \nIncludeSubdomains\n section of the STS  header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSPreload=true\n\n\nAdds the preload flag to the STS  header.\n\n\n\n\n\n\n\n\nContainers with Multiple Ports (segment labels)\n\n\nSegment labels are used to define routes to an application exposing multiple ports.\nA segment is a group of labels that apply to a port exposed by an application.\nYou can define as many segments as ports exposed in an application.\n\n\nSegment labels override the default behavior.\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.backend=BACKEND\n\n\nSame as \ntraefik.backend\n\n\n\n\n\n\ntraefik.\nsegment_name\n.domain=DOMAIN\n\n\nSame as \ntraefik.domain\n\n\n\n\n\n\ntraefik.\nsegment_name\n.port=PORT\n\n\nSame as \ntraefik.port\n\n\n\n\n\n\ntraefik.\nsegment_name\n.protocol=http\n\n\nSame as \ntraefik.protocol\n\n\n\n\n\n\ntraefik.\nsegment_name\n.weight=10\n\n\nSame as \ntraefik.weight\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic=EXPR\n\n\nSame as \ntraefik.frontend.auth.basic\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.basic.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.users=EXPR\n\n\nSame as \ntraefik.frontend.auth.basic.users\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.usersFile=/path/.htpasswd\n\n\nSame as \ntraefik.frontend.auth.basic.usersFile\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.digest.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.users=EXPR\n\n\nSame as \ntraefik.frontend.auth.digest.users\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.usersFile=/path/.htdigest\n\n\nSame as \ntraefik.frontend.auth.digest.usersFile\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.address=https://example.com\n\n\nSame as \ntraefik.frontend.auth.forward.address\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.authResponseHeaders=EXPR\n\n\nSame as \ntraefik.frontend.auth.forward.authResponseHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.ca=/path/ca.pem\n\n\nSame as \ntraefik.frontend.auth.forward.tls.ca\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.caOptional=true\n\n\nSame as \ntraefik.frontend.auth.forward.tls.caOptional\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.cert=/path/server.pem\n\n\nSame as \ntraefik.frontend.auth.forward.tls.cert\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.insecureSkipVerify=true\n\n\nSame as \ntraefik.frontend.auth.forward.tls.insecureSkipVerify\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.key=/path/server.key\n\n\nSame as \ntraefik.frontend.auth.forward.tls.key\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.trustForwardHeader=true\n\n\nSame as \ntraefik.frontend.auth.forward.trustForwardHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.headerField=X-WebAuth-User\n\n\nSame as \ntraefik.frontend.auth.headerField\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.entryPoints=https\n\n\nSame as \ntraefik.frontend.entryPoints\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.backend=NAME\n\n\nSame as \ntraefik.frontend.errors.\nname\n.backend\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.query=PATH\n\n\nSame as \ntraefik.frontend.errors.\nname\n.query\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.status=RANGE\n\n\nSame as \ntraefik.frontend.errors.\nname\n.status\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passHostHeader=true\n\n\nSame as \ntraefik.frontend.passHostHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.commonName=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.commonName\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.country=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.country\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.domainComponent=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.domainComponent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.locality=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.locality\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.organization=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.organization\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.province=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.province\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.serialNumber=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.serialNumber\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.notAfter=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.notAfter\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.notBefore=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.notBefore\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.sans=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.sans\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.commonName=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.commonName\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.country=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.country\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.domainComponent=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.domainComponent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.locality=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.locality\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.organization=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.organization\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.province=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.province\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.serialNumber=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.serialNumber\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.pem=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.pem\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSCert=true\n\n\nSame as \ntraefik.frontend.passTLSCert\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.priority=10\n\n\nSame as \ntraefik.frontend.priority\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.extractorFunc=EXP\n\n\nSame as \ntraefik.frontend.rateLimit.extractorFunc\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.period=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.period\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.average=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.average\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.burst=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.burst\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.entryPoint=https\n\n\nSame as \ntraefik.frontend.redirect.entryPoint\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.regex=^http://localhost/(.*)\n\n\nSame as \ntraefik.frontend.redirect.regex\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.replacement=http://mydomain/$1\n\n\nSame as \ntraefik.frontend.redirect.replacement\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.permanent=true\n\n\nSame as \ntraefik.frontend.redirect.permanent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rule=EXP\n\n\nSame as \ntraefik.frontend.rule\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.whiteList.sourceRange=RANGE\n\n\nSame as \ntraefik.frontend.whiteList.sourceRange\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.whiteList.useXForwardedFor=true\n\n\nSame as \ntraefik.frontend.whiteList.useXForwardedFor\n\n\n\n\n\n\n\n\nCustom Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customRequestHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.customRequestHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customResponseHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.customResponseHeaders\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.allowedHosts=EXPR\n\n\nSame as \ntraefik.frontend.headers.allowedHosts\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.browserXSSFilter=true\n\n\nSame as \ntraefik.frontend.headers.browserXSSFilter\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.contentSecurityPolicy=VALUE\n\n\nSame as \ntraefik.frontend.headers.contentSecurityPolicy\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.contentTypeNosniff=true\n\n\nSame as \ntraefik.frontend.headers.contentTypeNosniff\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customBrowserXSSValue=VALUE\n\n\nSame as \ntraefik.frontend.headers.customBrowserXSSValue\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customFrameOptionsValue=VALUE\n\n\nSame as \ntraefik.frontend.headers.customFrameOptionsValue\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.forceSTSHeader=false\n\n\nSame as \ntraefik.frontend.headers.forceSTSHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.frameDeny=false\n\n\nSame as \ntraefik.frontend.headers.frameDeny\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.hostsProxyHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.hostsProxyHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.isDevelopment=false\n\n\nSame as \ntraefik.frontend.headers.isDevelopment\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.publicKey=VALUE\n\n\nSame as \ntraefik.frontend.headers.publicKey\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.referrerPolicy=VALUE\n\n\nSame as \ntraefik.frontend.headers.referrerPolicy\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLRedirect=true\n\n\nSame as \ntraefik.frontend.headers.SSLRedirect\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLTemporaryRedirect=true\n\n\nSame as \ntraefik.frontend.headers.SSLTemporaryRedirect\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLHost=HOST\n\n\nSame as \ntraefik.frontend.headers.SSLHost\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLForceHost=true\n\n\nSame as \ntraefik.frontend.headers.SSLForceHost\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLProxyHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.SSLProxyHeaders=EXPR\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSSeconds=315360000\n\n\nSame as \ntraefik.frontend.headers.STSSeconds=315360000\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSIncludeSubdomains=true\n\n\nSame as \ntraefik.frontend.headers.STSIncludeSubdomains=true\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSPreload=true\n\n\nSame as \ntraefik.frontend.headers.STSPreload=true", 
            "title": "ECS"
        }, 
        {
            "location": "/configuration/backends/ecs/#ecs-provider", 
            "text": "Traefik can be configured to use Amazon ECS as a provider.", 
            "title": "ECS Provider"
        }, 
        {
            "location": "/configuration/backends/ecs/#configuration", 
            "text": "################################################################\n# ECS Provider\n################################################################\n\n# Enable ECS Provider.\n[ecs]\n\n# ECS Cluster Name.\n#\n# DEPRECATED - Please use `clusters`.\n#\ncluster =  default \n\n# ECS Clusters Name.\n#\n# Optional\n# Default: [ default ]\n#\nclusters = [ default ]\n\n# Enable watch ECS changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the  traefik.domain  label.\n#\n# Optional\n# Default:  \n#\ndomain =  ecs.localhost \n\n# Enable auto discover ECS clusters.\n#\n# Optional\n# Default: false\n#\nautoDiscoverClusters = false\n\n# Polling interval (in seconds).\n#\n# Optional\n# Default: 15\n#\nrefreshSeconds = 15\n\n# Expose ECS services by default in Traefik.\n#\n# Optional\n# Default: true\n#\nexposedByDefault = false\n\n# Region to use when connecting to AWS.\n#\n# Optional\n#\nregion =  us-east-1 \n\n# Access Key ID to use when connecting to AWS.\n#\n# Optional\n#\naccessKeyID =  abc \n\n# Secret Access Key to use when connecting to AWS.\n#\n# Optional\n#\nsecretAccessKey =  123 \n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename =  ecs.tmpl \n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# -  1 : previous template version (must be used only with older custom templates, see  filename )\n# -  2 : current template version (must be used to force template version when  filename  is used)\n#\n# templateVersion = 2  If  accessKeyID / secretAccessKey  is not given credentials will be resolved in the following order:   From environment variables;  AWS_ACCESS_KEY_ID ,  AWS_SECRET_ACCESS_KEY , and  AWS_SESSION_TOKEN .  Shared credentials, determined by  AWS_PROFILE  and  AWS_SHARED_CREDENTIALS_FILE , defaults to  default  and  ~/.aws/credentials .  EC2 instance role or ECS task role   To enable constraints see  provider-specific constraints section .", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/backends/ecs/#policy", 
            "text": "Traefik needs the following policy to read ECS information:  {\n     Version :  2012-10-17 ,\n     Statement : [\n        {\n             Sid :  TraefikECSReadAccess ,\n             Effect :  Allow ,\n             Action : [\n                 ecs:ListClusters ,\n                 ecs:DescribeClusters ,\n                 ecs:ListTasks ,\n                 ecs:DescribeTasks ,\n                 ecs:DescribeContainerInstances ,\n                 ecs:DescribeTaskDefinition ,\n                 ec2:DescribeInstances \n            ],\n             Resource : [\n                 * \n            ]\n        }\n    ]\n}", 
            "title": "Policy"
        }, 
        {
            "location": "/configuration/backends/ecs/#labels-overriding-default-behaviour", 
            "text": "Labels can be used on task containers to override default behaviour:     Label  Description      traefik.domain  Sets the default base domain for frontend rules.    traefik.enable=false  Disables this container in Traefik.    traefik.port=80  Overrides the default  port  value. Overrides  NetworkBindings  from Docker Container    traefik.protocol=https  Overrides the default  http  protocol    traefik.weight=10  Assigns this weight to the container    traefik.backend=foo  Overrides the service name by  foo  in the generated name of the backend.    traefik.backend.buffering.maxRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.maxResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.retryExpression=EXPR  See  buffering  section.    traefik.backend.circuitbreaker.expression=EXPR  Creates a  circuit breaker  to be used against the backend    traefik.backend.responseForwarding.flushInterval=10ms  Defines the interval between two flushes when forwarding response from backend to client.    traefik.backend.healthcheck.path=/health  Enables health check for the backend, hitting the container at  path .    traefik.backend.healthcheck.interval=1s  Defines the health check interval. (Default: 30s)    traefik.backend.healthcheck.scheme=http  Overrides the server URL scheme.    traefik.backend.healthcheck.port=8080  Sets a different port for the health check.    traefik.backend.healthcheck.hostname=foobar.com  Defines the health check hostname.    traefik.backend.healthcheck.headers=EXPR  Defines the health check request headers  Format:   HEADER:value HEADER2:value2    traefik.backend.loadbalancer.method=drr  Overrides the default  wrr  load balancer algorithm    traefik.backend.loadbalancer.stickiness=true  Enables backend sticky sessions    traefik.backend.loadbalancer.stickiness.cookieName=NAME  Sets the cookie manually  name for sticky sessions    traefik.backend.loadbalancer.sticky=true  Enables backend sticky sessions (DEPRECATED)    traefik.backend.maxconn.amount=10  Sets a maximum number of connections to the backend. Must be used in conjunction with the below label to take effect.    traefik.backend.maxconn.extractorfunc=client.ip  Sets the function to be used against the request to determine what to limit maximum connections to the backend by. Must be used in conjunction with the above label to take effect.    traefik.frontend.auth.basic=EXPR  Sets basic authentication to this frontend in CSV format:  User:Hash,User:Hash  (DEPRECATED).    traefik.frontend.auth.basic.removeHeader=true  If set to  true , removes the  Authorization  header.    traefik.frontend.auth.basic.users=EXPR  Sets basic authentication to this frontend in CSV format:  User:Hash,User:Hash .    traefik.frontend.auth.basic.usersFile=/path/.htpasswd  Sets basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    traefik.frontend.auth.digest.removeHeader=true  If set to  true , removes the  Authorization  header.    traefik.frontend.auth.digest.users=EXPR  Sets digest authentication to this frontend in CSV format:  User:Realm:Hash,User:Realm:Hash .    traefik.frontend.auth.digest.usersFile=/path/.htdigest  Sets digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    traefik.frontend.auth.forward.address=https://example.com  Sets the URL of the authentication server.    traefik.frontend.auth.forward.authResponseHeaders=EXPR  Sets the forward authentication authResponseHeaders in CSV format:  X-Auth-User,X-Auth-Header    traefik.frontend.auth.forward.tls.ca=/path/ca.pem  Sets the Certificate Authority (CA) for the TLS connection with the authentication server.    traefik.frontend.auth.forward.tls.caOptional=true  Checks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).    traefik.frontend.auth.forward.tls.cert=/path/server.pem  Sets the Certificate for the TLS connection with the authentication server.    traefik.frontend.auth.forward.tls.insecureSkipVerify=true  If set to true invalid SSL certificates are accepted.    traefik.frontend.auth.forward.tls.key=/path/server.key  Sets the Certificate for the TLS connection with the authentication server.    traefik.frontend.auth.forward.trustForwardHeader=true  Trusts X-Forwarded-* headers.    traefik.frontend.auth.headerField=X-WebAuth-User  Sets the header used to pass the authenticated user to the application.    traefik.frontend.auth.removeHeader=true  If set to true, removes the Authorization header.    traefik.frontend.passTLSClientCert.infos.issuer.commonName=true  Add the issuer.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.country=true  Add the issuer.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.domainComponent=true  Add the issuer.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.locality=true  Add the issuer.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.organization=true  Add the issuer.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.province=true  Add the issuer.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.serialNumber=true  Add the issuer.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.notAfter=true  Add the noAfter field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.notBefore=true  Add the noBefore field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.sans=true  Add the sans field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.commonName=true  Add the subject.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.country=true  Add the subject.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.domainComponent=true  Add the subject.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.locality=true  Add the subject.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.organization=true  Add the subject.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.province=true  Add the subject.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.serialNumber=true  Add the subject.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.pem=true  Pass the escaped pem in the  X-Forwarded-Ssl-Client-Cert  header.    traefik.frontend.entryPoints=http,https  Assigns this frontend to entry points  http  and  https . Overrides  defaultEntryPoints    traefik.frontend.errors. name .backend=NAME  See  custom error pages  section.    traefik.frontend.errors. name .query=PATH  See  custom error pages  section.    traefik.frontend.errors. name .status=RANGE  See  custom error pages  section.    traefik.frontend.passHostHeader=true  Forwards client  Host  header to the backend.    traefik.frontend.passTLSCert=true  Forwards TLS Client certificates to the backend.    traefik.frontend.priority=10  Overrides default frontend priority    traefik.frontend.rateLimit.extractorFunc=EXP  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .period=6  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .average=6  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .burst=6  See  rate limiting  section.    traefik.frontend.redirect.entryPoint=https  Enables Redirect to another entryPoint to this frontend (e.g. HTTPS)    traefik.frontend.redirect.regex=^http://localhost/(.*)  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.replacement .    traefik.frontend.redirect.replacement=http://mydomain/$1  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.regex .    traefik.frontend.redirect.permanent=true  Returns 301 instead of 302.    traefik.frontend.rule=EXPR  Overrides the default frontend rule. Default:  Host:{instance_name}.{domain} .    traefik.frontend.whiteList.sourceRange=RANGE  Sets a list of IP-Ranges which are allowed to access. An unset or empty list allows all Source-IPs to access. If one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.    traefik.frontend.whiteList.useXForwardedFor=true  Uses  X-Forwarded-For  header as valid source of IP for the white list.", 
            "title": "Labels: overriding default behaviour"
        }, 
        {
            "location": "/configuration/backends/ecs/#custom-headers", 
            "text": "Label  Description      traefik.frontend.headers.customRequestHeaders=EXPR  Provides the container with custom request headers that will be appended to each request forwarded to the container. Format:  HEADER:value HEADER2:value2    traefik.frontend.headers.customResponseHeaders=EXPR  Appends the headers to each response returned by the container, before forwarding the response to the client. Format:  HEADER:value HEADER2:value2", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/ecs/#security-headers", 
            "text": "Label  Description      traefik.frontend.headers.allowedHosts=EXPR  Provides a list of allowed hosts that requests will be processed. Format:  Host1,Host2    traefik.frontend.headers.browserXSSFilter=true  Adds the X-XSS-Protection header with the value  1; mode=block .    traefik.frontend.headers.contentSecurityPolicy=VALUE  Adds CSP Header with the custom value.    traefik.frontend.headers.contentTypeNosniff=true  Adds the  X-Content-Type-Options  header with the value  nosniff .    traefik.frontend.headers.customBrowserXSSValue=VALUE  Set custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.    traefik.frontend.headers.customFrameOptionsValue=VALUE  Overrides the  X-Frame-Options  header with the custom value.    traefik.frontend.headers.forceSTSHeader=false  Adds the STS  header to non-SSL requests.    traefik.frontend.headers.frameDeny=false  Adds the  X-Frame-Options  header with the value of  DENY .    traefik.frontend.headers.hostsProxyHeaders=EXPR  Provides a list of headers that the proxied hostname may be stored. Format:  HEADER1,HEADER2    traefik.frontend.headers.publicKey=VALUE  Adds HPKP header.    traefik.frontend.headers.referrerPolicy=VALUE  Adds referrer policy  header.    traefik.frontend.headers.isDevelopment=false  This will cause the  AllowedHosts ,  SSLRedirect , and  STSSeconds / STSIncludeSubdomains  options to be ignored during development. When deploying to production, be sure to set this to false.    traefik.frontend.headers.SSLRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent.    traefik.frontend.headers.SSLTemporaryRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.    traefik.frontend.headers.SSLHost=HOST  This setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.    traefik.frontend.headers.SSLForceHost=true  If  SSLForceHost  is  true  and  SSLHost  is set, requests will be forced to use  SSLHost  even the ones that are already using SSL. Default is false.    traefik.frontend.headers.SSLProxyHeaders=EXPR  Header combinations that would signify a proper SSL Request (Such as  X-Forwarded-For:https ). Format:   HEADER:value HEADER2:value2    traefik.frontend.headers.STSSeconds=315360000  Sets the max-age of the STS header.    traefik.frontend.headers.STSIncludeSubdomains=true  Adds the  IncludeSubdomains  section of the STS  header.    traefik.frontend.headers.STSPreload=true  Adds the preload flag to the STS  header.", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/ecs/#containers-with-multiple-ports-segment-labels", 
            "text": "Segment labels are used to define routes to an application exposing multiple ports.\nA segment is a group of labels that apply to a port exposed by an application.\nYou can define as many segments as ports exposed in an application.  Segment labels override the default behavior.     Label  Description      traefik. segment_name .backend=BACKEND  Same as  traefik.backend    traefik. segment_name .domain=DOMAIN  Same as  traefik.domain    traefik. segment_name .port=PORT  Same as  traefik.port    traefik. segment_name .protocol=http  Same as  traefik.protocol    traefik. segment_name .weight=10  Same as  traefik.weight    traefik. segment_name .frontend.auth.basic=EXPR  Same as  traefik.frontend.auth.basic    traefik. segment_name .frontend.auth.basic.removeHeader=true  Same as  traefik.frontend.auth.basic.removeHeader    traefik. segment_name .frontend.auth.basic.users=EXPR  Same as  traefik.frontend.auth.basic.users    traefik. segment_name .frontend.auth.basic.usersFile=/path/.htpasswd  Same as  traefik.frontend.auth.basic.usersFile    traefik. segment_name .frontend.auth.digest.removeHeader=true  Same as  traefik.frontend.auth.digest.removeHeader    traefik. segment_name .frontend.auth.digest.users=EXPR  Same as  traefik.frontend.auth.digest.users    traefik. segment_name .frontend.auth.digest.usersFile=/path/.htdigest  Same as  traefik.frontend.auth.digest.usersFile    traefik. segment_name .frontend.auth.forward.address=https://example.com  Same as  traefik.frontend.auth.forward.address    traefik. segment_name .frontend.auth.forward.authResponseHeaders=EXPR  Same as  traefik.frontend.auth.forward.authResponseHeaders    traefik. segment_name .frontend.auth.forward.tls.ca=/path/ca.pem  Same as  traefik.frontend.auth.forward.tls.ca    traefik. segment_name .frontend.auth.forward.tls.caOptional=true  Same as  traefik.frontend.auth.forward.tls.caOptional    traefik. segment_name .frontend.auth.forward.tls.cert=/path/server.pem  Same as  traefik.frontend.auth.forward.tls.cert    traefik. segment_name .frontend.auth.forward.tls.insecureSkipVerify=true  Same as  traefik.frontend.auth.forward.tls.insecureSkipVerify    traefik. segment_name .frontend.auth.forward.tls.key=/path/server.key  Same as  traefik.frontend.auth.forward.tls.key    traefik. segment_name .frontend.auth.forward.trustForwardHeader=true  Same as  traefik.frontend.auth.forward.trustForwardHeader    traefik. segment_name .frontend.auth.headerField=X-WebAuth-User  Same as  traefik.frontend.auth.headerField    traefik. segment_name .frontend.auth.removeHeader=true  Same as  traefik.frontend.auth.removeHeader    traefik. segment_name .frontend.entryPoints=https  Same as  traefik.frontend.entryPoints    traefik. segment_name .frontend.errors. name .backend=NAME  Same as  traefik.frontend.errors. name .backend    traefik. segment_name .frontend.errors. name .query=PATH  Same as  traefik.frontend.errors. name .query    traefik. segment_name .frontend.errors. name .status=RANGE  Same as  traefik.frontend.errors. name .status    traefik. segment_name .frontend.passHostHeader=true  Same as  traefik.frontend.passHostHeader    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.commonName=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.commonName    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.country=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.country    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.domainComponent=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.domainComponent    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.locality=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.locality    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.organization=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.organization    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.province=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.province    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.serialNumber=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.serialNumber    traefik. segment_name .frontend.passTLSClientCert.infos.notAfter=true  Same as  traefik.frontend.passTLSClientCert.infos.notAfter    traefik. segment_name .frontend.passTLSClientCert.infos.notBefore=true  Same as  traefik.frontend.passTLSClientCert.infos.notBefore    traefik. segment_name .frontend.passTLSClientCert.infos.sans=true  Same as  traefik.frontend.passTLSClientCert.infos.sans    traefik. segment_name .frontend.passTLSClientCert.infos.subject.commonName=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.commonName    traefik. segment_name .frontend.passTLSClientCert.infos.subject.country=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.country    traefik. segment_name .frontend.passTLSClientCert.infos.subject.domainComponent=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.domainComponent    traefik. segment_name .frontend.passTLSClientCert.infos.subject.locality=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.locality    traefik. segment_name .frontend.passTLSClientCert.infos.subject.organization=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.organization    traefik. segment_name .frontend.passTLSClientCert.infos.subject.province=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.province    traefik. segment_name .frontend.passTLSClientCert.infos.subject.serialNumber=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.serialNumber    traefik. segment_name .frontend.passTLSClientCert.pem=true  Same as  traefik.frontend.passTLSClientCert.infos.pem    traefik. segment_name .frontend.passTLSCert=true  Same as  traefik.frontend.passTLSCert    traefik. segment_name .frontend.priority=10  Same as  traefik.frontend.priority    traefik. segment_name .frontend.rateLimit.extractorFunc=EXP  Same as  traefik.frontend.rateLimit.extractorFunc    traefik. segment_name .frontend.rateLimit.rateSet. name .period=6  Same as  traefik.frontend.rateLimit.rateSet. name .period    traefik. segment_name .frontend.rateLimit.rateSet. name .average=6  Same as  traefik.frontend.rateLimit.rateSet. name .average    traefik. segment_name .frontend.rateLimit.rateSet. name .burst=6  Same as  traefik.frontend.rateLimit.rateSet. name .burst    traefik. segment_name .frontend.redirect.entryPoint=https  Same as  traefik.frontend.redirect.entryPoint    traefik. segment_name .frontend.redirect.regex=^http://localhost/(.*)  Same as  traefik.frontend.redirect.regex    traefik. segment_name .frontend.redirect.replacement=http://mydomain/$1  Same as  traefik.frontend.redirect.replacement    traefik. segment_name .frontend.redirect.permanent=true  Same as  traefik.frontend.redirect.permanent    traefik. segment_name .frontend.rule=EXP  Same as  traefik.frontend.rule    traefik. segment_name .frontend.whiteList.sourceRange=RANGE  Same as  traefik.frontend.whiteList.sourceRange    traefik. segment_name .frontend.whiteList.useXForwardedFor=true  Same as  traefik.frontend.whiteList.useXForwardedFor", 
            "title": "Containers with Multiple Ports (segment labels)"
        }, 
        {
            "location": "/configuration/backends/ecs/#custom-headers_1", 
            "text": "Label  Description      traefik. segment_name .frontend.headers.customRequestHeaders=EXPR  Same as  traefik.frontend.headers.customRequestHeaders    traefik. segment_name .frontend.headers.customResponseHeaders=EXPR  Same as  traefik.frontend.headers.customResponseHeaders", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/ecs/#security-headers_1", 
            "text": "Label  Description      traefik. segment_name .frontend.headers.allowedHosts=EXPR  Same as  traefik.frontend.headers.allowedHosts    traefik. segment_name .frontend.headers.browserXSSFilter=true  Same as  traefik.frontend.headers.browserXSSFilter    traefik. segment_name .frontend.headers.contentSecurityPolicy=VALUE  Same as  traefik.frontend.headers.contentSecurityPolicy    traefik. segment_name .frontend.headers.contentTypeNosniff=true  Same as  traefik.frontend.headers.contentTypeNosniff    traefik. segment_name .frontend.headers.customBrowserXSSValue=VALUE  Same as  traefik.frontend.headers.customBrowserXSSValue    traefik. segment_name .frontend.headers.customFrameOptionsValue=VALUE  Same as  traefik.frontend.headers.customFrameOptionsValue    traefik. segment_name .frontend.headers.forceSTSHeader=false  Same as  traefik.frontend.headers.forceSTSHeader    traefik. segment_name .frontend.headers.frameDeny=false  Same as  traefik.frontend.headers.frameDeny    traefik. segment_name .frontend.headers.hostsProxyHeaders=EXPR  Same as  traefik.frontend.headers.hostsProxyHeaders    traefik. segment_name .frontend.headers.isDevelopment=false  Same as  traefik.frontend.headers.isDevelopment    traefik. segment_name .frontend.headers.publicKey=VALUE  Same as  traefik.frontend.headers.publicKey    traefik. segment_name .frontend.headers.referrerPolicy=VALUE  Same as  traefik.frontend.headers.referrerPolicy    traefik. segment_name .frontend.headers.SSLRedirect=true  Same as  traefik.frontend.headers.SSLRedirect    traefik. segment_name .frontend.headers.SSLTemporaryRedirect=true  Same as  traefik.frontend.headers.SSLTemporaryRedirect    traefik. segment_name .frontend.headers.SSLHost=HOST  Same as  traefik.frontend.headers.SSLHost    traefik. segment_name .frontend.headers.SSLForceHost=true  Same as  traefik.frontend.headers.SSLForceHost    traefik. segment_name .frontend.headers.SSLProxyHeaders=EXPR  Same as  traefik.frontend.headers.SSLProxyHeaders=EXPR    traefik. segment_name .frontend.headers.STSSeconds=315360000  Same as  traefik.frontend.headers.STSSeconds=315360000    traefik. segment_name .frontend.headers.STSIncludeSubdomains=true  Same as  traefik.frontend.headers.STSIncludeSubdomains=true    traefik. segment_name .frontend.headers.STSPreload=true  Same as  traefik.frontend.headers.STSPreload=true", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/etcd/", 
            "text": "Etcd Provider\n\n\nTraefik can be configured to use Etcd as a provider.\n\n\n################################################################\n# Etcd Provider\n################################################################\n\n# Enable Etcd Provider.\n[etcd]\n\n# Etcd server endpoint.\n#\n# Required\n# Default: \n127.0.0.1:2379\n\n#\nendpoint = \n127.0.0.1:2379\n\n\n# Enable watch Etcd changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Prefix used for KV store.\n#\n# Optional\n# Default: \n/traefik\n\n#\nprefix = \n/traefik\n\n\n# Force to use API V3 (otherwise still use API V2)\n#\n# Deprecated\n#\n# Optional\n# Default: false\n#\nuseAPIV3 = true\n\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename = \netcd.tmpl\n\n\n# Use etcd user/pass authentication.\n#\n# Optional\n#\n# username = foo\n# password = bar\n\n# Enable etcd TLS connection.\n#\n# Optional\n#\n#    [etcd.tls]\n#    ca = \n/etc/ssl/ca.crt\n\n#    cert = \n/etc/ssl/etcd.crt\n\n#    key = \n/etc/ssl/etcd.key\n\n#    insecureSkipVerify = true\n\n\n\n\nTo enable constraints see \nprovider-specific constraints section\n.\n\n\nPlease refer to the \nKey Value storage structure\n section to get documentation on Traefik KV structure.\n\n\n\n\nNote\n\n\nThe option \nuseAPIV3\n allows using Etcd API V3 only if it's set to true.\nThis option is \ndeprecated\n and API V2 won't be supported in the future.", 
            "title": "Etcd"
        }, 
        {
            "location": "/configuration/backends/etcd/#etcd-provider", 
            "text": "Traefik can be configured to use Etcd as a provider.  ################################################################\n# Etcd Provider\n################################################################\n\n# Enable Etcd Provider.\n[etcd]\n\n# Etcd server endpoint.\n#\n# Required\n# Default:  127.0.0.1:2379 \n#\nendpoint =  127.0.0.1:2379 \n\n# Enable watch Etcd changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Prefix used for KV store.\n#\n# Optional\n# Default:  /traefik \n#\nprefix =  /traefik \n\n# Force to use API V3 (otherwise still use API V2)\n#\n# Deprecated\n#\n# Optional\n# Default: false\n#\nuseAPIV3 = true\n\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename =  etcd.tmpl \n\n# Use etcd user/pass authentication.\n#\n# Optional\n#\n# username = foo\n# password = bar\n\n# Enable etcd TLS connection.\n#\n# Optional\n#\n#    [etcd.tls]\n#    ca =  /etc/ssl/ca.crt \n#    cert =  /etc/ssl/etcd.crt \n#    key =  /etc/ssl/etcd.key \n#    insecureSkipVerify = true  To enable constraints see  provider-specific constraints section .  Please refer to the  Key Value storage structure  section to get documentation on Traefik KV structure.   Note  The option  useAPIV3  allows using Etcd API V3 only if it's set to true.\nThis option is  deprecated  and API V2 won't be supported in the future.", 
            "title": "Etcd Provider"
        }, 
        {
            "location": "/configuration/backends/eureka/", 
            "text": "Eureka Provider\n\n\nTraefik can be configured to use Eureka as a provider.\n\n\n################################################################\n# Eureka Provider\n################################################################\n\n# Enable Eureka Provider.\n[eureka]\n\n# Eureka server endpoint.\n#\n# Required\n#\nendpoint = \nhttp://my.eureka.server/eureka\n\n\n# Override default configuration time between refresh.\n#\n# Optional\n# Default: 30s\n#\nrefreshSeconds = \n1m\n\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename = \neureka.tmpl", 
            "title": "Eureka"
        }, 
        {
            "location": "/configuration/backends/eureka/#eureka-provider", 
            "text": "Traefik can be configured to use Eureka as a provider.  ################################################################\n# Eureka Provider\n################################################################\n\n# Enable Eureka Provider.\n[eureka]\n\n# Eureka server endpoint.\n#\n# Required\n#\nendpoint =  http://my.eureka.server/eureka \n\n# Override default configuration time between refresh.\n#\n# Optional\n# Default: 30s\n#\nrefreshSeconds =  1m \n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename =  eureka.tmpl", 
            "title": "Eureka Provider"
        }, 
        {
            "location": "/configuration/backends/file/", 
            "text": "File Provider\n\n\nTraefik can be configured with a file.\n\n\nReference\n\n\n[file]\n\n# Backends\n[backends]\n\n  [backends.backend1]\n\n    [backends.backend1.servers]\n      [backends.backend1.servers.server0]\n        url = \nhttp://10.10.10.1:80\n\n        weight = 1\n      [backends.backend1.servers.server1]\n        url = \nhttp://10.10.10.2:80\n\n        weight = 2\n      # ...\n\n    [backends.backend1.circuitBreaker]\n      expression = \nNetworkErrorRatio() \n 0.5\n\n\n    [backends.backend1.responseForwarding]\n      flushInterval = \n10ms\n\n\n    [backends.backend1.loadBalancer]\n      method = \ndrr\n\n      [backends.backend1.loadBalancer.stickiness]\n        cookieName = \nfoobar\n\n\n    [backends.backend1.maxConn]\n      amount = 10\n      extractorfunc = \nrequest.host\n\n\n    [backends.backend1.healthCheck]\n      path = \n/health\n\n      port = 88\n      interval = \n30s\n\n      scheme = \nhttp\n\n      hostname = \nmyhost.com\n\n      [backends.backend1.healthcheck.headers]\n        My-Custom-Header = \nfoo\n\n        My-Header = \nbar\n\n\n  [backends.backend2]\n    # ...\n\n# Frontends\n[frontends]\n\n  [frontends.frontend1]\n    entryPoints = [\nhttp\n, \nhttps\n]\n    backend = \nbackend1\n\n    passHostHeader = true\n    priority = 42\n\n    # Use frontends.frontend1.auth.basic below instead\n    basicAuth = [\n      \ntest:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\n,\n      \ntest2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\n,\n    ]\n    [frontends.frontend1.passTLSClientCert]\n        pem = true\n        [frontends.frontend1.passTLSClientCert.infos]\n            notBefore = true\n            notAfter = true\n            [frontends.frontend1.passTLSClientCert.infos.subject]\n                country = true\n                domainComponent = true\n                province = true\n                locality = true\n                organization = true\n                commonName = true\n                serialNumber = true\n            [frontends.frontend1.passTLSClientCert.infos.issuer]\n                country = true\n                domainComponent = true\n                province = true\n                locality = true\n                organization = true\n                commonName = true\n                serialNumber = true\n    [frontends.frontend1.auth]\n      headerField = \nX-WebAuth-User\n\n      [frontends.frontend1.auth.basic]\n        removeHeader = true\n        users = [\n          \ntest:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\n,\n          \ntest2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\n,\n        ]\n        usersFile = \n/path/to/.htpasswd\n\n      [frontends.frontend1.auth.digest]\n        removeHeader = true\n        users = [\n          \ntest:traefik:a2688e031edb4be6a3797f3882655c05\n,\n          \ntest2:traefik:518845800f9e2bfb1f1f740ec24f074e\n,\n        ]\n        usersFile = \n/path/to/.htdigest\n\n      [frontends.frontend1.auth.forward]\n        address = \nhttps://authserver.com/auth\n\n        trustForwardHeader = true\n        authResponseHeaders = [\nX-Auth-User\n]\n        [frontends.frontend1.auth.forward.tls]\n          ca = \npath/to/local.crt\n\n          caOptional = true\n          cert = \npath/to/foo.cert\n\n          key = \npath/to/foo.key\n\n          insecureSkipVerify = true\n\n    [frontends.frontend1.whiteList]\n      sourceRange = [\n10.42.0.0/16\n, \n152.89.1.33/32\n, \nafed:be44::/16\n]\n      useXForwardedFor = true\n\n    [frontends.frontend1.routes]\n      [frontends.frontend1.routes.route0]\n        rule = \nHost:test.localhost\n\n      [frontends.frontend1.routes.Route1]\n        rule = \nMethod:GET\n\n      # ...\n\n    [frontends.frontend1.headers]\n      allowedHosts = [\nfoobar\n, \nfoobar\n]\n      hostsProxyHeaders = [\nfoobar\n, \nfoobar\n]\n      SSLRedirect = true\n      SSLTemporaryRedirect = true\n      SSLHost = \nfoobar\n\n      STSSeconds = 42\n      STSIncludeSubdomains = true\n      STSPreload = true\n      forceSTSHeader = true\n      frameDeny = true\n      customFrameOptionsValue = \nfoobar\n\n      contentTypeNosniff = true\n      browserXSSFilter = true\n      contentSecurityPolicy = \nfoobar\n\n      publicKey = \nfoobar\n\n      referrerPolicy = \nfoobar\n\n      isDevelopment = true\n      [frontends.frontend1.headers.customRequestHeaders]\n        X-Foo-Bar-01 = \nfoobar\n\n        X-Foo-Bar-02 = \nfoobar\n\n        # ...\n      [frontends.frontend1.headers.customResponseHeaders]\n        X-Foo-Bar-03 = \nfoobar\n\n        X-Foo-Bar-04 = \nfoobar\n\n        # ...\n      [frontends.frontend1.headers.SSLProxyHeaders]\n        X-Foo-Bar-05 = \nfoobar\n\n        X-Foo-Bar-06 = \nfoobar\n\n        # ...\n\n    [frontends.frontend1.errors]\n      [frontends.frontend1.errors.errorPage0]\n        status = [\n500-599\n]\n        backend = \nerror\n\n        query = \n/{status}.html\n\n      [frontends.frontend1.errors.errorPage1]\n        status = [\n404\n, \n403\n]\n        backend = \nerror\n\n        query = \n/{status}.html\n\n      # ...\n\n    [frontends.frontend1.ratelimit]\n      extractorfunc = \nclient.ip\n\n        [frontends.frontend1.ratelimit.rateset.rateset1]\n          period = \n10s\n\n          average = 100\n          burst = 200\n        [frontends.frontend1.ratelimit.rateset.rateset2]\n          period = \n3s\n\n          average = 5\n          burst = 10\n        # ...\n\n    [frontends.frontend1.redirect]\n      entryPoint = \nhttps\n\n      regex = \n^http://localhost/(.*)\n\n      replacement = \nhttp://mydomain/$1\n\n      permanent = true\n\n  [frontends.frontend2]\n    # ...\n\n# HTTPS certificates\n[[tls]]\n  entryPoints = [\nhttps\n]\n  [tls.certificate]\n    certFile = \npath/to/my.cert\n\n    keyFile = \npath/to/my.key\n\n\n[[tls]]\n  # ...\n\n\n\n\nConfiguration Mode\n\n\nYou have two choices:\n\n\n\n\nRules in Traefik configuration file\n\n\nRules in dedicated files\n\n\n\n\nTo enable the file backend, you must either pass the \n--file\n option to the Traefik binary or put the \n[file]\n section (with or without inner settings) in the configuration file.\n\n\nThe configuration file allows managing both backends/frontends and HTTPS certificates (which are not \nLet's Encrypt\n certificates generated through Traefik).\n\n\nTOML templating can be used if rules are not defined in the Traefik configuration file.\n\n\nRules in Traefik Configuration File\n\n\nAdd your configuration at the end of the global configuration file \ntraefik.toml\n:\n\n\ndefaultEntryPoints = [\nhttp\n, \nhttps\n]\n\n[entryPoints]\n  [entryPoints.http]\n    # ...\n  [entryPoints.https]\n    # ...\n\n[file]\n\n# rules\n[backends]\n  [backends.backend1]\n    # ...\n  [backends.backend2]\n    # ...\n\n[frontends]\n  [frontends.frontend1]\n  # ...\n  [frontends.frontend2]\n  # ...\n  [frontends.frontend3]\n  # ...\n\n# HTTPS certificate\n[[tls]]\n  # ...\n\n[[tls]]\n  # ...\n\n\n\n\n\n\nNote\n\n\nIf \ntls.entryPoints\n is not defined, the certificate is attached to all the \ndefaultEntryPoints\n with a TLS configuration.\n\n\n\n\n\n\nNote\n\n\nAdding certificates directly to the entryPoint is still maintained but certificates declared in this way cannot be managed dynamically.\nIt's recommended to use the file provider to declare certificates.\n\n\n\n\n\n\nWarning\n\n\nTOML templating cannot be used if rules are defined in the Traefik configuration file.\n\n\n\n\nRules in Dedicated Files\n\n\nTraefik allows defining rules in one or more separate files.\n\n\nOne Separate File\n\n\nYou have to specify the file path in the \nfile.filename\n option.\n\n\n# traefik.toml\ndefaultEntryPoints = [\nhttp\n, \nhttps\n]\n\n[entryPoints]\n  [entryPoints.http]\n    # ...\n  [entryPoints.https]\n    # ...\n\n[file]\n  filename = \nrules.toml\n\n  watch = true\n\n\n\n\nThe option \nfile.watch\n allows Traefik to watch file changes automatically.\n\n\nMultiple Separated Files\n\n\nYou could have multiple \n.toml\n files in a directory (and recursively in its sub-directories):\n\n\n[file]\n  directory = \n/path/to/config/\n\n  watch = true\n\n\n\n\nThe option \nfile.watch\n allows Traefik to watch file changes automatically.\n\n\nSeparate Files Content\n\n\nIf you are defining rules in one or more separate files, you can use two formats.\n\n\nSimple Format\n\n\nBackends, Frontends and TLS certificates are defined one at time, as described in the file \nrules.toml\n:\n\n\n# rules.toml\n[backends]\n  [backends.backend1]\n    # ...\n  [backends.backend2]\n    # ...\n\n[frontends]\n  [frontends.frontend1]\n  # ...\n  [frontends.frontend2]\n  # ...\n  [frontends.frontend3]\n  # ...\n\n# HTTPS certificate\n[[tls]]\n  # ...\n\n[[tls]]\n  # ...\n\n\n\n\nTOML Templating\n\n\n\n\nWarning\n\n\nTOML templating can only be used \nif rules are defined in one or more separate files\n.\nTemplating will not work in the Traefik configuration file.\n\n\n\n\nTraefik allows using TOML templating.\n\n\nThus, it's possible to define easily lot of Backends, Frontends and TLS certificates as described in the file \ntemplate-rules.toml\n :\n\n\n# template-rules.toml\n[backends]\n{{ range $i, $e := until 100 }}\n  [backends.backend{{ $e }}]\n    #...\n{{ end }}\n\n[frontends]\n{{ range $i, $e := until 100 }}\n  [frontends.frontend{{ $e }}]\n    #...\n{{ end }}\n\n\n# HTTPS certificate\n{{ range $i, $e := until 100 }}\n[[tls]]\n    #...\n{{ end }}", 
            "title": "File"
        }, 
        {
            "location": "/configuration/backends/file/#file-provider", 
            "text": "Traefik can be configured with a file.", 
            "title": "File Provider"
        }, 
        {
            "location": "/configuration/backends/file/#reference", 
            "text": "[file]\n\n# Backends\n[backends]\n\n  [backends.backend1]\n\n    [backends.backend1.servers]\n      [backends.backend1.servers.server0]\n        url =  http://10.10.10.1:80 \n        weight = 1\n      [backends.backend1.servers.server1]\n        url =  http://10.10.10.2:80 \n        weight = 2\n      # ...\n\n    [backends.backend1.circuitBreaker]\n      expression =  NetworkErrorRatio()   0.5 \n\n    [backends.backend1.responseForwarding]\n      flushInterval =  10ms \n\n    [backends.backend1.loadBalancer]\n      method =  drr \n      [backends.backend1.loadBalancer.stickiness]\n        cookieName =  foobar \n\n    [backends.backend1.maxConn]\n      amount = 10\n      extractorfunc =  request.host \n\n    [backends.backend1.healthCheck]\n      path =  /health \n      port = 88\n      interval =  30s \n      scheme =  http \n      hostname =  myhost.com \n      [backends.backend1.healthcheck.headers]\n        My-Custom-Header =  foo \n        My-Header =  bar \n\n  [backends.backend2]\n    # ...\n\n# Frontends\n[frontends]\n\n  [frontends.frontend1]\n    entryPoints = [ http ,  https ]\n    backend =  backend1 \n    passHostHeader = true\n    priority = 42\n\n    # Use frontends.frontend1.auth.basic below instead\n    basicAuth = [\n       test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ ,\n       test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 ,\n    ]\n    [frontends.frontend1.passTLSClientCert]\n        pem = true\n        [frontends.frontend1.passTLSClientCert.infos]\n            notBefore = true\n            notAfter = true\n            [frontends.frontend1.passTLSClientCert.infos.subject]\n                country = true\n                domainComponent = true\n                province = true\n                locality = true\n                organization = true\n                commonName = true\n                serialNumber = true\n            [frontends.frontend1.passTLSClientCert.infos.issuer]\n                country = true\n                domainComponent = true\n                province = true\n                locality = true\n                organization = true\n                commonName = true\n                serialNumber = true\n    [frontends.frontend1.auth]\n      headerField =  X-WebAuth-User \n      [frontends.frontend1.auth.basic]\n        removeHeader = true\n        users = [\n           test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ ,\n           test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 ,\n        ]\n        usersFile =  /path/to/.htpasswd \n      [frontends.frontend1.auth.digest]\n        removeHeader = true\n        users = [\n           test:traefik:a2688e031edb4be6a3797f3882655c05 ,\n           test2:traefik:518845800f9e2bfb1f1f740ec24f074e ,\n        ]\n        usersFile =  /path/to/.htdigest \n      [frontends.frontend1.auth.forward]\n        address =  https://authserver.com/auth \n        trustForwardHeader = true\n        authResponseHeaders = [ X-Auth-User ]\n        [frontends.frontend1.auth.forward.tls]\n          ca =  path/to/local.crt \n          caOptional = true\n          cert =  path/to/foo.cert \n          key =  path/to/foo.key \n          insecureSkipVerify = true\n\n    [frontends.frontend1.whiteList]\n      sourceRange = [ 10.42.0.0/16 ,  152.89.1.33/32 ,  afed:be44::/16 ]\n      useXForwardedFor = true\n\n    [frontends.frontend1.routes]\n      [frontends.frontend1.routes.route0]\n        rule =  Host:test.localhost \n      [frontends.frontend1.routes.Route1]\n        rule =  Method:GET \n      # ...\n\n    [frontends.frontend1.headers]\n      allowedHosts = [ foobar ,  foobar ]\n      hostsProxyHeaders = [ foobar ,  foobar ]\n      SSLRedirect = true\n      SSLTemporaryRedirect = true\n      SSLHost =  foobar \n      STSSeconds = 42\n      STSIncludeSubdomains = true\n      STSPreload = true\n      forceSTSHeader = true\n      frameDeny = true\n      customFrameOptionsValue =  foobar \n      contentTypeNosniff = true\n      browserXSSFilter = true\n      contentSecurityPolicy =  foobar \n      publicKey =  foobar \n      referrerPolicy =  foobar \n      isDevelopment = true\n      [frontends.frontend1.headers.customRequestHeaders]\n        X-Foo-Bar-01 =  foobar \n        X-Foo-Bar-02 =  foobar \n        # ...\n      [frontends.frontend1.headers.customResponseHeaders]\n        X-Foo-Bar-03 =  foobar \n        X-Foo-Bar-04 =  foobar \n        # ...\n      [frontends.frontend1.headers.SSLProxyHeaders]\n        X-Foo-Bar-05 =  foobar \n        X-Foo-Bar-06 =  foobar \n        # ...\n\n    [frontends.frontend1.errors]\n      [frontends.frontend1.errors.errorPage0]\n        status = [ 500-599 ]\n        backend =  error \n        query =  /{status}.html \n      [frontends.frontend1.errors.errorPage1]\n        status = [ 404 ,  403 ]\n        backend =  error \n        query =  /{status}.html \n      # ...\n\n    [frontends.frontend1.ratelimit]\n      extractorfunc =  client.ip \n        [frontends.frontend1.ratelimit.rateset.rateset1]\n          period =  10s \n          average = 100\n          burst = 200\n        [frontends.frontend1.ratelimit.rateset.rateset2]\n          period =  3s \n          average = 5\n          burst = 10\n        # ...\n\n    [frontends.frontend1.redirect]\n      entryPoint =  https \n      regex =  ^http://localhost/(.*) \n      replacement =  http://mydomain/$1 \n      permanent = true\n\n  [frontends.frontend2]\n    # ...\n\n# HTTPS certificates\n[[tls]]\n  entryPoints = [ https ]\n  [tls.certificate]\n    certFile =  path/to/my.cert \n    keyFile =  path/to/my.key \n\n[[tls]]\n  # ...", 
            "title": "Reference"
        }, 
        {
            "location": "/configuration/backends/file/#configuration-mode", 
            "text": "You have two choices:   Rules in Traefik configuration file  Rules in dedicated files   To enable the file backend, you must either pass the  --file  option to the Traefik binary or put the  [file]  section (with or without inner settings) in the configuration file.  The configuration file allows managing both backends/frontends and HTTPS certificates (which are not  Let's Encrypt  certificates generated through Traefik).  TOML templating can be used if rules are not defined in the Traefik configuration file.", 
            "title": "Configuration Mode"
        }, 
        {
            "location": "/configuration/backends/file/#rules-in-traefik-configuration-file", 
            "text": "Add your configuration at the end of the global configuration file  traefik.toml :  defaultEntryPoints = [ http ,  https ]\n\n[entryPoints]\n  [entryPoints.http]\n    # ...\n  [entryPoints.https]\n    # ...\n\n[file]\n\n# rules\n[backends]\n  [backends.backend1]\n    # ...\n  [backends.backend2]\n    # ...\n\n[frontends]\n  [frontends.frontend1]\n  # ...\n  [frontends.frontend2]\n  # ...\n  [frontends.frontend3]\n  # ...\n\n# HTTPS certificate\n[[tls]]\n  # ...\n\n[[tls]]\n  # ...   Note  If  tls.entryPoints  is not defined, the certificate is attached to all the  defaultEntryPoints  with a TLS configuration.    Note  Adding certificates directly to the entryPoint is still maintained but certificates declared in this way cannot be managed dynamically.\nIt's recommended to use the file provider to declare certificates.    Warning  TOML templating cannot be used if rules are defined in the Traefik configuration file.", 
            "title": "Rules in Traefik Configuration File"
        }, 
        {
            "location": "/configuration/backends/file/#rules-in-dedicated-files", 
            "text": "Traefik allows defining rules in one or more separate files.", 
            "title": "Rules in Dedicated Files"
        }, 
        {
            "location": "/configuration/backends/file/#one-separate-file", 
            "text": "You have to specify the file path in the  file.filename  option.  # traefik.toml\ndefaultEntryPoints = [ http ,  https ]\n\n[entryPoints]\n  [entryPoints.http]\n    # ...\n  [entryPoints.https]\n    # ...\n\n[file]\n  filename =  rules.toml \n  watch = true  The option  file.watch  allows Traefik to watch file changes automatically.", 
            "title": "One Separate File"
        }, 
        {
            "location": "/configuration/backends/file/#multiple-separated-files", 
            "text": "You could have multiple  .toml  files in a directory (and recursively in its sub-directories):  [file]\n  directory =  /path/to/config/ \n  watch = true  The option  file.watch  allows Traefik to watch file changes automatically.", 
            "title": "Multiple Separated Files"
        }, 
        {
            "location": "/configuration/backends/file/#separate-files-content", 
            "text": "If you are defining rules in one or more separate files, you can use two formats.", 
            "title": "Separate Files Content"
        }, 
        {
            "location": "/configuration/backends/file/#simple-format", 
            "text": "Backends, Frontends and TLS certificates are defined one at time, as described in the file  rules.toml :  # rules.toml\n[backends]\n  [backends.backend1]\n    # ...\n  [backends.backend2]\n    # ...\n\n[frontends]\n  [frontends.frontend1]\n  # ...\n  [frontends.frontend2]\n  # ...\n  [frontends.frontend3]\n  # ...\n\n# HTTPS certificate\n[[tls]]\n  # ...\n\n[[tls]]\n  # ...", 
            "title": "Simple Format"
        }, 
        {
            "location": "/configuration/backends/file/#toml-templating", 
            "text": "Warning  TOML templating can only be used  if rules are defined in one or more separate files .\nTemplating will not work in the Traefik configuration file.   Traefik allows using TOML templating.  Thus, it's possible to define easily lot of Backends, Frontends and TLS certificates as described in the file  template-rules.toml  :  # template-rules.toml\n[backends]\n{{ range $i, $e := until 100 }}\n  [backends.backend{{ $e }}]\n    #...\n{{ end }}\n\n[frontends]\n{{ range $i, $e := until 100 }}\n  [frontends.frontend{{ $e }}]\n    #...\n{{ end }}\n\n\n# HTTPS certificate\n{{ range $i, $e := until 100 }}\n[[tls]]\n    #...\n{{ end }}", 
            "title": "TOML Templating"
        }, 
        {
            "location": "/configuration/backends/kubernetes/", 
            "text": "Kubernetes Ingress Provider\n\n\nTraefik can be configured to use Kubernetes Ingress as a provider.\n\n\nSee also \nKubernetes user guide\n.\n\n\nConfiguration\n\n\n################################################################\n# Kubernetes Ingress Provider\n################################################################\n\n# Enable Kubernetes Ingress Provider.\n[kubernetes]\n\n# Kubernetes server endpoint.\n#\n# Optional for in-cluster configuration, required otherwise.\n# Default: empty\n#\n# endpoint = \nhttp://localhost:8080\n\n\n# Bearer token used for the Kubernetes client configuration.\n#\n# Optional\n# Default: empty\n#\n# token = \nmy token\n\n\n# Path to the certificate authority file.\n# Used for the Kubernetes client configuration.\n#\n# Optional\n# Default: empty\n#\n# certAuthFilePath = \n/my/ca.crt\n\n\n# Array of namespaces to watch.\n#\n# Optional\n# Default: all namespaces (empty array).\n#\n# namespaces = [\ndefault\n, \nproduction\n]\n\n# Ingress label selector to filter Ingress objects that should be processed.\n#\n# Optional\n# Default: empty (process all Ingresses)\n#\n# labelselector = \nA and not B\n\n\n# Value of `kubernetes.io/ingress.class` annotation that identifies Ingress objects to be processed.\n# If the parameter is non-empty, only Ingresses containing an annotation with the same value are processed.\n# Otherwise, Ingresses missing the annotation, having an empty value, or the value `traefik` are processed.\n#\n# Optional\n# Default: empty\n#\n# ingressClass = \ntraefik-internal\n\n\n# Disable PassHost Headers.\n#\n# Optional\n# Default: false\n#\n# disablePassHostHeaders = true\n\n# Enable PassTLSCert Headers.\n#\n# Optional\n# Default: false\n#\n# enablePassTLSCert = true\n\n# Throttle how frequently we refresh our configuration from Ingresses when there\n# are frequent changes.\n#\n# Optional\n# Default: 0 (no throttling)\n#\n# throttleDuration = 10s\n\n# Override default configuration template.\n#\n# Optional\n# Default: \nbuilt-in template\n\n#\n# filename = \nkubernetes.tmpl\n\n\n# Enable IngressEndpoint configuration.\n# This will allow Traefik to update the status section of ingress objects, if desired.\n#\n# Optional\n#\n# [kubernetes.ingressEndpoint]\n#\n# At least one must be configured.\n# `publishedservice` will override the `hostname` and `ip` settings if configured.\n#\n# hostname = \nlocalhost\n\n# ip = \n127.0.0.1\n\n# publishedService = \nnamespace/servicename\n\n\n\n\n\nendpoint\n\n\nThe Kubernetes server endpoint as URL.\n\n\nWhen deployed into Kubernetes, Traefik will read the environment variables \nKUBERNETES_SERVICE_HOST\n and \nKUBERNETES_SERVICE_PORT\n to construct the endpoint.\n\n\nThe access token will be looked up in \n/var/run/secrets/kubernetes.io/serviceaccount/token\n and the SSL CA certificate in \n/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n.\nBoth are provided mounted automatically when deployed inside Kubernetes.\n\n\nThe endpoint may be specified to override the environment variable values inside a cluster.\n\n\nWhen the environment variables are not found, Traefik will try to connect to the Kubernetes API server with an external-cluster client.\nIn this case, the endpoint is required.\nSpecifically, it may be set to the URL used by \nkubectl proxy\n to connect to a Kubernetes cluster using the granted authentication and authorization of the associated kubeconfig.\n\n\nlabelselector\n\n\nBy default, Traefik processes all Ingress objects in the configured namespaces.\nA label selector can be defined to filter on specific Ingress objects only.\n\n\nSee \nlabel-selectors\n for details.\n\n\ningressEndpoint\n\n\nYou can configure a static hostname or IP address that Traefik will add to the status section of Ingress objects that it manages.\nIf you prefer, you can provide a service, which traefik will copy the status spec from.\nThis will give more flexibility in cloud/dynamic environments.\n\n\nTLS communication between Traefik and backend pods\n\n\nTraefik automatically requests endpoint information based on the service provided in the ingress spec.\nAlthough traefik will connect directly to the endpoints (pods), it still checks the service port to see if TLS communication is required.\n\n\nThere are 3 ways to configure Traefik to use https to communicate with backend pods:\n\n\n\n\nIf the service port defined in the ingress spec is 443 (note that you can still use \ntargetPort\n to use a different port on your pod).\n\n\nIf the service port defined in the ingress spec has a name that starts with \nhttps\n (such as \nhttps-api\n, \nhttps-web\n or just \nhttps\n).\n\n\nIf the ingress spec includes the annotation \ningress.kubernetes.io/protocol: https\n.\n\n\n\n\nIf either of those configuration options exist, then the backend communication protocol is assumed to be TLS, and will connect via TLS automatically.\n\n\n\n\nNote\n\n\nPlease note that by enabling TLS communication between traefik and your pods, you will have to have trusted certificates that have the proper trust chain and IP subject name.\nIf this is not an option, you may need to skip TLS certificate verification.\nSee the \ninsecureSkipVerify\n setting for more details.\n\n\n\n\nAnnotations\n\n\nGeneral annotations\n\n\nThe following general annotations are applicable on the Ingress object:\n\n\n\n\n\n\n\n\nAnnotation\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/app-root: \"/index.html\"\n\n\nRedirects all requests for \n/\n to the defined path. (1)\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/error-pages: \nYML\n\n\nSee \ncustom error pages\n section. (2)\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/frontend-entry-points: http,https\n\n\nOverride the default frontend endpoints.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/pass-client-tls-cert: \nYML\n\n\nForward the client certificate following the configuration in YAML. (3)\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/pass-tls-cert: \"true\"\n\n\nOverride the default frontend PassTLSCert value. Default: \nfalse\n.(DEPRECATED)\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/preserve-host: \"true\"\n\n\nForward client \nHost\n header to the backend.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/priority: \"3\"\n\n\nOverride the default frontend rule priority.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/rate-limit: \nYML\n\n\nSee \nrate limiting\n section. (4)\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/redirect-entry-point: https\n\n\nEnables Redirect to another entryPoint for that frontend (e.g. HTTPS).\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/redirect-permanent: \"true\"\n\n\nReturn 301 instead of 302.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/redirect-regex: ^http://localhost/(.*)\n\n\nRedirect to another URL for that frontend. Must be set with \ntraefik.ingress.kubernetes.io/redirect-replacement\n.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/redirect-replacement: http://mydomain/$1\n\n\nRedirect to another URL for that frontend. Must be set with \ntraefik.ingress.kubernetes.io/redirect-regex\n.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/request-modifier: AddPrefix: /users\n\n\nAdds a \nrequest modifier\n to the backend request.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/rewrite-target: /users\n\n\nReplaces each matched Ingress path with the specified one, and adds the old path to the \nX-Replaced-Path\n header.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/rule-type: PathPrefixStrip\n\n\nOverrides the default frontend rule type. Only path-related matchers can be specified \n(\nPath\n, \nPathPrefix\n, \nPathStrip\n, \nPathPrefixStrip\n)\n.(5)\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/service-weights: \nYML\n\n\nSet ingress backend weights specified as percentage or decimal numbers in YAML. (6)\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/whitelist-source-range: \"1.2.3.0/24, fe80::/16\"\n\n\nA comma-separated list of IP ranges permitted for access (7).\n\n\n\n\n\n\ningress.kubernetes.io/whitelist-x-forwarded-for: \"true\"\n\n\nUse \nX-Forwarded-For\n header as valid source of IP for the white list.\n\n\n\n\n\n\ningress.kubernetes.io/protocol:\nNAME\n\n\nSet the protocol Traefik will use to communicate with pods. Acceptable protocols: http,https,h2c\n\n\n\n\n\n\n\n\n1\n \ntraefik.ingress.kubernetes.io/app-root\n:\nNon-root paths will not be affected by this annotation and handled normally.\nThis annotation may not be combined with other redirect annotations.\nTrying to do so will result in the other redirects being ignored.\nThis annotation can be used in combination with \ntraefik.ingress.kubernetes.io/redirect-permanent\n to configure whether the \napp-root\n redirect is a 301 or a 302.\n\n\n2\n \ntraefik.ingress.kubernetes.io/error-pages\n example:\n\n\nfoo:\n  status:\n  - \n404\n\n  backend: bar\n  query: /bar\nfii:\n  status:\n  - \n503\n\n  - \n500\n\n  backend: bar\n  query: /bir\n\n\n\n\n3\n \ntraefik.ingress.kubernetes.io/pass-client-tls-cert\n example:\n\n\n# add escaped pem in the `X-Forwarded-Tls-Client-Cert` header\npem: true\n# add escaped certificate following infos in the `X-Forwarded-Tls-Client-Cert-Infos` header\ninfos:\n  notafter: true\n  notbefore: true\n  sans: true\n  subject:\n    country: true\n    province: true\n    locality: true\n    organization: true\n    commonname: true\n    serialnumber: true\n\n\n\n\nIf \npem\n is set, it will add a \nX-Forwarded-Tls-Client-Cert\n header that contains the escaped pem as value.\nIf at least one flag of the \ninfos\n part is set, it will add a \nX-Forwarded-Tls-Client-Cert-Infos\n header that contains an escaped string composed of the client certificate data selected by the infos flags.\nThis infos part is composed like the following example (not escaped):\n\n\nSubject=\nC=FR,ST=SomeState,L=Lyon,O=Cheese,CN=*.cheese.org\n,NB=1531900816,NA=1563436816,SAN=*.cheese.org,*.cheese.net,cheese.in,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2\n\n\n\n\nNote these options work only with certificates issued by CAs included in the applicable \nEntryPoint ClientCA section\n; certificates from other CAs are not parsed or passed through as-is.\n\n\n4\n \ntraefik.ingress.kubernetes.io/rate-limit\n example:\n\n\nextractorfunc: client.ip\nrateset:\n  bar:\n    period: 3s\n    average: 6\n    burst: 9\n  foo:\n    period: 6s\n    average: 12\n    burst: 18\n\n\n\n\n5\n \ntraefik.ingress.kubernetes.io/rule-type\n\nNote: \nReplacePath\n is deprecated in this annotation, use the \ntraefik.ingress.kubernetes.io/request-modifier\n annotation instead. Default: \nPathPrefix\n.\n\n\n6\n \ntraefik.ingress.kubernetes.io/service-weights\n:\nService weights enable to split traffic across multiple backing services in a fine-grained manner.\n\n\nExample:\n\n\nservice_backend1: 12.50%\nservice_backend2: 12.50%\nservice_backend3: 75 # Same as 75%, the percentage sign is optional\n\n\n\n\nA single service backend definition may be omitted; in this case, Traefik auto-completes that service backend to 100% automatically.\nConveniently, users need not bother to compute the percentage remainder for a main service backend.\nFor instance, in the example above \nservice_backend3\n does not need to be specified to be assigned 75%.\n\n\n\n\nNote\n\n\nFor each service weight given, the Ingress specification must include a backend item with the corresponding \nserviceName\n and (if given) matching path.\n\n\n\n\nCurrently, 3 decimal places for the weight are supported.\nAn attempt to exceed the precision should be avoided as it may lead to percentage computation flaws and, in consequence, Ingress parsing errors.\n\n\nFor each path definition, this annotation will fail if:\n\n\n\n\nthe sum of backend weights exceeds 100% or\n\n\nthe sum of backend weights is less than 100% without one or more omitted backends\n\n\n\n\nSee also the \nuser guide section traffic splitting\n.\n\n\n7\n \ntraefik.ingress.kubernetes.io/whitelist-source-range\n:\nAll source IPs are permitted if the list is empty or a single range is ill-formatted.\nPlease note, you may have to set \nservice.spec.externalTrafficPolicy\n to the value \nLocal\n to preserve the source IP of the request for filtering.\nPlease see \nthis link\n for more information.\n\n\n\n\nNote\n\n\nPlease note that \ntraefik.ingress.kubernetes.io/redirect-regex\n and \ntraefik.ingress.kubernetes.io/redirect-replacement\n do not have to be set if \ntraefik.ingress.kubernetes.io/redirect-entry-point\n is defined for the redirection (they will not be used in this case).\n\n\n\n\nThe following annotations are applicable on the Service object associated with a particular Ingress object:\n\n\n\n\n\n\n\n\nAnnotation\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/buffering: \nYML\n\n\n(1) See the \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.loadbalancer.sticky: \"true\"\n\n\nEnable backend sticky sessions (DEPRECATED).\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/affinity: \"true\"\n\n\nEnable backend sticky sessions.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/circuit-breaker-expression: \nexpression\n\n\nSet the circuit breaker expression for the backend.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/responseforwarding-flushinterval: \"10ms\n\n\nDefines the interval between two flushes when forwarding response from backend to client.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/load-balancer-method: drr\n\n\nOverride the default \nwrr\n load balancer algorithm.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/max-conn-amount: \"10\"\n\n\nSets the maximum number of simultaneous connections to the backend.\nMust be used in conjunction with the label below to take effect.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/max-conn-extractor-func: client.ip\n\n\nSet the function to be used against the request to determine what to limit maximum connections to the backend by.\nMust be used in conjunction with the above label to take effect.\n\n\n\n\n\n\ntraefik.ingress.kubernetes.io/session-cookie-name: \nNAME\n\n\nManually set the cookie name for sticky sessions.\n\n\n\n\n\n\n\n\n1\n \ntraefik.ingress.kubernetes.io/buffering\n example:\n\n\nmaxrequestbodybytes: 10485760\nmemrequestbodybytes: 2097153\nmaxresponsebodybytes: 10485761\nmemresponsebodybytes: 2097152\nretryexpression: IsNetworkError() \n Attempts() \n= 2\n\n\n\n\n\n\nNote\n\n\ntraefik.ingress.kubernetes.io/\n and \ningress.kubernetes.io/\n are supported prefixes.\n\n\n\n\nCustom Headers Annotations\n\n\n\n\n\n\n\n\nAnnotation\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ningress.kubernetes.io/custom-request-headers: EXPR\n\n\nProvides the container with custom request headers that will be appended to each request forwarded to the container. Format: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ningress.kubernetes.io/custom-response-headers: EXPR\n\n\nAppends the headers to each response returned by the container, before forwarding the response to the client. Format: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\n\n\nSecurity Headers Annotations\n\n\nThe following security annotations are applicable on the Ingress object:\n\n\n\n\n\n\n\n\nAnnotation\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ningress.kubernetes.io/allowed-hosts: EXPR\n\n\nProvides a list of allowed hosts that requests will be processed. Format: \nHost1,Host2\n\n\n\n\n\n\ningress.kubernetes.io/browser-xss-filter: \"true\"\n\n\nAdds the X-XSS-Protection header with the value \n1; mode=block\n.\n\n\n\n\n\n\ningress.kubernetes.io/content-security-policy: VALUE\n\n\nAdds CSP Header with the custom value.\n\n\n\n\n\n\ningress.kubernetes.io/content-type-nosniff: \"true\"\n\n\nAdds the \nX-Content-Type-Options\n header with the value \nnosniff\n.\n\n\n\n\n\n\ningress.kubernetes.io/custom-browser-xss-value: VALUE\n\n\nSet custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.\n\n\n\n\n\n\ningress.kubernetes.io/custom-frame-options-value: VALUE\n\n\nOverrides the \nX-Frame-Options\n header with the custom value.\n\n\n\n\n\n\ningress.kubernetes.io/force-hsts: \"false\"\n\n\nAdds the STS  header to non-SSL requests.\n\n\n\n\n\n\ningress.kubernetes.io/frame-deny: \"true\"\n\n\nAdds the \nX-Frame-Options\n header with the value of \nDENY\n.\n\n\n\n\n\n\ningress.kubernetes.io/hsts-max-age: \"315360000\"\n\n\nSets the max-age of the HSTS header.\n\n\n\n\n\n\ningress.kubernetes.io/hsts-include-subdomains: \"true\"\n\n\nAdds the IncludeSubdomains section of the STS  header.\n\n\n\n\n\n\ningress.kubernetes.io/hsts-preload: \"true\"\n\n\nAdds the preload flag to the HSTS  header.\n\n\n\n\n\n\ningress.kubernetes.io/is-development: \"false\"\n\n\nThis will cause the \nAllowedHosts\n, \nSSLRedirect\n, and \nSTSSeconds\n/\nSTSIncludeSubdomains\n options to be ignored during development.\nWhen deploying to production, be sure to set this to false.\n\n\n\n\n\n\ningress.kubernetes.io/proxy-headers: EXPR\n\n\nProvides a list of headers that the proxied hostname may be stored. Format:  \nHEADER1,HEADER2\n\n\n\n\n\n\ningress.kubernetes.io/public-key: VALUE\n\n\nAdds HPKP header.\n\n\n\n\n\n\ningress.kubernetes.io/referrer-policy: VALUE\n\n\nAdds referrer policy  header.\n\n\n\n\n\n\ningress.kubernetes.io/ssl-redirect: \"true\"\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent.\n\n\n\n\n\n\ningress.kubernetes.io/ssl-temporary-redirect: \"true\"\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.\n\n\n\n\n\n\ningress.kubernetes.io/ssl-host: HOST\n\n\nThis setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.\n\n\n\n\n\n\ningress.kubernetes.io/ssl-force-host: \"true\"\n\n\nIf \nSSLForceHost\n is \ntrue\n and \nSSLHost\n is set, requests will be forced to use \nSSLHost\n even the ones that are already using SSL. Default is false.\n\n\n\n\n\n\ningress.kubernetes.io/ssl-proxy-headers: EXPR\n\n\nHeader combinations that would signify a proper SSL Request (Such as \nX-Forwarded-For:https\n). Format: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\n\n\nAuthentication\n\n\nAdditional authentication annotations can be added to the Ingress object.\nThe source of the authentication is a Secret object that contains the credentials.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nbasic\n\n\ndigest\n\n\nforward\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ningress.kubernetes.io/auth-type: basic\n\n\nx\n\n\nx\n\n\nx\n\n\nContains the authentication type: \nbasic\n, \ndigest\n, \nforward\n.\n\n\n\n\n\n\ningress.kubernetes.io/auth-secret: mysecret\n\n\nx\n\n\nx\n\n\n\n\nName of Secret containing the username and password with access to the paths defined in the Ingress object.\n\n\n\n\n\n\ningress.kubernetes.io/auth-remove-header: true\n\n\nx\n\n\nx\n\n\n\n\nIf set to \ntrue\n removes the \nAuthorization\n header.\n\n\n\n\n\n\ningress.kubernetes.io/auth-header-field: X-WebAuth-User\n\n\nx\n\n\nx\n\n\n\n\nPass Authenticated user to application via headers.\n\n\n\n\n\n\ningress.kubernetes.io/auth-url: https://example.com\n\n\n\n\n\n\nx\n\n\nThe URL of the authentication server\n.\n\n\n\n\n\n\ningress.kubernetes.io/auth-trust-headers: false\n\n\n\n\n\n\nx\n\n\nTrust \nX-Forwarded-*\n headers.\n\n\n\n\n\n\ningress.kubernetes.io/auth-response-headers: X-Auth-User, X-Secret\n\n\n\n\n\n\nx\n\n\nCopy headers from the authentication server to the request.\n\n\n\n\n\n\ningress.kubernetes.io/auth-tls-secret: secret\n\n\n\n\n\n\nx\n\n\nName of Secret containing the certificate and key for the forward auth.\n\n\n\n\n\n\ningress.kubernetes.io/auth-tls-insecure\n\n\n\n\n\n\nx\n\n\nIf set to \ntrue\n invalid SSL certificates are accepted.\n\n\n\n\n\n\n\n\nThe secret must be created in the same namespace as the Ingress object.\n\n\nThe following limitations hold for basic/digest auth:\n\n\n\n\nThe realm is not configurable; the only supported (and default) value is \ntraefik\n.\n\n\nThe Secret must contain a single file only.\n\n\n\n\nTLS certificates management\n\n\nTLS certificates can be managed in Secrets objects.\nMore information are available in the  \nUser Guide\n.\n\n\n\n\nNote\n\n\nOnly TLS certificates provided by users can be stored in Kubernetes Secrets.\n\nLet's Encrypt\n certificates cannot be managed in Kubernets Secrets yet.\n\n\n\n\nGlobal Default Backend Ingresses\n\n\nIngresses can be created that look like the following:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: cheese\nspec:\n  backend:\n    serviceName: stilton\n    servicePort: 80\n\n\n\n\nThis ingress follows the \nGlobal Default Backend\n property of ingresses.\nThis will allow users to create a \"default backend\" that will match all unmatched requests.\n\n\n\n\nNote\n\n\nDue to Traefik's use of priorities, you may have to set this ingress priority lower than other ingresses in your environment, to avoid this global ingress from satisfying requests that \ncould\n match other ingresses.\nTo do this, use the \ntraefik.ingress.kubernetes.io/priority\n annotation (as seen in \nGeneral Annotations\n) on your ingresses accordingly.", 
            "title": "Kubernetes Ingress"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#kubernetes-ingress-provider", 
            "text": "Traefik can be configured to use Kubernetes Ingress as a provider.  See also  Kubernetes user guide .", 
            "title": "Kubernetes Ingress Provider"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#configuration", 
            "text": "################################################################\n# Kubernetes Ingress Provider\n################################################################\n\n# Enable Kubernetes Ingress Provider.\n[kubernetes]\n\n# Kubernetes server endpoint.\n#\n# Optional for in-cluster configuration, required otherwise.\n# Default: empty\n#\n# endpoint =  http://localhost:8080 \n\n# Bearer token used for the Kubernetes client configuration.\n#\n# Optional\n# Default: empty\n#\n# token =  my token \n\n# Path to the certificate authority file.\n# Used for the Kubernetes client configuration.\n#\n# Optional\n# Default: empty\n#\n# certAuthFilePath =  /my/ca.crt \n\n# Array of namespaces to watch.\n#\n# Optional\n# Default: all namespaces (empty array).\n#\n# namespaces = [ default ,  production ]\n\n# Ingress label selector to filter Ingress objects that should be processed.\n#\n# Optional\n# Default: empty (process all Ingresses)\n#\n# labelselector =  A and not B \n\n# Value of `kubernetes.io/ingress.class` annotation that identifies Ingress objects to be processed.\n# If the parameter is non-empty, only Ingresses containing an annotation with the same value are processed.\n# Otherwise, Ingresses missing the annotation, having an empty value, or the value `traefik` are processed.\n#\n# Optional\n# Default: empty\n#\n# ingressClass =  traefik-internal \n\n# Disable PassHost Headers.\n#\n# Optional\n# Default: false\n#\n# disablePassHostHeaders = true\n\n# Enable PassTLSCert Headers.\n#\n# Optional\n# Default: false\n#\n# enablePassTLSCert = true\n\n# Throttle how frequently we refresh our configuration from Ingresses when there\n# are frequent changes.\n#\n# Optional\n# Default: 0 (no throttling)\n#\n# throttleDuration = 10s\n\n# Override default configuration template.\n#\n# Optional\n# Default:  built-in template \n#\n# filename =  kubernetes.tmpl \n\n# Enable IngressEndpoint configuration.\n# This will allow Traefik to update the status section of ingress objects, if desired.\n#\n# Optional\n#\n# [kubernetes.ingressEndpoint]\n#\n# At least one must be configured.\n# `publishedservice` will override the `hostname` and `ip` settings if configured.\n#\n# hostname =  localhost \n# ip =  127.0.0.1 \n# publishedService =  namespace/servicename", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#endpoint", 
            "text": "The Kubernetes server endpoint as URL.  When deployed into Kubernetes, Traefik will read the environment variables  KUBERNETES_SERVICE_HOST  and  KUBERNETES_SERVICE_PORT  to construct the endpoint.  The access token will be looked up in  /var/run/secrets/kubernetes.io/serviceaccount/token  and the SSL CA certificate in  /var/run/secrets/kubernetes.io/serviceaccount/ca.crt .\nBoth are provided mounted automatically when deployed inside Kubernetes.  The endpoint may be specified to override the environment variable values inside a cluster.  When the environment variables are not found, Traefik will try to connect to the Kubernetes API server with an external-cluster client.\nIn this case, the endpoint is required.\nSpecifically, it may be set to the URL used by  kubectl proxy  to connect to a Kubernetes cluster using the granted authentication and authorization of the associated kubeconfig.", 
            "title": "endpoint"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#labelselector", 
            "text": "By default, Traefik processes all Ingress objects in the configured namespaces.\nA label selector can be defined to filter on specific Ingress objects only.  See  label-selectors  for details.", 
            "title": "labelselector"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#ingressendpoint", 
            "text": "You can configure a static hostname or IP address that Traefik will add to the status section of Ingress objects that it manages.\nIf you prefer, you can provide a service, which traefik will copy the status spec from.\nThis will give more flexibility in cloud/dynamic environments.", 
            "title": "ingressEndpoint"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#tls-communication-between-traefik-and-backend-pods", 
            "text": "Traefik automatically requests endpoint information based on the service provided in the ingress spec.\nAlthough traefik will connect directly to the endpoints (pods), it still checks the service port to see if TLS communication is required.  There are 3 ways to configure Traefik to use https to communicate with backend pods:   If the service port defined in the ingress spec is 443 (note that you can still use  targetPort  to use a different port on your pod).  If the service port defined in the ingress spec has a name that starts with  https  (such as  https-api ,  https-web  or just  https ).  If the ingress spec includes the annotation  ingress.kubernetes.io/protocol: https .   If either of those configuration options exist, then the backend communication protocol is assumed to be TLS, and will connect via TLS automatically.   Note  Please note that by enabling TLS communication between traefik and your pods, you will have to have trusted certificates that have the proper trust chain and IP subject name.\nIf this is not an option, you may need to skip TLS certificate verification.\nSee the  insecureSkipVerify  setting for more details.", 
            "title": "TLS communication between Traefik and backend pods"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#annotations", 
            "text": "", 
            "title": "Annotations"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#general-annotations", 
            "text": "The following general annotations are applicable on the Ingress object:     Annotation  Description      traefik.ingress.kubernetes.io/app-root: \"/index.html\"  Redirects all requests for  /  to the defined path. (1)    traefik.ingress.kubernetes.io/error-pages:  YML  See  custom error pages  section. (2)    traefik.ingress.kubernetes.io/frontend-entry-points: http,https  Override the default frontend endpoints.    traefik.ingress.kubernetes.io/pass-client-tls-cert:  YML  Forward the client certificate following the configuration in YAML. (3)    traefik.ingress.kubernetes.io/pass-tls-cert: \"true\"  Override the default frontend PassTLSCert value. Default:  false .(DEPRECATED)    traefik.ingress.kubernetes.io/preserve-host: \"true\"  Forward client  Host  header to the backend.    traefik.ingress.kubernetes.io/priority: \"3\"  Override the default frontend rule priority.    traefik.ingress.kubernetes.io/rate-limit:  YML  See  rate limiting  section. (4)    traefik.ingress.kubernetes.io/redirect-entry-point: https  Enables Redirect to another entryPoint for that frontend (e.g. HTTPS).    traefik.ingress.kubernetes.io/redirect-permanent: \"true\"  Return 301 instead of 302.    traefik.ingress.kubernetes.io/redirect-regex: ^http://localhost/(.*)  Redirect to another URL for that frontend. Must be set with  traefik.ingress.kubernetes.io/redirect-replacement .    traefik.ingress.kubernetes.io/redirect-replacement: http://mydomain/$1  Redirect to another URL for that frontend. Must be set with  traefik.ingress.kubernetes.io/redirect-regex .    traefik.ingress.kubernetes.io/request-modifier: AddPrefix: /users  Adds a  request modifier  to the backend request.    traefik.ingress.kubernetes.io/rewrite-target: /users  Replaces each matched Ingress path with the specified one, and adds the old path to the  X-Replaced-Path  header.    traefik.ingress.kubernetes.io/rule-type: PathPrefixStrip  Overrides the default frontend rule type. Only path-related matchers can be specified  ( Path ,  PathPrefix ,  PathStrip ,  PathPrefixStrip ) .(5)    traefik.ingress.kubernetes.io/service-weights:  YML  Set ingress backend weights specified as percentage or decimal numbers in YAML. (6)    traefik.ingress.kubernetes.io/whitelist-source-range: \"1.2.3.0/24, fe80::/16\"  A comma-separated list of IP ranges permitted for access (7).    ingress.kubernetes.io/whitelist-x-forwarded-for: \"true\"  Use  X-Forwarded-For  header as valid source of IP for the white list.    ingress.kubernetes.io/protocol: NAME  Set the protocol Traefik will use to communicate with pods. Acceptable protocols: http,https,h2c     1   traefik.ingress.kubernetes.io/app-root :\nNon-root paths will not be affected by this annotation and handled normally.\nThis annotation may not be combined with other redirect annotations.\nTrying to do so will result in the other redirects being ignored.\nThis annotation can be used in combination with  traefik.ingress.kubernetes.io/redirect-permanent  to configure whether the  app-root  redirect is a 301 or a 302.  2   traefik.ingress.kubernetes.io/error-pages  example:  foo:\n  status:\n  -  404 \n  backend: bar\n  query: /bar\nfii:\n  status:\n  -  503 \n  -  500 \n  backend: bar\n  query: /bir  3   traefik.ingress.kubernetes.io/pass-client-tls-cert  example:  # add escaped pem in the `X-Forwarded-Tls-Client-Cert` header\npem: true\n# add escaped certificate following infos in the `X-Forwarded-Tls-Client-Cert-Infos` header\ninfos:\n  notafter: true\n  notbefore: true\n  sans: true\n  subject:\n    country: true\n    province: true\n    locality: true\n    organization: true\n    commonname: true\n    serialnumber: true  If  pem  is set, it will add a  X-Forwarded-Tls-Client-Cert  header that contains the escaped pem as value.\nIf at least one flag of the  infos  part is set, it will add a  X-Forwarded-Tls-Client-Cert-Infos  header that contains an escaped string composed of the client certificate data selected by the infos flags.\nThis infos part is composed like the following example (not escaped):  Subject= C=FR,ST=SomeState,L=Lyon,O=Cheese,CN=*.cheese.org ,NB=1531900816,NA=1563436816,SAN=*.cheese.org,*.cheese.net,cheese.in,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2  Note these options work only with certificates issued by CAs included in the applicable  EntryPoint ClientCA section ; certificates from other CAs are not parsed or passed through as-is.  4   traefik.ingress.kubernetes.io/rate-limit  example:  extractorfunc: client.ip\nrateset:\n  bar:\n    period: 3s\n    average: 6\n    burst: 9\n  foo:\n    period: 6s\n    average: 12\n    burst: 18  5   traefik.ingress.kubernetes.io/rule-type \nNote:  ReplacePath  is deprecated in this annotation, use the  traefik.ingress.kubernetes.io/request-modifier  annotation instead. Default:  PathPrefix .  6   traefik.ingress.kubernetes.io/service-weights :\nService weights enable to split traffic across multiple backing services in a fine-grained manner.  Example:  service_backend1: 12.50%\nservice_backend2: 12.50%\nservice_backend3: 75 # Same as 75%, the percentage sign is optional  A single service backend definition may be omitted; in this case, Traefik auto-completes that service backend to 100% automatically.\nConveniently, users need not bother to compute the percentage remainder for a main service backend.\nFor instance, in the example above  service_backend3  does not need to be specified to be assigned 75%.   Note  For each service weight given, the Ingress specification must include a backend item with the corresponding  serviceName  and (if given) matching path.   Currently, 3 decimal places for the weight are supported.\nAn attempt to exceed the precision should be avoided as it may lead to percentage computation flaws and, in consequence, Ingress parsing errors.  For each path definition, this annotation will fail if:   the sum of backend weights exceeds 100% or  the sum of backend weights is less than 100% without one or more omitted backends   See also the  user guide section traffic splitting .  7   traefik.ingress.kubernetes.io/whitelist-source-range :\nAll source IPs are permitted if the list is empty or a single range is ill-formatted.\nPlease note, you may have to set  service.spec.externalTrafficPolicy  to the value  Local  to preserve the source IP of the request for filtering.\nPlease see  this link  for more information.   Note  Please note that  traefik.ingress.kubernetes.io/redirect-regex  and  traefik.ingress.kubernetes.io/redirect-replacement  do not have to be set if  traefik.ingress.kubernetes.io/redirect-entry-point  is defined for the redirection (they will not be used in this case).   The following annotations are applicable on the Service object associated with a particular Ingress object:     Annotation  Description      traefik.ingress.kubernetes.io/buffering:  YML  (1) See the  buffering  section.    traefik.backend.loadbalancer.sticky: \"true\"  Enable backend sticky sessions (DEPRECATED).    traefik.ingress.kubernetes.io/affinity: \"true\"  Enable backend sticky sessions.    traefik.ingress.kubernetes.io/circuit-breaker-expression:  expression  Set the circuit breaker expression for the backend.    traefik.ingress.kubernetes.io/responseforwarding-flushinterval: \"10ms  Defines the interval between two flushes when forwarding response from backend to client.    traefik.ingress.kubernetes.io/load-balancer-method: drr  Override the default  wrr  load balancer algorithm.    traefik.ingress.kubernetes.io/max-conn-amount: \"10\"  Sets the maximum number of simultaneous connections to the backend. Must be used in conjunction with the label below to take effect.    traefik.ingress.kubernetes.io/max-conn-extractor-func: client.ip  Set the function to be used against the request to determine what to limit maximum connections to the backend by. Must be used in conjunction with the above label to take effect.    traefik.ingress.kubernetes.io/session-cookie-name:  NAME  Manually set the cookie name for sticky sessions.     1   traefik.ingress.kubernetes.io/buffering  example:  maxrequestbodybytes: 10485760\nmemrequestbodybytes: 2097153\nmaxresponsebodybytes: 10485761\nmemresponsebodybytes: 2097152\nretryexpression: IsNetworkError()   Attempts()  = 2   Note  traefik.ingress.kubernetes.io/  and  ingress.kubernetes.io/  are supported prefixes.", 
            "title": "General annotations"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#custom-headers-annotations", 
            "text": "Annotation  Description      ingress.kubernetes.io/custom-request-headers: EXPR  Provides the container with custom request headers that will be appended to each request forwarded to the container. Format:  HEADER:value HEADER2:value2    ingress.kubernetes.io/custom-response-headers: EXPR  Appends the headers to each response returned by the container, before forwarding the response to the client. Format:  HEADER:value HEADER2:value2", 
            "title": "Custom Headers Annotations"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#security-headers-annotations", 
            "text": "The following security annotations are applicable on the Ingress object:     Annotation  Description      ingress.kubernetes.io/allowed-hosts: EXPR  Provides a list of allowed hosts that requests will be processed. Format:  Host1,Host2    ingress.kubernetes.io/browser-xss-filter: \"true\"  Adds the X-XSS-Protection header with the value  1; mode=block .    ingress.kubernetes.io/content-security-policy: VALUE  Adds CSP Header with the custom value.    ingress.kubernetes.io/content-type-nosniff: \"true\"  Adds the  X-Content-Type-Options  header with the value  nosniff .    ingress.kubernetes.io/custom-browser-xss-value: VALUE  Set custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.    ingress.kubernetes.io/custom-frame-options-value: VALUE  Overrides the  X-Frame-Options  header with the custom value.    ingress.kubernetes.io/force-hsts: \"false\"  Adds the STS  header to non-SSL requests.    ingress.kubernetes.io/frame-deny: \"true\"  Adds the  X-Frame-Options  header with the value of  DENY .    ingress.kubernetes.io/hsts-max-age: \"315360000\"  Sets the max-age of the HSTS header.    ingress.kubernetes.io/hsts-include-subdomains: \"true\"  Adds the IncludeSubdomains section of the STS  header.    ingress.kubernetes.io/hsts-preload: \"true\"  Adds the preload flag to the HSTS  header.    ingress.kubernetes.io/is-development: \"false\"  This will cause the  AllowedHosts ,  SSLRedirect , and  STSSeconds / STSIncludeSubdomains  options to be ignored during development. When deploying to production, be sure to set this to false.    ingress.kubernetes.io/proxy-headers: EXPR  Provides a list of headers that the proxied hostname may be stored. Format:   HEADER1,HEADER2    ingress.kubernetes.io/public-key: VALUE  Adds HPKP header.    ingress.kubernetes.io/referrer-policy: VALUE  Adds referrer policy  header.    ingress.kubernetes.io/ssl-redirect: \"true\"  Forces the frontend to redirect to SSL if a non-SSL request is sent.    ingress.kubernetes.io/ssl-temporary-redirect: \"true\"  Forces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.    ingress.kubernetes.io/ssl-host: HOST  This setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.    ingress.kubernetes.io/ssl-force-host: \"true\"  If  SSLForceHost  is  true  and  SSLHost  is set, requests will be forced to use  SSLHost  even the ones that are already using SSL. Default is false.    ingress.kubernetes.io/ssl-proxy-headers: EXPR  Header combinations that would signify a proper SSL Request (Such as  X-Forwarded-For:https ). Format:  HEADER:value HEADER2:value2", 
            "title": "Security Headers Annotations"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#authentication", 
            "text": "Additional authentication annotations can be added to the Ingress object.\nThe source of the authentication is a Secret object that contains the credentials.     Annotation  basic  digest  forward  Description      ingress.kubernetes.io/auth-type: basic  x  x  x  Contains the authentication type:  basic ,  digest ,  forward .    ingress.kubernetes.io/auth-secret: mysecret  x  x   Name of Secret containing the username and password with access to the paths defined in the Ingress object.    ingress.kubernetes.io/auth-remove-header: true  x  x   If set to  true  removes the  Authorization  header.    ingress.kubernetes.io/auth-header-field: X-WebAuth-User  x  x   Pass Authenticated user to application via headers.    ingress.kubernetes.io/auth-url: https://example.com    x  The URL of the authentication server .    ingress.kubernetes.io/auth-trust-headers: false    x  Trust  X-Forwarded-*  headers.    ingress.kubernetes.io/auth-response-headers: X-Auth-User, X-Secret    x  Copy headers from the authentication server to the request.    ingress.kubernetes.io/auth-tls-secret: secret    x  Name of Secret containing the certificate and key for the forward auth.    ingress.kubernetes.io/auth-tls-insecure    x  If set to  true  invalid SSL certificates are accepted.     The secret must be created in the same namespace as the Ingress object.  The following limitations hold for basic/digest auth:   The realm is not configurable; the only supported (and default) value is  traefik .  The Secret must contain a single file only.", 
            "title": "Authentication"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#tls-certificates-management", 
            "text": "TLS certificates can be managed in Secrets objects.\nMore information are available in the   User Guide .   Note  Only TLS certificates provided by users can be stored in Kubernetes Secrets. Let's Encrypt  certificates cannot be managed in Kubernets Secrets yet.", 
            "title": "TLS certificates management"
        }, 
        {
            "location": "/configuration/backends/kubernetes/#global-default-backend-ingresses", 
            "text": "Ingresses can be created that look like the following:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: cheese\nspec:\n  backend:\n    serviceName: stilton\n    servicePort: 80  This ingress follows the  Global Default Backend  property of ingresses.\nThis will allow users to create a \"default backend\" that will match all unmatched requests.   Note  Due to Traefik's use of priorities, you may have to set this ingress priority lower than other ingresses in your environment, to avoid this global ingress from satisfying requests that  could  match other ingresses.\nTo do this, use the  traefik.ingress.kubernetes.io/priority  annotation (as seen in  General Annotations ) on your ingresses accordingly.", 
            "title": "Global Default Backend Ingresses"
        }, 
        {
            "location": "/configuration/backends/marathon/", 
            "text": "Marathon Provider\n\n\nTraefik can be configured to use Marathon as a provider.\n\n\nSee also \nMarathon user guide\n.\n\n\nConfiguration\n\n\n################################################################\n# Mesos/Marathon Provider\n################################################################\n\n# Enable Marathon Provider.\n[marathon]\n\n# Marathon server endpoint.\n# You can also specify multiple endpoint for Marathon:\n# endpoint = \nhttp://10.241.1.71:8080,10.241.1.72:8080,10.241.1.73:8080\n\n#\n# Required\n# Default: \nhttp://127.0.0.1:8080\n\n#\nendpoint = \nhttp://127.0.0.1:8080\n\n\n# Enable watch Marathon changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the \ntraefik.domain\n label on an application.\n#\n# Required\n#\ndomain = \nmarathon.localhost\n\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename = \nmarathon.tmpl\n\n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# - \n1\n: previous template version (must be used only with older custom templates, see \nfilename\n)\n# - \n2\n: current template version (must be used to force template version when \nfilename\n is used)\n#\n# templateVersion = 2\n\n# Expose Marathon apps by default in Traefik.\n#\n# Optional\n# Default: true\n#\n# exposedByDefault = false\n\n# Convert Marathon groups to subdomains.\n# Default behavior: /foo/bar/myapp =\n foo-bar-myapp.{defaultDomain}\n# with groupsAsSubDomains enabled: /foo/bar/myapp =\n myapp.bar.foo.{defaultDomain}\n#\n# Optional\n# Default: false\n#\n# groupsAsSubDomains = true\n\n# Enable compatibility with marathon-lb labels.\n#\n# Optional\n# Default: false\n#\n# marathonLBCompatibility = true\n\n# Enable filtering using Marathon constraints..\n# If enabled, Traefik will read Marathon constraints, as defined in https://mesosphere.github.io/marathon/docs/constraints.html\n# Each individual constraint will be treated as a verbatim compounded tag.\n# i.e. \nrack_id:CLUSTER:rack-1\n, with all constraint groups concatenated together using \n:\n\n#\n# Optional\n# Default: false\n#\n# filterMarathonConstraints = true\n\n# Enable Marathon basic authentication.\n#\n# Optional\n#\n#    [marathon.basic]\n#    httpBasicAuthUser = \nfoo\n\n#    httpBasicPassword = \nbar\n\n\n# TLS client configuration. https://golang.org/pkg/crypto/tls/#Config\n#\n# Optional\n#\n#    [marathon.TLS]\n#    CA = \n/etc/ssl/ca.crt\n\n#    Cert = \n/etc/ssl/marathon.cert\n\n#    Key = \n/etc/ssl/marathon.key\n\n#    insecureSkipVerify = true\n\n# DCOSToken for DCOS environment.\n# This will override the Authorization header.\n#\n# Optional\n#\n# dcosToken = \nxxxxxx\n\n\n# Override DialerTimeout.\n# Amount of time to allow the Marathon provider to wait to open a TCP connection\n# to a Marathon master.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw\n# values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n#\n# Optional\n# Default: \n5s\n\n#\n# dialerTimeout = \n5s\n\n\n# Override ResponseHeaderTimeout.\n# Amount of time to allow the Marathon provider to wait until the first response\n# header from the Marathon master is received.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw\n# values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n#\n# Optional\n# Default: \n60s\n\n#\n# responseHeaderTimeout = \n60s\n\n\n# Override TLSHandshakeTimeout.\n# Amount of time to allow the Marathon provider to wait until the TLS\n# handshake completes.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw\n# values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n#\n# Optional\n# Default: \n5s\n\n#\n# TLSHandshakeTimeout = \n5s\n\n\n# Set the TCP Keep Alive interval for the Marathon HTTP Client.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw\n# values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n#\n# Optional\n# Default: \n10s\n\n#\n# keepAlive = \n10s\n\n\n# By default, a task's IP address (as returned by the Marathon API) is used as\n# backend server if an IP-per-task configuration can be found; otherwise, the\n# name of the host running the task is used.\n# The latter behavior can be enforced by enabling this switch.\n#\n# Optional\n# Default: false\n#\n# forceTaskHostname = true\n\n# Applications may define readiness checks which are probed by Marathon during\n# deployments periodically and the results exposed via the API.\n# Enabling the following parameter causes Traefik to filter out tasks\n# whose readiness checks have not succeeded.\n# Note that the checks are only valid at deployment times.\n# See the Marathon guide for details.\n#\n# Optional\n# Default: false\n#\n# respectReadinessChecks = true\n\n\n\n\nTo enable constraints see \nprovider-specific constraints section\n.\n\n\nLabels: overriding default behavior\n\n\nMarathon labels may be used to dynamically change the routing and forwarding behavior.\n\n\nThey may be specified on one of two levels: Application or service.\n\n\nApplication Level\n\n\nThe following labels can be defined on Marathon applications. They adjust the behavior for the entire application.\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.domain\n\n\nSets the default base domain used for the frontend rules.\n\n\n\n\n\n\ntraefik.enable=false\n\n\nDisables this container in Traefik.\n\n\n\n\n\n\ntraefik.port=80\n\n\nRegisters this port. Useful when the container exposes multiples ports.\n\n\n\n\n\n\ntraefik.portIndex=1\n\n\nRegisters port by index in the application's ports array. Useful when the application exposes multiple ports.\n\n\n\n\n\n\ntraefik.protocol=https\n\n\nOverrides the default \nhttp\n protocol.\n\n\n\n\n\n\ntraefik.weight=10\n\n\nAssigns this weight to the container.\n\n\n\n\n\n\ntraefik.backend=foo\n\n\nOverrides the application name by \nfoo\n in the generated name of the backend.\n\n\n\n\n\n\ntraefik.backend.buffering.maxRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.maxResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.retryExpression=EXPR\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.circuitbreaker.expression=EXPR\n\n\nCreates a \ncircuit breaker\n to be used against the backend\n\n\n\n\n\n\ntraefik.backend.responseForwarding.flushInterval=10ms\n\n\nDefines the interval between two flushes when forwarding response from backend to client.\n\n\n\n\n\n\ntraefik.backend.healthcheck.path=/health\n\n\nEnables health check for the backend, hitting the container at \npath\n.\n\n\n\n\n\n\ntraefik.backend.healthcheck.interval=1s\n\n\nDefines the health check interval. (Default: 30s)\n\n\n\n\n\n\ntraefik.backend.healthcheck.port=8080\n\n\nSets a different port for the health check.\n\n\n\n\n\n\ntraefik.backend.healthcheck.scheme=http\n\n\nOverrides the server URL scheme.\n\n\n\n\n\n\ntraefik.backend.healthcheck.hostname=foobar.com\n\n\nDefines the health check hostname.\n\n\n\n\n\n\ntraefik.backend.healthcheck.headers=EXPR\n\n\nDefines the health check request headers \nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.backend.loadbalancer.method=drr\n\n\nOverrides the default \nwrr\n load balancer algorithm\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness=true\n\n\nEnables backend sticky sessions\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness.cookieName=NAME\n\n\nSets the cookie name manually for sticky sessions\n\n\n\n\n\n\ntraefik.backend.loadbalancer.sticky=true\n\n\nEnables backend sticky sessions (DEPRECATED)\n\n\n\n\n\n\ntraefik.backend.maxconn.amount=10\n\n\nSets a maximum number of connections to the backend.\nMust be used in conjunction with the below label to take effect.\n\n\n\n\n\n\ntraefik.backend.maxconn.extractorfunc=client.ip\n\n\nSets the function to be used against the request to determine what to limit maximum connections to the backend by.\nMust be used in conjunction with the above label to take effect.\n\n\n\n\n\n\ntraefik.frontend.auth.basic=EXPR\n\n\nSets basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n (DEPRECATED).\n\n\n\n\n\n\ntraefik.frontend.auth.basic.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\ntraefik.frontend.auth.basic.users=EXPR\n\n\nSets basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n.\n\n\n\n\n\n\ntraefik.frontend.auth.basic.usersFile=/path/.htpasswd\n\n\nSets basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.users=EXPR\n\n\nSets digest authentication to this frontend in CSV format: \nUser:Realm:Hash,User:Realm:Hash\n.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.usersFile=/path/.htdigest\n\n\nSets digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.address=https://example.com\n\n\nSets the URL of the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.authResponseHeaders=EXPR\n\n\nSets the forward authentication authResponseHeaders in CSV format: \nX-Auth-User,X-Auth-Header\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.ca=/path/ca.pem\n\n\nSets the Certificate Authority (CA) for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.caOptional=true\n\n\nChecks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.cert=/path/server.pem\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.insecureSkipVerify=true\n\n\nIf set to true invalid SSL certificates are accepted.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.key=/path/server.key\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.trustForwardHeader=true\n\n\nTrusts X-Forwarded-* headers.\n\n\n\n\n\n\ntraefik.frontend.auth.headerField=X-WebAuth-User\n\n\nSets the header used to pass the authenticated user to the application.\n\n\n\n\n\n\ntraefik.frontend.auth.removeHeader=true\n\n\nIf set to true, removes the Authorization header.\n\n\n\n\n\n\ntraefik.frontend.entryPoints=http,https\n\n\nAssigns this frontend to entry points \nhttp\n and \nhttps\n.\nOverrides \ndefaultEntryPoints\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.backend=NAME\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.query=PATH\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.status=RANGE\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.passHostHeader=true\n\n\nForwards client \nHost\n header to the backend.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.commonName=true\n\n\nAdd the issuer.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.country=true\n\n\nAdd the issuer.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.domainComponent=true\n\n\nAdd the issuer.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.locality=true\n\n\nAdd the issuer.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.organization=true\n\n\nAdd the issuer.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.province=true\n\n\nAdd the issuer.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.serialNumber=true\n\n\nAdd the issuer.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.notAfter=true\n\n\nAdd the noAfter field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.notBefore=true\n\n\nAdd the noBefore field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.sans=true\n\n\nAdd the sans field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.commonName=true\n\n\nAdd the subject.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.country=true\n\n\nAdd the subject.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.domainComponent=true\n\n\nAdd the subject.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.locality=true\n\n\nAdd the subject.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.organization=true\n\n\nAdd the subject.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.province=true\n\n\nAdd the subject.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.serialNumber=true\n\n\nAdd the subject.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.pem=true\n\n\nPass the escaped pem in the \nX-Forwarded-Ssl-Client-Cert\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSCert=true\n\n\nForwards TLS Client certificates to the backend.\n\n\n\n\n\n\ntraefik.frontend.priority=10\n\n\nOverrides default frontend priority\n\n\n\n\n\n\ntraefik.frontend.rateLimit.extractorFunc=EXP\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.period=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.average=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.burst=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.redirect.entryPoint=https\n\n\nEnables Redirect to another entryPoint to this frontend (e.g. HTTPS)\n\n\n\n\n\n\ntraefik.frontend.redirect.regex=^http://localhost/(.*)\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.replacement\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.replacement=http://mydomain/$1\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.regex\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.permanent=true\n\n\nReturns 301 instead of 302.\n\n\n\n\n\n\ntraefik.frontend.rule=EXPR\n\n\nOverrides the default frontend rule. Default: \nHost:{sub_domain}.{domain}\n.\n\n\n\n\n\n\ntraefik.frontend.whiteList.sourceRange=RANGE\n\n\nSets a list of IP-Ranges which are allowed to access.\nAn unset or empty list allows all Source-IPs to access. If one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.\n\n\n\n\n\n\ntraefik.frontend.whiteList.useXForwardedFor=true\n\n\nUses \nX-Forwarded-For\n header as valid source of IP for the white list.\n\n\n\n\n\n\n\n\nCustom Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.customRequestHeaders=EXPR\n\n\nProvides the container with custom request headers that will be appended to each request forwarded to the container.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.customResponseHeaders=EXPR\n\n\nAppends the headers to each response returned by the container, before forwarding the response to the client.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.allowedHosts=EXPR\n\n\nProvides a list of allowed hosts that requests will be processed.\nFormat: \nHost1,Host2\n\n\n\n\n\n\ntraefik.frontend.headers.browserXSSFilter=true\n\n\nAdds the X-XSS-Protection header with the value \n1; mode=block\n.\n\n\n\n\n\n\ntraefik.frontend.headers.contentSecurityPolicy=VALUE\n\n\nAdds CSP Header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.contentTypeNosniff=true\n\n\nAdds the \nX-Content-Type-Options\n header with the value \nnosniff\n.\n\n\n\n\n\n\ntraefik.frontend.headers.customBrowserXSSValue=VALUE\n\n\nSet custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.\n\n\n\n\n\n\ntraefik.frontend.headers.customFrameOptionsValue=VALUE\n\n\nOverrides the \nX-Frame-Options\n header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.forceSTSHeader=false\n\n\nAdds the STS  header to non-SSL requests.\n\n\n\n\n\n\ntraefik.frontend.headers.frameDeny=false\n\n\nAdds the \nX-Frame-Options\n header with the value of \nDENY\n.\n\n\n\n\n\n\ntraefik.frontend.headers.hostsProxyHeaders=EXPR\n\n\nProvides a list of headers that the proxied hostname may be stored.\nFormat: \nHEADER1,HEADER2\n\n\n\n\n\n\ntraefik.frontend.headers.isDevelopment=false\n\n\nThis will cause the \nAllowedHosts\n, \nSSLRedirect\n, and \nSTSSeconds\n/\nSTSIncludeSubdomains\n options to be ignored during development.\nWhen deploying to production, be sure to set this to false.\n\n\n\n\n\n\ntraefik.frontend.headers.publicKey=VALUE\n\n\nAdds HPKP header.\n\n\n\n\n\n\ntraefik.frontend.headers.referrerPolicy=VALUE\n\n\nAdds referrer policy  header.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLTemporaryRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLHost=HOST\n\n\nThis setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLForceHost=true\n\n\nIf \nSSLForceHost\n is \ntrue\n and \nSSLHost\n is set, requests will be forced to use \nSSLHost\n even the ones that are already using SSL. Default is false.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLProxyHeaders=EXPR\n\n\nHeader combinations that would signify a proper SSL Request (Such as \nX-Forwarded-For:https\n).\nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.STSSeconds=315360000\n\n\nSets the max-age of the STS header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSIncludeSubdomains=true\n\n\nAdds the \nIncludeSubdomains\n section of the STS  header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSPreload=true\n\n\nAdds the preload flag to the STS  header.\n\n\n\n\n\n\n\n\nApplications with Multiple Ports (segment labels)\n\n\nSegment labels are used to define routes to an application exposing multiple ports.\nA segment is a group of labels that apply to a port exposed by an application.\nYou can define as many segments as ports exposed in an application.\n\n\nSegment labels override the default behavior.\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.backend=BACKEND\n\n\nSame as \ntraefik.backend\n\n\n\n\n\n\ntraefik.\nsegment_name\n.domain=DOMAIN\n\n\nSame as \ntraefik.domain\n\n\n\n\n\n\ntraefik.\nsegment_name\n.portIndex=1\n\n\nSame as \ntraefik.portIndex\n\n\n\n\n\n\ntraefik.\nsegment_name\n.port=PORT\n\n\nSame as \ntraefik.port\n\n\n\n\n\n\ntraefik.\nsegment_name\n.protocol=http\n\n\nSame as \ntraefik.protocol\n\n\n\n\n\n\ntraefik.\nsegment_name\n.weight=10\n\n\nSame as \ntraefik.weight\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic=EXPR\n\n\nSame as \ntraefik.frontend.auth.basic\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.basic.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.users=EXPR\n\n\nSame as \ntraefik.frontend.auth.basic.users\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.usersFile=/path/.htpasswd\n\n\nSame as \ntraefik.frontend.auth.basic.usersFile\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.digest.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.users=EXPR\n\n\nSame as \ntraefik.frontend.auth.digest.users\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.usersFile=/path/.htdigest\n\n\nSame as \ntraefik.frontend.auth.digest.usersFile\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.address=https://example.com\n\n\nSame as \ntraefik.frontend.auth.forward.address\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.authResponseHeaders=EXPR\n\n\nSame as \ntraefik.frontend.auth.forward.authResponseHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.ca=/path/ca.pem\n\n\nSame as \ntraefik.frontend.auth.forward.tls.ca\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.caOptional=true\n\n\nSame as \ntraefik.frontend.auth.forward.tls.caOptional\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.cert=/path/server.pem\n\n\nSame as \ntraefik.frontend.auth.forward.tls.cert\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.insecureSkipVerify=true\n\n\nSame as \ntraefik.frontend.auth.forward.tls.insecureSkipVerify\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.key=/path/server.key\n\n\nSame as \ntraefik.frontend.auth.forward.tls.key\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.trustForwardHeader=true\n\n\nSame as \ntraefik.frontend.auth.forward.trustForwardHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.headerField=X-WebAuth-User\n\n\nSame as \ntraefik.frontend.auth.headerField\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.entryPoints=https\n\n\nSame as \ntraefik.frontend.entryPoints\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.backend=NAME\n\n\nSame as \ntraefik.frontend.errors.\nname\n.backend\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.query=PATH\n\n\nSame as \ntraefik.frontend.errors.\nname\n.query\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.status=RANGE\n\n\nSame as \ntraefik.frontend.errors.\nname\n.status\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passHostHeader=true\n\n\nSame as \ntraefik.frontend.passHostHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.commonName=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.commonName\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.domainComponent=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.domainComponent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.country=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.country\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.locality=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.locality\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.organization=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.organization\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.province=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.province\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.serialNumber=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.serialNumber\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.notAfter=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.notAfter\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.notBefore=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.notBefore\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.sans=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.sans\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.commonName=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.commonName\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.domainComponent=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.domainComponent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.country=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.country\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.locality=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.locality\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.organization=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.organization\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.province=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.province\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.serialNumber=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.serialNumber\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.pem=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.pem\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSCert=true\n\n\nSame as \ntraefik.frontend.passTLSCert\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.priority=10\n\n\nSame as \ntraefik.frontend.priority\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.extractorFunc=EXP\n\n\nSame as \ntraefik.frontend.rateLimit.extractorFunc\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.period=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.period\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.average=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.average\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.burst=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.burst\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.entryPoint=https\n\n\nSame as \ntraefik.frontend.redirect.entryPoint\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.regex=^http://localhost/(.*)\n\n\nSame as \ntraefik.frontend.redirect.regex\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.replacement=http://mydomain/$1\n\n\nSame as \ntraefik.frontend.redirect.replacement\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.permanent=true\n\n\nSame as \ntraefik.frontend.redirect.permanent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rule=EXP\n\n\nSame as \ntraefik.frontend.rule\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.whiteList.sourceRange=RANGE\n\n\nSame as \ntraefik.frontend.whiteList.sourceRange\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.whiteList.useXForwardedFor=true\n\n\nSame as \ntraefik.frontend.whiteList.useXForwardedFor\n\n\n\n\n\n\n\n\nCustom Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customRequestHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.customRequestHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customResponseHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.customResponseHeaders\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.allowedHosts=EXPR\n\n\nSame as \ntraefik.frontend.headers.allowedHosts\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.browserXSSFilter=true\n\n\nSame as \ntraefik.frontend.headers.browserXSSFilter\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.contentSecurityPolicy=VALUE\n\n\nSame as \ntraefik.frontend.headers.contentSecurityPolicy\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.contentTypeNosniff=true\n\n\nSame as \ntraefik.frontend.headers.contentTypeNosniff\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customBrowserXSSValue=VALUE\n\n\nSame as \ntraefik.frontend.headers.customBrowserXSSValue\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customFrameOptionsValue=VALUE\n\n\nSame as \ntraefik.frontend.headers.customFrameOptionsValue\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.forceSTSHeader=false\n\n\nSame as \ntraefik.frontend.headers.forceSTSHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.frameDeny=false\n\n\nSame as \ntraefik.frontend.headers.frameDeny\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.hostsProxyHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.hostsProxyHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.isDevelopment=false\n\n\nSame as \ntraefik.frontend.headers.isDevelopment\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.publicKey=VALUE\n\n\nSame as \ntraefik.frontend.headers.publicKey\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.referrerPolicy=VALUE\n\n\nSame as \ntraefik.frontend.headers.referrerPolicy\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLRedirect=true\n\n\nSame as \ntraefik.frontend.headers.SSLRedirect\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLTemporaryRedirect=true\n\n\nSame as \ntraefik.frontend.headers.SSLTemporaryRedirect\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLHost=HOST\n\n\nSame as \ntraefik.frontend.headers.SSLHost\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLForceHost=true\n\n\nSame as \ntraefik.frontend.headers.SSLForceHost\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLProxyHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.SSLProxyHeaders=EXPR\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSSeconds=315360000\n\n\nSame as \ntraefik.frontend.headers.STSSeconds=315360000\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSIncludeSubdomains=true\n\n\nSame as \ntraefik.frontend.headers.STSIncludeSubdomains=true\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSPreload=true\n\n\nSame as \ntraefik.frontend.headers.STSPreload=true", 
            "title": "Marathon"
        }, 
        {
            "location": "/configuration/backends/marathon/#marathon-provider", 
            "text": "Traefik can be configured to use Marathon as a provider.  See also  Marathon user guide .", 
            "title": "Marathon Provider"
        }, 
        {
            "location": "/configuration/backends/marathon/#configuration", 
            "text": "################################################################\n# Mesos/Marathon Provider\n################################################################\n\n# Enable Marathon Provider.\n[marathon]\n\n# Marathon server endpoint.\n# You can also specify multiple endpoint for Marathon:\n# endpoint =  http://10.241.1.71:8080,10.241.1.72:8080,10.241.1.73:8080 \n#\n# Required\n# Default:  http://127.0.0.1:8080 \n#\nendpoint =  http://127.0.0.1:8080 \n\n# Enable watch Marathon changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the  traefik.domain  label on an application.\n#\n# Required\n#\ndomain =  marathon.localhost \n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename =  marathon.tmpl \n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# -  1 : previous template version (must be used only with older custom templates, see  filename )\n# -  2 : current template version (must be used to force template version when  filename  is used)\n#\n# templateVersion = 2\n\n# Expose Marathon apps by default in Traefik.\n#\n# Optional\n# Default: true\n#\n# exposedByDefault = false\n\n# Convert Marathon groups to subdomains.\n# Default behavior: /foo/bar/myapp =  foo-bar-myapp.{defaultDomain}\n# with groupsAsSubDomains enabled: /foo/bar/myapp =  myapp.bar.foo.{defaultDomain}\n#\n# Optional\n# Default: false\n#\n# groupsAsSubDomains = true\n\n# Enable compatibility with marathon-lb labels.\n#\n# Optional\n# Default: false\n#\n# marathonLBCompatibility = true\n\n# Enable filtering using Marathon constraints..\n# If enabled, Traefik will read Marathon constraints, as defined in https://mesosphere.github.io/marathon/docs/constraints.html\n# Each individual constraint will be treated as a verbatim compounded tag.\n# i.e.  rack_id:CLUSTER:rack-1 , with all constraint groups concatenated together using  : \n#\n# Optional\n# Default: false\n#\n# filterMarathonConstraints = true\n\n# Enable Marathon basic authentication.\n#\n# Optional\n#\n#    [marathon.basic]\n#    httpBasicAuthUser =  foo \n#    httpBasicPassword =  bar \n\n# TLS client configuration. https://golang.org/pkg/crypto/tls/#Config\n#\n# Optional\n#\n#    [marathon.TLS]\n#    CA =  /etc/ssl/ca.crt \n#    Cert =  /etc/ssl/marathon.cert \n#    Key =  /etc/ssl/marathon.key \n#    insecureSkipVerify = true\n\n# DCOSToken for DCOS environment.\n# This will override the Authorization header.\n#\n# Optional\n#\n# dcosToken =  xxxxxx \n\n# Override DialerTimeout.\n# Amount of time to allow the Marathon provider to wait to open a TCP connection\n# to a Marathon master.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw\n# values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n#\n# Optional\n# Default:  5s \n#\n# dialerTimeout =  5s \n\n# Override ResponseHeaderTimeout.\n# Amount of time to allow the Marathon provider to wait until the first response\n# header from the Marathon master is received.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw\n# values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n#\n# Optional\n# Default:  60s \n#\n# responseHeaderTimeout =  60s \n\n# Override TLSHandshakeTimeout.\n# Amount of time to allow the Marathon provider to wait until the TLS\n# handshake completes.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw\n# values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n#\n# Optional\n# Default:  5s \n#\n# TLSHandshakeTimeout =  5s \n\n# Set the TCP Keep Alive interval for the Marathon HTTP Client.\n# Can be provided in a format supported by [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) or as raw\n# values (digits).\n# If no units are provided, the value is parsed assuming seconds.\n#\n# Optional\n# Default:  10s \n#\n# keepAlive =  10s \n\n# By default, a task's IP address (as returned by the Marathon API) is used as\n# backend server if an IP-per-task configuration can be found; otherwise, the\n# name of the host running the task is used.\n# The latter behavior can be enforced by enabling this switch.\n#\n# Optional\n# Default: false\n#\n# forceTaskHostname = true\n\n# Applications may define readiness checks which are probed by Marathon during\n# deployments periodically and the results exposed via the API.\n# Enabling the following parameter causes Traefik to filter out tasks\n# whose readiness checks have not succeeded.\n# Note that the checks are only valid at deployment times.\n# See the Marathon guide for details.\n#\n# Optional\n# Default: false\n#\n# respectReadinessChecks = true  To enable constraints see  provider-specific constraints section .", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/backends/marathon/#labels-overriding-default-behavior", 
            "text": "Marathon labels may be used to dynamically change the routing and forwarding behavior.  They may be specified on one of two levels: Application or service.", 
            "title": "Labels: overriding default behavior"
        }, 
        {
            "location": "/configuration/backends/marathon/#application-level", 
            "text": "The following labels can be defined on Marathon applications. They adjust the behavior for the entire application.     Label  Description      traefik.domain  Sets the default base domain used for the frontend rules.    traefik.enable=false  Disables this container in Traefik.    traefik.port=80  Registers this port. Useful when the container exposes multiples ports.    traefik.portIndex=1  Registers port by index in the application's ports array. Useful when the application exposes multiple ports.    traefik.protocol=https  Overrides the default  http  protocol.    traefik.weight=10  Assigns this weight to the container.    traefik.backend=foo  Overrides the application name by  foo  in the generated name of the backend.    traefik.backend.buffering.maxRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.maxResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.retryExpression=EXPR  See  buffering  section.    traefik.backend.circuitbreaker.expression=EXPR  Creates a  circuit breaker  to be used against the backend    traefik.backend.responseForwarding.flushInterval=10ms  Defines the interval between two flushes when forwarding response from backend to client.    traefik.backend.healthcheck.path=/health  Enables health check for the backend, hitting the container at  path .    traefik.backend.healthcheck.interval=1s  Defines the health check interval. (Default: 30s)    traefik.backend.healthcheck.port=8080  Sets a different port for the health check.    traefik.backend.healthcheck.scheme=http  Overrides the server URL scheme.    traefik.backend.healthcheck.hostname=foobar.com  Defines the health check hostname.    traefik.backend.healthcheck.headers=EXPR  Defines the health check request headers  Format:   HEADER:value HEADER2:value2    traefik.backend.loadbalancer.method=drr  Overrides the default  wrr  load balancer algorithm    traefik.backend.loadbalancer.stickiness=true  Enables backend sticky sessions    traefik.backend.loadbalancer.stickiness.cookieName=NAME  Sets the cookie name manually for sticky sessions    traefik.backend.loadbalancer.sticky=true  Enables backend sticky sessions (DEPRECATED)    traefik.backend.maxconn.amount=10  Sets a maximum number of connections to the backend. Must be used in conjunction with the below label to take effect.    traefik.backend.maxconn.extractorfunc=client.ip  Sets the function to be used against the request to determine what to limit maximum connections to the backend by. Must be used in conjunction with the above label to take effect.    traefik.frontend.auth.basic=EXPR  Sets basic authentication to this frontend in CSV format:  User:Hash,User:Hash  (DEPRECATED).    traefik.frontend.auth.basic.removeHeader=true  If set to  true , removes the  Authorization  header.    traefik.frontend.auth.basic.users=EXPR  Sets basic authentication to this frontend in CSV format:  User:Hash,User:Hash .    traefik.frontend.auth.basic.usersFile=/path/.htpasswd  Sets basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    traefik.frontend.auth.digest.removeHeader=true  If set to  true , removes the  Authorization  header.    traefik.frontend.auth.digest.users=EXPR  Sets digest authentication to this frontend in CSV format:  User:Realm:Hash,User:Realm:Hash .    traefik.frontend.auth.digest.usersFile=/path/.htdigest  Sets digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    traefik.frontend.auth.forward.address=https://example.com  Sets the URL of the authentication server.    traefik.frontend.auth.forward.authResponseHeaders=EXPR  Sets the forward authentication authResponseHeaders in CSV format:  X-Auth-User,X-Auth-Header    traefik.frontend.auth.forward.tls.ca=/path/ca.pem  Sets the Certificate Authority (CA) for the TLS connection with the authentication server.    traefik.frontend.auth.forward.tls.caOptional=true  Checks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).    traefik.frontend.auth.forward.tls.cert=/path/server.pem  Sets the Certificate for the TLS connection with the authentication server.    traefik.frontend.auth.forward.tls.insecureSkipVerify=true  If set to true invalid SSL certificates are accepted.    traefik.frontend.auth.forward.tls.key=/path/server.key  Sets the Certificate for the TLS connection with the authentication server.    traefik.frontend.auth.forward.trustForwardHeader=true  Trusts X-Forwarded-* headers.    traefik.frontend.auth.headerField=X-WebAuth-User  Sets the header used to pass the authenticated user to the application.    traefik.frontend.auth.removeHeader=true  If set to true, removes the Authorization header.    traefik.frontend.entryPoints=http,https  Assigns this frontend to entry points  http  and  https . Overrides  defaultEntryPoints    traefik.frontend.errors. name .backend=NAME  See  custom error pages  section.    traefik.frontend.errors. name .query=PATH  See  custom error pages  section.    traefik.frontend.errors. name .status=RANGE  See  custom error pages  section.    traefik.frontend.passHostHeader=true  Forwards client  Host  header to the backend.    traefik.frontend.passTLSClientCert.infos.issuer.commonName=true  Add the issuer.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.country=true  Add the issuer.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.domainComponent=true  Add the issuer.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.locality=true  Add the issuer.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.organization=true  Add the issuer.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.province=true  Add the issuer.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.serialNumber=true  Add the issuer.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.notAfter=true  Add the noAfter field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.notBefore=true  Add the noBefore field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.sans=true  Add the sans field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.commonName=true  Add the subject.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.country=true  Add the subject.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.domainComponent=true  Add the subject.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.locality=true  Add the subject.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.organization=true  Add the subject.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.province=true  Add the subject.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.serialNumber=true  Add the subject.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.pem=true  Pass the escaped pem in the  X-Forwarded-Ssl-Client-Cert  header.    traefik.frontend.passTLSCert=true  Forwards TLS Client certificates to the backend.    traefik.frontend.priority=10  Overrides default frontend priority    traefik.frontend.rateLimit.extractorFunc=EXP  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .period=6  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .average=6  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .burst=6  See  rate limiting  section.    traefik.frontend.redirect.entryPoint=https  Enables Redirect to another entryPoint to this frontend (e.g. HTTPS)    traefik.frontend.redirect.regex=^http://localhost/(.*)  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.replacement .    traefik.frontend.redirect.replacement=http://mydomain/$1  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.regex .    traefik.frontend.redirect.permanent=true  Returns 301 instead of 302.    traefik.frontend.rule=EXPR  Overrides the default frontend rule. Default:  Host:{sub_domain}.{domain} .    traefik.frontend.whiteList.sourceRange=RANGE  Sets a list of IP-Ranges which are allowed to access. An unset or empty list allows all Source-IPs to access. If one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.    traefik.frontend.whiteList.useXForwardedFor=true  Uses  X-Forwarded-For  header as valid source of IP for the white list.", 
            "title": "Application Level"
        }, 
        {
            "location": "/configuration/backends/marathon/#custom-headers", 
            "text": "Label  Description      traefik.frontend.headers.customRequestHeaders=EXPR  Provides the container with custom request headers that will be appended to each request forwarded to the container. Format:  HEADER:value HEADER2:value2    traefik.frontend.headers.customResponseHeaders=EXPR  Appends the headers to each response returned by the container, before forwarding the response to the client. Format:  HEADER:value HEADER2:value2", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/marathon/#security-headers", 
            "text": "Label  Description      traefik.frontend.headers.allowedHosts=EXPR  Provides a list of allowed hosts that requests will be processed. Format:  Host1,Host2    traefik.frontend.headers.browserXSSFilter=true  Adds the X-XSS-Protection header with the value  1; mode=block .    traefik.frontend.headers.contentSecurityPolicy=VALUE  Adds CSP Header with the custom value.    traefik.frontend.headers.contentTypeNosniff=true  Adds the  X-Content-Type-Options  header with the value  nosniff .    traefik.frontend.headers.customBrowserXSSValue=VALUE  Set custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.    traefik.frontend.headers.customFrameOptionsValue=VALUE  Overrides the  X-Frame-Options  header with the custom value.    traefik.frontend.headers.forceSTSHeader=false  Adds the STS  header to non-SSL requests.    traefik.frontend.headers.frameDeny=false  Adds the  X-Frame-Options  header with the value of  DENY .    traefik.frontend.headers.hostsProxyHeaders=EXPR  Provides a list of headers that the proxied hostname may be stored. Format:  HEADER1,HEADER2    traefik.frontend.headers.isDevelopment=false  This will cause the  AllowedHosts ,  SSLRedirect , and  STSSeconds / STSIncludeSubdomains  options to be ignored during development. When deploying to production, be sure to set this to false.    traefik.frontend.headers.publicKey=VALUE  Adds HPKP header.    traefik.frontend.headers.referrerPolicy=VALUE  Adds referrer policy  header.    traefik.frontend.headers.SSLRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent.    traefik.frontend.headers.SSLTemporaryRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.    traefik.frontend.headers.SSLHost=HOST  This setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.    traefik.frontend.headers.SSLForceHost=true  If  SSLForceHost  is  true  and  SSLHost  is set, requests will be forced to use  SSLHost  even the ones that are already using SSL. Default is false.    traefik.frontend.headers.SSLProxyHeaders=EXPR  Header combinations that would signify a proper SSL Request (Such as  X-Forwarded-For:https ). Format:   HEADER:value HEADER2:value2    traefik.frontend.headers.STSSeconds=315360000  Sets the max-age of the STS header.    traefik.frontend.headers.STSIncludeSubdomains=true  Adds the  IncludeSubdomains  section of the STS  header.    traefik.frontend.headers.STSPreload=true  Adds the preload flag to the STS  header.", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/marathon/#applications-with-multiple-ports-segment-labels", 
            "text": "Segment labels are used to define routes to an application exposing multiple ports.\nA segment is a group of labels that apply to a port exposed by an application.\nYou can define as many segments as ports exposed in an application.  Segment labels override the default behavior.     Label  Description      traefik. segment_name .backend=BACKEND  Same as  traefik.backend    traefik. segment_name .domain=DOMAIN  Same as  traefik.domain    traefik. segment_name .portIndex=1  Same as  traefik.portIndex    traefik. segment_name .port=PORT  Same as  traefik.port    traefik. segment_name .protocol=http  Same as  traefik.protocol    traefik. segment_name .weight=10  Same as  traefik.weight    traefik. segment_name .frontend.auth.basic=EXPR  Same as  traefik.frontend.auth.basic    traefik. segment_name .frontend.auth.basic.removeHeader=true  Same as  traefik.frontend.auth.basic.removeHeader    traefik. segment_name .frontend.auth.basic.users=EXPR  Same as  traefik.frontend.auth.basic.users    traefik. segment_name .frontend.auth.basic.usersFile=/path/.htpasswd  Same as  traefik.frontend.auth.basic.usersFile    traefik. segment_name .frontend.auth.digest.removeHeader=true  Same as  traefik.frontend.auth.digest.removeHeader    traefik. segment_name .frontend.auth.digest.users=EXPR  Same as  traefik.frontend.auth.digest.users    traefik. segment_name .frontend.auth.digest.usersFile=/path/.htdigest  Same as  traefik.frontend.auth.digest.usersFile    traefik. segment_name .frontend.auth.forward.address=https://example.com  Same as  traefik.frontend.auth.forward.address    traefik. segment_name .frontend.auth.forward.authResponseHeaders=EXPR  Same as  traefik.frontend.auth.forward.authResponseHeaders    traefik. segment_name .frontend.auth.forward.tls.ca=/path/ca.pem  Same as  traefik.frontend.auth.forward.tls.ca    traefik. segment_name .frontend.auth.forward.tls.caOptional=true  Same as  traefik.frontend.auth.forward.tls.caOptional    traefik. segment_name .frontend.auth.forward.tls.cert=/path/server.pem  Same as  traefik.frontend.auth.forward.tls.cert    traefik. segment_name .frontend.auth.forward.tls.insecureSkipVerify=true  Same as  traefik.frontend.auth.forward.tls.insecureSkipVerify    traefik. segment_name .frontend.auth.forward.tls.key=/path/server.key  Same as  traefik.frontend.auth.forward.tls.key    traefik. segment_name .frontend.auth.forward.trustForwardHeader=true  Same as  traefik.frontend.auth.forward.trustForwardHeader    traefik. segment_name .frontend.auth.headerField=X-WebAuth-User  Same as  traefik.frontend.auth.headerField    traefik. segment_name .frontend.auth.removeHeader=true  Same as  traefik.frontend.auth.removeHeader    traefik. segment_name .frontend.entryPoints=https  Same as  traefik.frontend.entryPoints    traefik. segment_name .frontend.errors. name .backend=NAME  Same as  traefik.frontend.errors. name .backend    traefik. segment_name .frontend.errors. name .query=PATH  Same as  traefik.frontend.errors. name .query    traefik. segment_name .frontend.errors. name .status=RANGE  Same as  traefik.frontend.errors. name .status    traefik. segment_name .frontend.passHostHeader=true  Same as  traefik.frontend.passHostHeader    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.commonName=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.commonName    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.domainComponent=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.domainComponent    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.country=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.country    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.locality=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.locality    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.organization=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.organization    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.province=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.province    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.serialNumber=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.serialNumber    traefik. segment_name .frontend.passTLSClientCert.infos.notAfter=true  Same as  traefik.frontend.passTLSClientCert.infos.notAfter    traefik. segment_name .frontend.passTLSClientCert.infos.notBefore=true  Same as  traefik.frontend.passTLSClientCert.infos.notBefore    traefik. segment_name .frontend.passTLSClientCert.infos.sans=true  Same as  traefik.frontend.passTLSClientCert.infos.sans    traefik. segment_name .frontend.passTLSClientCert.infos.subject.commonName=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.commonName    traefik. segment_name .frontend.passTLSClientCert.infos.subject.domainComponent=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.domainComponent    traefik. segment_name .frontend.passTLSClientCert.infos.subject.country=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.country    traefik. segment_name .frontend.passTLSClientCert.infos.subject.locality=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.locality    traefik. segment_name .frontend.passTLSClientCert.infos.subject.organization=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.organization    traefik. segment_name .frontend.passTLSClientCert.infos.subject.province=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.province    traefik. segment_name .frontend.passTLSClientCert.infos.subject.serialNumber=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.serialNumber    traefik. segment_name .frontend.passTLSClientCert.pem=true  Same as  traefik.frontend.passTLSClientCert.infos.pem    traefik. segment_name .frontend.passTLSCert=true  Same as  traefik.frontend.passTLSCert    traefik. segment_name .frontend.priority=10  Same as  traefik.frontend.priority    traefik. segment_name .frontend.rateLimit.extractorFunc=EXP  Same as  traefik.frontend.rateLimit.extractorFunc    traefik. segment_name .frontend.rateLimit.rateSet. name .period=6  Same as  traefik.frontend.rateLimit.rateSet. name .period    traefik. segment_name .frontend.rateLimit.rateSet. name .average=6  Same as  traefik.frontend.rateLimit.rateSet. name .average    traefik. segment_name .frontend.rateLimit.rateSet. name .burst=6  Same as  traefik.frontend.rateLimit.rateSet. name .burst    traefik. segment_name .frontend.redirect.entryPoint=https  Same as  traefik.frontend.redirect.entryPoint    traefik. segment_name .frontend.redirect.regex=^http://localhost/(.*)  Same as  traefik.frontend.redirect.regex    traefik. segment_name .frontend.redirect.replacement=http://mydomain/$1  Same as  traefik.frontend.redirect.replacement    traefik. segment_name .frontend.redirect.permanent=true  Same as  traefik.frontend.redirect.permanent    traefik. segment_name .frontend.rule=EXP  Same as  traefik.frontend.rule    traefik. segment_name .frontend.whiteList.sourceRange=RANGE  Same as  traefik.frontend.whiteList.sourceRange    traefik. segment_name .frontend.whiteList.useXForwardedFor=true  Same as  traefik.frontend.whiteList.useXForwardedFor", 
            "title": "Applications with Multiple Ports (segment labels)"
        }, 
        {
            "location": "/configuration/backends/marathon/#custom-headers_1", 
            "text": "Label  Description      traefik. segment_name .frontend.headers.customRequestHeaders=EXPR  Same as  traefik.frontend.headers.customRequestHeaders    traefik. segment_name .frontend.headers.customResponseHeaders=EXPR  Same as  traefik.frontend.headers.customResponseHeaders", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/marathon/#security-headers_1", 
            "text": "Label  Description      traefik. segment_name .frontend.headers.allowedHosts=EXPR  Same as  traefik.frontend.headers.allowedHosts    traefik. segment_name .frontend.headers.browserXSSFilter=true  Same as  traefik.frontend.headers.browserXSSFilter    traefik. segment_name .frontend.headers.contentSecurityPolicy=VALUE  Same as  traefik.frontend.headers.contentSecurityPolicy    traefik. segment_name .frontend.headers.contentTypeNosniff=true  Same as  traefik.frontend.headers.contentTypeNosniff    traefik. segment_name .frontend.headers.customBrowserXSSValue=VALUE  Same as  traefik.frontend.headers.customBrowserXSSValue    traefik. segment_name .frontend.headers.customFrameOptionsValue=VALUE  Same as  traefik.frontend.headers.customFrameOptionsValue    traefik. segment_name .frontend.headers.forceSTSHeader=false  Same as  traefik.frontend.headers.forceSTSHeader    traefik. segment_name .frontend.headers.frameDeny=false  Same as  traefik.frontend.headers.frameDeny    traefik. segment_name .frontend.headers.hostsProxyHeaders=EXPR  Same as  traefik.frontend.headers.hostsProxyHeaders    traefik. segment_name .frontend.headers.isDevelopment=false  Same as  traefik.frontend.headers.isDevelopment    traefik. segment_name .frontend.headers.publicKey=VALUE  Same as  traefik.frontend.headers.publicKey    traefik. segment_name .frontend.headers.referrerPolicy=VALUE  Same as  traefik.frontend.headers.referrerPolicy    traefik. segment_name .frontend.headers.SSLRedirect=true  Same as  traefik.frontend.headers.SSLRedirect    traefik. segment_name .frontend.headers.SSLTemporaryRedirect=true  Same as  traefik.frontend.headers.SSLTemporaryRedirect    traefik. segment_name .frontend.headers.SSLHost=HOST  Same as  traefik.frontend.headers.SSLHost    traefik. segment_name .frontend.headers.SSLForceHost=true  Same as  traefik.frontend.headers.SSLForceHost    traefik. segment_name .frontend.headers.SSLProxyHeaders=EXPR  Same as  traefik.frontend.headers.SSLProxyHeaders=EXPR    traefik. segment_name .frontend.headers.STSSeconds=315360000  Same as  traefik.frontend.headers.STSSeconds=315360000    traefik. segment_name .frontend.headers.STSIncludeSubdomains=true  Same as  traefik.frontend.headers.STSIncludeSubdomains=true    traefik. segment_name .frontend.headers.STSPreload=true  Same as  traefik.frontend.headers.STSPreload=true", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/mesos/", 
            "text": "Mesos Generic Provider\n\n\nTraefik can be configured to use Mesos as a provider.\n\n\n################################################################\n# Mesos Provider\n################################################################\n\n# Enable Mesos Provider.\n[mesos]\n\n# Mesos server endpoint.\n# You can also specify multiple endpoint for Mesos:\n# endpoint = \n192.168.35.40:5050,192.168.35.41:5050,192.168.35.42:5050\n\n# endpoint = \nzk://192.168.35.20:2181,192.168.35.21:2181,192.168.35.22:2181/mesos\n\n#\n# Required\n# Default: \nhttp://127.0.0.1:5050\n\n#\nendpoint = \nhttp://127.0.0.1:8080\n\n\n# Enable watch Mesos changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the \ntraefik.domain\n label on an application.\n#\n# Required\n#\ndomain = \nmesos.localhost\n\n\n# Expose Mesos apps by default in Traefik.\n#\n# Optional\n# Default: true\n#\n# exposedByDefault = false\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename = \nmesos.tmpl\n\n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# - \n1\n: previous template version (must be used only with older custom templates, see \nfilename\n)\n# - \n2\n: current template version (must be used to force template version when \nfilename\n is used)\n#\n# templateVersion = 2\n\n# TLS client configuration. https://golang.org/pkg/crypto/tls/#Config\n#\n# Optional\n#\n# [mesos.TLS]\n# insecureSkipVerify = true\n\n# Zookeeper timeout (in seconds).\n#\n# Optional\n# Default: 30\n#\n# zkDetectionTimeout = 30\n\n# Polling interval (in seconds).\n#\n# Optional\n# Default: 30\n#\n# refreshSeconds = 30\n\n# IP sources (e.g. host, docker, mesos, netinfo).\n#\n# Optional\n#\n# ipSources = \nhost\n\n\n# HTTP Timeout (in seconds).\n#\n# Optional\n# Default: 30\n#\n# stateTimeoutSecond = \n30\n\n\n# Convert groups to subdomains.\n# Default behavior: /foo/bar/myapp =\n foo-bar-myapp.{defaultDomain}\n# with groupsAsSubDomains enabled: /foo/bar/myapp =\n myapp.bar.foo.{defaultDomain}\n#\n# Optional\n# Default: false\n#\n# groupsAsSubDomains = true\n\n\n\n\n\nLabels: overriding default behavior\n\n\nThe following labels can be defined on Mesos tasks. They adjust the behavior for the entire application.\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.domain\n\n\nSets the default base domain for the frontend rules.\n\n\n\n\n\n\ntraefik.enable=false\n\n\nDisables this container in Traefik.\n\n\n\n\n\n\ntraefik.port=80\n\n\nRegisters this port. Useful when the application exposes multiple ports.\n\n\n\n\n\n\ntraefik.portName=web\n\n\nRegisters port by name in the application's ports array. Useful when the application exposes multiple ports.\n\n\n\n\n\n\ntraefik.portIndex=1\n\n\nRegisters port by index in the application's ports array. Useful when the application exposes multiple ports.\n\n\n\n\n\n\ntraefik.protocol=https\n\n\nOverrides the default \nhttp\n protocol\n\n\n\n\n\n\ntraefik.weight=10\n\n\nAssigns this weight to the container\n\n\n\n\n\n\ntraefik.backend=foo\n\n\nOverrides the task name by \nfoo\n in the generated name of the backend.\n\n\n\n\n\n\ntraefik.backend.buffering.maxRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.maxResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.retryExpression=EXPR\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.circuitbreaker.expression=EXPR\n\n\nCreates a \ncircuit breaker\n to be used against the backend\n\n\n\n\n\n\ntraefik.backend.responseForwarding.flushInterval=10ms\n\n\nDefines the interval between two flushes when forwarding response from backend to client.\n\n\n\n\n\n\ntraefik.backend.healthcheck.path=/health\n\n\nEnables health check for the backend, hitting the container at \npath\n.\n\n\n\n\n\n\ntraefik.backend.healthcheck.interval=1s\n\n\nDefines the health check interval. (Default: 30s)\n\n\n\n\n\n\ntraefik.backend.healthcheck.scheme=http\n\n\nOverrides the server URL scheme.\n\n\n\n\n\n\ntraefik.backend.healthcheck.port=8080\n\n\nSets a different port for the health check.\n\n\n\n\n\n\ntraefik.backend.healthcheck.hostname=foobar.com\n\n\nDefines the health check hostname.\n\n\n\n\n\n\ntraefik.backend.healthcheck.headers=EXPR\n\n\nDefines the health check request headers \nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.backend.loadbalancer.method=drr\n\n\nOverrides the default \nwrr\n load balancer algorithm\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness=true\n\n\nEnables backend sticky sessions\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness.cookieName=NAME\n\n\nSets the cookie manually name for sticky sessions\n\n\n\n\n\n\ntraefik.backend.maxconn.amount=10\n\n\nSets a maximum number of connections to the backend.\nMust be used in conjunction with the below label to take effect.\n\n\n\n\n\n\ntraefik.backend.maxconn.extractorfunc=client.ip\n\n\nSets the function to be used against the request to determine what to limit maximum connections to the backend by.\nMust be used in conjunction with the above label to take effect.\n\n\n\n\n\n\ntraefik.frontend.auth.basic=EXPR\n\n\nSets basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n (DEPRECATED).\n\n\n\n\n\n\ntraefik.frontend.auth.basic.users=EXPR\n\n\nSets basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n.\n\n\n\n\n\n\ntraefik.frontend.auth.basic.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\ntraefik.frontend.auth.basic.usersFile=/path/.htpasswd\n\n\nSets basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.users=EXPR\n\n\nSets digest authentication to this frontend in CSV format: \nUser:Realm:Hash,User:Realm:Hash\n.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.usersFile=/path/.htdigest\n\n\nSets digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.address=https://example.com\n\n\nSets the URL of the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.authResponseHeaders=EXPR\n\n\nSets the forward authentication authResponseHeaders in CSV format: \nX-Auth-User,X-Auth-Header\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.ca=/path/ca.pem\n\n\nSets the Certificate Authority (CA) for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.caOptional=true\n\n\nChecks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.cert=/path/server.pem\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.insecureSkipVerify=true\n\n\nIf set to true invalid SSL certificates are accepted.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.key=/path/server.key\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.trustForwardHeader=true\n\n\nTrusts X-Forwarded-* headers.\n\n\n\n\n\n\ntraefik.frontend.auth.headerField=X-WebAuth-User\n\n\nSets the header used to pass the authenticated user to the application.\n\n\n\n\n\n\ntraefik.frontend.auth.removeHeader=true\n\n\nIf set to true, removes the Authorization header.\n\n\n\n\n\n\ntraefik.frontend.entryPoints=http,https\n\n\nAssigns this frontend to entry points \nhttp\n and \nhttps\n.\nOverrides \ndefaultEntryPoints\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.backend=NAME\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.query=PATH\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.status=RANGE\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.passHostHeader=true\n\n\nForwards client \nHost\n header to the backend.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.commonName=true\n\n\nAdd the issuer.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.country=true\n\n\nAdd the issuer.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.domainComponent=true\n\n\nAdd the issuer.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.locality=true\n\n\nAdd the issuer.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.organization=true\n\n\nAdd the issuer.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.province=true\n\n\nAdd the issuer.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.serialNumber=true\n\n\nAdd the issuer.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.notAfter=true\n\n\nAdd the noAfter field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.notBefore=true\n\n\nAdd the noBefore field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.sans=true\n\n\nAdd the sans field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.commonName=true\n\n\nAdd the subject.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.country=true\n\n\nAdd the subject.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.domainComponent=true\n\n\nAdd the subject.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.locality=true\n\n\nAdd the subject.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.organization=true\n\n\nAdd the subject.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.province=true\n\n\nAdd the subject.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.serialNumber=true\n\n\nAdd the subject.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.pem=true\n\n\nPass the escaped pem in the \nX-Forwarded-Ssl-Client-Cert\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSCert=true\n\n\nForwards TLS Client certificates to the backend.\n\n\n\n\n\n\ntraefik.frontend.priority=10\n\n\nOverrides default frontend priority\n\n\n\n\n\n\ntraefik.frontend.rateLimit.extractorFunc=EXP\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.period=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.average=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.burst=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.redirect.entryPoint=https\n\n\nEnables Redirect to another entryPoint to this frontend (e.g. HTTPS)\n\n\n\n\n\n\ntraefik.frontend.redirect.regex=^http://localhost/(.*)\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.replacement\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.replacement=http://mydomain/$1\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.regex\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.permanent=true\n\n\nReturns 301 instead of 302.\n\n\n\n\n\n\ntraefik.frontend.rule=EXPR\n\n\nOverrides the default frontend rule. Default: \nHost:{discovery_name}.{domain}\n.\n\n\n\n\n\n\ntraefik.frontend.whiteList.sourceRange=RANGE\n\n\nSets a list of IP-Ranges which are allowed to access.\nAn unset or empty list allows all Source-IPs to access. If one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.\n\n\n\n\n\n\ntraefik.frontend.whiteList.useXForwardedFor=true\n\n\nUses \nX-Forwarded-For\n header as valid source of IP for the white list.\n\n\n\n\n\n\n\n\nCustom Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.customRequestHeaders=EXPR\n\n\nProvides the container with custom request headers that will be appended to each request forwarded to the container.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.customResponseHeaders=EXPR\n\n\nAppends the headers to each response returned by the container, before forwarding the response to the client.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.allowedHosts=EXPR\n\n\nProvides a list of allowed hosts that requests will be processed.\nFormat: \nHost1,Host2\n\n\n\n\n\n\ntraefik.frontend.headers.browserXSSFilter=true\n\n\nAdds the X-XSS-Protection header with the value \n1; mode=block\n.\n\n\n\n\n\n\ntraefik.frontend.headers.contentSecurityPolicy=VALUE\n\n\nAdds CSP Header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.contentTypeNosniff=true\n\n\nAdds the \nX-Content-Type-Options\n header with the value \nnosniff\n.\n\n\n\n\n\n\ntraefik.frontend.headers.customBrowserXSSValue=VALUE\n\n\nSet custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.\n\n\n\n\n\n\ntraefik.frontend.headers.customFrameOptionsValue=VALUE\n\n\nOverrides the \nX-Frame-Options\n header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.forceSTSHeader=false\n\n\nAdds the STS  header to non-SSL requests.\n\n\n\n\n\n\ntraefik.frontend.headers.frameDeny=false\n\n\nAdds the \nX-Frame-Options\n header with the value of \nDENY\n.\n\n\n\n\n\n\ntraefik.frontend.headers.hostsProxyHeaders=EXPR\n\n\nProvides a list of headers that the proxied hostname may be stored.\nFormat: \nHEADER1,HEADER2\n\n\n\n\n\n\ntraefik.frontend.headers.isDevelopment=false\n\n\nThis will cause the \nAllowedHosts\n, \nSSLRedirect\n, and \nSTSSeconds\n/\nSTSIncludeSubdomains\n options to be ignored during development.\nWhen deploying to production, be sure to set this to false.\n\n\n\n\n\n\ntraefik.frontend.headers.publicKey=VALUE\n\n\nAdds HPKP header.\n\n\n\n\n\n\ntraefik.frontend.headers.referrerPolicy=VALUE\n\n\nAdds referrer policy  header.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLTemporaryRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLHost=HOST\n\n\nThis setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLForceHost=true\n\n\nIf \nSSLForceHost\n is \ntrue\n and \nSSLHost\n is set, requests will be forced to use \nSSLHost\n even the ones that are already using SSL. Default is false.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLProxyHeaders=EXPR\n\n\nHeader combinations that would signify a proper SSL Request (Such as \nX-Forwarded-For:https\n).\nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.STSSeconds=315360000\n\n\nSets the max-age of the STS header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSIncludeSubdomains=true\n\n\nAdds the \nIncludeSubdomains\n section of the STS  header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSPreload=true\n\n\nAdds the preload flag to the STS  header.\n\n\n\n\n\n\n\n\nApplications with Multiple Ports (segment labels)\n\n\nSegment labels are used to define routes to an application exposing multiple ports.\nA segment is a group of labels that apply to a port exposed by an application.\nYou can define as many segments as ports exposed in an application.\n\n\nAdditionally, if a segment name matches a named port, that port will be used unless \nportIndex\n, \nportName\n, or \nport\n labels are specified for that segment.\n\n\nSegment labels override the default behavior.\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.backend=BACKEND\n\n\nSame as \ntraefik.backend\n\n\n\n\n\n\ntraefik.\nsegment_name\n.domain=DOMAIN\n\n\nSame as \ntraefik.domain\n\n\n\n\n\n\ntraefik.\nsegment_name\n.portIndex=1\n\n\nSame as \ntraefik.portIndex\n\n\n\n\n\n\ntraefik.\nsegment_name\n.portName=web\n\n\nSame as \ntraefik.portName\n\n\n\n\n\n\ntraefik.\nsegment_name\n.port=PORT\n\n\nSame as \ntraefik.port\n\n\n\n\n\n\ntraefik.\nsegment_name\n.protocol=http\n\n\nSame as \ntraefik.protocol\n\n\n\n\n\n\ntraefik.\nsegment_name\n.weight=10\n\n\nSame as \ntraefik.weight\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic=EXPR\n\n\nSame as \ntraefik.frontend.auth.basic\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.basic.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.users=EXPR\n\n\nSame as \ntraefik.frontend.auth.basic.users\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.usersFile=/path/.htpasswd\n\n\nSame as \ntraefik.frontend.auth.basic.usersFile\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.digest.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.users=EXPR\n\n\nSame as \ntraefik.frontend.auth.digest.users\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.usersFile=/path/.htdigest\n\n\nSame as \ntraefik.frontend.auth.digest.usersFile\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.address=https://example.com\n\n\nSame as \ntraefik.frontend.auth.forward.address\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.authResponseHeaders=EXPR\n\n\nSame as \ntraefik.frontend.auth.forward.authResponseHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.ca=/path/ca.pem\n\n\nSame as \ntraefik.frontend.auth.forward.tls.ca\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.caOptional=true\n\n\nSame as \ntraefik.frontend.auth.forward.tls.caOptional\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.cert=/path/server.pem\n\n\nSame as \ntraefik.frontend.auth.forward.tls.cert\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.insecureSkipVerify=true\n\n\nSame as \ntraefik.frontend.auth.forward.tls.insecureSkipVerify\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.key=/path/server.key\n\n\nSame as \ntraefik.frontend.auth.forward.tls.key\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.trustForwardHeader=true\n\n\nSame as \ntraefik.frontend.auth.forward.trustForwardHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.headerField=X-WebAuth-User\n\n\nSame as \ntraefik.frontend.auth.headerField\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.entryPoints=https\n\n\nSame as \ntraefik.frontend.entryPoints\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.backend=NAME\n\n\nSame as \ntraefik.frontend.errors.\nname\n.backend\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.query=PATH\n\n\nSame as \ntraefik.frontend.errors.\nname\n.query\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.status=RANGE\n\n\nSame as \ntraefik.frontend.errors.\nname\n.status\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passHostHeader=true\n\n\nSame as \ntraefik.frontend.passHostHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.notAfter=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.notAfter\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.notBefore=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.notBefore\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.sans=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.sans\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.commonName=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.commonName\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.country=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.country\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.locality=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.locality\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.organization=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.organization\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.province=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.province\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.serialNumber=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.serialNumber\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.pem=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.pem\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSCert=true\n\n\nSame as \ntraefik.frontend.passTLSCert\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.priority=10\n\n\nSame as \ntraefik.frontend.priority\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.extractorFunc=EXP\n\n\nSame as \ntraefik.frontend.rateLimit.extractorFunc\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.period=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.period\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.average=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.average\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.burst=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.burst\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.entryPoint=https\n\n\nSame as \ntraefik.frontend.redirect.entryPoint\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.regex=^http://localhost/(.*)\n\n\nSame as \ntraefik.frontend.redirect.regex\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.replacement=http://mydomain/$1\n\n\nSame as \ntraefik.frontend.redirect.replacement\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.permanent=true\n\n\nSame as \ntraefik.frontend.redirect.permanent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rule=EXP\n\n\nSame as \ntraefik.frontend.rule\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.whiteList.sourceRange=RANGE\n\n\nSame as \ntraefik.frontend.whiteList.sourceRange\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.whiteList.useXForwardedFor=true\n\n\nSame as \ntraefik.frontend.whiteList.useXForwardedFor\n\n\n\n\n\n\n\n\nCustom Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customRequestHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.customRequestHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customResponseHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.customResponseHeaders\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.allowedHosts=EXPR\n\n\nSame as \ntraefik.frontend.headers.allowedHosts\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.browserXSSFilter=true\n\n\nSame as \ntraefik.frontend.headers.browserXSSFilter\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.contentSecurityPolicy=VALUE\n\n\nSame as \ntraefik.frontend.headers.contentSecurityPolicy\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.contentTypeNosniff=true\n\n\nSame as \ntraefik.frontend.headers.contentTypeNosniff\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customBrowserXSSValue=VALUE\n\n\nSame as \ntraefik.frontend.headers.customBrowserXSSValue\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customFrameOptionsValue=VALUE\n\n\nSame as \ntraefik.frontend.headers.customFrameOptionsValue\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.forceSTSHeader=false\n\n\nSame as \ntraefik.frontend.headers.forceSTSHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.frameDeny=false\n\n\nSame as \ntraefik.frontend.headers.frameDeny\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.hostsProxyHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.hostsProxyHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.isDevelopment=false\n\n\nSame as \ntraefik.frontend.headers.isDevelopment\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.publicKey=VALUE\n\n\nSame as \ntraefik.frontend.headers.publicKey\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.referrerPolicy=VALUE\n\n\nSame as \ntraefik.frontend.headers.referrerPolicy\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLRedirect=true\n\n\nSame as \ntraefik.frontend.headers.SSLRedirect\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLTemporaryRedirect=true\n\n\nSame as \ntraefik.frontend.headers.SSLTemporaryRedirect\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLHost=HOST\n\n\nSame as \ntraefik.frontend.headers.SSLHost\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLForceHost=true\n\n\nSame as \ntraefik.frontend.headers.SSLForceHost\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLProxyHeaders=EXPR\n\n\nSame as \ntraefik.frontend.headers.SSLProxyHeaders=EXPR\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSSeconds=315360000\n\n\nSame as \ntraefik.frontend.headers.STSSeconds=315360000\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSIncludeSubdomains=true\n\n\nSame as \ntraefik.frontend.headers.STSIncludeSubdomains=true\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSPreload=true\n\n\nSame as \ntraefik.frontend.headers.STSPreload=true", 
            "title": "Mesos"
        }, 
        {
            "location": "/configuration/backends/mesos/#mesos-generic-provider", 
            "text": "Traefik can be configured to use Mesos as a provider.  ################################################################\n# Mesos Provider\n################################################################\n\n# Enable Mesos Provider.\n[mesos]\n\n# Mesos server endpoint.\n# You can also specify multiple endpoint for Mesos:\n# endpoint =  192.168.35.40:5050,192.168.35.41:5050,192.168.35.42:5050 \n# endpoint =  zk://192.168.35.20:2181,192.168.35.21:2181,192.168.35.22:2181/mesos \n#\n# Required\n# Default:  http://127.0.0.1:5050 \n#\nendpoint =  http://127.0.0.1:8080 \n\n# Enable watch Mesos changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the  traefik.domain  label on an application.\n#\n# Required\n#\ndomain =  mesos.localhost \n\n# Expose Mesos apps by default in Traefik.\n#\n# Optional\n# Default: true\n#\n# exposedByDefault = false\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename =  mesos.tmpl \n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# -  1 : previous template version (must be used only with older custom templates, see  filename )\n# -  2 : current template version (must be used to force template version when  filename  is used)\n#\n# templateVersion = 2\n\n# TLS client configuration. https://golang.org/pkg/crypto/tls/#Config\n#\n# Optional\n#\n# [mesos.TLS]\n# insecureSkipVerify = true\n\n# Zookeeper timeout (in seconds).\n#\n# Optional\n# Default: 30\n#\n# zkDetectionTimeout = 30\n\n# Polling interval (in seconds).\n#\n# Optional\n# Default: 30\n#\n# refreshSeconds = 30\n\n# IP sources (e.g. host, docker, mesos, netinfo).\n#\n# Optional\n#\n# ipSources =  host \n\n# HTTP Timeout (in seconds).\n#\n# Optional\n# Default: 30\n#\n# stateTimeoutSecond =  30 \n\n# Convert groups to subdomains.\n# Default behavior: /foo/bar/myapp =  foo-bar-myapp.{defaultDomain}\n# with groupsAsSubDomains enabled: /foo/bar/myapp =  myapp.bar.foo.{defaultDomain}\n#\n# Optional\n# Default: false\n#\n# groupsAsSubDomains = true", 
            "title": "Mesos Generic Provider"
        }, 
        {
            "location": "/configuration/backends/mesos/#labels-overriding-default-behavior", 
            "text": "The following labels can be defined on Mesos tasks. They adjust the behavior for the entire application.     Label  Description      traefik.domain  Sets the default base domain for the frontend rules.    traefik.enable=false  Disables this container in Traefik.    traefik.port=80  Registers this port. Useful when the application exposes multiple ports.    traefik.portName=web  Registers port by name in the application's ports array. Useful when the application exposes multiple ports.    traefik.portIndex=1  Registers port by index in the application's ports array. Useful when the application exposes multiple ports.    traefik.protocol=https  Overrides the default  http  protocol    traefik.weight=10  Assigns this weight to the container    traefik.backend=foo  Overrides the task name by  foo  in the generated name of the backend.    traefik.backend.buffering.maxRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.maxResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.retryExpression=EXPR  See  buffering  section.    traefik.backend.circuitbreaker.expression=EXPR  Creates a  circuit breaker  to be used against the backend    traefik.backend.responseForwarding.flushInterval=10ms  Defines the interval between two flushes when forwarding response from backend to client.    traefik.backend.healthcheck.path=/health  Enables health check for the backend, hitting the container at  path .    traefik.backend.healthcheck.interval=1s  Defines the health check interval. (Default: 30s)    traefik.backend.healthcheck.scheme=http  Overrides the server URL scheme.    traefik.backend.healthcheck.port=8080  Sets a different port for the health check.    traefik.backend.healthcheck.hostname=foobar.com  Defines the health check hostname.    traefik.backend.healthcheck.headers=EXPR  Defines the health check request headers  Format:   HEADER:value HEADER2:value2    traefik.backend.loadbalancer.method=drr  Overrides the default  wrr  load balancer algorithm    traefik.backend.loadbalancer.stickiness=true  Enables backend sticky sessions    traefik.backend.loadbalancer.stickiness.cookieName=NAME  Sets the cookie manually name for sticky sessions    traefik.backend.maxconn.amount=10  Sets a maximum number of connections to the backend. Must be used in conjunction with the below label to take effect.    traefik.backend.maxconn.extractorfunc=client.ip  Sets the function to be used against the request to determine what to limit maximum connections to the backend by. Must be used in conjunction with the above label to take effect.    traefik.frontend.auth.basic=EXPR  Sets basic authentication to this frontend in CSV format:  User:Hash,User:Hash  (DEPRECATED).    traefik.frontend.auth.basic.users=EXPR  Sets basic authentication to this frontend in CSV format:  User:Hash,User:Hash .    traefik.frontend.auth.basic.removeHeader=true  If set to  true , removes the  Authorization  header.    traefik.frontend.auth.basic.usersFile=/path/.htpasswd  Sets basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    traefik.frontend.auth.digest.removeHeader=true  If set to  true , removes the  Authorization  header.    traefik.frontend.auth.digest.users=EXPR  Sets digest authentication to this frontend in CSV format:  User:Realm:Hash,User:Realm:Hash .    traefik.frontend.auth.digest.usersFile=/path/.htdigest  Sets digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    traefik.frontend.auth.forward.address=https://example.com  Sets the URL of the authentication server.    traefik.frontend.auth.forward.authResponseHeaders=EXPR  Sets the forward authentication authResponseHeaders in CSV format:  X-Auth-User,X-Auth-Header    traefik.frontend.auth.forward.tls.ca=/path/ca.pem  Sets the Certificate Authority (CA) for the TLS connection with the authentication server.    traefik.frontend.auth.forward.tls.caOptional=true  Checks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).    traefik.frontend.auth.forward.tls.cert=/path/server.pem  Sets the Certificate for the TLS connection with the authentication server.    traefik.frontend.auth.forward.tls.insecureSkipVerify=true  If set to true invalid SSL certificates are accepted.    traefik.frontend.auth.forward.tls.key=/path/server.key  Sets the Certificate for the TLS connection with the authentication server.    traefik.frontend.auth.forward.trustForwardHeader=true  Trusts X-Forwarded-* headers.    traefik.frontend.auth.headerField=X-WebAuth-User  Sets the header used to pass the authenticated user to the application.    traefik.frontend.auth.removeHeader=true  If set to true, removes the Authorization header.    traefik.frontend.entryPoints=http,https  Assigns this frontend to entry points  http  and  https . Overrides  defaultEntryPoints    traefik.frontend.errors. name .backend=NAME  See  custom error pages  section.    traefik.frontend.errors. name .query=PATH  See  custom error pages  section.    traefik.frontend.errors. name .status=RANGE  See  custom error pages  section.    traefik.frontend.passHostHeader=true  Forwards client  Host  header to the backend.    traefik.frontend.passTLSClientCert.infos.issuer.commonName=true  Add the issuer.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.country=true  Add the issuer.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.domainComponent=true  Add the issuer.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.locality=true  Add the issuer.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.organization=true  Add the issuer.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.province=true  Add the issuer.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.serialNumber=true  Add the issuer.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.notAfter=true  Add the noAfter field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.notBefore=true  Add the noBefore field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.sans=true  Add the sans field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.commonName=true  Add the subject.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.country=true  Add the subject.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.domainComponent=true  Add the subject.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.locality=true  Add the subject.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.organization=true  Add the subject.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.province=true  Add the subject.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.serialNumber=true  Add the subject.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.pem=true  Pass the escaped pem in the  X-Forwarded-Ssl-Client-Cert  header.    traefik.frontend.passTLSCert=true  Forwards TLS Client certificates to the backend.    traefik.frontend.priority=10  Overrides default frontend priority    traefik.frontend.rateLimit.extractorFunc=EXP  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .period=6  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .average=6  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .burst=6  See  rate limiting  section.    traefik.frontend.redirect.entryPoint=https  Enables Redirect to another entryPoint to this frontend (e.g. HTTPS)    traefik.frontend.redirect.regex=^http://localhost/(.*)  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.replacement .    traefik.frontend.redirect.replacement=http://mydomain/$1  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.regex .    traefik.frontend.redirect.permanent=true  Returns 301 instead of 302.    traefik.frontend.rule=EXPR  Overrides the default frontend rule. Default:  Host:{discovery_name}.{domain} .    traefik.frontend.whiteList.sourceRange=RANGE  Sets a list of IP-Ranges which are allowed to access. An unset or empty list allows all Source-IPs to access. If one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.    traefik.frontend.whiteList.useXForwardedFor=true  Uses  X-Forwarded-For  header as valid source of IP for the white list.", 
            "title": "Labels: overriding default behavior"
        }, 
        {
            "location": "/configuration/backends/mesos/#custom-headers", 
            "text": "Label  Description      traefik.frontend.headers.customRequestHeaders=EXPR  Provides the container with custom request headers that will be appended to each request forwarded to the container. Format:  HEADER:value HEADER2:value2    traefik.frontend.headers.customResponseHeaders=EXPR  Appends the headers to each response returned by the container, before forwarding the response to the client. Format:  HEADER:value HEADER2:value2", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/mesos/#security-headers", 
            "text": "Label  Description      traefik.frontend.headers.allowedHosts=EXPR  Provides a list of allowed hosts that requests will be processed. Format:  Host1,Host2    traefik.frontend.headers.browserXSSFilter=true  Adds the X-XSS-Protection header with the value  1; mode=block .    traefik.frontend.headers.contentSecurityPolicy=VALUE  Adds CSP Header with the custom value.    traefik.frontend.headers.contentTypeNosniff=true  Adds the  X-Content-Type-Options  header with the value  nosniff .    traefik.frontend.headers.customBrowserXSSValue=VALUE  Set custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.    traefik.frontend.headers.customFrameOptionsValue=VALUE  Overrides the  X-Frame-Options  header with the custom value.    traefik.frontend.headers.forceSTSHeader=false  Adds the STS  header to non-SSL requests.    traefik.frontend.headers.frameDeny=false  Adds the  X-Frame-Options  header with the value of  DENY .    traefik.frontend.headers.hostsProxyHeaders=EXPR  Provides a list of headers that the proxied hostname may be stored. Format:  HEADER1,HEADER2    traefik.frontend.headers.isDevelopment=false  This will cause the  AllowedHosts ,  SSLRedirect , and  STSSeconds / STSIncludeSubdomains  options to be ignored during development. When deploying to production, be sure to set this to false.    traefik.frontend.headers.publicKey=VALUE  Adds HPKP header.    traefik.frontend.headers.referrerPolicy=VALUE  Adds referrer policy  header.    traefik.frontend.headers.SSLRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent.    traefik.frontend.headers.SSLTemporaryRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.    traefik.frontend.headers.SSLHost=HOST  This setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.    traefik.frontend.headers.SSLForceHost=true  If  SSLForceHost  is  true  and  SSLHost  is set, requests will be forced to use  SSLHost  even the ones that are already using SSL. Default is false.    traefik.frontend.headers.SSLProxyHeaders=EXPR  Header combinations that would signify a proper SSL Request (Such as  X-Forwarded-For:https ). Format:   HEADER:value HEADER2:value2    traefik.frontend.headers.STSSeconds=315360000  Sets the max-age of the STS header.    traefik.frontend.headers.STSIncludeSubdomains=true  Adds the  IncludeSubdomains  section of the STS  header.    traefik.frontend.headers.STSPreload=true  Adds the preload flag to the STS  header.", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/mesos/#applications-with-multiple-ports-segment-labels", 
            "text": "Segment labels are used to define routes to an application exposing multiple ports.\nA segment is a group of labels that apply to a port exposed by an application.\nYou can define as many segments as ports exposed in an application.  Additionally, if a segment name matches a named port, that port will be used unless  portIndex ,  portName , or  port  labels are specified for that segment.  Segment labels override the default behavior.     Label  Description      traefik. segment_name .backend=BACKEND  Same as  traefik.backend    traefik. segment_name .domain=DOMAIN  Same as  traefik.domain    traefik. segment_name .portIndex=1  Same as  traefik.portIndex    traefik. segment_name .portName=web  Same as  traefik.portName    traefik. segment_name .port=PORT  Same as  traefik.port    traefik. segment_name .protocol=http  Same as  traefik.protocol    traefik. segment_name .weight=10  Same as  traefik.weight    traefik. segment_name .frontend.auth.basic=EXPR  Same as  traefik.frontend.auth.basic    traefik. segment_name .frontend.auth.basic.removeHeader=true  Same as  traefik.frontend.auth.basic.removeHeader    traefik. segment_name .frontend.auth.basic.users=EXPR  Same as  traefik.frontend.auth.basic.users    traefik. segment_name .frontend.auth.basic.usersFile=/path/.htpasswd  Same as  traefik.frontend.auth.basic.usersFile    traefik. segment_name .frontend.auth.digest.removeHeader=true  Same as  traefik.frontend.auth.digest.removeHeader    traefik. segment_name .frontend.auth.digest.users=EXPR  Same as  traefik.frontend.auth.digest.users    traefik. segment_name .frontend.auth.digest.usersFile=/path/.htdigest  Same as  traefik.frontend.auth.digest.usersFile    traefik. segment_name .frontend.auth.forward.address=https://example.com  Same as  traefik.frontend.auth.forward.address    traefik. segment_name .frontend.auth.forward.authResponseHeaders=EXPR  Same as  traefik.frontend.auth.forward.authResponseHeaders    traefik. segment_name .frontend.auth.forward.tls.ca=/path/ca.pem  Same as  traefik.frontend.auth.forward.tls.ca    traefik. segment_name .frontend.auth.forward.tls.caOptional=true  Same as  traefik.frontend.auth.forward.tls.caOptional    traefik. segment_name .frontend.auth.forward.tls.cert=/path/server.pem  Same as  traefik.frontend.auth.forward.tls.cert    traefik. segment_name .frontend.auth.forward.tls.insecureSkipVerify=true  Same as  traefik.frontend.auth.forward.tls.insecureSkipVerify    traefik. segment_name .frontend.auth.forward.tls.key=/path/server.key  Same as  traefik.frontend.auth.forward.tls.key    traefik. segment_name .frontend.auth.forward.trustForwardHeader=true  Same as  traefik.frontend.auth.forward.trustForwardHeader    traefik. segment_name .frontend.auth.headerField=X-WebAuth-User  Same as  traefik.frontend.auth.headerField    traefik. segment_name .frontend.auth.removeHeader=true  Same as  traefik.frontend.auth.removeHeader    traefik. segment_name .frontend.entryPoints=https  Same as  traefik.frontend.entryPoints    traefik. segment_name .frontend.errors. name .backend=NAME  Same as  traefik.frontend.errors. name .backend    traefik. segment_name .frontend.errors. name .query=PATH  Same as  traefik.frontend.errors. name .query    traefik. segment_name .frontend.errors. name .status=RANGE  Same as  traefik.frontend.errors. name .status    traefik. segment_name .frontend.passHostHeader=true  Same as  traefik.frontend.passHostHeader    traefik. segment_name .frontend.passTLSClientCert.infos.notAfter=true  Same as  traefik.frontend.passTLSClientCert.infos.notAfter    traefik. segment_name .frontend.passTLSClientCert.infos.notBefore=true  Same as  traefik.frontend.passTLSClientCert.infos.notBefore    traefik. segment_name .frontend.passTLSClientCert.infos.sans=true  Same as  traefik.frontend.passTLSClientCert.infos.sans    traefik. segment_name .frontend.passTLSClientCert.infos.subject.commonName=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.commonName    traefik. segment_name .frontend.passTLSClientCert.infos.subject.country=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.country    traefik. segment_name .frontend.passTLSClientCert.infos.subject.locality=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.locality    traefik. segment_name .frontend.passTLSClientCert.infos.subject.organization=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.organization    traefik. segment_name .frontend.passTLSClientCert.infos.subject.province=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.province    traefik. segment_name .frontend.passTLSClientCert.infos.subject.serialNumber=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.serialNumber    traefik. segment_name .frontend.passTLSClientCert.pem=true  Same as  traefik.frontend.passTLSClientCert.infos.pem    traefik. segment_name .frontend.passTLSCert=true  Same as  traefik.frontend.passTLSCert    traefik. segment_name .frontend.priority=10  Same as  traefik.frontend.priority    traefik. segment_name .frontend.rateLimit.extractorFunc=EXP  Same as  traefik.frontend.rateLimit.extractorFunc    traefik. segment_name .frontend.rateLimit.rateSet. name .period=6  Same as  traefik.frontend.rateLimit.rateSet. name .period    traefik. segment_name .frontend.rateLimit.rateSet. name .average=6  Same as  traefik.frontend.rateLimit.rateSet. name .average    traefik. segment_name .frontend.rateLimit.rateSet. name .burst=6  Same as  traefik.frontend.rateLimit.rateSet. name .burst    traefik. segment_name .frontend.redirect.entryPoint=https  Same as  traefik.frontend.redirect.entryPoint    traefik. segment_name .frontend.redirect.regex=^http://localhost/(.*)  Same as  traefik.frontend.redirect.regex    traefik. segment_name .frontend.redirect.replacement=http://mydomain/$1  Same as  traefik.frontend.redirect.replacement    traefik. segment_name .frontend.redirect.permanent=true  Same as  traefik.frontend.redirect.permanent    traefik. segment_name .frontend.rule=EXP  Same as  traefik.frontend.rule    traefik. segment_name .frontend.whiteList.sourceRange=RANGE  Same as  traefik.frontend.whiteList.sourceRange    traefik. segment_name .frontend.whiteList.useXForwardedFor=true  Same as  traefik.frontend.whiteList.useXForwardedFor", 
            "title": "Applications with Multiple Ports (segment labels)"
        }, 
        {
            "location": "/configuration/backends/mesos/#custom-headers_1", 
            "text": "Label  Description      traefik. segment_name .frontend.headers.customRequestHeaders=EXPR  Same as  traefik.frontend.headers.customRequestHeaders    traefik. segment_name .frontend.headers.customResponseHeaders=EXPR  Same as  traefik.frontend.headers.customResponseHeaders", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/mesos/#security-headers_1", 
            "text": "Label  Description      traefik. segment_name .frontend.headers.allowedHosts=EXPR  Same as  traefik.frontend.headers.allowedHosts    traefik. segment_name .frontend.headers.browserXSSFilter=true  Same as  traefik.frontend.headers.browserXSSFilter    traefik. segment_name .frontend.headers.contentSecurityPolicy=VALUE  Same as  traefik.frontend.headers.contentSecurityPolicy    traefik. segment_name .frontend.headers.contentTypeNosniff=true  Same as  traefik.frontend.headers.contentTypeNosniff    traefik. segment_name .frontend.headers.customBrowserXSSValue=VALUE  Same as  traefik.frontend.headers.customBrowserXSSValue    traefik. segment_name .frontend.headers.customFrameOptionsValue=VALUE  Same as  traefik.frontend.headers.customFrameOptionsValue    traefik. segment_name .frontend.headers.forceSTSHeader=false  Same as  traefik.frontend.headers.forceSTSHeader    traefik. segment_name .frontend.headers.frameDeny=false  Same as  traefik.frontend.headers.frameDeny    traefik. segment_name .frontend.headers.hostsProxyHeaders=EXPR  Same as  traefik.frontend.headers.hostsProxyHeaders    traefik. segment_name .frontend.headers.isDevelopment=false  Same as  traefik.frontend.headers.isDevelopment    traefik. segment_name .frontend.headers.publicKey=VALUE  Same as  traefik.frontend.headers.publicKey    traefik. segment_name .frontend.headers.referrerPolicy=VALUE  Same as  traefik.frontend.headers.referrerPolicy    traefik. segment_name .frontend.headers.SSLRedirect=true  Same as  traefik.frontend.headers.SSLRedirect    traefik. segment_name .frontend.headers.SSLTemporaryRedirect=true  Same as  traefik.frontend.headers.SSLTemporaryRedirect    traefik. segment_name .frontend.headers.SSLHost=HOST  Same as  traefik.frontend.headers.SSLHost    traefik. segment_name .frontend.headers.SSLForceHost=true  Same as  traefik.frontend.headers.SSLForceHost    traefik. segment_name .frontend.headers.SSLProxyHeaders=EXPR  Same as  traefik.frontend.headers.SSLProxyHeaders=EXPR    traefik. segment_name .frontend.headers.STSSeconds=315360000  Same as  traefik.frontend.headers.STSSeconds=315360000    traefik. segment_name .frontend.headers.STSIncludeSubdomains=true  Same as  traefik.frontend.headers.STSIncludeSubdomains=true    traefik. segment_name .frontend.headers.STSPreload=true  Same as  traefik.frontend.headers.STSPreload=true", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/rancher/", 
            "text": "Rancher Provider\n\n\nTraefik can be configured to use Rancher as a provider.\n\n\n\n\nImportant\n\n\nThis provider is specific to Rancher 1.x.\nRancher 2.x requires Kubernetes and does not have a metadata endpoint of its own for Traefik to query.\nAs such, Rancher 2.x users should utilize the \nKubernetes provider\n directly.\n\n\n\n\nGlobal Configuration\n\n\n################################################################\n# Rancher Provider\n################################################################\n\n# Enable Rancher Provider.\n[rancher]\n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the \ntraefik.domain\n label on an service.\n#\n# Required\n#\ndomain = \nrancher.localhost\n\n\n# Enable watch Rancher changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Polling interval (in seconds).\n#\n# Optional\n# Default: 15\n#\nrefreshSeconds = 15\n\n# Expose Rancher services by default in Traefik.\n#\n# Optional\n# Default: true\n#\nexposedByDefault = false\n\n# Filter services with unhealthy states and inactive states.\n#\n# Optional\n# Default: false\n#\nenableServiceHealthFilter = true\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename = \nrancher.tmpl\n\n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# - \n1\n: previous template version (must be used only with older custom templates, see \nfilename\n)\n# - \n2\n: current template version (must be used to force template version when \nfilename\n is used)\n#\n# templateVersion = 2\n\n\n\n\nTo enable constraints see \nprovider-specific constraints section\n.\n\n\nRancher Metadata Service\n\n\n# Enable Rancher metadata service provider instead of the API\n# provider.\n#\n# Optional\n# Default: false\n#\n[rancher.metadata]\n\n# Poll the Rancher metadata service for changes every `rancher.refreshSeconds`.\n# NOTE: this is less accurate than the default long polling technique which\n# will provide near instantaneous updates to Traefik\n#\n# Optional\n# Default: false\n#\nintervalPoll = true\n\n# Prefix used for accessing the Rancher metadata service.\n#\n# Optional\n# Default: \n/latest\n\n#\nprefix = \n/2016-07-29\n\n\n\n\n\nRancher API\n\n\n# Enable Rancher API provider.\n#\n# Optional\n# Default: true\n#\n[rancher.api]\n\n# Endpoint to use when connecting to the Rancher API.\n#\n# Required\nendpoint = \nhttp://rancherserver.example.com/v1\n\n\n# AccessKey to use when connecting to the Rancher API.\n#\n# Required\naccessKey = \nXXXXXXXXXXXXXXXXXXXX\n\n\n# SecretKey to use when connecting to the Rancher API.\n#\n# Required\nsecretKey = \nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n\n\n\n\n\n\nNote\n\n\nIf Traefik needs access to the Rancher API, you need to set the \nendpoint\n, \naccesskey\n and \nsecretkey\n parameters.\n\n\nTo enable Traefik to fetch information about the Environment it's deployed in only, you need to create an \nEnvironment API Key\n.\nThis can be found within the API Key advanced options.\n\n\nAdd these labels to traefik docker deployment to autogenerated these values:\n\nio.rancher.container.agent.role: environment\nio.rancher.container.create_agent: true\n\n\n\n\nLabels: overriding default behavior\n\n\nOn Containers\n\n\nLabels can be used on task containers to override default behavior:\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.domain\n\n\nSets the default base domain for the frontend rules.\n\n\n\n\n\n\ntraefik.enable=false\n\n\nDisables this container in Traefik.\n\n\n\n\n\n\ntraefik.port=80\n\n\nRegisters this port. Useful when the container exposes multiple ports.\n\n\n\n\n\n\ntraefik.protocol=https\n\n\nOverrides the default \nhttp\n protocol.\n\n\n\n\n\n\ntraefik.weight=10\n\n\nAssigns this weight to the container.\n\n\n\n\n\n\ntraefik.backend=foo\n\n\nOverrides the service name by \nfoo\n in the generated name of the backend.\n\n\n\n\n\n\ntraefik.backend.buffering.maxRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.maxResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memRequestBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.memResponseBodyBytes=0\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.buffering.retryExpression=EXPR\n\n\nSee \nbuffering\n section.\n\n\n\n\n\n\ntraefik.backend.circuitbreaker.expression=EXPR\n\n\nCreates a \ncircuit breaker\n to be used against the backend\n\n\n\n\n\n\ntraefik.backend.responseForwarding.flushInterval=10ms\n\n\nDefines the interval between two flushes when forwarding response from backend to client.\n\n\n\n\n\n\ntraefik.backend.healthcheck.path=/health\n\n\nEnables health check for the backend, hitting the container at \npath\n.\n\n\n\n\n\n\ntraefik.backend.healthcheck.interval=1s\n\n\nDefines the health check interval.\n\n\n\n\n\n\ntraefik.backend.healthcheck.port=8080\n\n\nSets a different port for the health check.\n\n\n\n\n\n\ntraefik.backend.healthcheck.scheme=http\n\n\nOverrides the server URL scheme.\n\n\n\n\n\n\ntraefik.backend.healthcheck.hostname=foobar.com\n\n\nDefines the health check hostname.\n\n\n\n\n\n\ntraefik.backend.healthcheck.headers=EXPR\n\n\nDefines the health check request headers \nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.backend.loadbalancer.method=drr\n\n\nOverrides the default \nwrr\n load balancer algorithm\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness=true\n\n\nEnables backend sticky sessions\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness.cookieName=NAME\n\n\nSets the cookie name manually for sticky sessions\n\n\n\n\n\n\ntraefik.backend.loadbalancer.sticky=true\n\n\nEnables backend sticky sessions (DEPRECATED)\n\n\n\n\n\n\ntraefik.backend.maxconn.amount=10\n\n\nSets a maximum number of connections to the backend.\nMust be used in conjunction with the below label to take effect.\n\n\n\n\n\n\ntraefik.backend.maxconn.extractorfunc=client.ip\n\n\nSets the function to be used against the request to determine what to limit maximum connections to the backend by.\nMust be used in conjunction with the above label to take effect.\n\n\n\n\n\n\ntraefik.frontend.auth.basic=EXPR\n\n\nSets the basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n (DEPRECATED).\n\n\n\n\n\n\ntraefik.frontend.auth.basic.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\ntraefik.frontend.auth.basic.users=EXPR\n\n\nSets the basic authentication to this frontend in CSV format: \nUser:Hash,User:Hash\n .\n\n\n\n\n\n\ntraefik.frontend.auth.basic.usersFile=/path/.htpasswd\n\n\nSets the basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.removeHeader=true\n\n\nIf set to \ntrue\n, removes the \nAuthorization\n header.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.users=EXPR\n\n\nSets the digest authentication to this frontend in CSV format: \nUser:Realm:Hash,User:Realm:Hash\n.\n\n\n\n\n\n\ntraefik.frontend.auth.digest.usersFile=/path/.htdigest\n\n\nSets the digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.address=https://example.com\n\n\nSets the URL of the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.authResponseHeaders=EXPR\n\n\nSets the forward authentication authResponseHeaders in CSV format: \nX-Auth-User,X-Auth-Header\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.ca=/path/ca.pem\n\n\nSets the Certificate Authority (CA) for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.caOptional=true\n\n\nChecks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.cert=/path/server.pem\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.insecureSkipVerify=true\n\n\nIf set to true invalid SSL certificates are accepted.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.tls.key=/path/server.key\n\n\nSets the Certificate for the TLS connection with the authentication server.\n\n\n\n\n\n\ntraefik.frontend.auth.forward.trustForwardHeader=true\n\n\nTrusts X-Forwarded-* headers.\n\n\n\n\n\n\ntraefik.frontend.auth.headerField=X-WebAuth-User\n\n\nSets the header used to pass the authenticated user to the application.\n\n\n\n\n\n\ntraefik.frontend.entryPoints=http,https\n\n\nAssigns this frontend to entry points \nhttp\n and \nhttps\n.\nOverrides \ndefaultEntryPoints\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.backend=NAME\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.query=PATH\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.errors.\nname\n.status=RANGE\n\n\nSee \ncustom error pages\n section.\n\n\n\n\n\n\ntraefik.frontend.passHostHeader=true\n\n\nForwards client \nHost\n header to the backend.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.commonName=true\n\n\nAdd the issuer.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.country=true\n\n\nAdd the issuer.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.domainComponent=true\n\n\nAdd the issuer.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.locality=true\n\n\nAdd the issuer.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.organization=true\n\n\nAdd the issuer.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.province=true\n\n\nAdd the issuer.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.issuer.serialNumber=true\n\n\nAdd the issuer.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.notAfter=true\n\n\nAdd the noAfter field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.notBefore=true\n\n\nAdd the noBefore field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.sans=true\n\n\nAdd the sans field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.commonName=true\n\n\nAdd the subject.commonName field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.country=true\n\n\nAdd the subject.country field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.domainComponent=true\n\n\nAdd the subject.domainComponent field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.locality=true\n\n\nAdd the subject.locality field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.organization=true\n\n\nAdd the subject.organization field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.province=true\n\n\nAdd the subject.province field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.infos.subject.serialNumber=true\n\n\nAdd the subject.serialNumber field in a escaped client infos in the \nX-Forwarded-Ssl-Client-Cert-Infos\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSClientCert.pem=true\n\n\nPass the escaped pem in the \nX-Forwarded-Ssl-Client-Cert\n header.\n\n\n\n\n\n\ntraefik.frontend.passTLSCert=true\n\n\nForwards TLS Client certificates to the backend.\n\n\n\n\n\n\ntraefik.frontend.priority=10\n\n\nOverrides default frontend priority\n\n\n\n\n\n\ntraefik.frontend.rateLimit.extractorFunc=EXP\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.period=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.average=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.rateLimit.rateSet.\nname\n.burst=6\n\n\nSee \nrate limiting\n section.\n\n\n\n\n\n\ntraefik.frontend.redirect.entryPoint=https\n\n\nEnables Redirect to another entryPoint to this frontend (e.g. HTTPS)\n\n\n\n\n\n\ntraefik.frontend.redirect.regex=^http://localhost/(.*)\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.replacement\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.replacement=http://mydomain/$1\n\n\nRedirects to another URL to this frontend.\nMust be set with \ntraefik.frontend.redirect.regex\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.permanent=true\n\n\nReturns 301 instead of 302.\n\n\n\n\n\n\ntraefik.frontend.rule=EXPR\n\n\nOverrides the default frontend rule. Default: \nHost:{containerName}.{domain}\n or \nHost:{service}.{project_name}.{domain}\n if you are using \ndocker-compose\n.\n\n\n\n\n\n\ntraefik.frontend.whiteList.sourceRange=RANGE\n\n\nSets a list of IP-Ranges which are allowed to access.\nAn unset or empty list allows all Source-IPs to access.\nIf one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.\n\n\n\n\n\n\ntraefik.frontend.whiteList.useXForwardedFor=true\n\n\nUses \nX-Forwarded-For\n header as valid source of IP for the white list.\n\n\n\n\n\n\n\n\nCustom Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.customRequestHeaders=EXPR\n\n\nProvides the container with custom request headers that will be appended to each request forwarded to the container.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.customResponseHeaders=EXPR\n\n\nAppends the headers to each response returned by the container, before forwarding the response to the client.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.allowedHosts=EXPR\n\n\nProvides a list of allowed hosts that requests will be processed.\nFormat: \nHost1,Host2\n\n\n\n\n\n\ntraefik.frontend.headers.browserXSSFilter=true\n\n\nAdds the X-XSS-Protection header with the value \n1; mode=block\n.\n\n\n\n\n\n\ntraefik.frontend.headers.contentSecurityPolicy=VALUE\n\n\nAdds CSP Header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.contentTypeNosniff=true\n\n\nAdds the \nX-Content-Type-Options\n header with the value \nnosniff\n.\n\n\n\n\n\n\ntraefik.frontend.headers.customBrowserXSSValue=VALUE\n\n\nSet custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.\n\n\n\n\n\n\ntraefik.frontend.headers.customFrameOptionsValue=VALUE\n\n\nOverrides the \nX-Frame-Options\n header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.forceSTSHeader=false\n\n\nAdds the STS  header to non-SSL requests.\n\n\n\n\n\n\ntraefik.frontend.headers.frameDeny=false\n\n\nAdds the \nX-Frame-Options\n header with the value of \nDENY\n.\n\n\n\n\n\n\ntraefik.frontend.headers.hostsProxyHeaders=EXPR\n\n\nProvides a list of headers that the proxied hostname may be stored.\nFormat: \nHEADER1,HEADER2\n\n\n\n\n\n\ntraefik.frontend.headers.isDevelopment=false\n\n\nThis will cause the \nAllowedHosts\n, \nSSLRedirect\n, and \nSTSSeconds\n/\nSTSIncludeSubdomains\n options to be ignored during development.\nWhen deploying to production, be sure to set this to false.\n\n\n\n\n\n\ntraefik.frontend.headers.publicKey=VALUE\n\n\nAdds HPKP header.\n\n\n\n\n\n\ntraefik.frontend.headers.referrerPolicy=VALUE\n\n\nAdds referrer policy  header.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLTemporaryRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLHost=HOST\n\n\nThis setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLForceHost=true\n\n\nIf \nSSLForceHost\n is \ntrue\n and \nSSLHost\n is set, requests will be forced to use \nSSLHost\n even the ones that are already using SSL. Default is false.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLProxyHeaders=EXPR\n\n\nHeader combinations that would signify a proper SSL Request (Such as \nX-Forwarded-For:https\n).\nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.STSSeconds=315360000\n\n\nSets the max-age of the STS header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSIncludeSubdomains=true\n\n\nAdds the \nIncludeSubdomains\n section of the STS  header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSPreload=true\n\n\nAdds the preload flag to the STS  header.\n\n\n\n\n\n\n\n\nOn containers with Multiple Ports (segment labels)\n\n\nSegment labels are used to define routes to a container exposing multiple ports.\nA segment is a group of labels that apply to a port exposed by a container.\nYou can define as many segments as ports exposed in a container.\n\n\nSegment labels override the default behavior.\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.backend=BACKEND\n\n\nSame as \ntraefik.backend\n\n\n\n\n\n\ntraefik.\nsegment_name\n.domain=DOMAIN\n\n\nSame as \ntraefik.domain\n\n\n\n\n\n\ntraefik.\nsegment_name\n.port=PORT\n\n\nSame as \ntraefik.port\n\n\n\n\n\n\ntraefik.\nsegment_name\n.protocol=http\n\n\nSame as \ntraefik.protocol\n\n\n\n\n\n\ntraefik.\nsegment_name\n.weight=10\n\n\nSame as \ntraefik.weight\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic=EXPR\n\n\nSame as \ntraefik.frontend.auth.basic\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.basic.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.users=EXPR\n\n\nSame as \ntraefik.frontend.auth.basic.users\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.basic.usersFile=/path/.htpasswd\n\n\nSame as \ntraefik.frontend.auth.basic.usersFile\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.removeHeader=true\n\n\nSame as \ntraefik.frontend.auth.digest.removeHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.users=EXPR\n\n\nSame as \ntraefik.frontend.auth.digest.users\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.digest.usersFile=/path/.htdigest\n\n\nSame as \ntraefik.frontend.auth.digest.usersFile\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.address=https://example.com\n\n\nSame as \ntraefik.frontend.auth.forward.address\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.authResponseHeaders=EXPR\n\n\nSame as \ntraefik.frontend.auth.forward.authResponseHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.ca=/path/ca.pem\n\n\nSame as \ntraefik.frontend.auth.forward.tls.ca\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.caOptional=true\n\n\nSame as \ntraefik.frontend.auth.forward.tls.caOptional\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.cert=/path/server.pem\n\n\nSame as \ntraefik.frontend.auth.forward.tls.cert\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.insecureSkipVerify=true\n\n\nSame as \ntraefik.frontend.auth.forward.tls.insecureSkipVerify\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.tls.key=/path/server.key\n\n\nSame as \ntraefik.frontend.auth.forward.tls.key\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.forward.trustForwardHeader=true\n\n\nSame as \ntraefik.frontend.auth.forward.trustForwardHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.auth.headerField=X-WebAuth-User\n\n\nSame as \ntraefik.frontend.auth.headerField\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.entryPoints=https\n\n\nSame as \ntraefik.frontend.entryPoints\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.backend=NAME\n\n\nSame as \ntraefik.frontend.errors.\nname\n.backend\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.query=PATH\n\n\nSame as \ntraefik.frontend.errors.\nname\n.query\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.errors.\nname\n.status=RANGE\n\n\nSame as \ntraefik.frontend.errors.\nname\n.status\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passHostHeader=true\n\n\nSame as \ntraefik.frontend.passHostHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.commonName=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.commonName\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.country=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.country\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.domainComponent=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.domainComponent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.locality=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.locality\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.organization=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.organization\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.province=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.province\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.issuer.serialNumber=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.issuer.serialNumber\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.notAfter=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.notAfter\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.notBefore=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.notBefore\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.sans=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.sans\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.commonName=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.commonName\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.country=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.country\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.domainComponent=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.domainComponent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.locality=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.locality\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.organization=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.organization\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.province=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.province\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.infos.subject.serialNumber=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.subject.serialNumber\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSClientCert.pem=true\n\n\nSame as \ntraefik.frontend.passTLSClientCert.infos.pem\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.passTLSCert=true\n\n\nSame as \ntraefik.frontend.passTLSCert\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.priority=10\n\n\nSame as \ntraefik.frontend.priority\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.extractorFunc=EXP\n\n\nSame as \ntraefik.frontend.rateLimit.extractorFunc\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.period=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.period\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.average=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.average\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rateLimit.rateSet.\nname\n.burst=6\n\n\nSame as \ntraefik.frontend.rateLimit.rateSet.\nname\n.burst\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.entryPoint=https\n\n\nSame as \ntraefik.frontend.redirect.entryPoint\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.regex=^http://localhost/(.*)\n\n\nSame as \ntraefik.frontend.redirect.regex\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.replacement=http://mydomain/$1\n\n\nSame as \ntraefik.frontend.redirect.replacement\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.redirect.permanent=true\n\n\nSame as \ntraefik.frontend.redirect.permanent\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.rule=EXP\n\n\nSame as \ntraefik.frontend.rule\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.whiteList.sourceRange=RANGE\n\n\nSame as \ntraefik.frontend.whiteList.sourceRange\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.whiteList.useXForwardedFor=true\n\n\nSame as \ntraefik.frontend.whiteList.useXForwardedFor\n\n\n\n\n\n\n\n\nCustom Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customRequestHeaders=EXPR\n\n\noverrides \ntraefik.frontend.headers.customRequestHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customResponseHeaders=EXPR\n\n\noverrides \ntraefik.frontend.headers.customResponseHeaders\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.allowedHosts=EXPR\n\n\noverrides \ntraefik.frontend.headers.allowedHosts\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.browserXSSFilter=true\n\n\noverrides \ntraefik.frontend.headers.browserXSSFilter\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.contentSecurityPolicy=VALUE\n\n\noverrides \ntraefik.frontend.headers.contentSecurityPolicy\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.contentTypeNosniff=true\n\n\noverrides \ntraefik.frontend.headers.contentTypeNosniff\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customBrowserXSSValue=VALUE\n\n\noverrides \ntraefik.frontend.headers.customBrowserXSSValue\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.customFrameOptionsValue=VALUE\n\n\noverrides \ntraefik.frontend.headers.customFrameOptionsValue\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.forceSTSHeader=false\n\n\noverrides \ntraefik.frontend.headers.forceSTSHeader\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.frameDeny=false\n\n\noverrides \ntraefik.frontend.headers.frameDeny\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.hostsProxyHeaders=EXPR\n\n\noverrides \ntraefik.frontend.headers.hostsProxyHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.isDevelopment=false\n\n\noverrides \ntraefik.frontend.headers.isDevelopment\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.publicKey=VALUE\n\n\noverrides \ntraefik.frontend.headers.publicKey\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.referrerPolicy=VALUE\n\n\noverrides \ntraefik.frontend.headers.referrerPolicy\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLRedirect=true\n\n\noverrides \ntraefik.frontend.headers.SSLRedirect\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLTemporaryRedirect=true\n\n\noverrides \ntraefik.frontend.headers.SSLTemporaryRedirect\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLHost=HOST\n\n\noverrides \ntraefik.frontend.headers.SSLHost\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLForceHost=true\n\n\noverrides \ntraefik.frontend.headers.SSLForceHost\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.SSLProxyHeaders=EXPR\n\n\noverrides \ntraefik.frontend.headers.SSLProxyHeaders\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSSeconds=315360000\n\n\noverrides \ntraefik.frontend.headers.STSSeconds\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSIncludeSubdomains=true\n\n\noverrides \ntraefik.frontend.headers.STSIncludeSubdomains\n\n\n\n\n\n\ntraefik.\nsegment_name\n.frontend.headers.STSPreload=true\n\n\noverrides \ntraefik.frontend.headers.STSPreload", 
            "title": "Rancher"
        }, 
        {
            "location": "/configuration/backends/rancher/#rancher-provider", 
            "text": "Traefik can be configured to use Rancher as a provider.   Important  This provider is specific to Rancher 1.x.\nRancher 2.x requires Kubernetes and does not have a metadata endpoint of its own for Traefik to query.\nAs such, Rancher 2.x users should utilize the  Kubernetes provider  directly.", 
            "title": "Rancher Provider"
        }, 
        {
            "location": "/configuration/backends/rancher/#global-configuration", 
            "text": "################################################################\n# Rancher Provider\n################################################################\n\n# Enable Rancher Provider.\n[rancher]\n\n# Default base domain used for the frontend rules.\n# Can be overridden by setting the  traefik.domain  label on an service.\n#\n# Required\n#\ndomain =  rancher.localhost \n\n# Enable watch Rancher changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Polling interval (in seconds).\n#\n# Optional\n# Default: 15\n#\nrefreshSeconds = 15\n\n# Expose Rancher services by default in Traefik.\n#\n# Optional\n# Default: true\n#\nexposedByDefault = false\n\n# Filter services with unhealthy states and inactive states.\n#\n# Optional\n# Default: false\n#\nenableServiceHealthFilter = true\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename =  rancher.tmpl \n\n# Override template version\n# For advanced users :)\n#\n# Optional\n# -  1 : previous template version (must be used only with older custom templates, see  filename )\n# -  2 : current template version (must be used to force template version when  filename  is used)\n#\n# templateVersion = 2  To enable constraints see  provider-specific constraints section .", 
            "title": "Global Configuration"
        }, 
        {
            "location": "/configuration/backends/rancher/#rancher-metadata-service", 
            "text": "# Enable Rancher metadata service provider instead of the API\n# provider.\n#\n# Optional\n# Default: false\n#\n[rancher.metadata]\n\n# Poll the Rancher metadata service for changes every `rancher.refreshSeconds`.\n# NOTE: this is less accurate than the default long polling technique which\n# will provide near instantaneous updates to Traefik\n#\n# Optional\n# Default: false\n#\nintervalPoll = true\n\n# Prefix used for accessing the Rancher metadata service.\n#\n# Optional\n# Default:  /latest \n#\nprefix =  /2016-07-29", 
            "title": "Rancher Metadata Service"
        }, 
        {
            "location": "/configuration/backends/rancher/#rancher-api", 
            "text": "# Enable Rancher API provider.\n#\n# Optional\n# Default: true\n#\n[rancher.api]\n\n# Endpoint to use when connecting to the Rancher API.\n#\n# Required\nendpoint =  http://rancherserver.example.com/v1 \n\n# AccessKey to use when connecting to the Rancher API.\n#\n# Required\naccessKey =  XXXXXXXXXXXXXXXXXXXX \n\n# SecretKey to use when connecting to the Rancher API.\n#\n# Required\nsecretKey =  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    Note  If Traefik needs access to the Rancher API, you need to set the  endpoint ,  accesskey  and  secretkey  parameters.  To enable Traefik to fetch information about the Environment it's deployed in only, you need to create an  Environment API Key .\nThis can be found within the API Key advanced options.  Add these labels to traefik docker deployment to autogenerated these values: io.rancher.container.agent.role: environment\nio.rancher.container.create_agent: true", 
            "title": "Rancher API"
        }, 
        {
            "location": "/configuration/backends/rancher/#labels-overriding-default-behavior", 
            "text": "", 
            "title": "Labels: overriding default behavior"
        }, 
        {
            "location": "/configuration/backends/rancher/#on-containers", 
            "text": "Labels can be used on task containers to override default behavior:     Label  Description      traefik.domain  Sets the default base domain for the frontend rules.    traefik.enable=false  Disables this container in Traefik.    traefik.port=80  Registers this port. Useful when the container exposes multiple ports.    traefik.protocol=https  Overrides the default  http  protocol.    traefik.weight=10  Assigns this weight to the container.    traefik.backend=foo  Overrides the service name by  foo  in the generated name of the backend.    traefik.backend.buffering.maxRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.maxResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memRequestBodyBytes=0  See  buffering  section.    traefik.backend.buffering.memResponseBodyBytes=0  See  buffering  section.    traefik.backend.buffering.retryExpression=EXPR  See  buffering  section.    traefik.backend.circuitbreaker.expression=EXPR  Creates a  circuit breaker  to be used against the backend    traefik.backend.responseForwarding.flushInterval=10ms  Defines the interval between two flushes when forwarding response from backend to client.    traefik.backend.healthcheck.path=/health  Enables health check for the backend, hitting the container at  path .    traefik.backend.healthcheck.interval=1s  Defines the health check interval.    traefik.backend.healthcheck.port=8080  Sets a different port for the health check.    traefik.backend.healthcheck.scheme=http  Overrides the server URL scheme.    traefik.backend.healthcheck.hostname=foobar.com  Defines the health check hostname.    traefik.backend.healthcheck.headers=EXPR  Defines the health check request headers  Format:   HEADER:value HEADER2:value2    traefik.backend.loadbalancer.method=drr  Overrides the default  wrr  load balancer algorithm    traefik.backend.loadbalancer.stickiness=true  Enables backend sticky sessions    traefik.backend.loadbalancer.stickiness.cookieName=NAME  Sets the cookie name manually for sticky sessions    traefik.backend.loadbalancer.sticky=true  Enables backend sticky sessions (DEPRECATED)    traefik.backend.maxconn.amount=10  Sets a maximum number of connections to the backend. Must be used in conjunction with the below label to take effect.    traefik.backend.maxconn.extractorfunc=client.ip  Sets the function to be used against the request to determine what to limit maximum connections to the backend by. Must be used in conjunction with the above label to take effect.    traefik.frontend.auth.basic=EXPR  Sets the basic authentication to this frontend in CSV format:  User:Hash,User:Hash  (DEPRECATED).    traefik.frontend.auth.basic.removeHeader=true  If set to  true , removes the  Authorization  header.    traefik.frontend.auth.basic.users=EXPR  Sets the basic authentication to this frontend in CSV format:  User:Hash,User:Hash  .    traefik.frontend.auth.basic.usersFile=/path/.htpasswd  Sets the basic authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    traefik.frontend.auth.digest.removeHeader=true  If set to  true , removes the  Authorization  header.    traefik.frontend.auth.digest.users=EXPR  Sets the digest authentication to this frontend in CSV format:  User:Realm:Hash,User:Realm:Hash .    traefik.frontend.auth.digest.usersFile=/path/.htdigest  Sets the digest authentication with an external file; if users and usersFile are provided, both are merged, with external file contents having precedence.    traefik.frontend.auth.forward.address=https://example.com  Sets the URL of the authentication server.    traefik.frontend.auth.forward.authResponseHeaders=EXPR  Sets the forward authentication authResponseHeaders in CSV format:  X-Auth-User,X-Auth-Header    traefik.frontend.auth.forward.tls.ca=/path/ca.pem  Sets the Certificate Authority (CA) for the TLS connection with the authentication server.    traefik.frontend.auth.forward.tls.caOptional=true  Checks the certificates if present but do not force to be signed by a specified Certificate Authority (CA).    traefik.frontend.auth.forward.tls.cert=/path/server.pem  Sets the Certificate for the TLS connection with the authentication server.    traefik.frontend.auth.forward.tls.insecureSkipVerify=true  If set to true invalid SSL certificates are accepted.    traefik.frontend.auth.forward.tls.key=/path/server.key  Sets the Certificate for the TLS connection with the authentication server.    traefik.frontend.auth.forward.trustForwardHeader=true  Trusts X-Forwarded-* headers.    traefik.frontend.auth.headerField=X-WebAuth-User  Sets the header used to pass the authenticated user to the application.    traefik.frontend.entryPoints=http,https  Assigns this frontend to entry points  http  and  https . Overrides  defaultEntryPoints    traefik.frontend.errors. name .backend=NAME  See  custom error pages  section.    traefik.frontend.errors. name .query=PATH  See  custom error pages  section.    traefik.frontend.errors. name .status=RANGE  See  custom error pages  section.    traefik.frontend.passHostHeader=true  Forwards client  Host  header to the backend.    traefik.frontend.passTLSClientCert.infos.issuer.commonName=true  Add the issuer.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.country=true  Add the issuer.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.domainComponent=true  Add the issuer.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.locality=true  Add the issuer.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.organization=true  Add the issuer.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.province=true  Add the issuer.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.issuer.serialNumber=true  Add the issuer.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.notAfter=true  Add the noAfter field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.notBefore=true  Add the noBefore field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.sans=true  Add the sans field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.commonName=true  Add the subject.commonName field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.country=true  Add the subject.country field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.domainComponent=true  Add the subject.domainComponent field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.locality=true  Add the subject.locality field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.organization=true  Add the subject.organization field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.province=true  Add the subject.province field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.infos.subject.serialNumber=true  Add the subject.serialNumber field in a escaped client infos in the  X-Forwarded-Ssl-Client-Cert-Infos  header.    traefik.frontend.passTLSClientCert.pem=true  Pass the escaped pem in the  X-Forwarded-Ssl-Client-Cert  header.    traefik.frontend.passTLSCert=true  Forwards TLS Client certificates to the backend.    traefik.frontend.priority=10  Overrides default frontend priority    traefik.frontend.rateLimit.extractorFunc=EXP  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .period=6  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .average=6  See  rate limiting  section.    traefik.frontend.rateLimit.rateSet. name .burst=6  See  rate limiting  section.    traefik.frontend.redirect.entryPoint=https  Enables Redirect to another entryPoint to this frontend (e.g. HTTPS)    traefik.frontend.redirect.regex=^http://localhost/(.*)  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.replacement .    traefik.frontend.redirect.replacement=http://mydomain/$1  Redirects to another URL to this frontend. Must be set with  traefik.frontend.redirect.regex .    traefik.frontend.redirect.permanent=true  Returns 301 instead of 302.    traefik.frontend.rule=EXPR  Overrides the default frontend rule. Default:  Host:{containerName}.{domain}  or  Host:{service}.{project_name}.{domain}  if you are using  docker-compose .    traefik.frontend.whiteList.sourceRange=RANGE  Sets a list of IP-Ranges which are allowed to access. An unset or empty list allows all Source-IPs to access. If one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.    traefik.frontend.whiteList.useXForwardedFor=true  Uses  X-Forwarded-For  header as valid source of IP for the white list.", 
            "title": "On Containers"
        }, 
        {
            "location": "/configuration/backends/rancher/#custom-headers", 
            "text": "Label  Description      traefik.frontend.headers.customRequestHeaders=EXPR  Provides the container with custom request headers that will be appended to each request forwarded to the container. Format:  HEADER:value HEADER2:value2    traefik.frontend.headers.customResponseHeaders=EXPR  Appends the headers to each response returned by the container, before forwarding the response to the client. Format:  HEADER:value HEADER2:value2", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/rancher/#security-headers", 
            "text": "Label  Description      traefik.frontend.headers.allowedHosts=EXPR  Provides a list of allowed hosts that requests will be processed. Format:  Host1,Host2    traefik.frontend.headers.browserXSSFilter=true  Adds the X-XSS-Protection header with the value  1; mode=block .    traefik.frontend.headers.contentSecurityPolicy=VALUE  Adds CSP Header with the custom value.    traefik.frontend.headers.contentTypeNosniff=true  Adds the  X-Content-Type-Options  header with the value  nosniff .    traefik.frontend.headers.customBrowserXSSValue=VALUE  Set custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.    traefik.frontend.headers.customFrameOptionsValue=VALUE  Overrides the  X-Frame-Options  header with the custom value.    traefik.frontend.headers.forceSTSHeader=false  Adds the STS  header to non-SSL requests.    traefik.frontend.headers.frameDeny=false  Adds the  X-Frame-Options  header with the value of  DENY .    traefik.frontend.headers.hostsProxyHeaders=EXPR  Provides a list of headers that the proxied hostname may be stored. Format:  HEADER1,HEADER2    traefik.frontend.headers.isDevelopment=false  This will cause the  AllowedHosts ,  SSLRedirect , and  STSSeconds / STSIncludeSubdomains  options to be ignored during development. When deploying to production, be sure to set this to false.    traefik.frontend.headers.publicKey=VALUE  Adds HPKP header.    traefik.frontend.headers.referrerPolicy=VALUE  Adds referrer policy  header.    traefik.frontend.headers.SSLRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent.    traefik.frontend.headers.SSLTemporaryRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.    traefik.frontend.headers.SSLHost=HOST  This setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.    traefik.frontend.headers.SSLForceHost=true  If  SSLForceHost  is  true  and  SSLHost  is set, requests will be forced to use  SSLHost  even the ones that are already using SSL. Default is false.    traefik.frontend.headers.SSLProxyHeaders=EXPR  Header combinations that would signify a proper SSL Request (Such as  X-Forwarded-For:https ). Format:   HEADER:value HEADER2:value2    traefik.frontend.headers.STSSeconds=315360000  Sets the max-age of the STS header.    traefik.frontend.headers.STSIncludeSubdomains=true  Adds the  IncludeSubdomains  section of the STS  header.    traefik.frontend.headers.STSPreload=true  Adds the preload flag to the STS  header.", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/rancher/#on-containers-with-multiple-ports-segment-labels", 
            "text": "Segment labels are used to define routes to a container exposing multiple ports.\nA segment is a group of labels that apply to a port exposed by a container.\nYou can define as many segments as ports exposed in a container.  Segment labels override the default behavior.     Label  Description      traefik. segment_name .backend=BACKEND  Same as  traefik.backend    traefik. segment_name .domain=DOMAIN  Same as  traefik.domain    traefik. segment_name .port=PORT  Same as  traefik.port    traefik. segment_name .protocol=http  Same as  traefik.protocol    traefik. segment_name .weight=10  Same as  traefik.weight    traefik. segment_name .frontend.auth.basic=EXPR  Same as  traefik.frontend.auth.basic    traefik. segment_name .frontend.auth.basic.removeHeader=true  Same as  traefik.frontend.auth.basic.removeHeader    traefik. segment_name .frontend.auth.basic.users=EXPR  Same as  traefik.frontend.auth.basic.users    traefik. segment_name .frontend.auth.basic.usersFile=/path/.htpasswd  Same as  traefik.frontend.auth.basic.usersFile    traefik. segment_name .frontend.auth.digest.removeHeader=true  Same as  traefik.frontend.auth.digest.removeHeader    traefik. segment_name .frontend.auth.digest.users=EXPR  Same as  traefik.frontend.auth.digest.users    traefik. segment_name .frontend.auth.digest.usersFile=/path/.htdigest  Same as  traefik.frontend.auth.digest.usersFile    traefik. segment_name .frontend.auth.forward.address=https://example.com  Same as  traefik.frontend.auth.forward.address    traefik. segment_name .frontend.auth.forward.authResponseHeaders=EXPR  Same as  traefik.frontend.auth.forward.authResponseHeaders    traefik. segment_name .frontend.auth.forward.tls.ca=/path/ca.pem  Same as  traefik.frontend.auth.forward.tls.ca    traefik. segment_name .frontend.auth.forward.tls.caOptional=true  Same as  traefik.frontend.auth.forward.tls.caOptional    traefik. segment_name .frontend.auth.forward.tls.cert=/path/server.pem  Same as  traefik.frontend.auth.forward.tls.cert    traefik. segment_name .frontend.auth.forward.tls.insecureSkipVerify=true  Same as  traefik.frontend.auth.forward.tls.insecureSkipVerify    traefik. segment_name .frontend.auth.forward.tls.key=/path/server.key  Same as  traefik.frontend.auth.forward.tls.key    traefik. segment_name .frontend.auth.forward.trustForwardHeader=true  Same as  traefik.frontend.auth.forward.trustForwardHeader    traefik. segment_name .frontend.auth.headerField=X-WebAuth-User  Same as  traefik.frontend.auth.headerField    traefik. segment_name .frontend.entryPoints=https  Same as  traefik.frontend.entryPoints    traefik. segment_name .frontend.errors. name .backend=NAME  Same as  traefik.frontend.errors. name .backend    traefik. segment_name .frontend.errors. name .query=PATH  Same as  traefik.frontend.errors. name .query    traefik. segment_name .frontend.errors. name .status=RANGE  Same as  traefik.frontend.errors. name .status    traefik. segment_name .frontend.passHostHeader=true  Same as  traefik.frontend.passHostHeader    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.commonName=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.commonName    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.country=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.country    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.domainComponent=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.domainComponent    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.locality=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.locality    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.organization=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.organization    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.province=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.province    traefik. segment_name .frontend.passTLSClientCert.infos.issuer.serialNumber=true  Same as  traefik.frontend.passTLSClientCert.infos.issuer.serialNumber    traefik. segment_name .frontend.passTLSClientCert.infos.notAfter=true  Same as  traefik.frontend.passTLSClientCert.infos.notAfter    traefik. segment_name .frontend.passTLSClientCert.infos.notBefore=true  Same as  traefik.frontend.passTLSClientCert.infos.notBefore    traefik. segment_name .frontend.passTLSClientCert.infos.sans=true  Same as  traefik.frontend.passTLSClientCert.infos.sans    traefik. segment_name .frontend.passTLSClientCert.infos.subject.commonName=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.commonName    traefik. segment_name .frontend.passTLSClientCert.infos.subject.country=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.country    traefik. segment_name .frontend.passTLSClientCert.infos.subject.domainComponent=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.domainComponent    traefik. segment_name .frontend.passTLSClientCert.infos.subject.locality=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.locality    traefik. segment_name .frontend.passTLSClientCert.infos.subject.organization=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.organization    traefik. segment_name .frontend.passTLSClientCert.infos.subject.province=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.province    traefik. segment_name .frontend.passTLSClientCert.infos.subject.serialNumber=true  Same as  traefik.frontend.passTLSClientCert.infos.subject.serialNumber    traefik. segment_name .frontend.passTLSClientCert.pem=true  Same as  traefik.frontend.passTLSClientCert.infos.pem    traefik. segment_name .frontend.passTLSCert=true  Same as  traefik.frontend.passTLSCert    traefik. segment_name .frontend.priority=10  Same as  traefik.frontend.priority    traefik. segment_name .frontend.rateLimit.extractorFunc=EXP  Same as  traefik.frontend.rateLimit.extractorFunc    traefik. segment_name .frontend.rateLimit.rateSet. name .period=6  Same as  traefik.frontend.rateLimit.rateSet. name .period    traefik. segment_name .frontend.rateLimit.rateSet. name .average=6  Same as  traefik.frontend.rateLimit.rateSet. name .average    traefik. segment_name .frontend.rateLimit.rateSet. name .burst=6  Same as  traefik.frontend.rateLimit.rateSet. name .burst    traefik. segment_name .frontend.redirect.entryPoint=https  Same as  traefik.frontend.redirect.entryPoint    traefik. segment_name .frontend.redirect.regex=^http://localhost/(.*)  Same as  traefik.frontend.redirect.regex    traefik. segment_name .frontend.redirect.replacement=http://mydomain/$1  Same as  traefik.frontend.redirect.replacement    traefik. segment_name .frontend.redirect.permanent=true  Same as  traefik.frontend.redirect.permanent    traefik. segment_name .frontend.rule=EXP  Same as  traefik.frontend.rule    traefik. segment_name .frontend.whiteList.sourceRange=RANGE  Same as  traefik.frontend.whiteList.sourceRange    traefik. segment_name .frontend.whiteList.useXForwardedFor=true  Same as  traefik.frontend.whiteList.useXForwardedFor", 
            "title": "On containers with Multiple Ports (segment labels)"
        }, 
        {
            "location": "/configuration/backends/rancher/#custom-headers_1", 
            "text": "Label  Description      traefik. segment_name .frontend.headers.customRequestHeaders=EXPR  overrides  traefik.frontend.headers.customRequestHeaders    traefik. segment_name .frontend.headers.customResponseHeaders=EXPR  overrides  traefik.frontend.headers.customResponseHeaders", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/rancher/#security-headers_1", 
            "text": "Label  Description      traefik. segment_name .frontend.headers.allowedHosts=EXPR  overrides  traefik.frontend.headers.allowedHosts    traefik. segment_name .frontend.headers.browserXSSFilter=true  overrides  traefik.frontend.headers.browserXSSFilter    traefik. segment_name .frontend.headers.contentSecurityPolicy=VALUE  overrides  traefik.frontend.headers.contentSecurityPolicy    traefik. segment_name .frontend.headers.contentTypeNosniff=true  overrides  traefik.frontend.headers.contentTypeNosniff    traefik. segment_name .frontend.headers.customBrowserXSSValue=VALUE  overrides  traefik.frontend.headers.customBrowserXSSValue    traefik. segment_name .frontend.headers.customFrameOptionsValue=VALUE  overrides  traefik.frontend.headers.customFrameOptionsValue    traefik. segment_name .frontend.headers.forceSTSHeader=false  overrides  traefik.frontend.headers.forceSTSHeader    traefik. segment_name .frontend.headers.frameDeny=false  overrides  traefik.frontend.headers.frameDeny    traefik. segment_name .frontend.headers.hostsProxyHeaders=EXPR  overrides  traefik.frontend.headers.hostsProxyHeaders    traefik. segment_name .frontend.headers.isDevelopment=false  overrides  traefik.frontend.headers.isDevelopment    traefik. segment_name .frontend.headers.publicKey=VALUE  overrides  traefik.frontend.headers.publicKey    traefik. segment_name .frontend.headers.referrerPolicy=VALUE  overrides  traefik.frontend.headers.referrerPolicy    traefik. segment_name .frontend.headers.SSLRedirect=true  overrides  traefik.frontend.headers.SSLRedirect    traefik. segment_name .frontend.headers.SSLTemporaryRedirect=true  overrides  traefik.frontend.headers.SSLTemporaryRedirect    traefik. segment_name .frontend.headers.SSLHost=HOST  overrides  traefik.frontend.headers.SSLHost    traefik. segment_name .frontend.headers.SSLForceHost=true  overrides  traefik.frontend.headers.SSLForceHost    traefik. segment_name .frontend.headers.SSLProxyHeaders=EXPR  overrides  traefik.frontend.headers.SSLProxyHeaders    traefik. segment_name .frontend.headers.STSSeconds=315360000  overrides  traefik.frontend.headers.STSSeconds    traefik. segment_name .frontend.headers.STSIncludeSubdomains=true  overrides  traefik.frontend.headers.STSIncludeSubdomains    traefik. segment_name .frontend.headers.STSPreload=true  overrides  traefik.frontend.headers.STSPreload", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/rest/", 
            "text": "Rest Provider\n\n\nTraefik can be configured:\n\n\n\n\nusing a RESTful api.\n\n\n\n\nConfiguration\n\n\n# Enable REST Provider.\n[rest]\n  # Name of the related entry point\n  #\n  # Optional\n  # Default: \ntraefik\n\n  #\n  entryPoint = \ntraefik\n\n\n\n\n\nAPI\n\n\n\n\n\n\n\n\nPath\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n/api/providers/web\n\n\nPUT\n\n\nupdate provider\n\n\n\n\n\n\n/api/providers/rest\n\n\nPUT\n\n\nupdate provider\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\nFor compatibility reason, when you activate the rest provider, you can use \nweb\n or \nrest\n as \nprovider\n value.\n\n\n\n\ncurl -XPUT -d @file \nhttp://localhost:8080/api/providers/rest\n\n\n\n\n\nwith \n@file\n:\n\n\n{\n    \nfrontends\n: {\n      \nfrontend2\n: {\n        \nroutes\n: {\n          \ntest_2\n: {\n            \nrule\n: \nPath:/test\n\n          }\n        },\n        \nbackend\n: \nbackend1\n\n      },\n      \nfrontend1\n: {\n        \nroutes\n: {\n          \ntest_1\n: {\n            \nrule\n: \nHost:test.localhost\n\n          }\n        },\n        \nbackend\n: \nbackend2\n\n      }\n    },\n    \nbackends\n: {\n      \nbackend2\n: {\n        \nloadBalancer\n: {\n          \nmethod\n: \ndrr\n\n        },\n        \nservers\n: {\n          \nserver2\n: {\n            \nweight\n: 2,\n            \nURL\n: \nhttp://172.17.0.5:80\n\n          },\n          \nserver1\n: {\n            \nweight\n: 1,\n            \nurl\n: \nhttp://172.17.0.4:80\n\n          }\n        }\n      },\n      \nbackend1\n: {\n        \nloadBalancer\n: {\n          \nmethod\n: \nwrr\n\n        },\n        \ncircuitBreaker\n: {\n          \nexpression\n: \nNetworkErrorRatio() \n 0.5\n\n        },\n        \nservers\n: {\n          \nserver2\n: {\n            \nweight\n: 1,\n            \nurl\n: \nhttp://172.17.0.3:80\n\n          },\n          \nserver1\n: {\n            \nweight\n: 10,\n            \nurl\n: \nhttp://172.17.0.2:80\n\n          }\n        }\n      }\n    }\n}", 
            "title": "Rest"
        }, 
        {
            "location": "/configuration/backends/rest/#rest-provider", 
            "text": "Traefik can be configured:   using a RESTful api.", 
            "title": "Rest Provider"
        }, 
        {
            "location": "/configuration/backends/rest/#configuration", 
            "text": "# Enable REST Provider.\n[rest]\n  # Name of the related entry point\n  #\n  # Optional\n  # Default:  traefik \n  #\n  entryPoint =  traefik", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/backends/rest/#api", 
            "text": "Path  Method  Description      /api/providers/web  PUT  update provider    /api/providers/rest  PUT  update provider      Warning  For compatibility reason, when you activate the rest provider, you can use  web  or  rest  as  provider  value.   curl -XPUT -d @file  http://localhost:8080/api/providers/rest   with  @file :  {\n     frontends : {\n       frontend2 : {\n         routes : {\n           test_2 : {\n             rule :  Path:/test \n          }\n        },\n         backend :  backend1 \n      },\n       frontend1 : {\n         routes : {\n           test_1 : {\n             rule :  Host:test.localhost \n          }\n        },\n         backend :  backend2 \n      }\n    },\n     backends : {\n       backend2 : {\n         loadBalancer : {\n           method :  drr \n        },\n         servers : {\n           server2 : {\n             weight : 2,\n             URL :  http://172.17.0.5:80 \n          },\n           server1 : {\n             weight : 1,\n             url :  http://172.17.0.4:80 \n          }\n        }\n      },\n       backend1 : {\n         loadBalancer : {\n           method :  wrr \n        },\n         circuitBreaker : {\n           expression :  NetworkErrorRatio()   0.5 \n        },\n         servers : {\n           server2 : {\n             weight : 1,\n             url :  http://172.17.0.3:80 \n          },\n           server1 : {\n             weight : 10,\n             url :  http://172.17.0.2:80 \n          }\n        }\n      }\n    }\n}", 
            "title": "API"
        }, 
        {
            "location": "/configuration/backends/servicefabric/", 
            "text": "Azure Service Fabric Provider\n\n\nTraefik can be configured to use Azure Service Fabric as a provider.\n\n\nSee \nthis repository for an example deployment package and further documentation.\n\n\nAzure Service Fabric\n\n\n################################################################\n# Azure Service Fabric Provider\n################################################################\n\n# Enable Azure Service Fabric Provider\n[serviceFabric]\n\n# Azure Service Fabric Management Endpoint\n#\n# Required\n#\nclusterManagementUrl = \nhttps://localhost:19080\n\n\n# Azure Service Fabric Management Endpoint API Version\n#\n# Required\n# Default: \n3.0\n\n#\napiVersion = \n3.0\n\n\n# Azure Service Fabric Polling Interval (in seconds)\n#\n# Required\n# Default: 10\n#\nrefreshSeconds = 10\n\n# Enable TLS connection.\n#\n# Optional\n#\n# [serviceFabric.tls]\n#   ca = \n/etc/ssl/ca.crt\n\n#   cert = \n/etc/ssl/servicefabric.crt\n\n#   key = \n/etc/ssl/servicefabric.key\n\n#   insecureSkipVerify = true\n\n\n\n\nLabels\n\n\nThe provider uses labels to configure how services are exposed through Traefik.\nThese can be set using Extensions and the Property Manager API\n\n\nExtensions\n\n\nSet labels with extensions through the services \nServiceManifest.xml\n file.\nHere is an example of an extension setting Traefik labels:\n\n\nStatelessServiceType ServiceTypeName=\nWebServiceType\n\n  \nExtensions\n\n      \nExtension Name=\nTraefik\n\n        \nLabels xmlns=\nhttp://schemas.microsoft.com/2015/03/fabact-no-schema\n\n          \nLabel Key=\ntraefik.frontend.rule.example2\nPathPrefixStrip: /a/path/to/strip\n/Label\n\n          \nLabel Key=\ntraefik.enable\ntrue\n/Label\n\n          \nLabel Key=\ntraefik.frontend.passHostHeader\ntrue\n/Label\n\n        \n/Labels\n\n      \n/Extension\n\n  \n/Extensions\n\n\n/StatelessServiceType\n\n\n\n\n\n\n\nNote\n: The \nLabel\n tag and its \nKey\n attribute are case sensitive. That is, if you use \nlabel\n instead of \nLabel\n or \nkey\n instead of \nKey\n, they will be silently ignored.\n\n\n\n\nProperty Manager\n\n\nSet Labels with the property manager API to overwrite and add labels, while your service is running.\nHere is an example of adding a frontend rule using the property manager API.\n\n\ncurl -X PUT \\\n  'http://localhost:19080/Names/GettingStartedApplication2/WebService/$/GetProperty?api-version=6.0\nIncludeValues=true' \\\n  -d '{\n  \nPropertyName\n: \ntraefik.frontend.rule.default\n,\n  \nValue\n: {\n    \nKind\n: \nString\n,\n    \nData\n: \nPathPrefixStrip: /a/path/to/strip\n\n  },\n  \nCustomTypeId\n: \nLabelType\n\n}'\n\n\n\n\n\n\nNote\n\n\nThis functionality will be released in a future version of the \nsfctl\n tool.\n\n\n\n\nAvailable Labels\n\n\nLabels, set through extensions or the property manager, can be used on services to override default behavior.\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.enable=false\n\n\nDisable this container in Traefik\n\n\n\n\n\n\ntraefik.backend.circuitbreaker.expression=EXPR\n\n\nCreate a \ncircuit breaker\n to be used against the backend\n\n\n\n\n\n\ntraefik.servicefabric.groupname\n\n\nGroup all services with the same name into a single backend in Traefik\n\n\n\n\n\n\ntraefik.servicefabric.groupweight\n\n\nSet the weighting of the current services nodes in the backend group\n\n\n\n\n\n\ntraefik.servicefabric.enablelabeloverrides\n\n\nToggle whether labels can be overridden using the Service Fabric Property Manager API\n\n\n\n\n\n\ntraefik.servicefabric.endpointname\n\n\nSpecify the name of the endpoint\n\n\n\n\n\n\ntraefik.backend.healthcheck.path=/health\n\n\nEnable health check for the backend, hitting the container at \npath\n.\n\n\n\n\n\n\ntraefik.backend.healthcheck.port=8080\n\n\nAllow to use a different port for the health check.\n\n\n\n\n\n\ntraefik.backend.healthcheck.interval=1s\n\n\nDefine the health check interval.\n\n\n\n\n\n\ntraefik.backend.healthcheck.hostname=foobar.com\n\n\nDefine the health check hostname.\n\n\n\n\n\n\ntraefik.backend.healthcheck.headers=EXPR\n\n\nDefine the health check request headers \nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.backend.loadbalancer.method=drr\n\n\nOverride the default \nwrr\n load balancer algorithm\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness=true\n\n\nEnable backend sticky sessions\n\n\n\n\n\n\ntraefik.backend.loadbalancer.stickiness.cookieName=NAME\n\n\nManually set the cookie name for sticky sessions\n\n\n\n\n\n\ntraefik.backend.loadbalancer.sticky=true\n\n\nEnable backend sticky sessions (DEPRECATED)\n\n\n\n\n\n\ntraefik.backend.maxconn.amount=10\n\n\nSet a maximum number of connections to the backend.\nMust be used in conjunction with the below label to take effect.\n\n\n\n\n\n\ntraefik.backend.maxconn.extractorfunc=client.ip\n\n\nSet the function to be used against the request to determine what to limit maximum connections to the backend by.\nMust be used in conjunction with the above label to take effect.\n\n\n\n\n\n\ntraefik.backend.weight=10\n\n\nAssign this weight to the container\n\n\n\n\n\n\ntraefik.frontend.auth.basic=EXPR\n\n\nSets basic authentication for that frontend in CSV format: \nUser:Hash,User:Hash\n\n\n\n\n\n\ntraefik.frontend.entryPoints=http,https\n\n\nAssign this frontend to entry points \nhttp\n and \nhttps\n.\nOverrides \ndefaultEntryPoints\n\n\n\n\n\n\ntraefik.frontend.passHostHeader=true\n\n\nForward client \nHost\n header to the backend.\n\n\n\n\n\n\ntraefik.frontend.passTLSCert=true\n\n\nForward TLS Client certificates to the backend.\n\n\n\n\n\n\ntraefik.frontend.priority=10\n\n\nOverride default frontend priority\n\n\n\n\n\n\ntraefik.frontend.redirect.entryPoint=https\n\n\nEnables Redirect to another entryPoint for that frontend (e.g. HTTPS)\n\n\n\n\n\n\ntraefik.frontend.redirect.regex=^http://localhost/(.*)\n\n\nRedirect to another URL for that frontend.\nMust be set with \ntraefik.frontend.redirect.replacement\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.replacement=http://mydomain/$1\n\n\nRedirect to another URL for that frontend.\nMust be set with \ntraefik.frontend.redirect.regex\n.\n\n\n\n\n\n\ntraefik.frontend.redirect.permanent=true\n\n\nReturn 301 instead of 302.\n\n\n\n\n\n\ntraefik.frontend.rule=EXPR\n\n\nOverride the default frontend rule. Defaults to SF address.\n\n\n\n\n\n\ntraefik.frontend.whiteList.sourceRange=RANGE\n\n\nList of IP-Ranges which are allowed to access.\nAn unset or empty list allows all Source-IPs to access.\nIf one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.\n\n\n\n\n\n\ntraefik.frontend.whiteList.useXForwardedFor=true\n\n\nUse \nX-Forwarded-For\n header as valid source of IP for the white list.\n\n\n\n\n\n\n\n\nCustom Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.customRequestHeaders=EXPR\n\n\nProvides the container with custom request headers that will be appended to each request forwarded to the container.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.customResponseHeaders=EXPR\n\n\nAppends the headers to each response returned by the container, before forwarding the response to the client.\nFormat: \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\n\n\nSecurity Headers\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntraefik.frontend.headers.allowedHosts=EXPR\n\n\nProvides a list of allowed hosts that requests will be processed.\nFormat: \nHost1,Host2\n\n\n\n\n\n\ntraefik.frontend.headers.hostsProxyHeaders=EXPR\n\n\nProvides a list of headers that the proxied hostname may be stored.\nFormat: \nHEADER1,HEADER2\n\n\n\n\n\n\ntraefik.frontend.headers.SSLRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLTemporaryRedirect=true\n\n\nForces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLHost=HOST\n\n\nThis setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.\n\n\n\n\n\n\ntraefik.frontend.headers.SSLProxyHeaders=EXPR\n\n\nHeader combinations that would signify a proper SSL Request (Such as \nX-Forwarded-For:https\n).\nFormat:  \nHEADER:value\nHEADER2:value2\n\n\n\n\n\n\ntraefik.frontend.headers.STSSeconds=315360000\n\n\nSets the max-age of the STS header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSIncludeSubdomains=true\n\n\nAdds the \nIncludeSubdomains\n section of the STS  header.\n\n\n\n\n\n\ntraefik.frontend.headers.STSPreload=true\n\n\nAdds the preload flag to the STS  header.\n\n\n\n\n\n\ntraefik.frontend.headers.forceSTSHeader=false\n\n\nAdds the STS  header to non-SSL requests.\n\n\n\n\n\n\ntraefik.frontend.headers.frameDeny=false\n\n\nAdds the \nX-Frame-Options\n header with the value of \nDENY\n.\n\n\n\n\n\n\ntraefik.frontend.headers.customFrameOptionsValue=VALUE\n\n\nOverrides the \nX-Frame-Options\n header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.contentTypeNosniff=true\n\n\nAdds the \nX-Content-Type-Options\n header with the value \nnosniff\n.\n\n\n\n\n\n\ntraefik.frontend.headers.browserXSSFilter=true\n\n\nAdds the X-XSS-Protection header with the value \n1; mode=block\n.\n\n\n\n\n\n\ntraefik.frontend.headers.customBrowserXSSValue=VALUE\n\n\nSet custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.\n\n\n\n\n\n\ntraefik.frontend.headers.contentSecurityPolicy=VALUE\n\n\nAdds CSP Header with the custom value.\n\n\n\n\n\n\ntraefik.frontend.headers.publicKey=VALUE\n\n\nAdds HPKP header.\n\n\n\n\n\n\ntraefik.frontend.headers.referrerPolicy=VALUE\n\n\nAdds referrer policy  header.\n\n\n\n\n\n\ntraefik.frontend.headers.isDevelopment=false\n\n\nThis will cause the \nAllowedHosts\n, \nSSLRedirect\n, and \nSTSSeconds\n/\nSTSIncludeSubdomains\n options to be ignored during development.\nWhen deploying to production, be sure to set this to false.", 
            "title": "Azure Service Fabric"
        }, 
        {
            "location": "/configuration/backends/servicefabric/#azure-service-fabric-provider", 
            "text": "Traefik can be configured to use Azure Service Fabric as a provider.  See  this repository for an example deployment package and further documentation.", 
            "title": "Azure Service Fabric Provider"
        }, 
        {
            "location": "/configuration/backends/servicefabric/#azure-service-fabric", 
            "text": "################################################################\n# Azure Service Fabric Provider\n################################################################\n\n# Enable Azure Service Fabric Provider\n[serviceFabric]\n\n# Azure Service Fabric Management Endpoint\n#\n# Required\n#\nclusterManagementUrl =  https://localhost:19080 \n\n# Azure Service Fabric Management Endpoint API Version\n#\n# Required\n# Default:  3.0 \n#\napiVersion =  3.0 \n\n# Azure Service Fabric Polling Interval (in seconds)\n#\n# Required\n# Default: 10\n#\nrefreshSeconds = 10\n\n# Enable TLS connection.\n#\n# Optional\n#\n# [serviceFabric.tls]\n#   ca =  /etc/ssl/ca.crt \n#   cert =  /etc/ssl/servicefabric.crt \n#   key =  /etc/ssl/servicefabric.key \n#   insecureSkipVerify = true", 
            "title": "Azure Service Fabric"
        }, 
        {
            "location": "/configuration/backends/servicefabric/#labels", 
            "text": "The provider uses labels to configure how services are exposed through Traefik.\nThese can be set using Extensions and the Property Manager API", 
            "title": "Labels"
        }, 
        {
            "location": "/configuration/backends/servicefabric/#extensions", 
            "text": "Set labels with extensions through the services  ServiceManifest.xml  file.\nHere is an example of an extension setting Traefik labels:  StatelessServiceType ServiceTypeName= WebServiceType \n   Extensions \n       Extension Name= Traefik \n         Labels xmlns= http://schemas.microsoft.com/2015/03/fabact-no-schema \n           Label Key= traefik.frontend.rule.example2 PathPrefixStrip: /a/path/to/strip /Label \n           Label Key= traefik.enable true /Label \n           Label Key= traefik.frontend.passHostHeader true /Label \n         /Labels \n       /Extension \n   /Extensions  /StatelessServiceType    Note : The  Label  tag and its  Key  attribute are case sensitive. That is, if you use  label  instead of  Label  or  key  instead of  Key , they will be silently ignored.", 
            "title": "Extensions"
        }, 
        {
            "location": "/configuration/backends/servicefabric/#property-manager", 
            "text": "Set Labels with the property manager API to overwrite and add labels, while your service is running.\nHere is an example of adding a frontend rule using the property manager API.  curl -X PUT \\\n  'http://localhost:19080/Names/GettingStartedApplication2/WebService/$/GetProperty?api-version=6.0 IncludeValues=true' \\\n  -d '{\n   PropertyName :  traefik.frontend.rule.default ,\n   Value : {\n     Kind :  String ,\n     Data :  PathPrefixStrip: /a/path/to/strip \n  },\n   CustomTypeId :  LabelType \n}'   Note  This functionality will be released in a future version of the  sfctl  tool.", 
            "title": "Property Manager"
        }, 
        {
            "location": "/configuration/backends/servicefabric/#available-labels", 
            "text": "Labels, set through extensions or the property manager, can be used on services to override default behavior.     Label  Description      traefik.enable=false  Disable this container in Traefik    traefik.backend.circuitbreaker.expression=EXPR  Create a  circuit breaker  to be used against the backend    traefik.servicefabric.groupname  Group all services with the same name into a single backend in Traefik    traefik.servicefabric.groupweight  Set the weighting of the current services nodes in the backend group    traefik.servicefabric.enablelabeloverrides  Toggle whether labels can be overridden using the Service Fabric Property Manager API    traefik.servicefabric.endpointname  Specify the name of the endpoint    traefik.backend.healthcheck.path=/health  Enable health check for the backend, hitting the container at  path .    traefik.backend.healthcheck.port=8080  Allow to use a different port for the health check.    traefik.backend.healthcheck.interval=1s  Define the health check interval.    traefik.backend.healthcheck.hostname=foobar.com  Define the health check hostname.    traefik.backend.healthcheck.headers=EXPR  Define the health check request headers  Format:   HEADER:value HEADER2:value2    traefik.backend.loadbalancer.method=drr  Override the default  wrr  load balancer algorithm    traefik.backend.loadbalancer.stickiness=true  Enable backend sticky sessions    traefik.backend.loadbalancer.stickiness.cookieName=NAME  Manually set the cookie name for sticky sessions    traefik.backend.loadbalancer.sticky=true  Enable backend sticky sessions (DEPRECATED)    traefik.backend.maxconn.amount=10  Set a maximum number of connections to the backend. Must be used in conjunction with the below label to take effect.    traefik.backend.maxconn.extractorfunc=client.ip  Set the function to be used against the request to determine what to limit maximum connections to the backend by. Must be used in conjunction with the above label to take effect.    traefik.backend.weight=10  Assign this weight to the container    traefik.frontend.auth.basic=EXPR  Sets basic authentication for that frontend in CSV format:  User:Hash,User:Hash    traefik.frontend.entryPoints=http,https  Assign this frontend to entry points  http  and  https . Overrides  defaultEntryPoints    traefik.frontend.passHostHeader=true  Forward client  Host  header to the backend.    traefik.frontend.passTLSCert=true  Forward TLS Client certificates to the backend.    traefik.frontend.priority=10  Override default frontend priority    traefik.frontend.redirect.entryPoint=https  Enables Redirect to another entryPoint for that frontend (e.g. HTTPS)    traefik.frontend.redirect.regex=^http://localhost/(.*)  Redirect to another URL for that frontend. Must be set with  traefik.frontend.redirect.replacement .    traefik.frontend.redirect.replacement=http://mydomain/$1  Redirect to another URL for that frontend. Must be set with  traefik.frontend.redirect.regex .    traefik.frontend.redirect.permanent=true  Return 301 instead of 302.    traefik.frontend.rule=EXPR  Override the default frontend rule. Defaults to SF address.    traefik.frontend.whiteList.sourceRange=RANGE  List of IP-Ranges which are allowed to access. An unset or empty list allows all Source-IPs to access. If one of the Net-Specifications are invalid, the whole list is invalid and allows all Source-IPs to access.    traefik.frontend.whiteList.useXForwardedFor=true  Use  X-Forwarded-For  header as valid source of IP for the white list.", 
            "title": "Available Labels"
        }, 
        {
            "location": "/configuration/backends/servicefabric/#custom-headers", 
            "text": "Label  Description      traefik.frontend.headers.customRequestHeaders=EXPR  Provides the container with custom request headers that will be appended to each request forwarded to the container. Format:  HEADER:value HEADER2:value2    traefik.frontend.headers.customResponseHeaders=EXPR  Appends the headers to each response returned by the container, before forwarding the response to the client. Format:  HEADER:value HEADER2:value2", 
            "title": "Custom Headers"
        }, 
        {
            "location": "/configuration/backends/servicefabric/#security-headers", 
            "text": "Label  Description      traefik.frontend.headers.allowedHosts=EXPR  Provides a list of allowed hosts that requests will be processed. Format:  Host1,Host2    traefik.frontend.headers.hostsProxyHeaders=EXPR  Provides a list of headers that the proxied hostname may be stored. Format:  HEADER1,HEADER2    traefik.frontend.headers.SSLRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent.    traefik.frontend.headers.SSLTemporaryRedirect=true  Forces the frontend to redirect to SSL if a non-SSL request is sent, but by sending a 302 instead of a 301.    traefik.frontend.headers.SSLHost=HOST  This setting configures the hostname that redirects will be based on. Default is \"\", which is the same host as the request.    traefik.frontend.headers.SSLProxyHeaders=EXPR  Header combinations that would signify a proper SSL Request (Such as  X-Forwarded-For:https ). Format:   HEADER:value HEADER2:value2    traefik.frontend.headers.STSSeconds=315360000  Sets the max-age of the STS header.    traefik.frontend.headers.STSIncludeSubdomains=true  Adds the  IncludeSubdomains  section of the STS  header.    traefik.frontend.headers.STSPreload=true  Adds the preload flag to the STS  header.    traefik.frontend.headers.forceSTSHeader=false  Adds the STS  header to non-SSL requests.    traefik.frontend.headers.frameDeny=false  Adds the  X-Frame-Options  header with the value of  DENY .    traefik.frontend.headers.customFrameOptionsValue=VALUE  Overrides the  X-Frame-Options  header with the custom value.    traefik.frontend.headers.contentTypeNosniff=true  Adds the  X-Content-Type-Options  header with the value  nosniff .    traefik.frontend.headers.browserXSSFilter=true  Adds the X-XSS-Protection header with the value  1; mode=block .    traefik.frontend.headers.customBrowserXSSValue=VALUE  Set custom value for X-XSS-Protection header. This overrides the BrowserXssFilter option.    traefik.frontend.headers.contentSecurityPolicy=VALUE  Adds CSP Header with the custom value.    traefik.frontend.headers.publicKey=VALUE  Adds HPKP header.    traefik.frontend.headers.referrerPolicy=VALUE  Adds referrer policy  header.    traefik.frontend.headers.isDevelopment=false  This will cause the  AllowedHosts ,  SSLRedirect , and  STSSeconds / STSIncludeSubdomains  options to be ignored during development. When deploying to production, be sure to set this to false.", 
            "title": "Security Headers"
        }, 
        {
            "location": "/configuration/backends/zookeeper/", 
            "text": "Zookeeper Provider\n\n\nTraefik can be configured to use Zookeeper as a provider.\n\n\n################################################################\n# Zookeeper Provider\n################################################################\n\n# Enable Zookeeper Provider.\n[zookeeper]\n\n# Zookeeper server endpoint.\n#\n# Required\n# Default: \n127.0.0.1:2181\n\n#\nendpoint = \n127.0.0.1:2181\n\n\n# Enable watch Zookeeper changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Prefix used for KV store.\n#\n# Optional\n# Default: \ntraefik\n\n#\nprefix = \ntraefik\n\n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename = \nzookeeper.tmpl\n\n\n# Use Zookeeper user/pass authentication.\n#\n# Optional\n#\n# username = foo\n# password = bar\n\n# Enable Zookeeper TLS connection.\n#\n# Optional\n#\n#    [zookeeper.tls]\n#    ca = \n/etc/ssl/ca.crt\n\n#    cert = \n/etc/ssl/zookeeper.crt\n\n#    key = \n/etc/ssl/zookeeper.key\n\n#    insecureSkipVerify = true\n\n\n\n\nTo enable constraints see \nprovider-specific constraints section\n.\n\n\nPlease refer to the \nKey Value storage structure\n section to get documentation on Traefik KV structure.", 
            "title": "Zookeeper"
        }, 
        {
            "location": "/configuration/backends/zookeeper/#zookeeper-provider", 
            "text": "Traefik can be configured to use Zookeeper as a provider.  ################################################################\n# Zookeeper Provider\n################################################################\n\n# Enable Zookeeper Provider.\n[zookeeper]\n\n# Zookeeper server endpoint.\n#\n# Required\n# Default:  127.0.0.1:2181 \n#\nendpoint =  127.0.0.1:2181 \n\n# Enable watch Zookeeper changes.\n#\n# Optional\n# Default: true\n#\nwatch = true\n\n# Prefix used for KV store.\n#\n# Optional\n# Default:  traefik \n#\nprefix =  traefik \n\n# Override default configuration template.\n# For advanced users :)\n#\n# Optional\n#\n# filename =  zookeeper.tmpl \n\n# Use Zookeeper user/pass authentication.\n#\n# Optional\n#\n# username = foo\n# password = bar\n\n# Enable Zookeeper TLS connection.\n#\n# Optional\n#\n#    [zookeeper.tls]\n#    ca =  /etc/ssl/ca.crt \n#    cert =  /etc/ssl/zookeeper.crt \n#    key =  /etc/ssl/zookeeper.key \n#    insecureSkipVerify = true  To enable constraints see  provider-specific constraints section .  Please refer to the  Key Value storage structure  section to get documentation on Traefik KV structure.", 
            "title": "Zookeeper Provider"
        }, 
        {
            "location": "/configuration/ping/", 
            "text": "Ping Definition\n\n\nConfiguration\n\n\n# Ping definition\n[ping]\n  # Name of the related entry point\n  #\n  # Optional\n  # Default: \ntraefik\n\n  #\n  entryPoint = \ntraefik\n\n\n\n\n\n\n\n\n\n\n\nPath\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n/ping\n\n\nGET\n, \nHEAD\n\n\nA simple endpoint to check for Traefik process liveness. Return a code \n200\n with the content: \nOK\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\nEven if you have authentication configured on entry point, the \n/ping\n path of the api is excluded from authentication.\n\n\n\n\nExamples\n\n\nThe \n/ping\n health-check URL is enabled with the command-line \n--ping\n or config file option \n[ping]\n.\nThus, if you have a regular path for \n/foo\n and an entrypoint on \n:80\n, you would access them as follows:\n\n\n\n\nRegular path: \nhttp://hostname:80/foo\n\n\nAdmin panel: \nhttp://hostname:8080/\n\n\nPing URL: \nhttp://hostname:8080/ping\n\n\n\n\nHowever, for security reasons, you may want to be able to expose the \n/ping\n health-check URL to outside health-checkers, e.g. an Internet service or cloud load-balancer, \nwithout\n exposing your dashboard's port.\nIn many environments, the security staff may not \nallow\n you to expose it.\n\n\nYou have two options:\n\n\n\n\nEnable \n/ping\n on a regular entry point\n\n\nEnable \n/ping\n on a dedicated port\n\n\n\n\nPing health check on a regular entry point\n\n\nTo proxy \n/ping\n from a regular entry point to the administration one without exposing the dashboard, do the following:\n\n\ndefaultEntryPoints = [\nhttp\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n\n[ping]\nentryPoint = \nhttp\n\n\n\n\n\n\nThe above link \nping\n on the \nhttp\n entry point and then expose it on port \n80\n\n\nEnable ping health check on dedicated port\n\n\nIf you do not want to or cannot expose the health-check on a regular entry point - e.g. your security rules do not allow it, or you have a conflicting path - then you can enable health-check on its own entry point.\nUse the following configuration:\n\n\ndefaultEntryPoints = [\nhttp\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.ping]\n  address = \n:8082\n\n\n[ping]\nentryPoint = \nping\n\n\n\n\n\nThe above is similar to the previous example, but instead of enabling \n/ping\n on the \ndefault\n entry point, we enable it on a \ndedicated\n entry point.\n\n\nIn the above example, you would access a regular path and health-check as follows:\n\n\n\n\nRegular path: \nhttp://hostname:80/foo\n\n\nPing URL: \nhttp://hostname:8082/ping\n\n\n\n\nNote the dedicated port \n:8082\n for \n/ping\n.\n\n\nIn the above example, it is \nvery\n important to create a named dedicated entry point, and do \nnot\n include it in \ndefaultEntryPoints\n.\nOtherwise, you are likely to expose \nall\n services via this entry point.\n\n\nUsing ping for external Load-balancer rotation health check\n\n\nIf you are running traefik behind a external Load-balancer, and want to configure rotation health check on the Load-balancer to take a traefik instance out of rotation gracefully, you can configure \nlifecycle.requestAcceptGraceTimeout\n and the ping endpoint will return \n503\n response on traefik server termination, so that the Load-balancer can take the terminating traefik instance out of rotation, before it stops responding.", 
            "title": "Ping"
        }, 
        {
            "location": "/configuration/ping/#ping-definition", 
            "text": "", 
            "title": "Ping Definition"
        }, 
        {
            "location": "/configuration/ping/#configuration", 
            "text": "# Ping definition\n[ping]\n  # Name of the related entry point\n  #\n  # Optional\n  # Default:  traefik \n  #\n  entryPoint =  traefik      Path  Method  Description      /ping  GET ,  HEAD  A simple endpoint to check for Traefik process liveness. Return a code  200  with the content:  OK      Warning  Even if you have authentication configured on entry point, the  /ping  path of the api is excluded from authentication.", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/ping/#examples", 
            "text": "The  /ping  health-check URL is enabled with the command-line  --ping  or config file option  [ping] .\nThus, if you have a regular path for  /foo  and an entrypoint on  :80 , you would access them as follows:   Regular path:  http://hostname:80/foo  Admin panel:  http://hostname:8080/  Ping URL:  http://hostname:8080/ping   However, for security reasons, you may want to be able to expose the  /ping  health-check URL to outside health-checkers, e.g. an Internet service or cloud load-balancer,  without  exposing your dashboard's port.\nIn many environments, the security staff may not  allow  you to expose it.  You have two options:   Enable  /ping  on a regular entry point  Enable  /ping  on a dedicated port", 
            "title": "Examples"
        }, 
        {
            "location": "/configuration/ping/#ping-health-check-on-a-regular-entry-point", 
            "text": "To proxy  /ping  from a regular entry point to the administration one without exposing the dashboard, do the following:  defaultEntryPoints = [ http ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n\n[ping]\nentryPoint =  http   The above link  ping  on the  http  entry point and then expose it on port  80", 
            "title": "Ping health check on a regular entry point"
        }, 
        {
            "location": "/configuration/ping/#enable-ping-health-check-on-dedicated-port", 
            "text": "If you do not want to or cannot expose the health-check on a regular entry point - e.g. your security rules do not allow it, or you have a conflicting path - then you can enable health-check on its own entry point.\nUse the following configuration:  defaultEntryPoints = [ http ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.ping]\n  address =  :8082 \n\n[ping]\nentryPoint =  ping   The above is similar to the previous example, but instead of enabling  /ping  on the  default  entry point, we enable it on a  dedicated  entry point.  In the above example, you would access a regular path and health-check as follows:   Regular path:  http://hostname:80/foo  Ping URL:  http://hostname:8082/ping   Note the dedicated port  :8082  for  /ping .  In the above example, it is  very  important to create a named dedicated entry point, and do  not  include it in  defaultEntryPoints .\nOtherwise, you are likely to expose  all  services via this entry point.", 
            "title": "Enable ping health check on dedicated port"
        }, 
        {
            "location": "/configuration/ping/#using-ping-for-external-load-balancer-rotation-health-check", 
            "text": "If you are running traefik behind a external Load-balancer, and want to configure rotation health check on the Load-balancer to take a traefik instance out of rotation gracefully, you can configure  lifecycle.requestAcceptGraceTimeout  and the ping endpoint will return  503  response on traefik server termination, so that the Load-balancer can take the terminating traefik instance out of rotation, before it stops responding.", 
            "title": "Using ping for external Load-balancer rotation health check"
        }, 
        {
            "location": "/configuration/metrics/", 
            "text": "Metrics Definition\n\n\nPrometheus\n\n\n# Metrics definition\n[metrics]\n  #...\n\n  # To enable Traefik to export internal metrics to Prometheus\n  [metrics.prometheus]\n\n    # Name of the related entry point\n    #\n    # Optional\n    # Default: \ntraefik\n\n    #\n    entryPoint = \ntraefik\n\n\n    # Buckets for latency metrics\n    #\n    # Optional\n    # Default: [0.1, 0.3, 1.2, 5.0]\n    #\n    buckets = [0.1,0.3,1.2,5.0]\n\n  # ...\n\n\n\n\nDataDog\n\n\n# Metrics definition\n[metrics]\n  #...\n\n  # DataDog metrics exporter type\n  [metrics.datadog]\n\n    # DataDog's address.\n    #\n    # Required\n    # Default: \nlocalhost:8125\n\n    #\n    address = \nlocalhost:8125\n\n\n    # DataDog push interval\n    #\n    # Optional\n    # Default: \n10s\n\n    #\n    pushInterval = \n10s\n\n\n  # ...\n\n\n\n\nStatsD\n\n\n# Metrics definition\n[metrics]\n  #...\n\n  # StatsD metrics exporter type\n  [metrics.statsd]\n\n    # StatD's address.\n    #\n    # Required\n    # Default: \nlocalhost:8125\n\n    #\n    address = \nlocalhost:8125\n\n\n    # StatD push interval\n    #\n    # Optional\n    # Default: \n10s\n\n    #\n    pushInterval = \n10s\n\n\n  # ...\n\n\n\n\nInfluxDB\n\n\n[metrics]\n  # ...\n\n  # InfluxDB metrics exporter type\n  [metrics.influxdb]\n\n    # InfluxDB's address.\n    #\n    # Required\n    # Default: \nlocalhost:8089\n\n    #\n    address = \nlocalhost:8089\n\n\n    # InfluxDB's address protocol (udp or http)\n    #\n    # Required\n    # Default: \nudp\n\n    #\n    protocol = \nudp\n\n\n    # InfluxDB push interval\n    #\n    # Optional\n    # Default: \n10s\n\n    #\n    pushinterval = \n10s\n\n\n    # InfluxDB database used when protocol is http\n    #\n    # Optional\n    # Default: \n\n    #\n    database = \n\n\n    # InfluxDB retention policy used when protocol is http\n    #\n    # Optional\n    # Default: \n\n    #\n    retentionpolicy = \n\n\n  # ...", 
            "title": "Metrics"
        }, 
        {
            "location": "/configuration/metrics/#metrics-definition", 
            "text": "", 
            "title": "Metrics Definition"
        }, 
        {
            "location": "/configuration/metrics/#prometheus", 
            "text": "# Metrics definition\n[metrics]\n  #...\n\n  # To enable Traefik to export internal metrics to Prometheus\n  [metrics.prometheus]\n\n    # Name of the related entry point\n    #\n    # Optional\n    # Default:  traefik \n    #\n    entryPoint =  traefik \n\n    # Buckets for latency metrics\n    #\n    # Optional\n    # Default: [0.1, 0.3, 1.2, 5.0]\n    #\n    buckets = [0.1,0.3,1.2,5.0]\n\n  # ...", 
            "title": "Prometheus"
        }, 
        {
            "location": "/configuration/metrics/#datadog", 
            "text": "# Metrics definition\n[metrics]\n  #...\n\n  # DataDog metrics exporter type\n  [metrics.datadog]\n\n    # DataDog's address.\n    #\n    # Required\n    # Default:  localhost:8125 \n    #\n    address =  localhost:8125 \n\n    # DataDog push interval\n    #\n    # Optional\n    # Default:  10s \n    #\n    pushInterval =  10s \n\n  # ...", 
            "title": "DataDog"
        }, 
        {
            "location": "/configuration/metrics/#statsd", 
            "text": "# Metrics definition\n[metrics]\n  #...\n\n  # StatsD metrics exporter type\n  [metrics.statsd]\n\n    # StatD's address.\n    #\n    # Required\n    # Default:  localhost:8125 \n    #\n    address =  localhost:8125 \n\n    # StatD push interval\n    #\n    # Optional\n    # Default:  10s \n    #\n    pushInterval =  10s \n\n  # ...", 
            "title": "StatsD"
        }, 
        {
            "location": "/configuration/metrics/#influxdb", 
            "text": "[metrics]\n  # ...\n\n  # InfluxDB metrics exporter type\n  [metrics.influxdb]\n\n    # InfluxDB's address.\n    #\n    # Required\n    # Default:  localhost:8089 \n    #\n    address =  localhost:8089 \n\n    # InfluxDB's address protocol (udp or http)\n    #\n    # Required\n    # Default:  udp \n    #\n    protocol =  udp \n\n    # InfluxDB push interval\n    #\n    # Optional\n    # Default:  10s \n    #\n    pushinterval =  10s \n\n    # InfluxDB database used when protocol is http\n    #\n    # Optional\n    # Default:  \n    #\n    database =  \n\n    # InfluxDB retention policy used when protocol is http\n    #\n    # Optional\n    # Default:  \n    #\n    retentionpolicy =  \n\n  # ...", 
            "title": "InfluxDB"
        }, 
        {
            "location": "/configuration/tracing/", 
            "text": "Tracing\n\n\nThe tracing system allows developers to visualize call flows in their infrastructure.\n\n\nWe use \nOpenTracing\n. It is an open standard designed for distributed tracing.\n\n\nTraefik supports three tracing backends: Jaeger, Zipkin and DataDog.\n\n\nJaeger\n\n\n# Tracing definition\n[tracing]\n  # Backend name used to send tracing data\n  #\n  # Default: \njaeger\n\n  #\n  backend = \njaeger\n\n\n  # Service name used in Jaeger backend\n  #\n  # Default: \ntraefik\n\n  #\n  serviceName = \ntraefik\n\n\n  # Span name limit allows for name truncation in case of very long Frontend/Backend names\n  # This can prevent certain tracing providers to drop traces that exceed their length limits\n  #\n  # Default: 0 - no truncation will occur\n  # \n  spanNameLimit = 0\n\n  [tracing.jaeger]\n    # Sampling Server URL is the address of jaeger-agent's HTTP sampling server\n    #\n    # Default: \nhttp://localhost:5778/sampling\n\n    #\n    samplingServerURL = \nhttp://localhost:5778/sampling\n\n\n    # Sampling Type specifies the type of the sampler: const, probabilistic, rateLimiting\n    #\n    # Default: \nconst\n\n    #\n    samplingType = \nconst\n\n\n    # Sampling Param is a value passed to the sampler.\n    # Valid values for Param field are:\n    #   - for \nconst\n sampler, 0 or 1 for always false/true respectively\n    #   - for \nprobabilistic\n sampler, a probability between 0 and 1\n    #   - for \nrateLimiting\n sampler, the number of spans per second\n    #\n    # Default: 1.0\n    #\n    samplingParam = 1.0\n\n    # Local Agent Host Port instructs reporter to send spans to jaeger-agent at this address\n    #\n    # Default: \n127.0.0.1:6831\n\n    #\n    localAgentHostPort = \n127.0.0.1:6831\n\n\n    # Trace Context Header Name is the http header name used to propagate tracing context.\n    # This must be in lower-case to avoid mismatches when decoding incoming headers.\n    #\n    # Default: \nuber-trace-id\n\n    #\n    traceContextHeaderName = \nuber-trace-id\n\n\n\n\n\n\n\nWarning\n\n\nTraefik is only able to send data over compact thrift protocol to the \nJaeger agent\n.\n\n\n\n\nZipkin\n\n\n# Tracing definition\n[tracing]\n  # Backend name used to send tracing data\n  #\n  # Default: \njaeger\n\n  #\n  backend = \nzipkin\n\n\n  # Service name used in Zipkin backend\n  #\n  # Default: \ntraefik\n\n  #\n  serviceName = \ntraefik\n\n\n  # Span name limit allows for name truncation in case of very long Frontend/Backend names\n  # This can prevent certain tracing providers to drop traces that exceed their length limits\n  #\n  # Default: 0 - no truncation will occur\n  # \n  spanNameLimit = 150\n\n  [tracing.zipkin]\n    # Zipking HTTP endpoint used to send data\n    #\n    # Default: \nhttp://localhost:9411/api/v1/spans\n\n    #\n    httpEndpoint = \nhttp://localhost:9411/api/v1/spans\n\n\n    # Enable Zipkin debug\n    #\n    # Default: false\n    #\n    debug = false\n\n    # Use ZipKin SameSpan RPC style traces\n    #\n    # Default: false\n    #\n    sameSpan = false\n\n    # Use ZipKin 128 bit root span IDs\n    #\n    # Default: true\n    #\n    id128Bit = true\n\n\n\n\nDataDog\n\n\n# Tracing definition\n[tracing]\n  # Backend name used to send tracing data\n  #\n  # Default: \njaeger\n\n  #\n  backend = \ndatadog\n\n\n  # Service name used in DataDog backend\n  #\n  # Default: \ntraefik\n\n  #\n  serviceName = \ntraefik\n\n\n  # Span name limit allows for name truncation in case of very long Frontend/Backend names\n  # This can prevent certain tracing providers to drop traces that exceed their length limits\n  #\n  # Default: 0 - no truncation will occur\n  # \n  spanNameLimit = 100\n\n  [tracing.datadog]\n    # Local Agent Host Port instructs reporter to send spans to datadog-tracing-agent at this address\n    #\n    # Default: \n127.0.0.1:8126\n\n    #\n    localAgentHostPort = \n127.0.0.1:8126\n\n\n    # Enable DataDog debug\n    #\n    # Default: false\n    #\n    debug = false\n\n    # Apply shared tag in a form of Key:Value to all the traces\n    #\n    # Default: \n\n    #\n    globalTag = \n\n\n    # Enable priority sampling. When using distributed tracing, this option must be enabled in order\n    # to get all the parts of a distributed trace sampled.\n    #\n    # Default: false\n    #\n    prioritySampling = false", 
            "title": "Tracing"
        }, 
        {
            "location": "/configuration/tracing/#tracing", 
            "text": "The tracing system allows developers to visualize call flows in their infrastructure.  We use  OpenTracing . It is an open standard designed for distributed tracing.  Traefik supports three tracing backends: Jaeger, Zipkin and DataDog.", 
            "title": "Tracing"
        }, 
        {
            "location": "/configuration/tracing/#jaeger", 
            "text": "# Tracing definition\n[tracing]\n  # Backend name used to send tracing data\n  #\n  # Default:  jaeger \n  #\n  backend =  jaeger \n\n  # Service name used in Jaeger backend\n  #\n  # Default:  traefik \n  #\n  serviceName =  traefik \n\n  # Span name limit allows for name truncation in case of very long Frontend/Backend names\n  # This can prevent certain tracing providers to drop traces that exceed their length limits\n  #\n  # Default: 0 - no truncation will occur\n  # \n  spanNameLimit = 0\n\n  [tracing.jaeger]\n    # Sampling Server URL is the address of jaeger-agent's HTTP sampling server\n    #\n    # Default:  http://localhost:5778/sampling \n    #\n    samplingServerURL =  http://localhost:5778/sampling \n\n    # Sampling Type specifies the type of the sampler: const, probabilistic, rateLimiting\n    #\n    # Default:  const \n    #\n    samplingType =  const \n\n    # Sampling Param is a value passed to the sampler.\n    # Valid values for Param field are:\n    #   - for  const  sampler, 0 or 1 for always false/true respectively\n    #   - for  probabilistic  sampler, a probability between 0 and 1\n    #   - for  rateLimiting  sampler, the number of spans per second\n    #\n    # Default: 1.0\n    #\n    samplingParam = 1.0\n\n    # Local Agent Host Port instructs reporter to send spans to jaeger-agent at this address\n    #\n    # Default:  127.0.0.1:6831 \n    #\n    localAgentHostPort =  127.0.0.1:6831 \n\n    # Trace Context Header Name is the http header name used to propagate tracing context.\n    # This must be in lower-case to avoid mismatches when decoding incoming headers.\n    #\n    # Default:  uber-trace-id \n    #\n    traceContextHeaderName =  uber-trace-id    Warning  Traefik is only able to send data over compact thrift protocol to the  Jaeger agent .", 
            "title": "Jaeger"
        }, 
        {
            "location": "/configuration/tracing/#zipkin", 
            "text": "# Tracing definition\n[tracing]\n  # Backend name used to send tracing data\n  #\n  # Default:  jaeger \n  #\n  backend =  zipkin \n\n  # Service name used in Zipkin backend\n  #\n  # Default:  traefik \n  #\n  serviceName =  traefik \n\n  # Span name limit allows for name truncation in case of very long Frontend/Backend names\n  # This can prevent certain tracing providers to drop traces that exceed their length limits\n  #\n  # Default: 0 - no truncation will occur\n  # \n  spanNameLimit = 150\n\n  [tracing.zipkin]\n    # Zipking HTTP endpoint used to send data\n    #\n    # Default:  http://localhost:9411/api/v1/spans \n    #\n    httpEndpoint =  http://localhost:9411/api/v1/spans \n\n    # Enable Zipkin debug\n    #\n    # Default: false\n    #\n    debug = false\n\n    # Use ZipKin SameSpan RPC style traces\n    #\n    # Default: false\n    #\n    sameSpan = false\n\n    # Use ZipKin 128 bit root span IDs\n    #\n    # Default: true\n    #\n    id128Bit = true", 
            "title": "Zipkin"
        }, 
        {
            "location": "/configuration/tracing/#datadog", 
            "text": "# Tracing definition\n[tracing]\n  # Backend name used to send tracing data\n  #\n  # Default:  jaeger \n  #\n  backend =  datadog \n\n  # Service name used in DataDog backend\n  #\n  # Default:  traefik \n  #\n  serviceName =  traefik \n\n  # Span name limit allows for name truncation in case of very long Frontend/Backend names\n  # This can prevent certain tracing providers to drop traces that exceed their length limits\n  #\n  # Default: 0 - no truncation will occur\n  # \n  spanNameLimit = 100\n\n  [tracing.datadog]\n    # Local Agent Host Port instructs reporter to send spans to datadog-tracing-agent at this address\n    #\n    # Default:  127.0.0.1:8126 \n    #\n    localAgentHostPort =  127.0.0.1:8126 \n\n    # Enable DataDog debug\n    #\n    # Default: false\n    #\n    debug = false\n\n    # Apply shared tag in a form of Key:Value to all the traces\n    #\n    # Default:  \n    #\n    globalTag =  \n\n    # Enable priority sampling. When using distributed tracing, this option must be enabled in order\n    # to get all the parts of a distributed trace sampled.\n    #\n    # Default: false\n    #\n    prioritySampling = false", 
            "title": "DataDog"
        }, 
        {
            "location": "/configuration/backends/web/", 
            "text": "Web Provider\n\n\n\n\nDEPRECATED\n\n\nThe web provider is deprecated, please use the \napi\n, the \nping\n, the \nmetrics\n and the \nrest\n provider.\n\n\n\n\nTraefik can be configured:\n\n\n\n\nusing a RESTful api.\n\n\nto use a monitoring system (like Prometheus, DataDog or StatD, ...).\n\n\nto expose a Web Dashboard.\n\n\n\n\nConfiguration\n\n\n# Enable Web Provider.\n[web]\n\n# Web administration port.\n#\n# Required\n# Default: \n:8080\n\n#\naddress = \n:8080\n\n\n# SSL certificate and key used.\n#\n# Optional\n#\n# certFile = \ntraefik.crt\n\n# keyFile = \ntraefik.key\n\n\n# Set REST API to read-only mode.\n#\n# Optional\n# Default: false\n#\nreadOnly = true\n\n# Set the root path for webui and API\n#\n# Deprecated\n# Optional\n#\n# path = \n/mypath\n\n#\n\n\n\n\nWeb UI\n\n\n\n\n\n\nAuthentication\n\n\n\n\nNote\n\n\nThe \n/ping\n path of the API is excluded from authentication (since 1.4).\n\n\n\n\nBasic Authentication\n\n\nPasswords can be encoded in MD5, SHA1 and BCrypt: you can use \nhtpasswd\n to generate those ones.\n\n\nUsers can be specified directly in the TOML file, or indirectly by referencing an external file;\n if both are provided, the two are merged, with external file contents having precedence.\n\n\n[web]\n# ...\n\n# To enable basic auth on the webui with 2 user/pass: test:test and test2:test2\n[web.auth.basic]\nusers = [\ntest:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\n, \ntest2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\n]\nusersFile = \n/path/to/.htpasswd\n\n\n# ...\n\n\n\n\nDigest Authentication\n\n\nYou can use \nhtdigest\n to generate those ones.\n\n\nUsers can be specified directly in the TOML file, or indirectly by referencing an external file;\n if both are provided, the two are merged, with external file contents having precedence\n\n\n[web]\n# ...\n\n# To enable digest auth on the webui with 2 user/realm/pass: test:traefik:test and test2:traefik:test2\n[web.auth.digest]\nusers = [\ntest:traefik:a2688e031edb4be6a3797f3882655c05\n, \ntest2:traefik:518845800f9e2bfb1f1f740ec24f074e\n]\nusersFile = \n/path/to/.htdigest\n\n\n# ...\n\n\n\n\nMetrics\n\n\nYou can enable Traefik to export internal metrics to different monitoring systems.\n\n\nPrometheus\n\n\n[web]\n# ...\n\n# To enable Traefik to export internal metrics to Prometheus\n[web.metrics.prometheus]\n\n# Buckets for latency metrics\n#\n# Optional\n# Default: [0.1, 0.3, 1.2, 5]\nbuckets=[0.1,0.3,1.2,5.0]\n\n# ...\n\n\n\n\nDataDog\n\n\n[web]\n# ...\n\n# DataDog metrics exporter type\n[web.metrics.datadog]\n\n# DataDog's address.\n#\n# Required\n# Default: \nlocalhost:8125\n\n#\naddress = \nlocalhost:8125\n\n\n# DataDog push interval\n#\n# Optional\n# Default: \n10s\n\n#\npushinterval = \n10s\n\n\n# ...\n\n\n\n\nStatsD\n\n\n[web]\n# ...\n\n# StatsD metrics exporter type\n[web.metrics.statsd]\n\n# StatD's address.\n#\n# Required\n# Default: \nlocalhost:8125\n\n#\naddress = \nlocalhost:8125\n\n\n# StatD push interval\n#\n# Optional\n# Default: \n10s\n\n#\npushinterval = \n10s\n\n\n# ...\n\n\n\n\nInfluxDB\n\n\n[web]\n# ...\n\n# InfluxDB metrics exporter type\n[web.metrics.influxdb]\n\n# InfluxDB's address.\n#\n# Required\n# Default: \nlocalhost:8089\n\n#\naddress = \nlocalhost:8089\n\n\n# InfluxDB's address protocol (udp or http)\n#\n# Required\n# Default: \nudp\n\n#\nprotocol = \nudp\n\n\n# InfluxDB push interval\n#\n# Optional\n# Default: \n10s\n\n#\npushinterval = \n10s\n\n\n# InfluxDB database used when protocol is http\n#\n# Optional\n# Default: \n\n#\ndatabase = \n\n\n# InfluxDB retention policy used when protocol is http\n#\n# Optional\n# Default: \n\n#\nretentionpolicy = \n\n\n# ...\n\n\n\n\nStatistics\n\n\n[web]\n# ...\n\n# Enable more detailed statistics.\n[web.statistics]\n\n# Number of recent errors logged.\n#\n# Default: 10\n#\nrecentErrors = 10\n\n# ...\n\n\n\n\nAPI\n\n\n\n\n\n\n\n\nPath\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n/\n\n\nGET\n\n\nProvides a simple HTML frontend of Traefik\n\n\n\n\n\n\n/ping\n\n\nGET\n, \nHEAD\n\n\nA simple endpoint to check for Traefik process liveness. Return a code \n200\n with the content: \nOK\n\n\n\n\n\n\n/health\n\n\nGET\n\n\nJSON health metrics\n\n\n\n\n\n\n/api\n\n\nGET\n\n\nConfiguration for all providers\n\n\n\n\n\n\n/api/providers\n\n\nGET\n\n\nProviders\n\n\n\n\n\n\n/api/providers/{provider}\n\n\nGET\n, \nPUT\n\n\nGet or update provider\n\n\n\n\n\n\n/api/providers/{provider}/backends\n\n\nGET\n\n\nList backends\n\n\n\n\n\n\n/api/providers/{provider}/backends/{backend}\n\n\nGET\n\n\nGet backend\n\n\n\n\n\n\n/api/providers/{provider}/backends/{backend}/servers\n\n\nGET\n\n\nList servers in backend\n\n\n\n\n\n\n/api/providers/{provider}/backends/{backend}/servers/{server}\n\n\nGET\n\n\nGet a server in a backend\n\n\n\n\n\n\n/api/providers/{provider}/frontends\n\n\nGET\n\n\nList frontends\n\n\n\n\n\n\n/api/providers/{provider}/frontends/{frontend}\n\n\nGET\n\n\nGet a frontend\n\n\n\n\n\n\n/api/providers/{provider}/frontends/{frontend}/routes\n\n\nGET\n\n\nList routes in a frontend\n\n\n\n\n\n\n/api/providers/{provider}/frontends/{frontend}/routes/{route}\n\n\nGET\n\n\nGet a route in a frontend\n\n\n\n\n\n\n/metrics\n\n\nGET\n\n\nExport internal metrics\n\n\n\n\n\n\n\n\nExample\n\n\nPing\n\n\ncurl -sv \nhttp://localhost:8080/ping\n\n\n\n\n\n*   Trying ::1...\n* Connected to localhost (::1) port 8080 (\\#0)\n\n GET /ping HTTP/1.1\n\n Host: localhost:8080\n\n User-Agent: curl/7.43.0\n\n Accept: */*\n\n\n\n HTTP/1.1 200 OK\n\n Date: Thu, 25 Aug 2016 01:35:36 GMT\n\n Content-Length: 2\n\n Content-Type: text/plain; charset=utf-8\n\n\n* Connection \\#0 to host localhost left intact\nOK\n\n\n\n\nHealth\n\n\ncurl -s \nhttp://localhost:8080/health\n | jq .\n\n\n\n\n{\n  // Traefik PID\n  \npid\n: 2458,\n  // Traefik server uptime (formated time)\n  \nuptime\n: \n39m6.885931127s\n,\n  //  Traefik server uptime in seconds\n  \nuptime_sec\n: 2346.885931127,\n  // current server date\n  \ntime\n: \n2015-10-07 18:32:24.362238909 +0200 CEST\n,\n  // current server date in seconds\n  \nunixtime\n: 1444235544,\n  // count HTTP response status code in realtime\n  \nstatus_code_count\n: {\n    \n502\n: 1\n  },\n  // count HTTP response status code since Traefik started\n  \ntotal_status_code_count\n: {\n    \n200\n: 7,\n    \n404\n: 21,\n    \n502\n: 13\n  },\n  // count HTTP response\n  \ncount\n: 1,\n  // count HTTP response\n  \ntotal_count\n: 41,\n  // sum of all response time (formated time)\n  \ntotal_response_time\n: \n35.456865605s\n,\n  // sum of all response time in seconds\n  \ntotal_response_time_sec\n: 35.456865605,\n  // average response time (formated time)\n  \naverage_response_time\n: \n864.8016ms\n,\n  // average response time in seconds\n  \naverage_response_time_sec\n: 0.8648016000000001,\n\n  // request statistics [requires --web.statistics to be set]\n  // ten most recent requests with 4xx and 5xx status codes\n  \nrecent_errors\n: [\n    {\n      // status code\n      \nstatus_code\n: 500,\n      // description of status code\n      \nstatus\n: \nInternal Server Error\n,\n      // request HTTP method\n      \nmethod\n: \nGET\n,\n      // request host name\n      \nhost\n: \nlocalhost\n,\n      // request path\n      \npath\n: \n/path\n,\n      // RFC 3339 formatted date/time\n      \ntime\n: \n2016-10-21T16:59:15.418495872-07:00\n\n    }\n  ]\n}\n\n\n\n\nProvider configurations\n\n\ncurl -s \nhttp://localhost:8080/api\n | jq .\n\n\n\n\n{\n  \nfile\n: {\n    \nfrontends\n: {\n      \nfrontend2\n: {\n        \nroutes\n: {\n          \ntest_2\n: {\n            \nrule\n: \nPath:/test\n\n          }\n        },\n        \nbackend\n: \nbackend1\n\n      },\n      \nfrontend1\n: {\n        \nroutes\n: {\n          \ntest_1\n: {\n            \nrule\n: \nHost:test.localhost\n\n          }\n        },\n        \nbackend\n: \nbackend2\n\n      }\n    },\n    \nbackends\n: {\n      \nbackend2\n: {\n        \nloadBalancer\n: {\n          \nmethod\n: \ndrr\n\n        },\n        \nservers\n: {\n          \nserver2\n: {\n            \nweight\n: 2,\n            \nURL\n: \nhttp://172.17.0.5:80\n\n          },\n          \nserver1\n: {\n            \nweight\n: 1,\n            \nurl\n: \nhttp://172.17.0.4:80\n\n          }\n        }\n      },\n      \nbackend1\n: {\n        \nloadBalancer\n: {\n          \nmethod\n: \nwrr\n\n        },\n        \ncircuitBreaker\n: {\n          \nexpression\n: \nNetworkErrorRatio() \n 0.5\n\n        },\n        \nservers\n: {\n          \nserver2\n: {\n            \nweight\n: 1,\n            \nurl\n: \nhttp://172.17.0.3:80\n\n          },\n          \nserver1\n: {\n            \nweight\n: 10,\n            \nurl\n: \nhttp://172.17.0.2:80\n\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\nDeprecation compatibility\n\n\nAddress\n\n\nAs the web provider is deprecated, you can handle the \nAddress\n option like this:\n\n\ndefaultEntryPoints = [\nhttp\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n\n  [entryPoints.foo]\n  address = \n:8082\n\n\n  [entryPoints.bar]\n  address = \n:8083\n\n\n[ping]\nentryPoint = \nfoo\n\n\n[api]\nentryPoint = \nbar\n\n\n\n\n\nIn the above example, you would access a regular path, administration panel, and health-check as follows:\n\n\n\n\nRegular path: \nhttp://hostname:80/path\n\n\nAdmin Panel: \nhttp://hostname:8083/\n\n\nPing URL: \nhttp://hostname:8082/ping\n\n\n\n\nIn the above example, it is \nvery\n important to create a named dedicated entry point, and do \nnot\n include it in \ndefaultEntryPoints\n.\nOtherwise, you are likely to expose \nall\n services via that entry point.\n\n\nPath\n\n\nAs the web provider is deprecated, you can handle the \nPath\n option like this:\n\n\ndefaultEntryPoints = [\nhttp\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n\n  [entryPoints.foo]\n  address = \n:8080\n\n\n  [entryPoints.bar]\n  address = \n:8081\n\n\n# Activate API and Dashboard\n[api]\nentryPoint = \nbar\n\ndashboard = true\n\n[file]\n  [backends]\n    [backends.backend1]\n      [backends.backend1.servers.server1]\n      url = \nhttp://127.0.0.1:8081\n\n\n  [frontends]\n    [frontends.frontend1]\n    entryPoints = [\nfoo\n]\n    backend = \nbackend1\n\n      [frontends.frontend1.routes.test_1]\n      rule = \nPathPrefixStrip:/yourprefix;PathPrefix:/yourprefix\n\n\n\n\n\nAuthentication\n\n\nAs the web provider is deprecated, you can handle the \nauth\n option like this:\n\n\ndefaultEntryPoints = [\nhttp\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n\n [entryPoints.foo]\n   address=\n:8080\n\n   [entryPoints.foo.auth]\n     [entryPoints.foo.auth.basic]\n       users = [\n         \ntest:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\n,\n         \ntest2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\n,\n       ]\n\n[api]\nentrypoint=\nfoo\n\n\n\n\n\nFor more information, see \nentry points\n .", 
            "title": "Web (Deprecated)"
        }, 
        {
            "location": "/configuration/backends/web/#web-provider", 
            "text": "DEPRECATED  The web provider is deprecated, please use the  api , the  ping , the  metrics  and the  rest  provider.   Traefik can be configured:   using a RESTful api.  to use a monitoring system (like Prometheus, DataDog or StatD, ...).  to expose a Web Dashboard.", 
            "title": "Web Provider"
        }, 
        {
            "location": "/configuration/backends/web/#configuration", 
            "text": "# Enable Web Provider.\n[web]\n\n# Web administration port.\n#\n# Required\n# Default:  :8080 \n#\naddress =  :8080 \n\n# SSL certificate and key used.\n#\n# Optional\n#\n# certFile =  traefik.crt \n# keyFile =  traefik.key \n\n# Set REST API to read-only mode.\n#\n# Optional\n# Default: false\n#\nreadOnly = true\n\n# Set the root path for webui and API\n#\n# Deprecated\n# Optional\n#\n# path =  /mypath \n#", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/backends/web/#web-ui", 
            "text": "", 
            "title": "Web UI"
        }, 
        {
            "location": "/configuration/backends/web/#authentication", 
            "text": "Note  The  /ping  path of the API is excluded from authentication (since 1.4).", 
            "title": "Authentication"
        }, 
        {
            "location": "/configuration/backends/web/#basic-authentication", 
            "text": "Passwords can be encoded in MD5, SHA1 and BCrypt: you can use  htpasswd  to generate those ones.  Users can be specified directly in the TOML file, or indirectly by referencing an external file;\n if both are provided, the two are merged, with external file contents having precedence.  [web]\n# ...\n\n# To enable basic auth on the webui with 2 user/pass: test:test and test2:test2\n[web.auth.basic]\nusers = [ test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ ,  test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 ]\nusersFile =  /path/to/.htpasswd \n\n# ...", 
            "title": "Basic Authentication"
        }, 
        {
            "location": "/configuration/backends/web/#digest-authentication", 
            "text": "You can use  htdigest  to generate those ones.  Users can be specified directly in the TOML file, or indirectly by referencing an external file;\n if both are provided, the two are merged, with external file contents having precedence  [web]\n# ...\n\n# To enable digest auth on the webui with 2 user/realm/pass: test:traefik:test and test2:traefik:test2\n[web.auth.digest]\nusers = [ test:traefik:a2688e031edb4be6a3797f3882655c05 ,  test2:traefik:518845800f9e2bfb1f1f740ec24f074e ]\nusersFile =  /path/to/.htdigest \n\n# ...", 
            "title": "Digest Authentication"
        }, 
        {
            "location": "/configuration/backends/web/#metrics", 
            "text": "You can enable Traefik to export internal metrics to different monitoring systems.", 
            "title": "Metrics"
        }, 
        {
            "location": "/configuration/backends/web/#prometheus", 
            "text": "[web]\n# ...\n\n# To enable Traefik to export internal metrics to Prometheus\n[web.metrics.prometheus]\n\n# Buckets for latency metrics\n#\n# Optional\n# Default: [0.1, 0.3, 1.2, 5]\nbuckets=[0.1,0.3,1.2,5.0]\n\n# ...", 
            "title": "Prometheus"
        }, 
        {
            "location": "/configuration/backends/web/#datadog", 
            "text": "[web]\n# ...\n\n# DataDog metrics exporter type\n[web.metrics.datadog]\n\n# DataDog's address.\n#\n# Required\n# Default:  localhost:8125 \n#\naddress =  localhost:8125 \n\n# DataDog push interval\n#\n# Optional\n# Default:  10s \n#\npushinterval =  10s \n\n# ...", 
            "title": "DataDog"
        }, 
        {
            "location": "/configuration/backends/web/#statsd", 
            "text": "[web]\n# ...\n\n# StatsD metrics exporter type\n[web.metrics.statsd]\n\n# StatD's address.\n#\n# Required\n# Default:  localhost:8125 \n#\naddress =  localhost:8125 \n\n# StatD push interval\n#\n# Optional\n# Default:  10s \n#\npushinterval =  10s \n\n# ...", 
            "title": "StatsD"
        }, 
        {
            "location": "/configuration/backends/web/#influxdb", 
            "text": "[web]\n# ...\n\n# InfluxDB metrics exporter type\n[web.metrics.influxdb]\n\n# InfluxDB's address.\n#\n# Required\n# Default:  localhost:8089 \n#\naddress =  localhost:8089 \n\n# InfluxDB's address protocol (udp or http)\n#\n# Required\n# Default:  udp \n#\nprotocol =  udp \n\n# InfluxDB push interval\n#\n# Optional\n# Default:  10s \n#\npushinterval =  10s \n\n# InfluxDB database used when protocol is http\n#\n# Optional\n# Default:  \n#\ndatabase =  \n\n# InfluxDB retention policy used when protocol is http\n#\n# Optional\n# Default:  \n#\nretentionpolicy =  \n\n# ...", 
            "title": "InfluxDB"
        }, 
        {
            "location": "/configuration/backends/web/#statistics", 
            "text": "[web]\n# ...\n\n# Enable more detailed statistics.\n[web.statistics]\n\n# Number of recent errors logged.\n#\n# Default: 10\n#\nrecentErrors = 10\n\n# ...", 
            "title": "Statistics"
        }, 
        {
            "location": "/configuration/backends/web/#api", 
            "text": "Path  Method  Description      /  GET  Provides a simple HTML frontend of Traefik    /ping  GET ,  HEAD  A simple endpoint to check for Traefik process liveness. Return a code  200  with the content:  OK    /health  GET  JSON health metrics    /api  GET  Configuration for all providers    /api/providers  GET  Providers    /api/providers/{provider}  GET ,  PUT  Get or update provider    /api/providers/{provider}/backends  GET  List backends    /api/providers/{provider}/backends/{backend}  GET  Get backend    /api/providers/{provider}/backends/{backend}/servers  GET  List servers in backend    /api/providers/{provider}/backends/{backend}/servers/{server}  GET  Get a server in a backend    /api/providers/{provider}/frontends  GET  List frontends    /api/providers/{provider}/frontends/{frontend}  GET  Get a frontend    /api/providers/{provider}/frontends/{frontend}/routes  GET  List routes in a frontend    /api/providers/{provider}/frontends/{frontend}/routes/{route}  GET  Get a route in a frontend    /metrics  GET  Export internal metrics", 
            "title": "API"
        }, 
        {
            "location": "/configuration/backends/web/#example", 
            "text": "", 
            "title": "Example"
        }, 
        {
            "location": "/configuration/backends/web/#ping", 
            "text": "curl -sv  http://localhost:8080/ping   *   Trying ::1...\n* Connected to localhost (::1) port 8080 (\\#0)  GET /ping HTTP/1.1  Host: localhost:8080  User-Agent: curl/7.43.0  Accept: */*   HTTP/1.1 200 OK  Date: Thu, 25 Aug 2016 01:35:36 GMT  Content-Length: 2  Content-Type: text/plain; charset=utf-8 \n* Connection \\#0 to host localhost left intact\nOK", 
            "title": "Ping"
        }, 
        {
            "location": "/configuration/backends/web/#health", 
            "text": "curl -s  http://localhost:8080/health  | jq .  {\n  // Traefik PID\n   pid : 2458,\n  // Traefik server uptime (formated time)\n   uptime :  39m6.885931127s ,\n  //  Traefik server uptime in seconds\n   uptime_sec : 2346.885931127,\n  // current server date\n   time :  2015-10-07 18:32:24.362238909 +0200 CEST ,\n  // current server date in seconds\n   unixtime : 1444235544,\n  // count HTTP response status code in realtime\n   status_code_count : {\n     502 : 1\n  },\n  // count HTTP response status code since Traefik started\n   total_status_code_count : {\n     200 : 7,\n     404 : 21,\n     502 : 13\n  },\n  // count HTTP response\n   count : 1,\n  // count HTTP response\n   total_count : 41,\n  // sum of all response time (formated time)\n   total_response_time :  35.456865605s ,\n  // sum of all response time in seconds\n   total_response_time_sec : 35.456865605,\n  // average response time (formated time)\n   average_response_time :  864.8016ms ,\n  // average response time in seconds\n   average_response_time_sec : 0.8648016000000001,\n\n  // request statistics [requires --web.statistics to be set]\n  // ten most recent requests with 4xx and 5xx status codes\n   recent_errors : [\n    {\n      // status code\n       status_code : 500,\n      // description of status code\n       status :  Internal Server Error ,\n      // request HTTP method\n       method :  GET ,\n      // request host name\n       host :  localhost ,\n      // request path\n       path :  /path ,\n      // RFC 3339 formatted date/time\n       time :  2016-10-21T16:59:15.418495872-07:00 \n    }\n  ]\n}", 
            "title": "Health"
        }, 
        {
            "location": "/configuration/backends/web/#provider-configurations", 
            "text": "curl -s  http://localhost:8080/api  | jq .  {\n   file : {\n     frontends : {\n       frontend2 : {\n         routes : {\n           test_2 : {\n             rule :  Path:/test \n          }\n        },\n         backend :  backend1 \n      },\n       frontend1 : {\n         routes : {\n           test_1 : {\n             rule :  Host:test.localhost \n          }\n        },\n         backend :  backend2 \n      }\n    },\n     backends : {\n       backend2 : {\n         loadBalancer : {\n           method :  drr \n        },\n         servers : {\n           server2 : {\n             weight : 2,\n             URL :  http://172.17.0.5:80 \n          },\n           server1 : {\n             weight : 1,\n             url :  http://172.17.0.4:80 \n          }\n        }\n      },\n       backend1 : {\n         loadBalancer : {\n           method :  wrr \n        },\n         circuitBreaker : {\n           expression :  NetworkErrorRatio()   0.5 \n        },\n         servers : {\n           server2 : {\n             weight : 1,\n             url :  http://172.17.0.3:80 \n          },\n           server1 : {\n             weight : 10,\n             url :  http://172.17.0.2:80 \n          }\n        }\n      }\n    }\n  }\n}", 
            "title": "Provider configurations"
        }, 
        {
            "location": "/configuration/backends/web/#deprecation-compatibility", 
            "text": "", 
            "title": "Deprecation compatibility"
        }, 
        {
            "location": "/configuration/backends/web/#address", 
            "text": "As the web provider is deprecated, you can handle the  Address  option like this:  defaultEntryPoints = [ http ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n\n  [entryPoints.foo]\n  address =  :8082 \n\n  [entryPoints.bar]\n  address =  :8083 \n\n[ping]\nentryPoint =  foo \n\n[api]\nentryPoint =  bar   In the above example, you would access a regular path, administration panel, and health-check as follows:   Regular path:  http://hostname:80/path  Admin Panel:  http://hostname:8083/  Ping URL:  http://hostname:8082/ping   In the above example, it is  very  important to create a named dedicated entry point, and do  not  include it in  defaultEntryPoints .\nOtherwise, you are likely to expose  all  services via that entry point.", 
            "title": "Address"
        }, 
        {
            "location": "/configuration/backends/web/#path", 
            "text": "As the web provider is deprecated, you can handle the  Path  option like this:  defaultEntryPoints = [ http ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n\n  [entryPoints.foo]\n  address =  :8080 \n\n  [entryPoints.bar]\n  address =  :8081 \n\n# Activate API and Dashboard\n[api]\nentryPoint =  bar \ndashboard = true\n\n[file]\n  [backends]\n    [backends.backend1]\n      [backends.backend1.servers.server1]\n      url =  http://127.0.0.1:8081 \n\n  [frontends]\n    [frontends.frontend1]\n    entryPoints = [ foo ]\n    backend =  backend1 \n      [frontends.frontend1.routes.test_1]\n      rule =  PathPrefixStrip:/yourprefix;PathPrefix:/yourprefix", 
            "title": "Path"
        }, 
        {
            "location": "/configuration/backends/web/#authentication_1", 
            "text": "As the web provider is deprecated, you can handle the  auth  option like this:  defaultEntryPoints = [ http ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n\n [entryPoints.foo]\n   address= :8080 \n   [entryPoints.foo.auth]\n     [entryPoints.foo.auth.basic]\n       users = [\n          test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ ,\n          test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 ,\n       ]\n\n[api]\nentrypoint= foo   For more information, see  entry points  .", 
            "title": "Authentication"
        }, 
        {
            "location": "/user-guide/examples/", 
            "text": "Examples\n\n\nYou will find here some configuration examples of Traefik.\n\n\nHTTP only\n\n\ndefaultEntryPoints = [\nhttp\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n\n\n\n\nHTTP + HTTPS (with SNI)\n\n\ndefaultEntryPoints = [\nhttp\n, \nhttps\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile = \nintegration/fixtures/https/snitest.com.cert\n\n      keyFile = \nintegration/fixtures/https/snitest.com.key\n\n      [[entryPoints.https.tls.certificates]]\n      certFile = \nintegration/fixtures/https/snitest.org.cert\n\n      keyFile = \nintegration/fixtures/https/snitest.org.key\n\n\n\n\n\nNote that we can either give path to certificate file or directly the file content itself (\nlike in this TOML example\n).\n\n\nHTTP redirect on HTTPS\n\n\ndefaultEntryPoints = [\nhttp\n, \nhttps\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n    [entryPoints.http.redirect]\n    entryPoint = \nhttps\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile = \nexamples/traefik.crt\n\n      keyFile = \nexamples/traefik.key\n\n\n\n\n\n\n\nNote\n\n\nPlease note that \nregex\n and \nreplacement\n do not have to be set in the \nredirect\n structure if an entrypoint is defined for the redirection (they will not be used in this case)\n\n\n\n\nLet's Encrypt support\n\n\nBasic example with HTTP challenge\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n\n[acme]\nemail = \ntest@traefik.io\n\nstorage = \nacme.json\n\ncaServer = \nhttps://acme-staging-v02.api.letsencrypt.org/directory\n\nentryPoint = \nhttps\n\n  [acme.httpChallenge]\n  entryPoint = \nhttp\n\n\n[[acme.domains]]\n  main = \nlocal1.com\n\n  sans = [\ntest1.local1.com\n, \ntest2.local1.com\n]\n[[acme.domains]]\n  main = \nlocal2.com\n\n  sans = [\ntest1.local2.com\n, \ntest2x.local2.com\n]\n[[acme.domains]]\n  main = \nlocal3.com\n\n[[acme.domains]]\n  main = \nlocal4.com\n\n\n\n\n\nThis configuration allows generating Let's Encrypt certificates (thanks to \nHTTP-01\n challenge) for the four domains \nlocal[1-4].com\n with described SANs.\n\n\nTraefik generates these certificates when it starts and it needs to be restart if new domains are added.\n\n\nonHostRule option (with HTTP challenge)\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n\n[acme]\nemail = \ntest@traefik.io\n\nstorage = \nacme.json\n\nonHostRule = true\ncaServer = \nhttps://acme-staging-v02.api.letsencrypt.org/directory\n\nentryPoint = \nhttps\n\n  [acme.httpChallenge]\n  entryPoint = \nhttp\n\n\n[[acme.domains]]\n  main = \nlocal1.com\n\n  sans = [\ntest1.local1.com\n, \ntest2.local1.com\n]\n[[acme.domains]]\n  main = \nlocal2.com\n\n  sans = [\ntest1.local2.com\n, \ntest2x.local2.com\n]\n[[acme.domains]]\n  main = \nlocal3.com\n\n[[acme.domains]]\n  main = \nlocal4.com\n\n\n\n\n\nThis configuration allows generating Let's Encrypt certificates (thanks to \nHTTP-01\n challenge) for the four domains \nlocal[1-4].com\n.\n\n\nTraefik generates these certificates when it starts.\n\n\nIf a backend is added with a \nonHost\n rule, Traefik will automatically generate the Let's Encrypt certificate for the new domain (for frontends wired on the \nacme.entryPoint\n).\n\n\nOnDemand option (with HTTP challenge)\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n\n[acme]\nemail = \ntest@traefik.io\n\nstorage = \nacme.json\n\nonDemand = true\ncaServer = \nhttps://acme-staging-v02.api.letsencrypt.org/directory\n\nentryPoint = \nhttps\n\n  [acme.httpChallenge]\n  entryPoint = \nhttp\n\n\n\n\n\nThis configuration allows generating a Let's Encrypt certificate (thanks to \nHTTP-01\n challenge) during the first HTTPS request on a new domain.\n\n\n\n\nNote\n\n\nThis option simplifies the configuration but :\n\n\n\n\nTLS handshakes will be slow when requesting a hostname certificate for the first time, which can lead to DDoS attacks.\n\n\nLet's Encrypt have rate limiting: https://letsencrypt.org/docs/rate-limits\n\n\n\n\nThat's why, it's better to use the \nonHostRule\n option if possible.\n\n\n\n\nDNS challenge\n\n\n[entryPoints]\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n\n[acme]\nemail = \ntest@traefik.io\n\nstorage = \nacme.json\n\ncaServer = \nhttps://acme-staging-v02.api.letsencrypt.org/directory\n\nentryPoint = \nhttps\n\n  [acme.dnsChallenge]\n  provider = \ndigitalocean\n # DNS Provider name (cloudflare, OVH, gandi...)\n  delayBeforeCheck = 0\n\n[[acme.domains]]\n  main = \nlocal1.com\n\n  sans = [\ntest1.local1.com\n, \ntest2.local1.com\n]\n[[acme.domains]]\n  main = \nlocal2.com\n\n  sans = [\ntest1.local2.com\n, \ntest2x.local2.com\n]\n[[acme.domains]]\n  main = \nlocal3.com\n\n[[acme.domains]]\n  main = \nlocal4.com\n\n\n\n\n\nDNS challenge needs environment variables to be executed.\nThese variables have to be set on the machine/container that host Traefik.\n\n\nThese variables are described \nin this section\n.\n\n\nDNS challenge with wildcard domains\n\n\n[entryPoints]\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n\n[acme]\nemail = \ntest@traefik.io\n\nstorage = \nacme.json\n\ncaServer = \nhttps://acme-staging-v02.api.letsencrypt.org/directory\n\nentryPoint = \nhttps\n\n  [acme.dnsChallenge]\n  provider = \ndigitalocean\n # DNS Provider name (cloudflare, OVH, gandi...)\n  delayBeforeCheck = 0\n\n[[acme.domains]]\n  main = \n*.local1.com\n\n[[acme.domains]]\n  main = \nlocal2.com\n\n  sans = [\ntest1.local2.com\n, \ntest2x.local2.com\n]\n[[acme.domains]]\n  main = \n*.local3.com\n\n[[acme.domains]]\n  main = \n*.local4.com\n\n\n\n\n\nDNS challenge needs environment variables to be executed.\nThese variables have to be set on the machine/container that host Traefik.\n\n\nThese variables are described \nin this section\n.\n\n\nMore information about wildcard certificates are available \nin this section\n.\n\n\nonHostRule option and provided certificates (with HTTP challenge)\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile = \nexamples/traefik.crt\n\n      keyFile = \nexamples/traefik.key\n\n\n[acme]\nemail = \ntest@traefik.io\n\nstorage = \nacme.json\n\nonHostRule = true\ncaServer = \nhttp://172.18.0.1:4000/directory\n\nentryPoint = \nhttps\n\n  [acme.httpChallenge]\n  entryPoint = \nhttp\n\n\n\n\n\nTraefik will only try to generate a Let's encrypt certificate (thanks to \nHTTP-01\n challenge) if the domain cannot be checked by the provided certificates.\n\n\nCluster mode\n\n\nPrerequisites\n\n\nBefore you use Let's Encrypt in a Traefik cluster, take a look to \nthe key-value store explanations\n and more precisely at \nthis section\n, which will describe how to migrate from a acme local storage \n(acme.json file)\n to a key-value store configuration.\n\n\nConfiguration\n\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.https]\n  address = \n:443\n\n    [entryPoints.https.tls]\n\n[acme]\nemail = \ntest@traefik.io\n\nstorage = \ntraefik/acme/account\n\ncaServer = \nhttp://172.18.0.1:4000/directory\n\nentryPoint = \nhttps\n\n\n[acme.httpChallenge]\n    entryPoint = \nhttp\n\n\n[[acme.domains]]\n  main = \nlocal1.com\n\n  sans = [\ntest1.local1.com\n, \ntest2.local1.com\n]\n[[acme.domains]]\n  main = \nlocal2.com\n\n  sans = [\ntest1.local2.com\n, \ntest2x.local2.com\n]\n[[acme.domains]]\n  main = \nlocal3.com\n\n[[acme.domains]]\n  main = \nlocal4.com\n\n\n[consul]\n  endpoint = \n127.0.0.1:8500\n\n  watch = true\n  prefix = \ntraefik\n\n\n\n\n\nThis configuration allows to use the key \ntraefik/acme/account\n to get/set Let's Encrypt certificates content.\nThe \nconsul\n provider contains the configuration.\n\n\n\n\nNote\n\n\nIt's possible to use others key-value store providers as described \nhere\n.\n\n\n\n\nOverride entrypoints in frontends\n\n\n[frontends]\n\n  [frontends.frontend1]\n  backend = \nbackend2\n\n    [frontends.frontend1.routes.test_1]\n    rule = \nHost:test.localhost\n\n\n  [frontends.frontend2]\n  backend = \nbackend1\n\n  passHostHeader = true\n  entrypoints = [\nhttps\n] # overrides defaultEntryPoints\n    [frontends.frontend2.routes.test_1]\n    rule = \nHost:{subdomain:[a-z]+}.localhost\n\n\n  [frontends.frontend3]\n  entrypoints = [\nhttp\n, \nhttps\n] # overrides defaultEntryPoints\n  backend = \nbackend2\n\n  rule = \nPath:/test\n\n\n\n\n\nOverride the Traefik HTTP server idleTimeout and/or throttle configurations from re-loading too quickly\n\n\nprovidersThrottleDuration = \n5s\n\n\n[respondingTimeouts]\nidleTimeout = \n360s\n\n\n\n\n\nUsing labels in docker-compose.yml\n\n\nPay attention to the \nlabels\n section:\n\n\nhome:\n  image: abiosoft/caddy:0.10.14\n  networks:\n    - ntw_front\n  volumes:\n    - ./www/home/srv/:/srv/\n  deploy:\n    mode: replicated\n    replicas: 2\n    #placement:\n    #  constraints: [node.role==manager]\n    restart_policy:\n      condition: on-failure\n      max_attempts: 5\n    resources:\n      limits:\n        cpus: '0.20'\n        memory: 9M\n      reservations:\n        cpus: '0.05'\n        memory: 9M\n    labels:\n      - \ntraefik.frontend.rule=PathPrefixStrip:/\n\n      - \ntraefik.backend=home\n\n      - \ntraefik.port=2015\n\n      - \ntraefik.weight=10\n\n      - \ntraefik.enable=true\n\n      - \ntraefik.passHostHeader=true\n\n      - \ntraefik.docker.network=ntw_front\n\n      - \ntraefik.frontend.entryPoints=http\n\n      - \ntraefik.backend.loadbalancer.swarm=true\n\n      - \ntraefik.backend.loadbalancer.method=drr\n\n\n\n\n\nSomething more tricky using \nregex\n.\n\n\nIn this case a slash is added to \nsiteexample.io/portainer\n and redirect to \nsiteexample.io/portainer/\n. For more details: https://github.com/containous/traefik/issues/563\n\n\nThe double sign \n$$\n are variables managed by the docker compose file (\ndocumentation\n). \n\n\nportainer:\n  image: portainer/portainer:1.16.5\n  networks:\n    - ntw_front\n  volumes:\n    - /var/run/docker.sock:/var/run/docker.sock\n  deploy:\n    mode: replicated\n    replicas: 1\n    placement:\n      constraints: [node.role==manager]\n    restart_policy:\n      condition: on-failure\n      max_attempts: 5\n    resources:\n      limits:\n        cpus: '0.33'\n        memory: 20M\n      reservations:\n        cpus: '0.05'\n        memory: 10M\n    labels:\n      - \ntraefik.frontend.rule=PathPrefixStrip:/portainer\n\n      - \ntraefik.backend=portainer\n\n      - \ntraefik.port=9000\n\n      - \ntraefik.weight=10\n\n      - \ntraefik.enable=true\n\n      - \ntraefik.passHostHeader=true\n\n      - \ntraefik.docker.network=ntw_front\n\n      - \ntraefik.frontend.entryPoints=http\n\n      - \ntraefik.backend.loadbalancer.swarm=true\n\n      - \ntraefik.backend.loadbalancer.method=drr\n\n      # https://github.com/containous/traefik/issues/563#issuecomment-421360934\n      - \ntraefik.frontend.redirect.regex=^(.*)/portainer$$\n\n      - \ntraefik.frontend.redirect.replacement=$$1/portainer/\n\n      - \ntraefik.frontend.rule=PathPrefix:/portainer;ReplacePathRegex: ^/portainer/(.*) /$$1", 
            "title": "Configuration Examples"
        }, 
        {
            "location": "/user-guide/examples/#examples", 
            "text": "You will find here some configuration examples of Traefik.", 
            "title": "Examples"
        }, 
        {
            "location": "/user-guide/examples/#http-only", 
            "text": "defaultEntryPoints = [ http ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80", 
            "title": "HTTP only"
        }, 
        {
            "location": "/user-guide/examples/#http-https-with-sni", 
            "text": "defaultEntryPoints = [ http ,  https ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile =  integration/fixtures/https/snitest.com.cert \n      keyFile =  integration/fixtures/https/snitest.com.key \n      [[entryPoints.https.tls.certificates]]\n      certFile =  integration/fixtures/https/snitest.org.cert \n      keyFile =  integration/fixtures/https/snitest.org.key   Note that we can either give path to certificate file or directly the file content itself ( like in this TOML example ).", 
            "title": "HTTP + HTTPS (with SNI)"
        }, 
        {
            "location": "/user-guide/examples/#http-redirect-on-https", 
            "text": "defaultEntryPoints = [ http ,  https ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n    [entryPoints.http.redirect]\n    entryPoint =  https \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile =  examples/traefik.crt \n      keyFile =  examples/traefik.key    Note  Please note that  regex  and  replacement  do not have to be set in the  redirect  structure if an entrypoint is defined for the redirection (they will not be used in this case)", 
            "title": "HTTP redirect on HTTPS"
        }, 
        {
            "location": "/user-guide/examples/#lets-encrypt-support", 
            "text": "", 
            "title": "Let's Encrypt support"
        }, 
        {
            "location": "/user-guide/examples/#basic-example-with-http-challenge", 
            "text": "[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n\n[acme]\nemail =  test@traefik.io \nstorage =  acme.json \ncaServer =  https://acme-staging-v02.api.letsencrypt.org/directory \nentryPoint =  https \n  [acme.httpChallenge]\n  entryPoint =  http \n\n[[acme.domains]]\n  main =  local1.com \n  sans = [ test1.local1.com ,  test2.local1.com ]\n[[acme.domains]]\n  main =  local2.com \n  sans = [ test1.local2.com ,  test2x.local2.com ]\n[[acme.domains]]\n  main =  local3.com \n[[acme.domains]]\n  main =  local4.com   This configuration allows generating Let's Encrypt certificates (thanks to  HTTP-01  challenge) for the four domains  local[1-4].com  with described SANs.  Traefik generates these certificates when it starts and it needs to be restart if new domains are added.", 
            "title": "Basic example with HTTP challenge"
        }, 
        {
            "location": "/user-guide/examples/#onhostrule-option-with-http-challenge", 
            "text": "[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n\n[acme]\nemail =  test@traefik.io \nstorage =  acme.json \nonHostRule = true\ncaServer =  https://acme-staging-v02.api.letsencrypt.org/directory \nentryPoint =  https \n  [acme.httpChallenge]\n  entryPoint =  http \n\n[[acme.domains]]\n  main =  local1.com \n  sans = [ test1.local1.com ,  test2.local1.com ]\n[[acme.domains]]\n  main =  local2.com \n  sans = [ test1.local2.com ,  test2x.local2.com ]\n[[acme.domains]]\n  main =  local3.com \n[[acme.domains]]\n  main =  local4.com   This configuration allows generating Let's Encrypt certificates (thanks to  HTTP-01  challenge) for the four domains  local[1-4].com .  Traefik generates these certificates when it starts.  If a backend is added with a  onHost  rule, Traefik will automatically generate the Let's Encrypt certificate for the new domain (for frontends wired on the  acme.entryPoint ).", 
            "title": "onHostRule option (with HTTP challenge)"
        }, 
        {
            "location": "/user-guide/examples/#ondemand-option-with-http-challenge", 
            "text": "[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n\n[acme]\nemail =  test@traefik.io \nstorage =  acme.json \nonDemand = true\ncaServer =  https://acme-staging-v02.api.letsencrypt.org/directory \nentryPoint =  https \n  [acme.httpChallenge]\n  entryPoint =  http   This configuration allows generating a Let's Encrypt certificate (thanks to  HTTP-01  challenge) during the first HTTPS request on a new domain.   Note  This option simplifies the configuration but :   TLS handshakes will be slow when requesting a hostname certificate for the first time, which can lead to DDoS attacks.  Let's Encrypt have rate limiting: https://letsencrypt.org/docs/rate-limits   That's why, it's better to use the  onHostRule  option if possible.", 
            "title": "OnDemand option (with HTTP challenge)"
        }, 
        {
            "location": "/user-guide/examples/#dns-challenge", 
            "text": "[entryPoints]\n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n\n[acme]\nemail =  test@traefik.io \nstorage =  acme.json \ncaServer =  https://acme-staging-v02.api.letsencrypt.org/directory \nentryPoint =  https \n  [acme.dnsChallenge]\n  provider =  digitalocean  # DNS Provider name (cloudflare, OVH, gandi...)\n  delayBeforeCheck = 0\n\n[[acme.domains]]\n  main =  local1.com \n  sans = [ test1.local1.com ,  test2.local1.com ]\n[[acme.domains]]\n  main =  local2.com \n  sans = [ test1.local2.com ,  test2x.local2.com ]\n[[acme.domains]]\n  main =  local3.com \n[[acme.domains]]\n  main =  local4.com   DNS challenge needs environment variables to be executed.\nThese variables have to be set on the machine/container that host Traefik.  These variables are described  in this section .", 
            "title": "DNS challenge"
        }, 
        {
            "location": "/user-guide/examples/#dns-challenge-with-wildcard-domains", 
            "text": "[entryPoints]\n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n\n[acme]\nemail =  test@traefik.io \nstorage =  acme.json \ncaServer =  https://acme-staging-v02.api.letsencrypt.org/directory \nentryPoint =  https \n  [acme.dnsChallenge]\n  provider =  digitalocean  # DNS Provider name (cloudflare, OVH, gandi...)\n  delayBeforeCheck = 0\n\n[[acme.domains]]\n  main =  *.local1.com \n[[acme.domains]]\n  main =  local2.com \n  sans = [ test1.local2.com ,  test2x.local2.com ]\n[[acme.domains]]\n  main =  *.local3.com \n[[acme.domains]]\n  main =  *.local4.com   DNS challenge needs environment variables to be executed.\nThese variables have to be set on the machine/container that host Traefik.  These variables are described  in this section .  More information about wildcard certificates are available  in this section .", 
            "title": "DNS challenge with wildcard domains"
        }, 
        {
            "location": "/user-guide/examples/#onhostrule-option-and-provided-certificates-with-http-challenge", 
            "text": "[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile =  examples/traefik.crt \n      keyFile =  examples/traefik.key \n\n[acme]\nemail =  test@traefik.io \nstorage =  acme.json \nonHostRule = true\ncaServer =  http://172.18.0.1:4000/directory \nentryPoint =  https \n  [acme.httpChallenge]\n  entryPoint =  http   Traefik will only try to generate a Let's encrypt certificate (thanks to  HTTP-01  challenge) if the domain cannot be checked by the provided certificates.", 
            "title": "onHostRule option and provided certificates (with HTTP challenge)"
        }, 
        {
            "location": "/user-guide/examples/#cluster-mode", 
            "text": "", 
            "title": "Cluster mode"
        }, 
        {
            "location": "/user-guide/examples/#prerequisites", 
            "text": "Before you use Let's Encrypt in a Traefik cluster, take a look to  the key-value store explanations  and more precisely at  this section , which will describe how to migrate from a acme local storage  (acme.json file)  to a key-value store configuration.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/user-guide/examples/#configuration", 
            "text": "[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.https]\n  address =  :443 \n    [entryPoints.https.tls]\n\n[acme]\nemail =  test@traefik.io \nstorage =  traefik/acme/account \ncaServer =  http://172.18.0.1:4000/directory \nentryPoint =  https \n\n[acme.httpChallenge]\n    entryPoint =  http \n\n[[acme.domains]]\n  main =  local1.com \n  sans = [ test1.local1.com ,  test2.local1.com ]\n[[acme.domains]]\n  main =  local2.com \n  sans = [ test1.local2.com ,  test2x.local2.com ]\n[[acme.domains]]\n  main =  local3.com \n[[acme.domains]]\n  main =  local4.com \n\n[consul]\n  endpoint =  127.0.0.1:8500 \n  watch = true\n  prefix =  traefik   This configuration allows to use the key  traefik/acme/account  to get/set Let's Encrypt certificates content.\nThe  consul  provider contains the configuration.   Note  It's possible to use others key-value store providers as described  here .", 
            "title": "Configuration"
        }, 
        {
            "location": "/user-guide/examples/#override-entrypoints-in-frontends", 
            "text": "[frontends]\n\n  [frontends.frontend1]\n  backend =  backend2 \n    [frontends.frontend1.routes.test_1]\n    rule =  Host:test.localhost \n\n  [frontends.frontend2]\n  backend =  backend1 \n  passHostHeader = true\n  entrypoints = [ https ] # overrides defaultEntryPoints\n    [frontends.frontend2.routes.test_1]\n    rule =  Host:{subdomain:[a-z]+}.localhost \n\n  [frontends.frontend3]\n  entrypoints = [ http ,  https ] # overrides defaultEntryPoints\n  backend =  backend2 \n  rule =  Path:/test", 
            "title": "Override entrypoints in frontends"
        }, 
        {
            "location": "/user-guide/examples/#override-the-traefik-http-server-idletimeout-andor-throttle-configurations-from-re-loading-too-quickly", 
            "text": "providersThrottleDuration =  5s \n\n[respondingTimeouts]\nidleTimeout =  360s", 
            "title": "Override the Traefik HTTP server idleTimeout and/or throttle configurations from re-loading too quickly"
        }, 
        {
            "location": "/user-guide/examples/#using-labels-in-docker-composeyml", 
            "text": "Pay attention to the  labels  section:  home:\n  image: abiosoft/caddy:0.10.14\n  networks:\n    - ntw_front\n  volumes:\n    - ./www/home/srv/:/srv/\n  deploy:\n    mode: replicated\n    replicas: 2\n    #placement:\n    #  constraints: [node.role==manager]\n    restart_policy:\n      condition: on-failure\n      max_attempts: 5\n    resources:\n      limits:\n        cpus: '0.20'\n        memory: 9M\n      reservations:\n        cpus: '0.05'\n        memory: 9M\n    labels:\n      -  traefik.frontend.rule=PathPrefixStrip:/ \n      -  traefik.backend=home \n      -  traefik.port=2015 \n      -  traefik.weight=10 \n      -  traefik.enable=true \n      -  traefik.passHostHeader=true \n      -  traefik.docker.network=ntw_front \n      -  traefik.frontend.entryPoints=http \n      -  traefik.backend.loadbalancer.swarm=true \n      -  traefik.backend.loadbalancer.method=drr   Something more tricky using  regex .  In this case a slash is added to  siteexample.io/portainer  and redirect to  siteexample.io/portainer/ . For more details: https://github.com/containous/traefik/issues/563  The double sign  $$  are variables managed by the docker compose file ( documentation ).   portainer:\n  image: portainer/portainer:1.16.5\n  networks:\n    - ntw_front\n  volumes:\n    - /var/run/docker.sock:/var/run/docker.sock\n  deploy:\n    mode: replicated\n    replicas: 1\n    placement:\n      constraints: [node.role==manager]\n    restart_policy:\n      condition: on-failure\n      max_attempts: 5\n    resources:\n      limits:\n        cpus: '0.33'\n        memory: 20M\n      reservations:\n        cpus: '0.05'\n        memory: 10M\n    labels:\n      -  traefik.frontend.rule=PathPrefixStrip:/portainer \n      -  traefik.backend=portainer \n      -  traefik.port=9000 \n      -  traefik.weight=10 \n      -  traefik.enable=true \n      -  traefik.passHostHeader=true \n      -  traefik.docker.network=ntw_front \n      -  traefik.frontend.entryPoints=http \n      -  traefik.backend.loadbalancer.swarm=true \n      -  traefik.backend.loadbalancer.method=drr \n      # https://github.com/containous/traefik/issues/563#issuecomment-421360934\n      -  traefik.frontend.redirect.regex=^(.*)/portainer$$ \n      -  traefik.frontend.redirect.replacement=$$1/portainer/ \n      -  traefik.frontend.rule=PathPrefix:/portainer;ReplacePathRegex: ^/portainer/(.*) /$$1", 
            "title": "Using labels in docker-compose.yml"
        }, 
        {
            "location": "/user-guide/swarm-mode/", 
            "text": "Docker Swarm (mode) cluster\n\n\nThis section explains how to create a multi-host docker cluster with swarm mode using \ndocker-machine\n and how to deploy Traefik on it.\n\n\nThe cluster consists of:\n\n\n\n\n3 servers\n\n\n1 manager\n\n\n2 workers\n\n\n1 \noverlay\n network (multi-host networking)\n\n\n\n\nPrerequisites\n\n\n\n\nYou will need to install \ndocker-machine\n\n\nYou will need the latest \nVirtualBox\n\n\n\n\nCluster provisioning\n\n\nFirst, let's create all the required nodes.\nIt's a shorter version of the \nswarm tutorial\n.\n\n\ndocker-machine create -d virtualbox manager\ndocker-machine create -d virtualbox worker1\ndocker-machine create -d virtualbox worker2\n\n\n\n\nThen, let's setup the cluster, in order:\n\n\n\n\ninitialize the cluster\n\n\nget the token for other host to join\n\n\non both workers, join the cluster with the token\n\n\n\n\ndocker-machine ssh manager \ndocker swarm init \\\n    --listen-addr $(docker-machine ip manager) \\\n    --advertise-addr $(docker-machine ip manager)\n\n\nexport worker_token=$(docker-machine ssh manager \ndocker swarm \\\njoin-token worker -q\n)\n\ndocker-machine ssh worker1 \ndocker swarm join \\\n    --token=${worker_token} \\\n    --listen-addr $(docker-machine ip worker1) \\\n    --advertise-addr $(docker-machine ip worker1) \\\n    $(docker-machine ip manager)\n\n\ndocker-machine ssh worker2 \ndocker swarm join \\\n    --token=${worker_token} \\\n    --listen-addr $(docker-machine ip worker2) \\\n    --advertise-addr $(docker-machine ip worker2) \\\n    $(docker-machine ip manager)\n\n\n\n\n\nLet's validate the cluster is up and running.\n\n\ndocker-machine ssh manager docker node ls\n\n\n\n\nID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS\n013v16l1sbuwjqcn7ucbu4jwt    worker1   Ready   Active\n8buzkquycd17jqjber0mo2gn8    worker2   Ready   Active\nfnpj8ozfc85zvahx2r540xfcf *  manager   Ready   Active        Leader\n\n\n\n\nFinally, let's create a network for Traefik to use.\n\n\ndocker-machine ssh manager \ndocker network create --driver=overlay traefik-net\n\n\n\n\n\nDeploy Traefik\n\n\nLet's deploy Traefik as a docker service in our cluster.\nThe only requirement for Traefik to work with swarm mode is that it needs to run on a manager node - we are going to use a \nconstraint\n for that.\n\n\ndocker-machine ssh manager \ndocker service create \\\n    --name traefik \\\n    --constraint=node.role==manager \\\n    --publish 80:80 --publish 8080:8080 \\\n    --mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock \\\n    --network traefik-net \\\n    traefik:\nstable version from https://hub.docker.com/_/traefik\n \\\n    --docker \\\n    --docker.swarmMode \\\n    --docker.domain=traefik \\\n    --docker.watch \\\n    --api\n\n\n\n\n\nLet's explain this command:\n\n\n\n\n\n\n\n\nOption\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n--publish 80:80 --publish 8080:8080\n\n\nwe publish port \n80\n and \n8080\n on the cluster.\n\n\n\n\n\n\n--constraint=node.role==manager\n\n\nwe ask docker to schedule Traefik on a manager node.\n\n\n\n\n\n\n--mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock\n\n\nwe bind mount the docker socket where Traefik is scheduled to be able to speak to the daemon.\n\n\n\n\n\n\n--network traefik-net\n\n\nwe attach the Traefik service (and thus the underlying container) to the \ntraefik-net\n network.\n\n\n\n\n\n\n--docker\n\n\nenable docker provider, and \n--docker.swarmMode\n to enable the swarm mode on Traefik.\n\n\n\n\n\n\n--api\n\n\nactivate the webUI on port 8080\n\n\n\n\n\n\n\n\nDeploy your apps\n\n\nWe can now deploy our app on the cluster, here \nwhoami\n, a simple web server in Go.\nWe start 2 services, on the \ntraefik-net\n network.\n\n\ndocker-machine ssh manager \ndocker service create \\\n    --name whoami0 \\\n    --label traefik.port=80 \\\n    --network traefik-net \\\n    containous/whoami\n\n\ndocker-machine ssh manager \ndocker service create \\\n    --name whoami1 \\\n    --label traefik.port=80 \\\n    --network traefik-net \\\n    --label traefik.backend.loadbalancer.sticky=true \\\n    containous/whoami\n\n\n\n\n\n\n\nNote\n\n\nWe set \nwhoami1\n to use sticky sessions (\n--label traefik.backend.loadbalancer.stickiness=true\n).\nWe'll demonstrate that later.\n\n\n\n\n\n\nNote\n\n\nIf using \ndocker stack deploy\n, there is \na specific way that the labels must be defined in the docker-compose file\n.\n\n\n\n\nCheck that everything is scheduled and started:\n\n\ndocker-machine ssh manager \ndocker service ls\n\n\n\n\n\nID            NAME     MODE        REPLICAS  IMAGE                     PORTS\nmoq3dq4xqv6t  traefik  replicated  1/1       traefik:latest            *:80-\n80/tcp,*:8080-\n8080/tcp\nysil6oto1wim  whoami0  replicated  1/1       containous/whoami:latest\nz9re2mnl34k4  whoami1  replicated  1/1       containous/whoami:latest\n\n\n\n\nAccess to your apps through Traefik\n\n\ncurl -H Host:whoami0.traefik http://$(docker-machine ip manager)\n\n\n\n\nHostname: 5b0b3d148359\nIP: 127.0.0.1\nIP: 10.0.0.8\nIP: 10.0.0.4\nIP: 172.18.0.5\nGET / HTTP/1.1\nHost: whoami0.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.2\nX-Forwarded-Host: whoami0.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4\n\n\n\n\ncurl -H Host:whoami1.traefik http://$(docker-machine ip manager)\n\n\n\n\nHostname: 3633163970f6\nIP: 127.0.0.1\nIP: 10.0.0.14\nIP: 10.0.0.6\nIP: 172.18.0.5\nGET / HTTP/1.1\nHost: whoami1.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.2\nX-Forwarded-Host: whoami1.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4\n\n\n\n\n\n\nNote\n\n\nAs Traefik is published, you can access it from any machine and not only the manager.\n\n\n\n\ncurl -H Host:whoami0.traefik http://$(docker-machine ip worker1)\n\n\n\n\nHostname: 5b0b3d148359\nIP: 127.0.0.1\nIP: 10.0.0.8\nIP: 10.0.0.4\nIP: 172.18.0.5\nGET / HTTP/1.1\nHost: whoami0.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.3\nX-Forwarded-Host: whoami0.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4\n\n\n\n\ncurl -H Host:whoami1.traefik http://$(docker-machine ip worker2)\n\n\n\n\nHostname: 3633163970f6\nIP: 127.0.0.1\nIP: 10.0.0.14\nIP: 10.0.0.6\nIP: 172.18.0.5\nGET / HTTP/1.1\nHost: whoami1.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.4\nX-Forwarded-Host: whoami1.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4\n\n\n\n\nScale both services\n\n\ndocker-machine ssh manager \ndocker service scale whoami0=5\n\ndocker-machine ssh manager \ndocker service scale whoami1=5\n\n\n\n\n\nCheck that we now have 5 replicas of each \nwhoami\n service:\n\n\ndocker-machine ssh manager \ndocker service ls\n\n\n\n\n\nID            NAME     MODE        REPLICAS  IMAGE                     PORTS\nmoq3dq4xqv6t  traefik  replicated  1/1       traefik:latest            *:80-\n80/tcp,*:8080-\n8080/tcp\nysil6oto1wim  whoami0  replicated  5/5       containous/whoami:latest\nz9re2mnl34k4  whoami1  replicated  5/5       containous/whoami:latest\n\n\n\n\nAccess to your \nwhoami0\n through Traefik multiple times.\n\n\nRepeat the following command multiple times and note that the Hostname changes each time as Traefik load balances each request against the 5 tasks:\n\n\ncurl -H Host:whoami0.traefik http://$(docker-machine ip manager)\n\n\n\n\nHostname: f3138d15b567\nIP: 127.0.0.1\nIP: 10.0.0.5\nIP: 10.0.0.4\nIP: 172.18.0.3\nGET / HTTP/1.1\nHost: whoami0.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.2\nX-Forwarded-Host: whoami0.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4\n\n\n\n\nDo the same against \nwhoami1\n:\n\n\ncurl -c cookies.txt -H Host:whoami1.traefik http://$(docker-machine ip manager)\n\n\n\n\nHostname: 348e2f7bf432\nIP: 127.0.0.1\nIP: 10.0.0.15\nIP: 10.0.0.6\nIP: 172.18.0.6\nGET / HTTP/1.1\nHost: whoami1.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.2\nX-Forwarded-Host: whoami1.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4\n\n\n\n\nBecause the sticky sessions require cookies to work, we used the \n-c cookies.txt\n option to store the cookie into a file.\nThe cookie contains the IP of the container to which the session sticks:\n\n\ncat ./cookies.txt\n\n\n\n\n# Netscape HTTP Cookie File\n# https://curl.haxx.se/docs/http-cookies.html\n# This file was generated by libcurl! Edit at your own risk.\n\nwhoami1.traefik FALSE  /  FALSE  0  _TRAEFIK_BACKEND  http://10.0.0.15:80\n\n\n\n\nIf you load the cookies file (\n-b cookies.txt\n) for the next request, you will see that stickiness is maintained:\n\n\ncurl -b cookies.txt -H Host:whoami1.traefik http://$(docker-machine ip manager)\n\n\n\n\nHostname: 348e2f7bf432\nIP: 127.0.0.1\nIP: 10.0.0.15\nIP: 10.0.0.6\nIP: 172.18.0.6\nGET / HTTP/1.1\nHost: whoami1.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nCookie: _TRAEFIK_BACKEND=http://10.0.0.15:80\nX-Forwarded-For: 10.255.0.2\nX-Forwarded-Host: whoami1.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4", 
            "title": "Swarm Mode Cluster"
        }, 
        {
            "location": "/user-guide/swarm-mode/#docker-swarm-mode-cluster", 
            "text": "This section explains how to create a multi-host docker cluster with swarm mode using  docker-machine  and how to deploy Traefik on it.  The cluster consists of:   3 servers  1 manager  2 workers  1  overlay  network (multi-host networking)", 
            "title": "Docker Swarm (mode) cluster"
        }, 
        {
            "location": "/user-guide/swarm-mode/#prerequisites", 
            "text": "You will need to install  docker-machine  You will need the latest  VirtualBox", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/user-guide/swarm-mode/#cluster-provisioning", 
            "text": "First, let's create all the required nodes.\nIt's a shorter version of the  swarm tutorial .  docker-machine create -d virtualbox manager\ndocker-machine create -d virtualbox worker1\ndocker-machine create -d virtualbox worker2  Then, let's setup the cluster, in order:   initialize the cluster  get the token for other host to join  on both workers, join the cluster with the token   docker-machine ssh manager  docker swarm init \\\n    --listen-addr $(docker-machine ip manager) \\\n    --advertise-addr $(docker-machine ip manager) \n\nexport worker_token=$(docker-machine ssh manager  docker swarm \\\njoin-token worker -q )\n\ndocker-machine ssh worker1  docker swarm join \\\n    --token=${worker_token} \\\n    --listen-addr $(docker-machine ip worker1) \\\n    --advertise-addr $(docker-machine ip worker1) \\\n    $(docker-machine ip manager) \n\ndocker-machine ssh worker2  docker swarm join \\\n    --token=${worker_token} \\\n    --listen-addr $(docker-machine ip worker2) \\\n    --advertise-addr $(docker-machine ip worker2) \\\n    $(docker-machine ip manager)   Let's validate the cluster is up and running.  docker-machine ssh manager docker node ls  ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS\n013v16l1sbuwjqcn7ucbu4jwt    worker1   Ready   Active\n8buzkquycd17jqjber0mo2gn8    worker2   Ready   Active\nfnpj8ozfc85zvahx2r540xfcf *  manager   Ready   Active        Leader  Finally, let's create a network for Traefik to use.  docker-machine ssh manager  docker network create --driver=overlay traefik-net", 
            "title": "Cluster provisioning"
        }, 
        {
            "location": "/user-guide/swarm-mode/#deploy-traefik", 
            "text": "Let's deploy Traefik as a docker service in our cluster.\nThe only requirement for Traefik to work with swarm mode is that it needs to run on a manager node - we are going to use a  constraint  for that.  docker-machine ssh manager  docker service create \\\n    --name traefik \\\n    --constraint=node.role==manager \\\n    --publish 80:80 --publish 8080:8080 \\\n    --mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock \\\n    --network traefik-net \\\n    traefik: stable version from https://hub.docker.com/_/traefik  \\\n    --docker \\\n    --docker.swarmMode \\\n    --docker.domain=traefik \\\n    --docker.watch \\\n    --api   Let's explain this command:     Option  Description      --publish 80:80 --publish 8080:8080  we publish port  80  and  8080  on the cluster.    --constraint=node.role==manager  we ask docker to schedule Traefik on a manager node.    --mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock  we bind mount the docker socket where Traefik is scheduled to be able to speak to the daemon.    --network traefik-net  we attach the Traefik service (and thus the underlying container) to the  traefik-net  network.    --docker  enable docker provider, and  --docker.swarmMode  to enable the swarm mode on Traefik.    --api  activate the webUI on port 8080", 
            "title": "Deploy Traefik"
        }, 
        {
            "location": "/user-guide/swarm-mode/#deploy-your-apps", 
            "text": "We can now deploy our app on the cluster, here  whoami , a simple web server in Go.\nWe start 2 services, on the  traefik-net  network.  docker-machine ssh manager  docker service create \\\n    --name whoami0 \\\n    --label traefik.port=80 \\\n    --network traefik-net \\\n    containous/whoami \n\ndocker-machine ssh manager  docker service create \\\n    --name whoami1 \\\n    --label traefik.port=80 \\\n    --network traefik-net \\\n    --label traefik.backend.loadbalancer.sticky=true \\\n    containous/whoami    Note  We set  whoami1  to use sticky sessions ( --label traefik.backend.loadbalancer.stickiness=true ).\nWe'll demonstrate that later.    Note  If using  docker stack deploy , there is  a specific way that the labels must be defined in the docker-compose file .   Check that everything is scheduled and started:  docker-machine ssh manager  docker service ls   ID            NAME     MODE        REPLICAS  IMAGE                     PORTS\nmoq3dq4xqv6t  traefik  replicated  1/1       traefik:latest            *:80- 80/tcp,*:8080- 8080/tcp\nysil6oto1wim  whoami0  replicated  1/1       containous/whoami:latest\nz9re2mnl34k4  whoami1  replicated  1/1       containous/whoami:latest", 
            "title": "Deploy your apps"
        }, 
        {
            "location": "/user-guide/swarm-mode/#access-to-your-apps-through-traefik", 
            "text": "curl -H Host:whoami0.traefik http://$(docker-machine ip manager)  Hostname: 5b0b3d148359\nIP: 127.0.0.1\nIP: 10.0.0.8\nIP: 10.0.0.4\nIP: 172.18.0.5\nGET / HTTP/1.1\nHost: whoami0.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.2\nX-Forwarded-Host: whoami0.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4  curl -H Host:whoami1.traefik http://$(docker-machine ip manager)  Hostname: 3633163970f6\nIP: 127.0.0.1\nIP: 10.0.0.14\nIP: 10.0.0.6\nIP: 172.18.0.5\nGET / HTTP/1.1\nHost: whoami1.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.2\nX-Forwarded-Host: whoami1.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4   Note  As Traefik is published, you can access it from any machine and not only the manager.   curl -H Host:whoami0.traefik http://$(docker-machine ip worker1)  Hostname: 5b0b3d148359\nIP: 127.0.0.1\nIP: 10.0.0.8\nIP: 10.0.0.4\nIP: 172.18.0.5\nGET / HTTP/1.1\nHost: whoami0.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.3\nX-Forwarded-Host: whoami0.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4  curl -H Host:whoami1.traefik http://$(docker-machine ip worker2)  Hostname: 3633163970f6\nIP: 127.0.0.1\nIP: 10.0.0.14\nIP: 10.0.0.6\nIP: 172.18.0.5\nGET / HTTP/1.1\nHost: whoami1.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.4\nX-Forwarded-Host: whoami1.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4", 
            "title": "Access to your apps through Traefik"
        }, 
        {
            "location": "/user-guide/swarm-mode/#scale-both-services", 
            "text": "docker-machine ssh manager  docker service scale whoami0=5 \ndocker-machine ssh manager  docker service scale whoami1=5   Check that we now have 5 replicas of each  whoami  service:  docker-machine ssh manager  docker service ls   ID            NAME     MODE        REPLICAS  IMAGE                     PORTS\nmoq3dq4xqv6t  traefik  replicated  1/1       traefik:latest            *:80- 80/tcp,*:8080- 8080/tcp\nysil6oto1wim  whoami0  replicated  5/5       containous/whoami:latest\nz9re2mnl34k4  whoami1  replicated  5/5       containous/whoami:latest", 
            "title": "Scale both services"
        }, 
        {
            "location": "/user-guide/swarm-mode/#access-to-your-whoami0-through-traefik-multiple-times", 
            "text": "Repeat the following command multiple times and note that the Hostname changes each time as Traefik load balances each request against the 5 tasks:  curl -H Host:whoami0.traefik http://$(docker-machine ip manager)  Hostname: f3138d15b567\nIP: 127.0.0.1\nIP: 10.0.0.5\nIP: 10.0.0.4\nIP: 172.18.0.3\nGET / HTTP/1.1\nHost: whoami0.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.2\nX-Forwarded-Host: whoami0.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4  Do the same against  whoami1 :  curl -c cookies.txt -H Host:whoami1.traefik http://$(docker-machine ip manager)  Hostname: 348e2f7bf432\nIP: 127.0.0.1\nIP: 10.0.0.15\nIP: 10.0.0.6\nIP: 172.18.0.6\nGET / HTTP/1.1\nHost: whoami1.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 10.255.0.2\nX-Forwarded-Host: whoami1.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4  Because the sticky sessions require cookies to work, we used the  -c cookies.txt  option to store the cookie into a file.\nThe cookie contains the IP of the container to which the session sticks:  cat ./cookies.txt  # Netscape HTTP Cookie File\n# https://curl.haxx.se/docs/http-cookies.html\n# This file was generated by libcurl! Edit at your own risk.\n\nwhoami1.traefik FALSE  /  FALSE  0  _TRAEFIK_BACKEND  http://10.0.0.15:80  If you load the cookies file ( -b cookies.txt ) for the next request, you will see that stickiness is maintained:  curl -b cookies.txt -H Host:whoami1.traefik http://$(docker-machine ip manager)  Hostname: 348e2f7bf432\nIP: 127.0.0.1\nIP: 10.0.0.15\nIP: 10.0.0.6\nIP: 172.18.0.6\nGET / HTTP/1.1\nHost: whoami1.traefik\nUser-Agent: curl/7.55.1\nAccept: */*\nAccept-Encoding: gzip\nCookie: _TRAEFIK_BACKEND=http://10.0.0.15:80\nX-Forwarded-For: 10.255.0.2\nX-Forwarded-Host: whoami1.traefik\nX-Forwarded-Proto: http\nX-Forwarded-Server: 77fc29c69fe4", 
            "title": "Access to your whoami0 through Traefik multiple times."
        }, 
        {
            "location": "/user-guide/swarm/", 
            "text": "Swarm cluster\n\n\nThis section explains how to create a multi-host \nswarm\n cluster using \ndocker-machine\n and how to deploy Traefik on it.\n\n\nThe cluster consists of:\n\n\n\n\n2 servers\n\n\n1 swarm master\n\n\n2 swarm nodes\n\n\n1 \noverlay\n network (multi-host networking)\n\n\n\n\nPrerequisites\n\n\n\n\nYou need to install \ndocker-machine\n\n\nYou need the latest \nVirtualBox\n\n\n\n\nCluster provisioning\n\n\nWe first follow \nthis guide\n to create the cluster.\n\n\nCreate machine \nmh-keystore\n\n\nThis machine is the service registry of our cluster.\n\n\ndocker-machine create -d virtualbox mh-keystore\n\n\n\n\nThen we install the service registry \nConsul\n on this machine:\n\n\neval \n$(docker-machine env mh-keystore)\n\ndocker run -d \\\n    -p \n8500:8500\n \\\n    -h \nconsul\n \\\n    progrium/consul -server -bootstrap\n\n\n\n\nCreate machine \nmhs-demo0\n\n\nThis machine is a swarm master and a swarm agent on it.\n\n\ndocker-machine create -d virtualbox \\\n    --swarm --swarm-master \\\n    --swarm-discovery=\nconsul://$(docker-machine ip mh-keystore):8500\n \\\n    --engine-opt=\ncluster-store=consul://$(docker-machine ip mh-keystore):8500\n \\\n    --engine-opt=\ncluster-advertise=eth1:2376\n \\\n    mhs-demo0\n\n\n\n\nCreate machine \nmhs-demo1\n\n\nThis machine have a swarm agent on it.\n\n\ndocker-machine create -d virtualbox \\\n    --swarm \\\n    --swarm-discovery=\nconsul://$(docker-machine ip mh-keystore):8500\n \\\n    --engine-opt=\ncluster-store=consul://$(docker-machine ip mh-keystore):8500\n \\\n    --engine-opt=\ncluster-advertise=eth1:2376\n \\\n    mhs-demo1\n\n\n\n\nCreate the overlay Network\n\n\nCreate the overlay network on the swarm master:\n\n\neval $(docker-machine env --swarm mhs-demo0)\ndocker network create --driver overlay --subnet=10.0.9.0/24 my-net\n\n\n\n\nDeploy Traefik\n\n\nDeploy Traefik:\n\n\ndocker $(docker-machine config mhs-demo0) run \\\n    -d \\\n    -p 80:80 -p 8080:8080 \\\n    --net=my-net \\\n    -v /var/lib/boot2docker/:/ssl \\\n    traefik:\nstable version from https://hub.docker.com/_/traefik\n \\\n    -l DEBUG \\\n    -c /dev/null \\\n    --docker \\\n    --docker.domain=traefik \\\n    --docker.endpoint=tcp://$(docker-machine ip mhs-demo0):2376 \\\n    --docker.tls \\\n    --docker.tls.ca=/ssl/ca.pem \\\n    --docker.tls.cert=/ssl/server.pem \\\n    --docker.tls.key=/ssl/server-key.pem \\\n    --docker.tls.insecureSkipVerify \\\n    --docker.watch \\\n    --api\n\n\n\n\nLet's explain this command:\n\n\n\n\n\n\n\n\nOption\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-p 80:80 -p 8080:8080\n\n\nwe bind ports 80 and 8080\n\n\n\n\n\n\n--net=my-net\n\n\nrun the container on the network my-net\n\n\n\n\n\n\n-v /var/lib/boot2docker/:/ssl\n\n\nmount the ssl keys generated by docker-machine\n\n\n\n\n\n\n-c /dev/null\n\n\nempty config file\n\n\n\n\n\n\n--docker\n\n\nenable docker provider\n\n\n\n\n\n\n--docker.endpoint=tcp://172.18.0.1:2376\n\n\nconnect to the swarm master using the docker_gwbridge network\n\n\n\n\n\n\n--docker.tls\n\n\nenable TLS using the docker-machine keys\n\n\n\n\n\n\n--api\n\n\nactivate the webUI on port 8080\n\n\n\n\n\n\n\n\nDeploy your apps\n\n\nWe can now deploy our app on the cluster, here \nwhoami\n, a simple web server in GO, on the network \nmy-net\n:\n\n\neval $(docker-machine env --swarm mhs-demo0)\ndocker run -d --name=whoami0 --net=my-net --env=\nconstraint:node==mhs-demo0\n containous/whoami\ndocker run -d --name=whoami1 --net=my-net --env=\nconstraint:node==mhs-demo1\n containous/whoami\n\n\n\n\nCheck that everything is started:\n\n\ndocker ps\n\n\n\n\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                      NAMES\nba2c21488299        containous/whoami   \n/whoamI\n                8 seconds ago       Up 9 seconds        80/tcp                                                     mhs-demo1/whoami1\n8147a7746e7a        containous/whoami   \n/whoamI\n                19 seconds ago      Up 20 seconds       80/tcp                                                     mhs-demo0/whoami0\n8fbc39271b4c        traefik             \n/traefik -l DEBUG -c\n   36 seconds ago      Up 37 seconds       192.168.99.101:80-\n80/tcp, 192.168.99.101:8080-\n8080/tcp   mhs-demo0/serene_bhabha\n\n\n\n\nAccess to your apps through Traefik\n\n\ncurl -H Host:whoami0.traefik http://$(docker-machine ip mhs-demo0)\n\n\n\n\nHostname: 8147a7746e7a\nIP: 127.0.0.1\nIP: ::1\nIP: 10.0.9.3\nIP: fe80::42:aff:fe00:903\nIP: 172.18.0.3\nIP: fe80::42:acff:fe12:3\nGET / HTTP/1.1\nHost: 10.0.9.3:80\nUser-Agent: curl/7.35.0\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 192.168.99.1\nX-Forwarded-Host: 10.0.9.3:80\nX-Forwarded-Proto: http\nX-Forwarded-Server: 8fbc39271b4c\n\n\n\n\ncurl -H Host:whoami1.traefik http://$(docker-machine ip mhs-demo0)\n\n\n\n\nHostname: ba2c21488299\nIP: 127.0.0.1\nIP: ::1\nIP: 10.0.9.4\nIP: fe80::42:aff:fe00:904\nIP: 172.18.0.2\nIP: fe80::42:acff:fe12:2\nGET / HTTP/1.1\nHost: 10.0.9.4:80\nUser-Agent: curl/7.35.0\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 192.168.99.1\nX-Forwarded-Host: 10.0.9.4:80\nX-Forwarded-Proto: http\nX-Forwarded-Server: 8fbc39271b4c", 
            "title": "Swarm Cluster"
        }, 
        {
            "location": "/user-guide/swarm/#swarm-cluster", 
            "text": "This section explains how to create a multi-host  swarm  cluster using  docker-machine  and how to deploy Traefik on it.  The cluster consists of:   2 servers  1 swarm master  2 swarm nodes  1  overlay  network (multi-host networking)", 
            "title": "Swarm cluster"
        }, 
        {
            "location": "/user-guide/swarm/#prerequisites", 
            "text": "You need to install  docker-machine  You need the latest  VirtualBox", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/user-guide/swarm/#cluster-provisioning", 
            "text": "We first follow  this guide  to create the cluster.", 
            "title": "Cluster provisioning"
        }, 
        {
            "location": "/user-guide/swarm/#create-machine-mh-keystore", 
            "text": "This machine is the service registry of our cluster.  docker-machine create -d virtualbox mh-keystore  Then we install the service registry  Consul  on this machine:  eval  $(docker-machine env mh-keystore) \ndocker run -d \\\n    -p  8500:8500  \\\n    -h  consul  \\\n    progrium/consul -server -bootstrap", 
            "title": "Create machine mh-keystore"
        }, 
        {
            "location": "/user-guide/swarm/#create-machine-mhs-demo0", 
            "text": "This machine is a swarm master and a swarm agent on it.  docker-machine create -d virtualbox \\\n    --swarm --swarm-master \\\n    --swarm-discovery= consul://$(docker-machine ip mh-keystore):8500  \\\n    --engine-opt= cluster-store=consul://$(docker-machine ip mh-keystore):8500  \\\n    --engine-opt= cluster-advertise=eth1:2376  \\\n    mhs-demo0", 
            "title": "Create machine mhs-demo0"
        }, 
        {
            "location": "/user-guide/swarm/#create-machine-mhs-demo1", 
            "text": "This machine have a swarm agent on it.  docker-machine create -d virtualbox \\\n    --swarm \\\n    --swarm-discovery= consul://$(docker-machine ip mh-keystore):8500  \\\n    --engine-opt= cluster-store=consul://$(docker-machine ip mh-keystore):8500  \\\n    --engine-opt= cluster-advertise=eth1:2376  \\\n    mhs-demo1", 
            "title": "Create machine mhs-demo1"
        }, 
        {
            "location": "/user-guide/swarm/#create-the-overlay-network", 
            "text": "Create the overlay network on the swarm master:  eval $(docker-machine env --swarm mhs-demo0)\ndocker network create --driver overlay --subnet=10.0.9.0/24 my-net", 
            "title": "Create the overlay Network"
        }, 
        {
            "location": "/user-guide/swarm/#deploy-traefik", 
            "text": "Deploy Traefik:  docker $(docker-machine config mhs-demo0) run \\\n    -d \\\n    -p 80:80 -p 8080:8080 \\\n    --net=my-net \\\n    -v /var/lib/boot2docker/:/ssl \\\n    traefik: stable version from https://hub.docker.com/_/traefik  \\\n    -l DEBUG \\\n    -c /dev/null \\\n    --docker \\\n    --docker.domain=traefik \\\n    --docker.endpoint=tcp://$(docker-machine ip mhs-demo0):2376 \\\n    --docker.tls \\\n    --docker.tls.ca=/ssl/ca.pem \\\n    --docker.tls.cert=/ssl/server.pem \\\n    --docker.tls.key=/ssl/server-key.pem \\\n    --docker.tls.insecureSkipVerify \\\n    --docker.watch \\\n    --api  Let's explain this command:     Option  Description      -p 80:80 -p 8080:8080  we bind ports 80 and 8080    --net=my-net  run the container on the network my-net    -v /var/lib/boot2docker/:/ssl  mount the ssl keys generated by docker-machine    -c /dev/null  empty config file    --docker  enable docker provider    --docker.endpoint=tcp://172.18.0.1:2376  connect to the swarm master using the docker_gwbridge network    --docker.tls  enable TLS using the docker-machine keys    --api  activate the webUI on port 8080", 
            "title": "Deploy Traefik"
        }, 
        {
            "location": "/user-guide/swarm/#deploy-your-apps", 
            "text": "We can now deploy our app on the cluster, here  whoami , a simple web server in GO, on the network  my-net :  eval $(docker-machine env --swarm mhs-demo0)\ndocker run -d --name=whoami0 --net=my-net --env= constraint:node==mhs-demo0  containous/whoami\ndocker run -d --name=whoami1 --net=my-net --env= constraint:node==mhs-demo1  containous/whoami  Check that everything is started:  docker ps  CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                      NAMES\nba2c21488299        containous/whoami    /whoamI                 8 seconds ago       Up 9 seconds        80/tcp                                                     mhs-demo1/whoami1\n8147a7746e7a        containous/whoami    /whoamI                 19 seconds ago      Up 20 seconds       80/tcp                                                     mhs-demo0/whoami0\n8fbc39271b4c        traefik              /traefik -l DEBUG -c    36 seconds ago      Up 37 seconds       192.168.99.101:80- 80/tcp, 192.168.99.101:8080- 8080/tcp   mhs-demo0/serene_bhabha", 
            "title": "Deploy your apps"
        }, 
        {
            "location": "/user-guide/swarm/#access-to-your-apps-through-traefik", 
            "text": "curl -H Host:whoami0.traefik http://$(docker-machine ip mhs-demo0)  Hostname: 8147a7746e7a\nIP: 127.0.0.1\nIP: ::1\nIP: 10.0.9.3\nIP: fe80::42:aff:fe00:903\nIP: 172.18.0.3\nIP: fe80::42:acff:fe12:3\nGET / HTTP/1.1\nHost: 10.0.9.3:80\nUser-Agent: curl/7.35.0\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 192.168.99.1\nX-Forwarded-Host: 10.0.9.3:80\nX-Forwarded-Proto: http\nX-Forwarded-Server: 8fbc39271b4c  curl -H Host:whoami1.traefik http://$(docker-machine ip mhs-demo0)  Hostname: ba2c21488299\nIP: 127.0.0.1\nIP: ::1\nIP: 10.0.9.4\nIP: fe80::42:aff:fe00:904\nIP: 172.18.0.2\nIP: fe80::42:acff:fe12:2\nGET / HTTP/1.1\nHost: 10.0.9.4:80\nUser-Agent: curl/7.35.0\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 192.168.99.1\nX-Forwarded-Host: 10.0.9.4:80\nX-Forwarded-Proto: http\nX-Forwarded-Server: 8fbc39271b4c", 
            "title": "Access to your apps through Traefik"
        }, 
        {
            "location": "/user-guide/docker-and-lets-encrypt/", 
            "text": "Let's Encrypt \n Docker\n\n\nIn this use case, we want to use Traefik as a \nlayer-7\n load balancer with SSL termination for a set of micro-services used to run a web application.\n\n\nWe also want to automatically \ndiscover any services\n on the Docker host and let Traefik reconfigure itself automatically when containers get created (or shut down) so HTTP traffic can be routed accordingly.\n\n\nIn addition, we want to use Let's Encrypt to automatically generate and renew SSL certificates per hostname.\n\n\nSetting Up\n\n\nIn order for this to work, you'll need a server with a public IP address, with Docker and docker-compose installed on it.\n\n\nIn this example, we're using the fictitious domain \nmy-awesome-app.org\n.\n\n\nIn real-life, you'll want to use your own domain and have the DNS configured accordingly so the hostname records you'll want to use point to the aforementioned public IP address.\n\n\nNetworking\n\n\nDocker containers can only communicate with each other over TCP when they share at least one network.\nThis makes sense from a topological point of view in the context of networking, since Docker under the hood creates IPTable rules so containers can't reach other containers \nunless you'd want to\n.\n\n\nIn this example, we're going to use a single network called \nweb\n where all containers that are handling HTTP traffic (including Traefik) will reside in.\n\n\nOn the Docker host, run the following command:\n\n\ndocker network create web\n\n\n\n\nNow, let's create a directory on the server where we will configure the rest of Traefik:\n\n\nmkdir -p /opt/traefik\n\n\n\n\nWithin this directory, we're going to create 3 empty files:\n\n\ntouch /opt/traefik/docker-compose.yml\ntouch /opt/traefik/acme.json \n chmod 600 /opt/traefik/acme.json\ntouch /opt/traefik/traefik.toml\n\n\n\n\nThe \ndocker-compose.yml\n file will provide us with a simple, consistent and more importantly, a deterministic way to create Traefik.\n\n\nThe contents of the file is as follows:\n\n\nversion: '2'\n\nservices:\n  traefik:\n    image: traefik:\nstable v1.7 from https://hub.docker.com/_/traefik\n\n    restart: always\n    ports:\n      - 80:80\n      - 443:443\n    networks:\n      - web\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /opt/traefik/traefik.toml:/traefik.toml\n      - /opt/traefik/acme.json:/acme.json\n    container_name: traefik\n\nnetworks:\n  web:\n    external: true\n\n\n\n\nAs you can see, we're mounting the \ntraefik.toml\n file as well as the (empty) \nacme.json\n file in the container.\n\nAlso, we're mounting the \n/var/run/docker.sock\n Docker socket in the container as well, so Traefik can listen to Docker events and reconfigure its own internal configuration when containers are created (or shut down).\n\nAlso, we're making sure the container is automatically restarted by the Docker engine in case of problems (or: if the server is rebooted).\nWe're publishing the default HTTP ports \n80\n and \n443\n on the host, and making sure the container is placed within the \nweb\n network we've created earlier on.\n\nFinally, we're giving this container a static name called \ntraefik\n.\n\n\nLet's take a look at a simple \ntraefik.toml\n configuration as well before we'll create the Traefik container:\n\n\ndebug = false\n\nlogLevel = \nERROR\n\ndefaultEntryPoints = [\nhttps\n,\nhttp\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n    [entryPoints.http.redirect]\n    entryPoint = \nhttps\n\n  [entryPoints.https]\n  address = \n:443\n\n  [entryPoints.https.tls]\n\n[retry]\n\n[docker]\nendpoint = \nunix:///var/run/docker.sock\n\ndomain = \nmy-awesome-app.org\n\nwatch = true\nexposedByDefault = false\n\n[acme]\nemail = \nyour-email-here@my-awesome-app.org\n\nstorage = \nacme.json\n\nentryPoint = \nhttps\n\nonHostRule = true\n[acme.httpChallenge]\nentryPoint = \nhttp\n\n\n\n\n\nAlternatively, the \nTOML\n file above can also be translated into command line switches. \nThis is the \ncommand\n value of the \ntraefik\n service in the \ndocker-compose.yml\n manifest:\n\n\ncommand:\n  - --debug=false\n  - --logLevel=ERROR\n  - --defaultentrypoints=https,http\n  - --entryPoints=Name:http Address::80 Redirect.EntryPoint:https\n  - --entryPoints=Name:https Address::443 TLS\n  - --retry\n  - --docker.endpoint=unix:///var/run/docker.sock\n  - --docker.domain=my-awesome-app.org\n  - --docker.watch=true\n  - --docker.exposedbydefault=false\n  - --acme.email=your-email-here@my-awesome-app.org\n  - --acme.storage=acme.json\n  - --acme.entryPoint=https\n  - --acme.onHostRule=true\n  - --acme.httpchallenge.entrypoint=http\n\n\n\n\nThis is the minimum configuration required to do the following:\n\n\n\n\nLog \nERROR\n-level messages (or more severe) to the console, but silence \nDEBUG\n-level messages\n\n\nCheck for new versions of Traefik periodically\n\n\nCreate two entry points, namely an \nHTTP\n endpoint on port \n80\n, and an \nHTTPS\n endpoint on port \n443\n where all incoming traffic on port \n80\n will immediately get redirected to \nHTTPS\n.\n\n\nEnable the Docker provider and listen for container events on the Docker unix socket we've mounted earlier. However, \nnew containers will not be exposed by Traefik by default, we'll get into this in a bit!\n\n\nEnable automatic request and configuration of SSL certificates using Let's Encrypt.\n    These certificates will be stored in the \nacme.json\n file, which you can back-up yourself and store off-premises.\n\n\n\n\nAlright, let's boot the container. From the \n/opt/traefik\n directory, run \ndocker-compose up -d\n which will create and start the Traefik container.\n\n\nExposing Web Services to the Outside World\n\n\nNow that we've fully configured and started Traefik, it's time to get our applications running!\n\n\nLet's take a simple example of a micro-service project consisting of various services, where some will be exposed to the outside world and some will not.\n\n\nThe \ndocker-compose.yml\n of our project looks like this:\n\n\nversion: \n2.1\n\n\nservices:\n  app:\n    image: my-docker-registry.com/my-awesome-app/app:latest\n    depends_on:\n      db:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    restart: always\n    networks:\n      - web\n      - default\n    expose:\n      - \n9000\n\n    labels:\n      - \ntraefik.docker.network=web\n\n      - \ntraefik.enable=true\n\n      - \ntraefik.basic.frontend.rule=Host:app.my-awesome-app.org\n\n      - \ntraefik.basic.port=9000\n\n      - \ntraefik.basic.protocol=http\n\n      - \ntraefik.admin.frontend.rule=Host:admin-app.my-awesome-app.org\n\n      - \ntraefik.admin.protocol=https\n\n      - \ntraefik.admin.port=9443\n\n\n  db:\n    image: my-docker-registry.com/back-end/5.7\n    restart: always\n\n  redis:\n    image: my-docker-registry.com/back-end/redis:4-alpine\n    restart: always\n\n  events:\n    image: my-docker-registry.com/my-awesome-app/events:latest\n    depends_on:\n      db:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    restart: always\n    networks:\n      - web\n      - default\n    expose:\n      - \n3000\n\n    labels:\n      - \ntraefik.backend=my-awesome-app-events\n\n      - \ntraefik.docker.network=web\n\n      - \ntraefik.frontend.rule=Host:events.my-awesome-app.org\n\n      - \ntraefik.enable=true\n\n      - \ntraefik.port=3000\n\n\nnetworks:\n  web:\n    external: true\n\n\n\n\nHere, we can see a set of services with two applications that we're actually exposing to the outside world.\n\nNotice how there isn't a single container that has any published ports to the host -- everything is routed through Docker networks.\n\nAlso, only the containers that we want traffic to get routed to are attached to the \nweb\n network we created at the start of this document.\n\n\nSince the \ntraefik\n container we've created and started earlier is also attached to this network, HTTP requests can now get routed to these containers.\n\n\nLabels\n\n\nAs mentioned earlier, we don't want containers exposed automatically by Traefik.\n\n\nThe reason behind this is simple: we want to have control over this process ourselves.\nThanks to Docker labels, we can tell Traefik how to create its internal routing configuration.\n\n\nLet's take a look at the labels themselves for the \napp\n service, which is a HTTP webservice listing on port 9000:\n\n\n- \ntraefik.docker.network=web\n\n- \ntraefik.enable=true\n\n- \ntraefik.basic.frontend.rule=Host:app.my-awesome-app.org\n\n- \ntraefik.basic.port=9000\n\n- \ntraefik.basic.protocol=http\n\n- \ntraefik.admin.frontend.rule=Host:admin-app.my-awesome-app.org\n\n- \ntraefik.admin.protocol=https\n\n- \ntraefik.admin.port=9443\n\n\n\n\n\nWe use both \ncontainer labels\n and \nservice labels\n.\n\n\nContainer labels\n\n\nFirst, we specify the \nbackend\n name which corresponds to the actual service we're routing \nto\n.\n\n\nWe also tell Traefik to use the \nweb\n network to route HTTP traffic to this container.\nWith the \ntraefik.enable\n label, we tell Traefik to include this container in its internal configuration.\n\n\nWith the \nfrontend.rule\n label, we tell Traefik that we want to route to this container if the incoming HTTP request contains the \nHost\n \napp.my-awesome-app.org\n.\nEssentially, this is the actual rule used for Layer-7 load balancing.\n\n\nFinally but not unimportantly, we tell Traefik to route \nto\n port \n9000\n, since that is the actual TCP/IP port the container actually listens on.\n\n\nService labels\n\n\nService labels\n allow managing many routes for the same container.\n\n\nWhen both \ncontainer labels\n and \nservice labels\n are defined, \ncontainer labels\n are just used as default values for missing \nservice labels\n but no frontend/backend are going to be defined only with these labels.\nObviously, labels \ntraefik.frontend.rule\n and \ntraefik.port\n described above, will only be used to complete information set in \nservice labels\n during the container frontends/backends creation.\n\n\nIn the example, two service names are defined : \nbasic\n and \nadmin\n.\nThey allow creating two frontends and two backends.\n\n\n\n\nbasic\n has only one \nservice label\n : \ntraefik.basic.protocol\n.\nTraefik will use values set in \ntraefik.frontend.rule\n and \ntraefik.port\n to create the \nbasic\n frontend and backend.\nThe frontend listens to incoming HTTP requests which contain the \nHost\n \napp.my-awesome-app.org\n and redirect them in \nHTTP\n to the port \n9000\n of the backend.\n\n\nadmin\n has all the \nservices labels\n needed to create the \nadmin\n frontend and backend (\ntraefik.admin.frontend.rule\n, \ntraefik.admin.protocol\n, \ntraefik.admin.port\n).\nTraefik will create a frontend to listen to incoming HTTP requests which contain the \nHost\n \nadmin-app.my-awesome-app.org\n and redirect them in \nHTTPS\n to the port \n9443\n of the backend.\n\n\n\n\nGotchas and tips\n\n\n\n\nAlways specify the correct port where the container expects HTTP traffic using \ntraefik.port\n label.\n\n    If a container exposes multiple ports, Traefik may forward traffic to the wrong port.\n    Even if a container only exposes one port, you should always write configuration defensively and explicitly.\n\n\nShould you choose to enable the \nexposedByDefault\n flag in the \ntraefik.toml\n configuration, be aware that all containers that are placed in the same network as Traefik will automatically be reachable from the outside world, for everyone and everyone to see.\n    Usually, this is a bad idea.\n\n\nWith the \ntraefik.frontend.auth.basic\n label, it's possible for Traefik to provide a HTTP basic-auth challenge for the endpoints you provide the label for.\n\n\nTraefik has built-in support to automatically export \nPrometheus\n metrics\n\n\nTraefik supports websockets out of the box. In the example above, the \nevents\n-service could be a NodeJS-based application which allows clients to connect using websocket protocol.\n    Thanks to the fact that HTTPS in our example is enforced, these websockets are automatically secure as well (WSS)\n\n\n\n\nFinal thoughts\n\n\nUsing Traefik as a Layer-7 load balancer in combination with both Docker and Let's Encrypt provides you with an extremely flexible, powerful and self-configuring solution for your projects.\n\n\nWith Let's Encrypt, your endpoints are automatically secured with production-ready SSL certificates that are renewed automatically as well.", 
            "title": "Let's Encrypt & Docker"
        }, 
        {
            "location": "/user-guide/docker-and-lets-encrypt/#lets-encrypt-docker", 
            "text": "In this use case, we want to use Traefik as a  layer-7  load balancer with SSL termination for a set of micro-services used to run a web application.  We also want to automatically  discover any services  on the Docker host and let Traefik reconfigure itself automatically when containers get created (or shut down) so HTTP traffic can be routed accordingly.  In addition, we want to use Let's Encrypt to automatically generate and renew SSL certificates per hostname.", 
            "title": "Let's Encrypt &amp; Docker"
        }, 
        {
            "location": "/user-guide/docker-and-lets-encrypt/#setting-up", 
            "text": "In order for this to work, you'll need a server with a public IP address, with Docker and docker-compose installed on it.  In this example, we're using the fictitious domain  my-awesome-app.org .  In real-life, you'll want to use your own domain and have the DNS configured accordingly so the hostname records you'll want to use point to the aforementioned public IP address.", 
            "title": "Setting Up"
        }, 
        {
            "location": "/user-guide/docker-and-lets-encrypt/#networking", 
            "text": "Docker containers can only communicate with each other over TCP when they share at least one network.\nThis makes sense from a topological point of view in the context of networking, since Docker under the hood creates IPTable rules so containers can't reach other containers  unless you'd want to .  In this example, we're going to use a single network called  web  where all containers that are handling HTTP traffic (including Traefik) will reside in.  On the Docker host, run the following command:  docker network create web  Now, let's create a directory on the server where we will configure the rest of Traefik:  mkdir -p /opt/traefik  Within this directory, we're going to create 3 empty files:  touch /opt/traefik/docker-compose.yml\ntouch /opt/traefik/acme.json   chmod 600 /opt/traefik/acme.json\ntouch /opt/traefik/traefik.toml  The  docker-compose.yml  file will provide us with a simple, consistent and more importantly, a deterministic way to create Traefik.  The contents of the file is as follows:  version: '2'\n\nservices:\n  traefik:\n    image: traefik: stable v1.7 from https://hub.docker.com/_/traefik \n    restart: always\n    ports:\n      - 80:80\n      - 443:443\n    networks:\n      - web\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /opt/traefik/traefik.toml:/traefik.toml\n      - /opt/traefik/acme.json:/acme.json\n    container_name: traefik\n\nnetworks:\n  web:\n    external: true  As you can see, we're mounting the  traefik.toml  file as well as the (empty)  acme.json  file in the container. \nAlso, we're mounting the  /var/run/docker.sock  Docker socket in the container as well, so Traefik can listen to Docker events and reconfigure its own internal configuration when containers are created (or shut down). \nAlso, we're making sure the container is automatically restarted by the Docker engine in case of problems (or: if the server is rebooted).\nWe're publishing the default HTTP ports  80  and  443  on the host, and making sure the container is placed within the  web  network we've created earlier on. \nFinally, we're giving this container a static name called  traefik .  Let's take a look at a simple  traefik.toml  configuration as well before we'll create the Traefik container:  debug = false\n\nlogLevel =  ERROR \ndefaultEntryPoints = [ https , http ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n    [entryPoints.http.redirect]\n    entryPoint =  https \n  [entryPoints.https]\n  address =  :443 \n  [entryPoints.https.tls]\n\n[retry]\n\n[docker]\nendpoint =  unix:///var/run/docker.sock \ndomain =  my-awesome-app.org \nwatch = true\nexposedByDefault = false\n\n[acme]\nemail =  your-email-here@my-awesome-app.org \nstorage =  acme.json \nentryPoint =  https \nonHostRule = true\n[acme.httpChallenge]\nentryPoint =  http   Alternatively, the  TOML  file above can also be translated into command line switches. \nThis is the  command  value of the  traefik  service in the  docker-compose.yml  manifest:  command:\n  - --debug=false\n  - --logLevel=ERROR\n  - --defaultentrypoints=https,http\n  - --entryPoints=Name:http Address::80 Redirect.EntryPoint:https\n  - --entryPoints=Name:https Address::443 TLS\n  - --retry\n  - --docker.endpoint=unix:///var/run/docker.sock\n  - --docker.domain=my-awesome-app.org\n  - --docker.watch=true\n  - --docker.exposedbydefault=false\n  - --acme.email=your-email-here@my-awesome-app.org\n  - --acme.storage=acme.json\n  - --acme.entryPoint=https\n  - --acme.onHostRule=true\n  - --acme.httpchallenge.entrypoint=http  This is the minimum configuration required to do the following:   Log  ERROR -level messages (or more severe) to the console, but silence  DEBUG -level messages  Check for new versions of Traefik periodically  Create two entry points, namely an  HTTP  endpoint on port  80 , and an  HTTPS  endpoint on port  443  where all incoming traffic on port  80  will immediately get redirected to  HTTPS .  Enable the Docker provider and listen for container events on the Docker unix socket we've mounted earlier. However,  new containers will not be exposed by Traefik by default, we'll get into this in a bit!  Enable automatic request and configuration of SSL certificates using Let's Encrypt.\n    These certificates will be stored in the  acme.json  file, which you can back-up yourself and store off-premises.   Alright, let's boot the container. From the  /opt/traefik  directory, run  docker-compose up -d  which will create and start the Traefik container.", 
            "title": "Networking"
        }, 
        {
            "location": "/user-guide/docker-and-lets-encrypt/#exposing-web-services-to-the-outside-world", 
            "text": "Now that we've fully configured and started Traefik, it's time to get our applications running!  Let's take a simple example of a micro-service project consisting of various services, where some will be exposed to the outside world and some will not.  The  docker-compose.yml  of our project looks like this:  version:  2.1 \n\nservices:\n  app:\n    image: my-docker-registry.com/my-awesome-app/app:latest\n    depends_on:\n      db:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    restart: always\n    networks:\n      - web\n      - default\n    expose:\n      -  9000 \n    labels:\n      -  traefik.docker.network=web \n      -  traefik.enable=true \n      -  traefik.basic.frontend.rule=Host:app.my-awesome-app.org \n      -  traefik.basic.port=9000 \n      -  traefik.basic.protocol=http \n      -  traefik.admin.frontend.rule=Host:admin-app.my-awesome-app.org \n      -  traefik.admin.protocol=https \n      -  traefik.admin.port=9443 \n\n  db:\n    image: my-docker-registry.com/back-end/5.7\n    restart: always\n\n  redis:\n    image: my-docker-registry.com/back-end/redis:4-alpine\n    restart: always\n\n  events:\n    image: my-docker-registry.com/my-awesome-app/events:latest\n    depends_on:\n      db:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    restart: always\n    networks:\n      - web\n      - default\n    expose:\n      -  3000 \n    labels:\n      -  traefik.backend=my-awesome-app-events \n      -  traefik.docker.network=web \n      -  traefik.frontend.rule=Host:events.my-awesome-app.org \n      -  traefik.enable=true \n      -  traefik.port=3000 \n\nnetworks:\n  web:\n    external: true  Here, we can see a set of services with two applications that we're actually exposing to the outside world. \nNotice how there isn't a single container that has any published ports to the host -- everything is routed through Docker networks. \nAlso, only the containers that we want traffic to get routed to are attached to the  web  network we created at the start of this document.  Since the  traefik  container we've created and started earlier is also attached to this network, HTTP requests can now get routed to these containers.", 
            "title": "Exposing Web Services to the Outside World"
        }, 
        {
            "location": "/user-guide/docker-and-lets-encrypt/#labels", 
            "text": "As mentioned earlier, we don't want containers exposed automatically by Traefik.  The reason behind this is simple: we want to have control over this process ourselves.\nThanks to Docker labels, we can tell Traefik how to create its internal routing configuration.  Let's take a look at the labels themselves for the  app  service, which is a HTTP webservice listing on port 9000:  -  traefik.docker.network=web \n-  traefik.enable=true \n-  traefik.basic.frontend.rule=Host:app.my-awesome-app.org \n-  traefik.basic.port=9000 \n-  traefik.basic.protocol=http \n-  traefik.admin.frontend.rule=Host:admin-app.my-awesome-app.org \n-  traefik.admin.protocol=https \n-  traefik.admin.port=9443   We use both  container labels  and  service labels .", 
            "title": "Labels"
        }, 
        {
            "location": "/user-guide/docker-and-lets-encrypt/#container-labels", 
            "text": "First, we specify the  backend  name which corresponds to the actual service we're routing  to .  We also tell Traefik to use the  web  network to route HTTP traffic to this container.\nWith the  traefik.enable  label, we tell Traefik to include this container in its internal configuration.  With the  frontend.rule  label, we tell Traefik that we want to route to this container if the incoming HTTP request contains the  Host   app.my-awesome-app.org .\nEssentially, this is the actual rule used for Layer-7 load balancing.  Finally but not unimportantly, we tell Traefik to route  to  port  9000 , since that is the actual TCP/IP port the container actually listens on.", 
            "title": "Container labels"
        }, 
        {
            "location": "/user-guide/docker-and-lets-encrypt/#service-labels", 
            "text": "Service labels  allow managing many routes for the same container.  When both  container labels  and  service labels  are defined,  container labels  are just used as default values for missing  service labels  but no frontend/backend are going to be defined only with these labels.\nObviously, labels  traefik.frontend.rule  and  traefik.port  described above, will only be used to complete information set in  service labels  during the container frontends/backends creation.  In the example, two service names are defined :  basic  and  admin .\nThey allow creating two frontends and two backends.   basic  has only one  service label  :  traefik.basic.protocol .\nTraefik will use values set in  traefik.frontend.rule  and  traefik.port  to create the  basic  frontend and backend.\nThe frontend listens to incoming HTTP requests which contain the  Host   app.my-awesome-app.org  and redirect them in  HTTP  to the port  9000  of the backend.  admin  has all the  services labels  needed to create the  admin  frontend and backend ( traefik.admin.frontend.rule ,  traefik.admin.protocol ,  traefik.admin.port ).\nTraefik will create a frontend to listen to incoming HTTP requests which contain the  Host   admin-app.my-awesome-app.org  and redirect them in  HTTPS  to the port  9443  of the backend.", 
            "title": "Service labels"
        }, 
        {
            "location": "/user-guide/docker-and-lets-encrypt/#gotchas-and-tips", 
            "text": "Always specify the correct port where the container expects HTTP traffic using  traefik.port  label. \n    If a container exposes multiple ports, Traefik may forward traffic to the wrong port.\n    Even if a container only exposes one port, you should always write configuration defensively and explicitly.  Should you choose to enable the  exposedByDefault  flag in the  traefik.toml  configuration, be aware that all containers that are placed in the same network as Traefik will automatically be reachable from the outside world, for everyone and everyone to see.\n    Usually, this is a bad idea.  With the  traefik.frontend.auth.basic  label, it's possible for Traefik to provide a HTTP basic-auth challenge for the endpoints you provide the label for.  Traefik has built-in support to automatically export  Prometheus  metrics  Traefik supports websockets out of the box. In the example above, the  events -service could be a NodeJS-based application which allows clients to connect using websocket protocol.\n    Thanks to the fact that HTTPS in our example is enforced, these websockets are automatically secure as well (WSS)", 
            "title": "Gotchas and tips"
        }, 
        {
            "location": "/user-guide/docker-and-lets-encrypt/#final-thoughts", 
            "text": "Using Traefik as a Layer-7 load balancer in combination with both Docker and Let's Encrypt provides you with an extremely flexible, powerful and self-configuring solution for your projects.  With Let's Encrypt, your endpoints are automatically secured with production-ready SSL certificates that are renewed automatically as well.", 
            "title": "Final thoughts"
        }, 
        {
            "location": "/user-guide/kubernetes/", 
            "text": "Kubernetes Ingress Controller\n\n\nThis guide explains how to use Traefik as an Ingress controller for a Kubernetes cluster.\n\n\nIf you are not familiar with Ingresses in Kubernetes you might want to read the \nKubernetes user guide\n\n\nThe config files used in this guide can be found in the \nexamples directory\n\n\nPrerequisites\n\n\n\n\nA working Kubernetes cluster. If you want to follow along with this guide, you should setup \nminikube\n on your machine, as it is the quickest way to get a local Kubernetes cluster setup for experimentation and development.\n\n\n\n\n\n\nNote\n\n\nThe guide is likely not fully adequate for a production-ready setup.\n\n\n\n\n\n\nThe \nkubectl\n binary should be \ninstalled on your workstation\n.\n\n\n\n\nRole Based Access Control configuration (Kubernetes 1.6+ only)\n\n\nKubernetes introduces \nRole Based Access Control (RBAC)\n in 1.6+ to allow fine-grained control of Kubernetes resources and API.\n\n\nIf your cluster is configured with RBAC, you will need to authorize Traefik to use the Kubernetes API. There are two ways to set up the proper permission: Via namespace-specific RoleBindings or a single, global ClusterRoleBinding.\n\n\nRoleBindings per namespace enable to restrict granted permissions to the very namespaces only that Traefik is watching over, thereby following the least-privileges principle. This is the preferred approach if Traefik is not supposed to watch all namespaces, and the set of namespaces does not change dynamically. Otherwise, a single ClusterRoleBinding must be employed.\n\n\n\n\nNote\n\n\nRoleBindings per namespace are available in Traefik 1.5 and later. Please use ClusterRoleBindings for older versions.\n\n\n\n\nFor the sake of simplicity, this guide will use a ClusterRoleBinding:\n\n\n---\nkind: ClusterRole\napiVersion: rbac.authorization.k8s.io/v1beta1\nmetadata:\n  name: traefik-ingress-controller\nrules:\n  - apiGroups:\n      - \n\n    resources:\n      - services\n      - endpoints\n      - secrets\n    verbs:\n      - get\n      - list\n      - watch\n  - apiGroups:\n      - extensions\n    resources:\n      - ingresses\n    verbs:\n      - get\n      - list\n      - watch\n---\nkind: ClusterRoleBinding\napiVersion: rbac.authorization.k8s.io/v1beta1\nmetadata:\n  name: traefik-ingress-controller\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: traefik-ingress-controller\nsubjects:\n- kind: ServiceAccount\n  name: traefik-ingress-controller\n  namespace: kube-system\n\n\n\n\nexamples/k8s/traefik-rbac.yaml\n\n\nkubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/traefik-rbac.yaml\n\n\n\n\nFor namespaced restrictions, one RoleBinding is required per watched namespace along with a corresponding configuration of Traefik's \nkubernetes.namespaces\n parameter.\n\n\nDeploy Traefik using a Deployment or DaemonSet\n\n\nIt is possible to use Traefik with a \nDeployment\n or a \nDaemonSet\n object,\n whereas both options have their own pros and cons:\n\n\n\n\nThe scalability can be much better when using a Deployment, because you will have a Single-Pod-per-Node model when using a DaemonSet, whereas you may need less replicas based on your environment when using a Deployment.\n\n\nDaemonSets automatically scale to new nodes, when the nodes join the cluster, whereas Deployment pods are only scheduled on new nodes if required.\n\n\nDaemonSets ensure that only one replica of pods run on any single node. Deployments require affinity settings if you want to ensure that two pods don't end up on the same node.\n\n\nDaemonSets can be run with the \nNET_BIND_SERVICE\n capability, which will allow it to bind to port 80/443/etc on each host. This will allow bypassing the kube-proxy, and reduce traffic hops. Note that this is against the Kubernetes Best Practices \nGuidelines\n, and raises the potential for scheduling/scaling issues. Despite potential issues, this remains the choice for most ingress controllers.\n\n\nIf you are unsure which to choose, start with the Daemonset.\n\n\n\n\nThe Deployment objects looks like this:\n\n\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: traefik-ingress-controller\n  namespace: kube-system\n---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: traefik-ingress-controller\n  namespace: kube-system\n  labels:\n    k8s-app: traefik-ingress-lb\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      k8s-app: traefik-ingress-lb\n  template:\n    metadata:\n      labels:\n        k8s-app: traefik-ingress-lb\n        name: traefik-ingress-lb\n    spec:\n      serviceAccountName: traefik-ingress-controller\n      terminationGracePeriodSeconds: 60\n      containers:\n      - image: traefik:v1.7\n        name: traefik-ingress-lb\n        ports:\n        - name: http\n          containerPort: 80\n        - name: admin\n          containerPort: 8080\n        args:\n        - --api\n        - --kubernetes\n        - --logLevel=INFO\n---\nkind: Service\napiVersion: v1\nmetadata:\n  name: traefik-ingress-service\n  namespace: kube-system\nspec:\n  selector:\n    k8s-app: traefik-ingress-lb\n  ports:\n    - protocol: TCP\n      port: 80\n      name: web\n    - protocol: TCP\n      port: 8080\n      name: admin\n  type: NodePort\n\n\n\n\nexamples/k8s/traefik-deployment.yaml\n\n\n\n\nNote\n\n\nThe Service will expose two NodePorts which allow access to the ingress and the web interface.\n\n\n\n\nThe DaemonSet objects looks not much different:\n\n\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: traefik-ingress-controller\n  namespace: kube-system\n---\nkind: DaemonSet\napiVersion: apps/v1\nmetadata:\n  name: traefik-ingress-controller\n  namespace: kube-system\n  labels:\n    k8s-app: traefik-ingress-lb\nspec:\n  template:\n    metadata:\n      labels:\n        k8s-app: traefik-ingress-lb\n        name: traefik-ingress-lb\n    spec:\n      serviceAccountName: traefik-ingress-controller\n      terminationGracePeriodSeconds: 60\n      containers:\n      - image: traefik:v1.7\n        name: traefik-ingress-lb\n        ports:\n        - name: http\n          containerPort: 80\n          hostPort: 80\n        - name: admin\n          containerPort: 8080\n        securityContext:\n          capabilities:\n            drop:\n            - ALL\n            add:\n            - NET_BIND_SERVICE\n        args:\n        - --api\n        - --kubernetes\n        - --logLevel=INFO\n---\nkind: Service\napiVersion: v1\nmetadata:\n  name: traefik-ingress-service\n  namespace: kube-system\nspec:\n  selector:\n    k8s-app: traefik-ingress-lb\n  ports:\n    - protocol: TCP\n      port: 80\n      name: web\n    - protocol: TCP\n      port: 8080\n      name: admin\n\n\n\n\nexamples/k8s/traefik-ds.yaml\n\n\n\n\nNote\n\n\nThis will create a Daemonset that uses privileged ports 80/8080 on the host. This may not work on all providers, but illustrates the static (non-NodePort) hostPort binding. The \ntraefik-ingress-service\n can still be used inside the cluster to access the DaemonSet pods.\n\n\n\n\nTo deploy Traefik to your cluster start by submitting one of the YAML files to the cluster with \nkubectl\n:\n\n\nkubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/traefik-deployment.yaml\n\n\n\n\nkubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/traefik-ds.yaml\n\n\n\n\nThere are some significant differences between using Deployments and DaemonSets:\n\n\n\n\nThe Deployment has easier up and down scaling possibilities.\n    It can implement full pod lifecycle and supports rolling updates from Kubernetes 1.2.\n    At least one Pod is needed to run the Deployment.\n\n\nThe DaemonSet automatically scales to all nodes that meets a specific selector and guarantees to fill nodes one at a time.\n    Rolling updates are fully supported from Kubernetes 1.7 for DaemonSets as well.\n\n\n\n\nCheck the Pods\n\n\nNow lets check if our command was successful.\n\n\nStart by listing the pods in the \nkube-system\n namespace:\n\n\nkubectl --namespace=kube-system get pods\n\n\n\n\nNAME                                         READY     STATUS    RESTARTS   AGE\nkube-addon-manager-minikubevm                1/1       Running   0          4h\nkubernetes-dashboard-s8krj                   1/1       Running   0          4h\ntraefik-ingress-controller-678226159-eqseo   1/1       Running   0          7m\n\n\n\n\nYou should see that after submitting the Deployment or DaemonSet to Kubernetes it has launched a Pod, and it is now running.\n\nIt might take a few moments for Kubernetes to pull the Traefik image and start the container.\n\n\n\n\nNote\n\n\nYou could also check the deployment with the Kubernetes dashboard, run\n\nminikube dashboard\n to open it in your browser, then choose the \nkube-system\n\nnamespace from the menu at the top right of the screen.\n\n\n\n\nYou should now be able to access Traefik on port 80 of your Minikube instance when using the DaemonSet:\n\n\ncurl $(minikube ip)\n\n\n\n\n404 page not found\n\n\n\n\nIf you decided to use the deployment, then you need to target the correct NodePort, which can be seen when you execute \nkubectl get services --namespace=kube-system\n.\n\n\ncurl $(minikube ip):\nNODEPORT\n\n\n\n\n\n404 page not found\n\n\n\n\n\n\nNote\n\n\nWe expect to see a 404 response here as we haven't yet given Traefik any configuration.\n\n\n\n\nAll further examples below assume a DaemonSet installation. Deployment users will need to append the NodePort when constructing requests.\n\n\nDeploy Traefik using Helm Chart\n\n\n\n\nNote\n\n\nThe Helm Chart is maintained by the community, not the Traefik project maintainers.\n\n\n\n\nInstead of installing Traefik via Kubernetes object directly, you can also use the Traefik Helm chart.\n\n\nInstall the Traefik chart by:\n\n\nhelm install stable/traefik\n\n\n\n\nInstall the Traefik chart using a values.yaml file.\n\n\nhelm install --values values.yaml stable/traefik\n\n\n\n\ndashboard:\n  enabled: true\n  domain: traefik-ui.minikube\nkubernetes:\n  namespaces:\n    - default\n    - kube-system\n\n\n\n\nFor more information, check out \nthe documentation\n.\n\n\nSubmitting an Ingress to the Cluster\n\n\nLets start by creating a Service and an Ingress that will expose the \nTraefik Web UI\n.\n\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: traefik-web-ui\n  namespace: kube-system\nspec:\n  selector:\n    k8s-app: traefik-ingress-lb\n  ports:\n  - name: web\n    port: 80\n    targetPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: traefik-web-ui\n  namespace: kube-system\nspec:\n  rules:\n  - host: traefik-ui.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: traefik-web-ui\n          servicePort: web\n\n\n\n\nexamples/k8s/ui.yaml\n\n\nkubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/ui.yaml\n\n\n\n\nNow lets setup an entry in our \n/etc/hosts\n file to route \ntraefik-ui.minikube\n to our cluster.\n\n\nIn production you would want to set up real DNS entries.\nYou can get the IP address of your minikube instance by running \nminikube ip\n:\n\n\necho \n$(minikube ip) traefik-ui.minikube\n | sudo tee -a /etc/hosts\n\n\n\n\nWe should now be able to visit \ntraefik-ui.minikube\n in the browser and view the Traefik web UI.\n\n\nAdd a TLS Certificate to the Ingress\n\n\n\n\nNote\n\n\nFor this example to work you need a TLS entrypoint. You don't have to provide a TLS certificate at this point.\nFor more details see \nhere\n.\n\n\n\n\nYou can add a TLS entrypoint by adding the following \nargs\n to the container spec:\n\n\n --defaultentrypoints=http,https\n --entrypoints=Name:https Address::443 TLS\n --entrypoints=Name:http Address::80\n\n\n\n\nTo setup an HTTPS-protected ingress, you can leverage the TLS feature of the ingress resource.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: traefik-web-ui\n  namespace: kube-system\n  annotations:\n    kubernetes.io/ingress.class: traefik\nspec:\n  rules:\n  - host: traefik-ui.minikube\n    http:\n      paths:\n      - backend:\n          serviceName: traefik-web-ui\n          servicePort: 80\n  tls:\n   - secretName: traefik-ui-tls-cert\n\n\n\n\nIn addition to the modified ingress you need to provide the TLS certificate via a Kubernetes secret in the same namespace as the ingress.\nThe following two commands will generate a new certificate and create a secret containing the key and cert files.\n\n\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj \n/CN=traefik-ui.minikube\n\nkubectl -n kube-system create secret tls traefik-ui-tls-cert --key=tls.key --cert=tls.crt\n\n\n\n\nIf there are any errors while loading the TLS section of an ingress, the whole ingress will be skipped.\n\n\n\n\nNote\n\n\nThe secret must have two entries named \ntls.key\nand \ntls.crt\n.\nSee the \nKubernetes documentation\n for more details.\n\n\n\n\n\n\nNote\n\n\nThe TLS certificates will be added to all entrypoints defined by the ingress annotation \ntraefik.frontend.entryPoints\n.\nIf no such annotation is provided, the TLS certificates will be added to all TLS-enabled \ndefaultEntryPoints\n.\n\n\n\n\n\n\nNote\n\n\nThe field \nhosts\n in the TLS configuration is ignored. Instead, the domains provided by the certificate are used for this purpose.\nIt is recommended to not use wildcard certificates as they will match globally.\n\n\n\n\nBasic Authentication\n\n\nIt's possible to protect access to Traefik through basic authentication. (See the \nKubernetes Ingress\n configuration page for syntactical details and restrictions.)\n\n\nCreating the Secret\n\n\nA. Use \nhtpasswd\n to create a file containing the username and the MD5-encoded password:\n\n\nhtpasswd -c ./auth myusername\n\n\n\n\nYou will be prompted for a password which you will have to enter twice.\n\nhtpasswd\n will create a file with the following:\n\n\ncat auth\n\n\n\n\nmyusername:$apr1$78Jyn/1K$ERHKVRPPlzAX8eBtLuvRZ0\n\n\n\n\nB. Now use \nkubectl\n to create a secret in the \nmonitoring\n namespace using the file created by \nhtpasswd\n.\n\n\nkubectl create secret generic mysecret --from-file auth --namespace=monitoring\n\n\n\n\n\n\nNote\n\n\nSecret must be in same namespace as the Ingress object.\n\n\n\n\nC. Attach the following annotations to the Ingress object:\n\n\n\n\ntraefik.ingress.kubernetes.io/auth-type: \"basic\"\n\n\ntraefik.ingress.kubernetes.io/auth-secret: \"mysecret\"\n\n\n\n\nThey specify basic authentication and reference the Secret \nmysecret\n containing the credentials.\n\n\nFollowing is a full Ingress example based on Prometheus:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n name: prometheus-dashboard\n namespace: monitoring\n annotations:\n   kubernetes.io/ingress.class: traefik\n   traefik.ingress.kubernetes.io/auth-type: \nbasic\n\n   traefik.ingress.kubernetes.io/auth-secret: \nmysecret\n\nspec:\n rules:\n - host: dashboard.prometheus.example.com\n   http:\n     paths:\n     - backend:\n         serviceName: prometheus\n         servicePort: 9090\n\n\n\n\nYou can apply the example as following:\n\n\nkubectl create -f prometheus-ingress.yaml -n monitoring\n\n\n\n\nName-based Routing\n\n\nIn this example we are going to setup websites for three of the United Kingdoms best loved cheeses: Cheddar, Stilton, and Wensleydale.\n\n\nFirst lets start by launching the pods for the cheese websites.\n\n\n---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: stilton\n  labels:\n    app: cheese\n    cheese: stilton\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: cheese\n      task: stilton\n  template:\n    metadata:\n      labels:\n        app: cheese\n        task: stilton\n        version: v0.0.1\n    spec:\n      containers:\n      - name: cheese\n        image: errm/cheese:stilton\n        ports:\n        - containerPort: 80\n---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: cheddar\n  labels:\n    app: cheese\n    cheese: cheddar\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: cheese\n      task: cheddar\n  template:\n    metadata:\n      labels:\n        app: cheese\n        task: cheddar\n        version: v0.0.1\n    spec:\n      containers:\n      - name: cheese\n        image: errm/cheese:cheddar\n        ports:\n        - containerPort: 80\n---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: wensleydale\n  labels:\n    app: cheese\n    cheese: wensleydale\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: cheese\n      task: wensleydale\n  template:\n    metadata:\n      labels:\n        app: cheese\n        task: wensleydale\n        version: v0.0.1\n    spec:\n      containers:\n      - name: cheese\n        image: errm/cheese:wensleydale\n        ports:\n        - containerPort: 80\n\n\n\n\nexamples/k8s/cheese-deployments.yaml\n\n\nkubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/cheese-deployments.yaml\n\n\n\n\nNext we need to setup a Service for each of the cheese pods.\n\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: stilton\nspec:\n  ports:\n  - name: http\n    targetPort: 80\n    port: 80\n  selector:\n    app: cheese\n    task: stilton\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: cheddar\nspec:\n  ports:\n  - name: http\n    targetPort: 80\n    port: 80\n  selector:\n    app: cheese\n    task: cheddar\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: wensleydale\n  annotations:\n    traefik.backend.circuitbreaker: \nNetworkErrorRatio() \n 0.5\n\nspec:\n  ports:\n  - name: http\n    targetPort: 80\n    port: 80\n  selector:\n    app: cheese\n    task: wensleydale\n\n\n\n\n\n\nNote\n\n\nWe also set a \ncircuit breaker expression\n for one of the backends by setting the \ntraefik.backend.circuitbreaker\n annotation on the service.\n\n\n\n\nexamples/k8s/cheese-services.yaml\n\n\nkubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/cheese-services.yaml\n\n\n\n\nNow we can submit an ingress for the cheese websites.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: cheese\n  annotations:\n    kubernetes.io/ingress.class: traefik\nspec:\n  rules:\n  - host: stilton.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: stilton\n          servicePort: http\n  - host: cheddar.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: cheddar\n          servicePort: http\n  - host: wensleydale.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: wensleydale\n          servicePort: http\n\n\n\n\nexamples/k8s/cheese-ingress.yaml\n\n\n\n\nNote\n\n\nWe list each hostname, and add a backend service.\n\n\n\n\nkubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/cheese-ingress.yaml\n\n\n\n\nNow visit the \nTraefik dashboard\n and you should see a frontend for each host.\nAlong with a backend listing for each service with a server set up for each pod.\n\n\nIf you edit your \n/etc/hosts\n again you should be able to access the cheese websites in your browser.\n\n\necho \n$(minikube ip) stilton.minikube cheddar.minikube wensleydale.minikube\n | sudo tee -a /etc/hosts\n\n\n\n\n\n\nStilton\n\n\nCheddar\n\n\nWensleydale\n\n\n\n\nPath-based Routing\n\n\nNow lets suppose that our fictional client has decided that while they are super happy about our cheesy web design, when they asked for 3 websites they had not really bargained on having to buy 3 domain names.\n\n\nNo problem, we say, why don't we reconfigure the sites to host all 3 under one domain.\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: cheeses\n  annotations:\n    kubernetes.io/ingress.class: traefik\n    traefik.frontend.rule.type: PathPrefixStrip\nspec:\n  rules:\n  - host: cheeses.minikube\n    http:\n      paths:\n      - path: /stilton\n        backend:\n          serviceName: stilton\n          servicePort: http\n      - path: /cheddar\n        backend:\n          serviceName: cheddar\n          servicePort: http\n      - path: /wensleydale\n        backend:\n          serviceName: wensleydale\n          servicePort: http\n\n\n\n\nexamples/k8s/cheeses-ingress.yaml\n\n\n\n\nNote\n\n\nWe are configuring Traefik to strip the prefix from the url path with the \ntraefik.frontend.rule.type\n annotation so that we can use the containers from the previous example without modification.\n\n\n\n\nkubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/cheeses-ingress.yaml\n\n\n\n\necho \n$(minikube ip) cheeses.minikube\n | sudo tee -a /etc/hosts\n\n\n\n\nYou should now be able to visit the websites in your browser.\n\n\n\n\ncheeses.minikube/stilton\n\n\ncheeses.minikube/cheddar\n\n\ncheeses.minikube/wensleydale\n\n\n\n\nMultiple Ingress Definitions for the Same Host (or Host+Path)\n\n\nTraefik will merge multiple Ingress definitions for the same host/path pair into one definition.\n\n\nLet's say the number of cheese services is growing.\nIt is now time to move the cheese services to a dedicated cheese namespace to simplify the managements of cheese and non-cheese services.\n\n\nSimply deploy a new Ingress Object with the same host an path into the cheese namespace:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: cheese\n  namespace: cheese\n  annotations:\n    kubernetes.io/ingress.class: traefik\n    traefik.frontend.rule.type: PathPrefixStrip\nspec:\n  rules:\n  - host: cheese.minikube\n    http:\n      paths:\n      - path: /cheddar\n        backend:\n          serviceName: cheddar\n          servicePort: http\n\n\n\n\nTraefik will now look for cheddar service endpoints (ports on healthy pods) in both the cheese and the default namespace.\nDeploying cheddar into the cheese namespace and afterwards shutting down cheddar in the default namespace is enough to migrate the traffic.\n\n\n\n\nNote\n\n\nThe kubernetes documentation does not specify this merging behavior.\n\n\n\n\n\n\nNote\n\n\nMerging ingress definitions can cause problems if the annotations differ or if the services handle requests differently.\nBe careful and extra cautious when running multiple overlapping ingress definitions.\n\n\n\n\nSpecifying Routing Priorities\n\n\nSometimes you need to specify priority for ingress routes, especially when handling wildcard routes.\nThis can be done by adding the \ntraefik.frontend.priority\n annotation, i.e.:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: wildcard-cheeses\n  annotations:\n    traefik.frontend.priority: \n1\n\nspec:\n  rules:\n  - host: *.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: stilton\n          servicePort: http\n\nkind: Ingress\nmetadata:\n  name: specific-cheeses\n  annotations:\n    traefik.frontend.priority: \n2\n\nspec:\n  rules:\n  - host: specific.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: stilton\n          servicePort: http\n\n\n\n\nNote that priority values must be quoted to avoid numeric interpretation (which are illegal for annotations).\n\n\nForwarding to ExternalNames\n\n\nWhen specifying an \nExternalName\n,\nTraefik will forward requests to the given host accordingly and use HTTPS when the Service port matches 443.\nThis still requires setting up a proper port mapping on the Service from the Ingress port to the (external) Service port.\n\n\nDisable passing the Host Header\n\n\nBy default Traefik will pass the incoming Host header to the upstream resource.\n\n\nHowever, there are times when you may not want this to be the case. For example, if your service is of the ExternalName type.\n\n\nDisable globally\n\n\nAdd the following to your TOML configuration file:\n\n\ndisablePassHostHeaders = true\n\n\n\n\nDisable per Ingress\n\n\nTo disable passing the Host header per ingress resource set the \ntraefik.frontend.passHostHeader\n annotation on your ingress to \n\"false\"\n.\n\n\nHere is an example definition:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: example\n  annotations:\n    kubernetes.io/ingress.class: traefik\n    traefik.frontend.passHostHeader: \nfalse\n\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /static\n        backend:\n          serviceName: static\n          servicePort: https\n\n\n\n\nAnd an example service definition:\n\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: static\nspec:\n  ports:\n  - name: https\n    port: 443\n  type: ExternalName\n  externalName: static.otherdomain.com\n\n\n\n\nIf you were to visit \nexample.com/static\n the request would then be passed on to \nstatic.otherdomain.com/static\n, and \nstatic.otherdomain.com\n would receive the request with the Host header being \nstatic.otherdomain.com\n.\n\n\n\n\nNote\n\n\nThe per-ingress annotation overrides whatever the global value is set to.\nSo you could set \ndisablePassHostHeaders\n to \ntrue\n in your TOML configuration file and then enable passing the host header per ingress if you wanted.\n\n\n\n\nPartitioning the Ingress object space\n\n\nBy default, Traefik processes every Ingress objects it observes. At times, however, it may be desirable to ignore certain objects. The following sub-sections describe common use cases and how they can be handled with Traefik.\n\n\nBetween Traefik and other Ingress controller implementations\n\n\nSometimes Traefik runs along other Ingress controller implementations. One such example is when both Traefik and a cloud provider Ingress controller are active.\n\n\nThe \nkubernetes.io/ingress.class\n annotation can be attached to any Ingress object in order to control whether Traefik should handle it.\n\n\nIf the annotation is missing, contains an empty value, or the value \ntraefik\n, then the Traefik controller will take responsibility and process the associated Ingress object.\n\n\nIt is also possible to set the \ningressClass\n option in Traefik to a particular value. Traefik will only process matching Ingress objects.\nFor instance, setting the option to \ntraefik-internal\n causes Traefik to process Ingress objects with the same \nkubernetes.io/ingress.class\n annotation value, ignoring all other objects (including those with a \ntraefik\n value, empty value, and missing annotation).\n\n\n\n\nNote\n\n\nLetting multiple ingress controllers handle the same ingress objects can lead to unintended behavior.\nIt is recommended to prefix all ingressClass values with \ntraefik\n to avoid unintended collisions with other ingress implementations.\n\n\n\n\nBetween multiple Traefik Deployments\n\n\nSometimes multiple Traefik Deployments are supposed to run concurrently.\nFor instance, it is conceivable to have one Deployment deal with internal and another one with external traffic.\n\n\nFor such cases, it is advisable to classify Ingress objects through a label and configure the \nlabelSelector\n option per each Traefik Deployment accordingly.\nTo stick with the internal/external example above, all Ingress objects meant for internal traffic could receive a \ntraffic-type: internal\n label while objects designated for external traffic receive a \ntraffic-type: external\n label.\nThe label selectors on the Traefik Deployments would then be \ntraffic-type=internal\n and \ntraffic-type=external\n, respectively.\n\n\nTraffic Splitting\n\n\nIt is possible to split Ingress traffic in a fine-grained manner between multiple deployments using \nservice weights\n.\n\n\nOne canonical use case is canary releases where a deployment representing a newer release is to receive an initially small but ever-increasing fraction of the requests over time.\nThe way this can be done in Traefik is to specify a percentage of requests that should go into each deployment.\n\n\nFor instance, say that an application \nmy-app\n runs in version 1.\nA newer version 2 is about to be released, but confidence in the robustness and reliability of new version running in production can only be gained gradually.\nThus, a new deployment \nmy-app-canary\n is created and scaled to a replica count that suffices for a 1% traffic share.\nAlong with it, a Service object is created as usual.\n\n\nThe Ingress specification would look like this:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-app: 99%\n      my-app-canary: 1%\n  name: my-app\nspec:\n  rules:\n  - http:\n      paths:\n      - backend:\n          serviceName: my-app\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-app-canary\n          servicePort: 80\n        path: /\n\n\n\n\nTake note of the \ntraefik.ingress.kubernetes.io/service-weights\n annotation: It specifies the distribution of requests among the referenced backend services, \nmy-app\n and \nmy-app-canary\n.\nWith this definition, Traefik will route 99% of the requests to the pods backed by the \nmy-app\n deployment, and 1% to those backed by \nmy-app-canary\n.\nOver time, the ratio may slowly shift towards the canary deployment until it is deemed to replace the previous main application, in steps such as 5%/95%, 10%/90%, 50%/50%, and finally 100%/0%.\n\n\nA few conditions must hold for service weights to be applied correctly:\n\n\n\n\nThe associated service backends must share the same path and host.\n\n\nThe total percentage shared across all service backends must yield 100% (see the section on \nomitting the final service\n, however).\n\n\nThe percentage values are interpreted as floating point numbers to a supported precision as defined in the \nannotation documentation\n.\n\n\n\n\nOmitting the Final Service\n\n\nWhen specifying service weights, it is possible to omit exactly one service for convenience reasons.\n\n\nFor instance, the following definition shows how to split requests in a scenario where a canary release is accompanied by a baseline deployment for easier metrics comparison or automated canary analysis:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-app-canary: 10%\n      my-app-baseline: 10%\n  name: app\nspec:\n  rules:\n  - http:\n      paths:\n      - backend:\n          serviceName: my-app-canary\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-app-baseline\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-app-main\n          servicePort: 80\n        path: /\n\n\n\n\nThis configuration assigns 80% of traffic to \nmy-app-main\n automatically, thus freeing the user from having to complete percentage values manually.\nThis becomes handy when increasing shares for canary releases continuously.\n\n\nProduction advice\n\n\nResource limitations\n\n\nThe examples shown deliberately do not specify any \nresource limitations\n as there is no one size fits all.\n\n\nIn a production environment, however, it is important to set proper bounds, especially with regards to CPU:\n\n\n\n\ntoo strict and Traefik will be throttled while serving requests (as Kubernetes imposes hard quotas)\n\n\ntoo loose and Traefik may waste resources not available for other containers\n\n\n\n\nWhen in doubt, you should measure your resource needs, and adjust requests and limits accordingly.", 
            "title": "Kubernetes"
        }, 
        {
            "location": "/user-guide/kubernetes/#kubernetes-ingress-controller", 
            "text": "This guide explains how to use Traefik as an Ingress controller for a Kubernetes cluster.  If you are not familiar with Ingresses in Kubernetes you might want to read the  Kubernetes user guide  The config files used in this guide can be found in the  examples directory", 
            "title": "Kubernetes Ingress Controller"
        }, 
        {
            "location": "/user-guide/kubernetes/#prerequisites", 
            "text": "A working Kubernetes cluster. If you want to follow along with this guide, you should setup  minikube  on your machine, as it is the quickest way to get a local Kubernetes cluster setup for experimentation and development.    Note  The guide is likely not fully adequate for a production-ready setup.    The  kubectl  binary should be  installed on your workstation .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/user-guide/kubernetes/#role-based-access-control-configuration-kubernetes-16-only", 
            "text": "Kubernetes introduces  Role Based Access Control (RBAC)  in 1.6+ to allow fine-grained control of Kubernetes resources and API.  If your cluster is configured with RBAC, you will need to authorize Traefik to use the Kubernetes API. There are two ways to set up the proper permission: Via namespace-specific RoleBindings or a single, global ClusterRoleBinding.  RoleBindings per namespace enable to restrict granted permissions to the very namespaces only that Traefik is watching over, thereby following the least-privileges principle. This is the preferred approach if Traefik is not supposed to watch all namespaces, and the set of namespaces does not change dynamically. Otherwise, a single ClusterRoleBinding must be employed.   Note  RoleBindings per namespace are available in Traefik 1.5 and later. Please use ClusterRoleBindings for older versions.   For the sake of simplicity, this guide will use a ClusterRoleBinding:  ---\nkind: ClusterRole\napiVersion: rbac.authorization.k8s.io/v1beta1\nmetadata:\n  name: traefik-ingress-controller\nrules:\n  - apiGroups:\n      -  \n    resources:\n      - services\n      - endpoints\n      - secrets\n    verbs:\n      - get\n      - list\n      - watch\n  - apiGroups:\n      - extensions\n    resources:\n      - ingresses\n    verbs:\n      - get\n      - list\n      - watch\n---\nkind: ClusterRoleBinding\napiVersion: rbac.authorization.k8s.io/v1beta1\nmetadata:\n  name: traefik-ingress-controller\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: traefik-ingress-controller\nsubjects:\n- kind: ServiceAccount\n  name: traefik-ingress-controller\n  namespace: kube-system  examples/k8s/traefik-rbac.yaml  kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/traefik-rbac.yaml  For namespaced restrictions, one RoleBinding is required per watched namespace along with a corresponding configuration of Traefik's  kubernetes.namespaces  parameter.", 
            "title": "Role Based Access Control configuration (Kubernetes 1.6+ only)"
        }, 
        {
            "location": "/user-guide/kubernetes/#deploy-traefik-using-a-deployment-or-daemonset", 
            "text": "It is possible to use Traefik with a  Deployment  or a  DaemonSet  object,\n whereas both options have their own pros and cons:   The scalability can be much better when using a Deployment, because you will have a Single-Pod-per-Node model when using a DaemonSet, whereas you may need less replicas based on your environment when using a Deployment.  DaemonSets automatically scale to new nodes, when the nodes join the cluster, whereas Deployment pods are only scheduled on new nodes if required.  DaemonSets ensure that only one replica of pods run on any single node. Deployments require affinity settings if you want to ensure that two pods don't end up on the same node.  DaemonSets can be run with the  NET_BIND_SERVICE  capability, which will allow it to bind to port 80/443/etc on each host. This will allow bypassing the kube-proxy, and reduce traffic hops. Note that this is against the Kubernetes Best Practices  Guidelines , and raises the potential for scheduling/scaling issues. Despite potential issues, this remains the choice for most ingress controllers.  If you are unsure which to choose, start with the Daemonset.   The Deployment objects looks like this:  ---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: traefik-ingress-controller\n  namespace: kube-system\n---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: traefik-ingress-controller\n  namespace: kube-system\n  labels:\n    k8s-app: traefik-ingress-lb\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      k8s-app: traefik-ingress-lb\n  template:\n    metadata:\n      labels:\n        k8s-app: traefik-ingress-lb\n        name: traefik-ingress-lb\n    spec:\n      serviceAccountName: traefik-ingress-controller\n      terminationGracePeriodSeconds: 60\n      containers:\n      - image: traefik:v1.7\n        name: traefik-ingress-lb\n        ports:\n        - name: http\n          containerPort: 80\n        - name: admin\n          containerPort: 8080\n        args:\n        - --api\n        - --kubernetes\n        - --logLevel=INFO\n---\nkind: Service\napiVersion: v1\nmetadata:\n  name: traefik-ingress-service\n  namespace: kube-system\nspec:\n  selector:\n    k8s-app: traefik-ingress-lb\n  ports:\n    - protocol: TCP\n      port: 80\n      name: web\n    - protocol: TCP\n      port: 8080\n      name: admin\n  type: NodePort  examples/k8s/traefik-deployment.yaml   Note  The Service will expose two NodePorts which allow access to the ingress and the web interface.   The DaemonSet objects looks not much different:  ---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: traefik-ingress-controller\n  namespace: kube-system\n---\nkind: DaemonSet\napiVersion: apps/v1\nmetadata:\n  name: traefik-ingress-controller\n  namespace: kube-system\n  labels:\n    k8s-app: traefik-ingress-lb\nspec:\n  template:\n    metadata:\n      labels:\n        k8s-app: traefik-ingress-lb\n        name: traefik-ingress-lb\n    spec:\n      serviceAccountName: traefik-ingress-controller\n      terminationGracePeriodSeconds: 60\n      containers:\n      - image: traefik:v1.7\n        name: traefik-ingress-lb\n        ports:\n        - name: http\n          containerPort: 80\n          hostPort: 80\n        - name: admin\n          containerPort: 8080\n        securityContext:\n          capabilities:\n            drop:\n            - ALL\n            add:\n            - NET_BIND_SERVICE\n        args:\n        - --api\n        - --kubernetes\n        - --logLevel=INFO\n---\nkind: Service\napiVersion: v1\nmetadata:\n  name: traefik-ingress-service\n  namespace: kube-system\nspec:\n  selector:\n    k8s-app: traefik-ingress-lb\n  ports:\n    - protocol: TCP\n      port: 80\n      name: web\n    - protocol: TCP\n      port: 8080\n      name: admin  examples/k8s/traefik-ds.yaml   Note  This will create a Daemonset that uses privileged ports 80/8080 on the host. This may not work on all providers, but illustrates the static (non-NodePort) hostPort binding. The  traefik-ingress-service  can still be used inside the cluster to access the DaemonSet pods.   To deploy Traefik to your cluster start by submitting one of the YAML files to the cluster with  kubectl :  kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/traefik-deployment.yaml  kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/traefik-ds.yaml  There are some significant differences between using Deployments and DaemonSets:   The Deployment has easier up and down scaling possibilities.\n    It can implement full pod lifecycle and supports rolling updates from Kubernetes 1.2.\n    At least one Pod is needed to run the Deployment.  The DaemonSet automatically scales to all nodes that meets a specific selector and guarantees to fill nodes one at a time.\n    Rolling updates are fully supported from Kubernetes 1.7 for DaemonSets as well.", 
            "title": "Deploy Traefik using a Deployment or DaemonSet"
        }, 
        {
            "location": "/user-guide/kubernetes/#check-the-pods", 
            "text": "Now lets check if our command was successful.  Start by listing the pods in the  kube-system  namespace:  kubectl --namespace=kube-system get pods  NAME                                         READY     STATUS    RESTARTS   AGE\nkube-addon-manager-minikubevm                1/1       Running   0          4h\nkubernetes-dashboard-s8krj                   1/1       Running   0          4h\ntraefik-ingress-controller-678226159-eqseo   1/1       Running   0          7m  You should see that after submitting the Deployment or DaemonSet to Kubernetes it has launched a Pod, and it is now running. It might take a few moments for Kubernetes to pull the Traefik image and start the container.   Note  You could also check the deployment with the Kubernetes dashboard, run minikube dashboard  to open it in your browser, then choose the  kube-system \nnamespace from the menu at the top right of the screen.   You should now be able to access Traefik on port 80 of your Minikube instance when using the DaemonSet:  curl $(minikube ip)  404 page not found  If you decided to use the deployment, then you need to target the correct NodePort, which can be seen when you execute  kubectl get services --namespace=kube-system .  curl $(minikube ip): NODEPORT   404 page not found   Note  We expect to see a 404 response here as we haven't yet given Traefik any configuration.   All further examples below assume a DaemonSet installation. Deployment users will need to append the NodePort when constructing requests.", 
            "title": "Check the Pods"
        }, 
        {
            "location": "/user-guide/kubernetes/#deploy-traefik-using-helm-chart", 
            "text": "Note  The Helm Chart is maintained by the community, not the Traefik project maintainers.   Instead of installing Traefik via Kubernetes object directly, you can also use the Traefik Helm chart.  Install the Traefik chart by:  helm install stable/traefik  Install the Traefik chart using a values.yaml file.  helm install --values values.yaml stable/traefik  dashboard:\n  enabled: true\n  domain: traefik-ui.minikube\nkubernetes:\n  namespaces:\n    - default\n    - kube-system  For more information, check out  the documentation .", 
            "title": "Deploy Traefik using Helm Chart"
        }, 
        {
            "location": "/user-guide/kubernetes/#submitting-an-ingress-to-the-cluster", 
            "text": "Lets start by creating a Service and an Ingress that will expose the  Traefik Web UI .  apiVersion: v1\nkind: Service\nmetadata:\n  name: traefik-web-ui\n  namespace: kube-system\nspec:\n  selector:\n    k8s-app: traefik-ingress-lb\n  ports:\n  - name: web\n    port: 80\n    targetPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: traefik-web-ui\n  namespace: kube-system\nspec:\n  rules:\n  - host: traefik-ui.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: traefik-web-ui\n          servicePort: web  examples/k8s/ui.yaml  kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/ui.yaml  Now lets setup an entry in our  /etc/hosts  file to route  traefik-ui.minikube  to our cluster.  In production you would want to set up real DNS entries.\nYou can get the IP address of your minikube instance by running  minikube ip :  echo  $(minikube ip) traefik-ui.minikube  | sudo tee -a /etc/hosts  We should now be able to visit  traefik-ui.minikube  in the browser and view the Traefik web UI.", 
            "title": "Submitting an Ingress to the Cluster"
        }, 
        {
            "location": "/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress", 
            "text": "Note  For this example to work you need a TLS entrypoint. You don't have to provide a TLS certificate at this point.\nFor more details see  here .   You can add a TLS entrypoint by adding the following  args  to the container spec:   --defaultentrypoints=http,https\n --entrypoints=Name:https Address::443 TLS\n --entrypoints=Name:http Address::80  To setup an HTTPS-protected ingress, you can leverage the TLS feature of the ingress resource.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: traefik-web-ui\n  namespace: kube-system\n  annotations:\n    kubernetes.io/ingress.class: traefik\nspec:\n  rules:\n  - host: traefik-ui.minikube\n    http:\n      paths:\n      - backend:\n          serviceName: traefik-web-ui\n          servicePort: 80\n  tls:\n   - secretName: traefik-ui-tls-cert  In addition to the modified ingress you need to provide the TLS certificate via a Kubernetes secret in the same namespace as the ingress.\nThe following two commands will generate a new certificate and create a secret containing the key and cert files.  openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj  /CN=traefik-ui.minikube \nkubectl -n kube-system create secret tls traefik-ui-tls-cert --key=tls.key --cert=tls.crt  If there are any errors while loading the TLS section of an ingress, the whole ingress will be skipped.   Note  The secret must have two entries named  tls.key and  tls.crt .\nSee the  Kubernetes documentation  for more details.    Note  The TLS certificates will be added to all entrypoints defined by the ingress annotation  traefik.frontend.entryPoints .\nIf no such annotation is provided, the TLS certificates will be added to all TLS-enabled  defaultEntryPoints .    Note  The field  hosts  in the TLS configuration is ignored. Instead, the domains provided by the certificate are used for this purpose.\nIt is recommended to not use wildcard certificates as they will match globally.", 
            "title": "Add a TLS Certificate to the Ingress"
        }, 
        {
            "location": "/user-guide/kubernetes/#basic-authentication", 
            "text": "It's possible to protect access to Traefik through basic authentication. (See the  Kubernetes Ingress  configuration page for syntactical details and restrictions.)", 
            "title": "Basic Authentication"
        }, 
        {
            "location": "/user-guide/kubernetes/#creating-the-secret", 
            "text": "A. Use  htpasswd  to create a file containing the username and the MD5-encoded password:  htpasswd -c ./auth myusername  You will be prompted for a password which you will have to enter twice. htpasswd  will create a file with the following:  cat auth  myusername:$apr1$78Jyn/1K$ERHKVRPPlzAX8eBtLuvRZ0  B. Now use  kubectl  to create a secret in the  monitoring  namespace using the file created by  htpasswd .  kubectl create secret generic mysecret --from-file auth --namespace=monitoring   Note  Secret must be in same namespace as the Ingress object.   C. Attach the following annotations to the Ingress object:   traefik.ingress.kubernetes.io/auth-type: \"basic\"  traefik.ingress.kubernetes.io/auth-secret: \"mysecret\"   They specify basic authentication and reference the Secret  mysecret  containing the credentials.  Following is a full Ingress example based on Prometheus:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n name: prometheus-dashboard\n namespace: monitoring\n annotations:\n   kubernetes.io/ingress.class: traefik\n   traefik.ingress.kubernetes.io/auth-type:  basic \n   traefik.ingress.kubernetes.io/auth-secret:  mysecret \nspec:\n rules:\n - host: dashboard.prometheus.example.com\n   http:\n     paths:\n     - backend:\n         serviceName: prometheus\n         servicePort: 9090  You can apply the example as following:  kubectl create -f prometheus-ingress.yaml -n monitoring", 
            "title": "Creating the Secret"
        }, 
        {
            "location": "/user-guide/kubernetes/#name-based-routing", 
            "text": "In this example we are going to setup websites for three of the United Kingdoms best loved cheeses: Cheddar, Stilton, and Wensleydale.  First lets start by launching the pods for the cheese websites.  ---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: stilton\n  labels:\n    app: cheese\n    cheese: stilton\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: cheese\n      task: stilton\n  template:\n    metadata:\n      labels:\n        app: cheese\n        task: stilton\n        version: v0.0.1\n    spec:\n      containers:\n      - name: cheese\n        image: errm/cheese:stilton\n        ports:\n        - containerPort: 80\n---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: cheddar\n  labels:\n    app: cheese\n    cheese: cheddar\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: cheese\n      task: cheddar\n  template:\n    metadata:\n      labels:\n        app: cheese\n        task: cheddar\n        version: v0.0.1\n    spec:\n      containers:\n      - name: cheese\n        image: errm/cheese:cheddar\n        ports:\n        - containerPort: 80\n---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: wensleydale\n  labels:\n    app: cheese\n    cheese: wensleydale\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: cheese\n      task: wensleydale\n  template:\n    metadata:\n      labels:\n        app: cheese\n        task: wensleydale\n        version: v0.0.1\n    spec:\n      containers:\n      - name: cheese\n        image: errm/cheese:wensleydale\n        ports:\n        - containerPort: 80  examples/k8s/cheese-deployments.yaml  kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/cheese-deployments.yaml  Next we need to setup a Service for each of the cheese pods.  ---\napiVersion: v1\nkind: Service\nmetadata:\n  name: stilton\nspec:\n  ports:\n  - name: http\n    targetPort: 80\n    port: 80\n  selector:\n    app: cheese\n    task: stilton\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: cheddar\nspec:\n  ports:\n  - name: http\n    targetPort: 80\n    port: 80\n  selector:\n    app: cheese\n    task: cheddar\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: wensleydale\n  annotations:\n    traefik.backend.circuitbreaker:  NetworkErrorRatio()   0.5 \nspec:\n  ports:\n  - name: http\n    targetPort: 80\n    port: 80\n  selector:\n    app: cheese\n    task: wensleydale   Note  We also set a  circuit breaker expression  for one of the backends by setting the  traefik.backend.circuitbreaker  annotation on the service.   examples/k8s/cheese-services.yaml  kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/cheese-services.yaml  Now we can submit an ingress for the cheese websites.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: cheese\n  annotations:\n    kubernetes.io/ingress.class: traefik\nspec:\n  rules:\n  - host: stilton.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: stilton\n          servicePort: http\n  - host: cheddar.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: cheddar\n          servicePort: http\n  - host: wensleydale.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: wensleydale\n          servicePort: http  examples/k8s/cheese-ingress.yaml   Note  We list each hostname, and add a backend service.   kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/cheese-ingress.yaml  Now visit the  Traefik dashboard  and you should see a frontend for each host.\nAlong with a backend listing for each service with a server set up for each pod.  If you edit your  /etc/hosts  again you should be able to access the cheese websites in your browser.  echo  $(minikube ip) stilton.minikube cheddar.minikube wensleydale.minikube  | sudo tee -a /etc/hosts   Stilton  Cheddar  Wensleydale", 
            "title": "Name-based Routing"
        }, 
        {
            "location": "/user-guide/kubernetes/#path-based-routing", 
            "text": "Now lets suppose that our fictional client has decided that while they are super happy about our cheesy web design, when they asked for 3 websites they had not really bargained on having to buy 3 domain names.  No problem, we say, why don't we reconfigure the sites to host all 3 under one domain.  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: cheeses\n  annotations:\n    kubernetes.io/ingress.class: traefik\n    traefik.frontend.rule.type: PathPrefixStrip\nspec:\n  rules:\n  - host: cheeses.minikube\n    http:\n      paths:\n      - path: /stilton\n        backend:\n          serviceName: stilton\n          servicePort: http\n      - path: /cheddar\n        backend:\n          serviceName: cheddar\n          servicePort: http\n      - path: /wensleydale\n        backend:\n          serviceName: wensleydale\n          servicePort: http  examples/k8s/cheeses-ingress.yaml   Note  We are configuring Traefik to strip the prefix from the url path with the  traefik.frontend.rule.type  annotation so that we can use the containers from the previous example without modification.   kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/cheeses-ingress.yaml  echo  $(minikube ip) cheeses.minikube  | sudo tee -a /etc/hosts  You should now be able to visit the websites in your browser.   cheeses.minikube/stilton  cheeses.minikube/cheddar  cheeses.minikube/wensleydale", 
            "title": "Path-based Routing"
        }, 
        {
            "location": "/user-guide/kubernetes/#multiple-ingress-definitions-for-the-same-host-or-hostpath", 
            "text": "Traefik will merge multiple Ingress definitions for the same host/path pair into one definition.  Let's say the number of cheese services is growing.\nIt is now time to move the cheese services to a dedicated cheese namespace to simplify the managements of cheese and non-cheese services.  Simply deploy a new Ingress Object with the same host an path into the cheese namespace:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: cheese\n  namespace: cheese\n  annotations:\n    kubernetes.io/ingress.class: traefik\n    traefik.frontend.rule.type: PathPrefixStrip\nspec:\n  rules:\n  - host: cheese.minikube\n    http:\n      paths:\n      - path: /cheddar\n        backend:\n          serviceName: cheddar\n          servicePort: http  Traefik will now look for cheddar service endpoints (ports on healthy pods) in both the cheese and the default namespace.\nDeploying cheddar into the cheese namespace and afterwards shutting down cheddar in the default namespace is enough to migrate the traffic.   Note  The kubernetes documentation does not specify this merging behavior.    Note  Merging ingress definitions can cause problems if the annotations differ or if the services handle requests differently.\nBe careful and extra cautious when running multiple overlapping ingress definitions.", 
            "title": "Multiple Ingress Definitions for the Same Host (or Host+Path)"
        }, 
        {
            "location": "/user-guide/kubernetes/#specifying-routing-priorities", 
            "text": "Sometimes you need to specify priority for ingress routes, especially when handling wildcard routes.\nThis can be done by adding the  traefik.frontend.priority  annotation, i.e.:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: wildcard-cheeses\n  annotations:\n    traefik.frontend.priority:  1 \nspec:\n  rules:\n  - host: *.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: stilton\n          servicePort: http\n\nkind: Ingress\nmetadata:\n  name: specific-cheeses\n  annotations:\n    traefik.frontend.priority:  2 \nspec:\n  rules:\n  - host: specific.minikube\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: stilton\n          servicePort: http  Note that priority values must be quoted to avoid numeric interpretation (which are illegal for annotations).", 
            "title": "Specifying Routing Priorities"
        }, 
        {
            "location": "/user-guide/kubernetes/#forwarding-to-externalnames", 
            "text": "When specifying an  ExternalName ,\nTraefik will forward requests to the given host accordingly and use HTTPS when the Service port matches 443.\nThis still requires setting up a proper port mapping on the Service from the Ingress port to the (external) Service port.", 
            "title": "Forwarding to ExternalNames"
        }, 
        {
            "location": "/user-guide/kubernetes/#disable-passing-the-host-header", 
            "text": "By default Traefik will pass the incoming Host header to the upstream resource.  However, there are times when you may not want this to be the case. For example, if your service is of the ExternalName type.", 
            "title": "Disable passing the Host Header"
        }, 
        {
            "location": "/user-guide/kubernetes/#disable-globally", 
            "text": "Add the following to your TOML configuration file:  disablePassHostHeaders = true", 
            "title": "Disable globally"
        }, 
        {
            "location": "/user-guide/kubernetes/#disable-per-ingress", 
            "text": "To disable passing the Host header per ingress resource set the  traefik.frontend.passHostHeader  annotation on your ingress to  \"false\" .  Here is an example definition:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: example\n  annotations:\n    kubernetes.io/ingress.class: traefik\n    traefik.frontend.passHostHeader:  false \nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /static\n        backend:\n          serviceName: static\n          servicePort: https  And an example service definition:  apiVersion: v1\nkind: Service\nmetadata:\n  name: static\nspec:\n  ports:\n  - name: https\n    port: 443\n  type: ExternalName\n  externalName: static.otherdomain.com  If you were to visit  example.com/static  the request would then be passed on to  static.otherdomain.com/static , and  static.otherdomain.com  would receive the request with the Host header being  static.otherdomain.com .   Note  The per-ingress annotation overrides whatever the global value is set to.\nSo you could set  disablePassHostHeaders  to  true  in your TOML configuration file and then enable passing the host header per ingress if you wanted.", 
            "title": "Disable per Ingress"
        }, 
        {
            "location": "/user-guide/kubernetes/#partitioning-the-ingress-object-space", 
            "text": "By default, Traefik processes every Ingress objects it observes. At times, however, it may be desirable to ignore certain objects. The following sub-sections describe common use cases and how they can be handled with Traefik.", 
            "title": "Partitioning the Ingress object space"
        }, 
        {
            "location": "/user-guide/kubernetes/#between-traefik-and-other-ingress-controller-implementations", 
            "text": "Sometimes Traefik runs along other Ingress controller implementations. One such example is when both Traefik and a cloud provider Ingress controller are active.  The  kubernetes.io/ingress.class  annotation can be attached to any Ingress object in order to control whether Traefik should handle it.  If the annotation is missing, contains an empty value, or the value  traefik , then the Traefik controller will take responsibility and process the associated Ingress object.  It is also possible to set the  ingressClass  option in Traefik to a particular value. Traefik will only process matching Ingress objects.\nFor instance, setting the option to  traefik-internal  causes Traefik to process Ingress objects with the same  kubernetes.io/ingress.class  annotation value, ignoring all other objects (including those with a  traefik  value, empty value, and missing annotation).   Note  Letting multiple ingress controllers handle the same ingress objects can lead to unintended behavior.\nIt is recommended to prefix all ingressClass values with  traefik  to avoid unintended collisions with other ingress implementations.", 
            "title": "Between Traefik and other Ingress controller implementations"
        }, 
        {
            "location": "/user-guide/kubernetes/#between-multiple-traefik-deployments", 
            "text": "Sometimes multiple Traefik Deployments are supposed to run concurrently.\nFor instance, it is conceivable to have one Deployment deal with internal and another one with external traffic.  For such cases, it is advisable to classify Ingress objects through a label and configure the  labelSelector  option per each Traefik Deployment accordingly.\nTo stick with the internal/external example above, all Ingress objects meant for internal traffic could receive a  traffic-type: internal  label while objects designated for external traffic receive a  traffic-type: external  label.\nThe label selectors on the Traefik Deployments would then be  traffic-type=internal  and  traffic-type=external , respectively.", 
            "title": "Between multiple Traefik Deployments"
        }, 
        {
            "location": "/user-guide/kubernetes/#traffic-splitting", 
            "text": "It is possible to split Ingress traffic in a fine-grained manner between multiple deployments using  service weights .  One canonical use case is canary releases where a deployment representing a newer release is to receive an initially small but ever-increasing fraction of the requests over time.\nThe way this can be done in Traefik is to specify a percentage of requests that should go into each deployment.  For instance, say that an application  my-app  runs in version 1.\nA newer version 2 is about to be released, but confidence in the robustness and reliability of new version running in production can only be gained gradually.\nThus, a new deployment  my-app-canary  is created and scaled to a replica count that suffices for a 1% traffic share.\nAlong with it, a Service object is created as usual.  The Ingress specification would look like this:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-app: 99%\n      my-app-canary: 1%\n  name: my-app\nspec:\n  rules:\n  - http:\n      paths:\n      - backend:\n          serviceName: my-app\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-app-canary\n          servicePort: 80\n        path: /  Take note of the  traefik.ingress.kubernetes.io/service-weights  annotation: It specifies the distribution of requests among the referenced backend services,  my-app  and  my-app-canary .\nWith this definition, Traefik will route 99% of the requests to the pods backed by the  my-app  deployment, and 1% to those backed by  my-app-canary .\nOver time, the ratio may slowly shift towards the canary deployment until it is deemed to replace the previous main application, in steps such as 5%/95%, 10%/90%, 50%/50%, and finally 100%/0%.  A few conditions must hold for service weights to be applied correctly:   The associated service backends must share the same path and host.  The total percentage shared across all service backends must yield 100% (see the section on  omitting the final service , however).  The percentage values are interpreted as floating point numbers to a supported precision as defined in the  annotation documentation .", 
            "title": "Traffic Splitting"
        }, 
        {
            "location": "/user-guide/kubernetes/#omitting-the-final-service", 
            "text": "When specifying service weights, it is possible to omit exactly one service for convenience reasons.  For instance, the following definition shows how to split requests in a scenario where a canary release is accompanied by a baseline deployment for easier metrics comparison or automated canary analysis:  apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-app-canary: 10%\n      my-app-baseline: 10%\n  name: app\nspec:\n  rules:\n  - http:\n      paths:\n      - backend:\n          serviceName: my-app-canary\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-app-baseline\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-app-main\n          servicePort: 80\n        path: /  This configuration assigns 80% of traffic to  my-app-main  automatically, thus freeing the user from having to complete percentage values manually.\nThis becomes handy when increasing shares for canary releases continuously.", 
            "title": "Omitting the Final Service"
        }, 
        {
            "location": "/user-guide/kubernetes/#production-advice", 
            "text": "", 
            "title": "Production advice"
        }, 
        {
            "location": "/user-guide/kubernetes/#resource-limitations", 
            "text": "The examples shown deliberately do not specify any  resource limitations  as there is no one size fits all.  In a production environment, however, it is important to set proper bounds, especially with regards to CPU:   too strict and Traefik will be throttled while serving requests (as Kubernetes imposes hard quotas)  too loose and Traefik may waste resources not available for other containers   When in doubt, you should measure your resource needs, and adjust requests and limits accordingly.", 
            "title": "Resource limitations"
        }, 
        {
            "location": "/user-guide/marathon/", 
            "text": "Marathon\n\n\nThis guide explains how to integrate Marathon and operate the cluster in a reliable way from Traefik's standpoint.\n\n\nHost detection\n\n\nMarathon offers multiple ways to run (Docker-containerized) applications, the most popular ones being\n\n\n\n\nBRIDGE-networked containers with dynamic high ports exposed\n\n\nHOST-networked containers with host machine ports\n\n\ncontainers with dedicated IP addresses (\nIP-per-task\n).\n\n\n\n\nTraefik tries to detect the configured mode and route traffic to the right IP addresses. It is possible to force using task hosts with the \nforceTaskHostname\n option.\n\n\nGiven the complexity of the subject, it is possible that the heuristic fails.\nApart from filing an issue and waiting for the feature request / bug report to get addressed, one workaround for such situations is to customize the Marathon template file to the individual needs.\n\n\n\n\nNote\n\n\nThis does \nnot\n require rebuilding Traefik but only to point the \nfilename\n configuration parameter to a customized version of the \nmarathon.tmpl\n file on Traefik startup.\n\n\n\n\nPort detection\n\n\nTraefik also attempts to determine the right port (which is a \nnon-trivial matter in Marathon\n).\nFollowing is the order by which Traefik tries to identify the port (the first one that yields a positive result will be used):\n\n\n\n\nA arbitrary port specified through the \ntraefik.port\n label.\n\n\nThe task port (possibly indexed through the \ntraefik.portIndex\n label, otherwise the first one).\n\n\nThe port from the application's \nportDefinitions\n field (possibly indexed through the \ntraefik.portIndex\n label, otherwise the first one).\n\n\nThe port from the application's \nipAddressPerTask\n field (possibly indexed through the \ntraefik.portIndex\n label, otherwise the first one).\n\n\n\n\nApplications with multiple ports\n\n\nSome Marathon applications may expose multiple ports. Traefik supports creating one so-called \nsegment\n per port using \nsegment labels\n.\n\n\nFor instance, assume that a Marathon application exposes a web API on port 80 and an admin interface on port 8080. It would then be possible to make each service available by specifying the following Marathon labels:\n\n\ntraefik.web.port=80\n\n\n\n\ntraefik.admin.port=8080\n\n\n\n\n(Note that the service names \nweb\n and \nadmin\n can be chosen arbitrarily.)\n\n\nTechnically, Traefik will create one pair of frontend and backend configurations for each service.\n\n\nAchieving high availability\n\n\nScenarios\n\n\nThere are three scenarios where the availability of a Marathon application could be impaired along with the risk of losing or failing requests:\n\n\n\n\nDuring the startup phase when Traefik already routes requests to the backend even though it has not completed its bootstrapping process yet.\n\n\nDuring the shutdown phase when Traefik still routes requests to the backend while the backend is already terminating.\n\n\nDuring a failure of the application when Traefik has not yet identified the backend as being erroneous.\n\n\n\n\nThe first two scenarios are common with every rolling upgrade of an application (i.e. a new version release or configuration update).\n\n\nThe following sub-sections describe how to resolve or mitigate each scenario.\n\n\nStartup\n\n\nIt is possible to define \nreadiness checks\n (available since Marathon version 1.1) per application and have Marathon take these into account during the startup phase.\n\n\nThe idea is that each application provides an HTTP endpoint that Marathon queries periodically during an ongoing deployment in order to mark the associated readiness check result as successful if and only if the endpoint returns a response within the configured HTTP code range.\n\nAs long as the check keeps failing, Marathon will not proceed with the deployment (within the configured upgrade strategy bounds).\n\n\nBeginning with version 1.4, Traefik respects readiness check results if the Traefik option is set and checks are configured on the applications accordingly.\n\n\n\n\nNote\n\n\nDue to the way readiness check results are currently exposed by the Marathon API, ready tasks may be taken into rotation with a small delay.\nIt is on the order of one readiness check timeout interval (as configured on the application specifiation) and guarantees that non-ready tasks do not receive traffic prematurely.\n\n\n\n\nIf readiness checks are not possible, a current mitigation strategy is to enable \nretries\n and make sure that a sufficient number of healthy application tasks exist so that one retry will likely hit one of those.\nApart from its probabilistic nature, the workaround comes at the price of increased latency.\n\n\nShutdown\n\n\nIt is possible to install a \ntermination handler\n (available since Marathon version 1.3) with each application whose responsibility it is to delay the shutdown process long enough until the backend has been taken out of load-balancing rotation with reasonable confidence (i.e., Traefik has received an update from the Marathon event bus, recomputes the available Marathon backends, and applies the new configuration).\n\nSpecifically, each termination handler should install a signal handler listening for a SIGTERM signal and implement the following steps on signal reception:\n\n\n\n\nDisable Keep-Alive HTTP connections.\n\n\nKeep accepting HTTP requests for a certain period of time.\n\n\nStop accepting new connections.\n\n\nFinish serving any in-flight requests.\n\n\nShut down.\n\n\n\n\nTraefik already ignores Marathon tasks whose state does not match \nTASK_RUNNING\n; since terminating tasks transition into the \nTASK_KILLING\n and eventually \nTASK_KILLED\n state, there is nothing further that needs to be done on Traefik's end.\n\n\nHow long HTTP requests should continue to be accepted in step 2 depends on how long Traefik needs to receive and process the Marathon configuration update.\nUnder regular operational conditions, it should be on the order of seconds, with 10 seconds possibly being a good default value.\n\n\nAgain, configuring Traefik to do retries (as discussed in the previous section) can serve as a decent workaround strategy.\n\nPaired with termination handlers, they would cover for those cases where either the termination sequence or Traefik cannot complete their part of the orchestration process in time.\n\n\nFailure\n\n\nA failing application always happens unexpectedly, and hence, it is very difficult or even impossible to rule out the adversal effects categorically.\n\n\nFailure reasons vary broadly and could stretch from unacceptable slowness, a task crash, or a network split.\n\n\nThere are two mitigaton efforts:\n\n\n\n\nConfigure \nMarathon health checks\n on each application.\n\n\nConfigure Traefik health checks (possibly via the \ntraefik.backend.healthcheck.*\n labels) and make sure they probe with proper frequency.\n\n\n\n\nThe Marathon health check makes sure that applications once deemed dysfunctional are being rescheduled to different slaves.\nHowever, they might take a while to get triggered and the follow-up processes to complete.\n\n\nFor that reason, the Treafik health check provides an additional check that responds more rapidly and does not require a configuration reload to happen.\nAdditionally, it protects from cases that the Marathon health check may not be able to cover, such as a network split.\n\n\n(Non-)Alternatives\n\n\nThere are a few alternatives of varying quality that are frequently asked for.\n\n\nThe remaining section is going to explore them along with a benefit/cost trade-off.\n\n\nReusing Marathon health checks\n\n\nIt may seem obvious to reuse the Marathon health checks as a signal to Traefik whether an application should be taken into load-balancing rotation or not.\n\n\nApart from the increased latency a failing health check may have, a major problem with this is is that Marathon does not persist the health check results.\nConsequently, if a master re-election occurs in the Marathon clusters, all health check results will revert to the \nunknown\n state, effectively causing all applications inside the cluster to become unavailable and leading to a complete cluster failure.\n\nRe-elections do not only happen during regular maintenance work (often requiring rolling upgrades of the Marathon nodes) but also when the Marathon leader fails spontaneously.\nAs such, there is no way to handle this situation deterministically.\n\n\nFinally, Marathon health checks are not mandatory (the default is to use the task state as reported by Mesos), so requiring them for Traefik would raise the entry barrier for Marathon users.\n\n\nTraefik used to use the health check results as a strict requirement but moved away from it as \nusers reported the dramatic consequences\n.\n\n\nDraining\n\n\nAnother common approach is to let a proxy drain backends that are supposed to shut down.\nThat is, once a backend is supposed to shut down, Traefik would stop forwarding requests.\n\n\nOn the plus side, this would not require any modifications to the application in question.\nHowever, implementing this fully within Traefik seems like a non-trivial undertaking.\n\n\nAdditionally, the approach is less flexible compared to a custom termination handler since only the latter allows for the implementation of custom termination sequences that go beyond simple request draining (e.g., persisting a snapshot state to disk prior to terminating).\n\n\nThe feature is currently not implemented; a request for draining in general is at \nissue 41\n.", 
            "title": "Marathon"
        }, 
        {
            "location": "/user-guide/marathon/#marathon", 
            "text": "This guide explains how to integrate Marathon and operate the cluster in a reliable way from Traefik's standpoint.", 
            "title": "Marathon"
        }, 
        {
            "location": "/user-guide/marathon/#host-detection", 
            "text": "Marathon offers multiple ways to run (Docker-containerized) applications, the most popular ones being   BRIDGE-networked containers with dynamic high ports exposed  HOST-networked containers with host machine ports  containers with dedicated IP addresses ( IP-per-task ).   Traefik tries to detect the configured mode and route traffic to the right IP addresses. It is possible to force using task hosts with the  forceTaskHostname  option.  Given the complexity of the subject, it is possible that the heuristic fails.\nApart from filing an issue and waiting for the feature request / bug report to get addressed, one workaround for such situations is to customize the Marathon template file to the individual needs.   Note  This does  not  require rebuilding Traefik but only to point the  filename  configuration parameter to a customized version of the  marathon.tmpl  file on Traefik startup.", 
            "title": "Host detection"
        }, 
        {
            "location": "/user-guide/marathon/#port-detection", 
            "text": "Traefik also attempts to determine the right port (which is a  non-trivial matter in Marathon ).\nFollowing is the order by which Traefik tries to identify the port (the first one that yields a positive result will be used):   A arbitrary port specified through the  traefik.port  label.  The task port (possibly indexed through the  traefik.portIndex  label, otherwise the first one).  The port from the application's  portDefinitions  field (possibly indexed through the  traefik.portIndex  label, otherwise the first one).  The port from the application's  ipAddressPerTask  field (possibly indexed through the  traefik.portIndex  label, otherwise the first one).", 
            "title": "Port detection"
        }, 
        {
            "location": "/user-guide/marathon/#applications-with-multiple-ports", 
            "text": "Some Marathon applications may expose multiple ports. Traefik supports creating one so-called  segment  per port using  segment labels .  For instance, assume that a Marathon application exposes a web API on port 80 and an admin interface on port 8080. It would then be possible to make each service available by specifying the following Marathon labels:  traefik.web.port=80  traefik.admin.port=8080  (Note that the service names  web  and  admin  can be chosen arbitrarily.)  Technically, Traefik will create one pair of frontend and backend configurations for each service.", 
            "title": "Applications with multiple ports"
        }, 
        {
            "location": "/user-guide/marathon/#achieving-high-availability", 
            "text": "", 
            "title": "Achieving high availability"
        }, 
        {
            "location": "/user-guide/marathon/#scenarios", 
            "text": "There are three scenarios where the availability of a Marathon application could be impaired along with the risk of losing or failing requests:   During the startup phase when Traefik already routes requests to the backend even though it has not completed its bootstrapping process yet.  During the shutdown phase when Traefik still routes requests to the backend while the backend is already terminating.  During a failure of the application when Traefik has not yet identified the backend as being erroneous.   The first two scenarios are common with every rolling upgrade of an application (i.e. a new version release or configuration update).  The following sub-sections describe how to resolve or mitigate each scenario.", 
            "title": "Scenarios"
        }, 
        {
            "location": "/user-guide/marathon/#startup", 
            "text": "It is possible to define  readiness checks  (available since Marathon version 1.1) per application and have Marathon take these into account during the startup phase.  The idea is that each application provides an HTTP endpoint that Marathon queries periodically during an ongoing deployment in order to mark the associated readiness check result as successful if and only if the endpoint returns a response within the configured HTTP code range. \nAs long as the check keeps failing, Marathon will not proceed with the deployment (within the configured upgrade strategy bounds).  Beginning with version 1.4, Traefik respects readiness check results if the Traefik option is set and checks are configured on the applications accordingly.   Note  Due to the way readiness check results are currently exposed by the Marathon API, ready tasks may be taken into rotation with a small delay.\nIt is on the order of one readiness check timeout interval (as configured on the application specifiation) and guarantees that non-ready tasks do not receive traffic prematurely.   If readiness checks are not possible, a current mitigation strategy is to enable  retries  and make sure that a sufficient number of healthy application tasks exist so that one retry will likely hit one of those.\nApart from its probabilistic nature, the workaround comes at the price of increased latency.", 
            "title": "Startup"
        }, 
        {
            "location": "/user-guide/marathon/#shutdown", 
            "text": "It is possible to install a  termination handler  (available since Marathon version 1.3) with each application whose responsibility it is to delay the shutdown process long enough until the backend has been taken out of load-balancing rotation with reasonable confidence (i.e., Traefik has received an update from the Marathon event bus, recomputes the available Marathon backends, and applies the new configuration). \nSpecifically, each termination handler should install a signal handler listening for a SIGTERM signal and implement the following steps on signal reception:   Disable Keep-Alive HTTP connections.  Keep accepting HTTP requests for a certain period of time.  Stop accepting new connections.  Finish serving any in-flight requests.  Shut down.   Traefik already ignores Marathon tasks whose state does not match  TASK_RUNNING ; since terminating tasks transition into the  TASK_KILLING  and eventually  TASK_KILLED  state, there is nothing further that needs to be done on Traefik's end.  How long HTTP requests should continue to be accepted in step 2 depends on how long Traefik needs to receive and process the Marathon configuration update.\nUnder regular operational conditions, it should be on the order of seconds, with 10 seconds possibly being a good default value.  Again, configuring Traefik to do retries (as discussed in the previous section) can serve as a decent workaround strategy. \nPaired with termination handlers, they would cover for those cases where either the termination sequence or Traefik cannot complete their part of the orchestration process in time.", 
            "title": "Shutdown"
        }, 
        {
            "location": "/user-guide/marathon/#failure", 
            "text": "A failing application always happens unexpectedly, and hence, it is very difficult or even impossible to rule out the adversal effects categorically.  Failure reasons vary broadly and could stretch from unacceptable slowness, a task crash, or a network split.  There are two mitigaton efforts:   Configure  Marathon health checks  on each application.  Configure Traefik health checks (possibly via the  traefik.backend.healthcheck.*  labels) and make sure they probe with proper frequency.   The Marathon health check makes sure that applications once deemed dysfunctional are being rescheduled to different slaves.\nHowever, they might take a while to get triggered and the follow-up processes to complete.  For that reason, the Treafik health check provides an additional check that responds more rapidly and does not require a configuration reload to happen.\nAdditionally, it protects from cases that the Marathon health check may not be able to cover, such as a network split.", 
            "title": "Failure"
        }, 
        {
            "location": "/user-guide/marathon/#non-alternatives", 
            "text": "There are a few alternatives of varying quality that are frequently asked for.  The remaining section is going to explore them along with a benefit/cost trade-off.", 
            "title": "(Non-)Alternatives"
        }, 
        {
            "location": "/user-guide/marathon/#reusing-marathon-health-checks", 
            "text": "It may seem obvious to reuse the Marathon health checks as a signal to Traefik whether an application should be taken into load-balancing rotation or not.  Apart from the increased latency a failing health check may have, a major problem with this is is that Marathon does not persist the health check results.\nConsequently, if a master re-election occurs in the Marathon clusters, all health check results will revert to the  unknown  state, effectively causing all applications inside the cluster to become unavailable and leading to a complete cluster failure. \nRe-elections do not only happen during regular maintenance work (often requiring rolling upgrades of the Marathon nodes) but also when the Marathon leader fails spontaneously.\nAs such, there is no way to handle this situation deterministically.  Finally, Marathon health checks are not mandatory (the default is to use the task state as reported by Mesos), so requiring them for Traefik would raise the entry barrier for Marathon users.  Traefik used to use the health check results as a strict requirement but moved away from it as  users reported the dramatic consequences .", 
            "title": "Reusing Marathon health checks"
        }, 
        {
            "location": "/user-guide/marathon/#draining", 
            "text": "Another common approach is to let a proxy drain backends that are supposed to shut down.\nThat is, once a backend is supposed to shut down, Traefik would stop forwarding requests.  On the plus side, this would not require any modifications to the application in question.\nHowever, implementing this fully within Traefik seems like a non-trivial undertaking.  Additionally, the approach is less flexible compared to a custom termination handler since only the latter allows for the implementation of custom termination sequences that go beyond simple request draining (e.g., persisting a snapshot state to disk prior to terminating).  The feature is currently not implemented; a request for draining in general is at  issue 41 .", 
            "title": "Draining"
        }, 
        {
            "location": "/user-guide/kv-config/", 
            "text": "Key-value store configuration\n\n\nBoth \nstatic global configuration\n and \ndynamic\n configuration can be stored in a Key-value store.\n\n\nThis section explains how to launch Traefik using a configuration loaded from a Key-value store.\n\n\nTraefik supports several Key-value stores:\n\n\n\n\nConsul\n\n\netcd\n\n\nZooKeeper\n\n\nboltdb\n\n\n\n\nStatic configuration in Key-value store\n\n\nWe will see the steps to set it up with an easy example.\n\n\n\n\nNote\n\n\nWe could do the same with any other Key-value Store.\n\n\n\n\ndocker-compose file for Consul\n\n\nThe Traefik global configuration will be retrieved from a \nConsul\n store.\n\n\nFirst we have to launch Consul in a container.\n\n\nThe \ndocker-compose file\n allows us to launch Consul and four instances of the trivial app \ncontainous/whoami\n :\n\n\nconsul:\n  image: progrium/consul\n  command: -server -bootstrap -log-level debug -ui-dir /ui\n  ports:\n    - \n8400:8400\n\n    - \n8500:8500\n\n    - \n8600:53/udp\n\n  expose:\n    - \n8300\n\n    - \n8301\n\n    - \n8301/udp\n\n    - \n8302\n\n    - \n8302/udp\n\n\nwhoami1:\n  image: containous/whoami\n\nwhoami2:\n  image: containous/whoami\n\nwhoami3:\n  image: containous/whoami\n\nwhoami4:\n  image: containous/whoami\n\n\n\n\nUpload the configuration in the Key-value store\n\n\nWe should now fill the store with the Traefik global configuration.\n\nTo do that, we can send the Key-value pairs via \ncurl commands\n or via the \nWeb UI\n.\n\n\nFortunately, Traefik allows automation of this process using the \nstoreconfig\n subcommand.\n\nPlease refer to the \nstore Traefik configuration\n section to get documentation on it.\n\n\nHere is the toml configuration we would like to store in the Key-value Store  :\n\n\nlogLevel = \nDEBUG\n\n\ndefaultEntryPoints = [\nhttp\n, \nhttps\n]\n\n[entryPoints]\n  [entryPoints.api]\n    address = \n:8081\n\n  [entryPoints.http]\n  address = \n:80\n\n  [entryPoints.https]\n  address = \n:443\n\n\n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile = \nintegration/fixtures/https/snitest.com.cert\n\n      keyFile = \nintegration/fixtures/https/snitest.com.key\n\n      [[entryPoints.https.tls.certificates]]\n      certFile = \n-----BEGIN CERTIFICATE-----\n                      \ncert file content\n\n                      -----END CERTIFICATE-----\n\n      keyFile = \n-----BEGIN PRIVATE KEY-----\n                      \nkey file content\n\n                      -----END PRIVATE KEY-----\n\n    [entryPoints.other-https]\n    address = \n:4443\n\n      [entryPoints.other-https.tls]\n\n[consul]\n  endpoint = \n127.0.0.1:8500\n\n  watch = true\n  prefix = \ntraefik\n\n\n[api]\n  entrypoint = \napi\n\n\n\n\n\nAnd there, the same global configuration in the Key-value Store (using \nprefix = \"traefik\"\n):\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\n\n\n\n\n/traefik/loglevel\n\n\nDEBUG\n\n\n\n\n\n\n/traefik/defaultentrypoints/0\n\n\nhttp\n\n\n\n\n\n\n/traefik/defaultentrypoints/1\n\n\nhttps\n\n\n\n\n\n\n/traefik/entrypoints/api/address\n\n\n:8081\n\n\n\n\n\n\n/traefik/entrypoints/http/address\n\n\n:80\n\n\n\n\n\n\n/traefik/entrypoints/https/address\n\n\n:443\n\n\n\n\n\n\n/traefik/entrypoints/https/tls/certificates/0/certfile\n\n\nintegration/fixtures/https/snitest.com.cert\n\n\n\n\n\n\n/traefik/entrypoints/https/tls/certificates/0/keyfile\n\n\nintegration/fixtures/https/snitest.com.key\n\n\n\n\n\n\n/traefik/entrypoints/https/tls/certificates/1/certfile\n\n\n--BEGIN CERTIFICATE--\ncert file content\n--END CERTIFICATE--\n\n\n\n\n\n\n/traefik/entrypoints/https/tls/certificates/1/keyfile\n\n\n--BEGIN CERTIFICATE--\nkey file content\n--END CERTIFICATE--\n\n\n\n\n\n\n/traefik/entrypoints/other-https/address\n\n\n:4443\n\n\n\n\n\n\n/traefik/consul/endpoint\n\n\n127.0.0.1:8500\n\n\n\n\n\n\n/traefik/consul/watch\n\n\ntrue\n\n\n\n\n\n\n/traefik/consul/prefix\n\n\ntraefik\n\n\n\n\n\n\n/traefik/api/entrypoint\n\n\napi\n\n\n\n\n\n\n\n\nIn case you are setting key values manually:\n\n\n\n\nRemember to specify the indexes (\n0\n,\n1\n, \n2\n, ... ) under prefixes \n/traefik/defaultentrypoints/\n and \n/traefik/entrypoints/https/tls/certificates/\n in order to match the global configuration structure.\n\n\nBe careful to give the correct IP address and port on the key \n/traefik/consul/endpoint\n.\n\n\n\n\nNote that we can either give path to certificate file or directly the file content itself.\n\n\nLaunch Traefik\n\n\nWe will now launch Traefik in a container.\n\n\nWe use CLI flags to setup the connection between Traefik and Consul.\nAll the rest of the global configuration is stored in Consul.\n\n\nHere is the \ndocker-compose file\n :\n\n\ntraefik:\n  image: traefik:\nstable v1.7 from https://hub.docker.com/_/traefik\n\n  command: --consul --consul.endpoint=127.0.0.1:8500\n  ports:\n    - \n80:80\n\n    - \n8080:8080\n\n\n\n\n\n\n\nWarning\n\n\nBe careful to give the correct IP address and port in the flag \n--consul.endpoint\n.\n\n\n\n\nConsul ACL Token support\n\n\nTo specify a Consul ACL token for Traefik, we have to set a System Environment variable named \nCONSUL_HTTP_TOKEN\n prior to starting Traefik.\nThis variable must be initialized with the ACL token value.\n\n\nIf Traefik is launched into a Docker container, the variable \nCONSUL_HTTP_TOKEN\n can be initialized with the \n-e\n Docker option : \n-e \"CONSUL_HTTP_TOKEN=[consul-acl-token-value]\"\n\n\nIf a Consul ACL is used to restrict Traefik read/write access, one of the following configurations is needed.\n\n\n\n\nHCL format :\n\n\n\n\n    key \ntraefik\n {\n        policy = \nwrite\n\n    },\n\n    session \n {\n        policy = \nwrite\n\n    }\n\n\n\n\n\n\nJSON format :\n\n\n\n\n{\n    \nkey\n: {\n        \ntraefik\n: {\n          \npolicy\n: \nwrite\n\n        }\n    },\n    \nsession\n: {\n        \n: {\n        \npolicy\n: \nwrite\n\n        }\n    }\n}\n\n\n\n\nTLS support\n\n\nTo connect to a Consul endpoint using SSL, simply specify \nhttps://\n in the \nconsul.endpoint\n property\n\n\n\n\n--consul.endpoint=https://[consul-host]:[consul-ssl-port]\n\n\n\n\nTLS support with client certificates\n\n\nSo far, only \nConsul\n and \netcd\n support TLS connections with client certificates.\n\n\nTo set it up, we should enable \nconsul security\n (or \netcd security\n).\n\n\nThen, we have to provide CA, Cert and Key to Traefik using \nconsul\n flags :\n\n\n\n\n--consul.tls\n\n\n--consul.tls.ca=path/to/the/file\n\n\n--consul.tls.cert=path/to/the/file\n\n\n--consul.tls.key=path/to/the/file\n\n\n\n\nOr etcd flags :\n\n\n\n\n--etcd.tls\n\n\n--etcd.tls.ca=path/to/the/file\n\n\n--etcd.tls.cert=path/to/the/file\n\n\n--etcd.tls.key=path/to/the/file\n\n\n\n\n!! note\n    We can either give directly directly the file content itself (instead of the path to certificate) in a TOML file configuration.\n\n\nRemember the command \ntraefik --help\n to display the updated list of flags.\n\n\nDynamic configuration in Key-value store\n\n\nFollowing our example, we will provide backends/frontends  rules and HTTPS certificates to Traefik.\n\n\n\n\nNote\n\n\nThis section is independent of the way Traefik got its static configuration.\nIt means that the static configuration can either come from the same Key-value store or from any other sources.\n\n\n\n\nKey-value storage structure\n\n\nHere is the toml configuration we would like to store in the store :\n\n\n[file]\n\n# rules\n[backends]\n  [backends.backend1]\n    [backends.backend1.circuitbreaker]\n    expression = \nNetworkErrorRatio() \n 0.5\n\n    [backends.backend1.servers.server1]\n    url = \nhttp://172.17.0.2:80\n\n    weight = 10\n    [backends.backend1.servers.server2]\n    url = \nhttp://172.17.0.3:80\n\n    weight = 1\n  [backends.backend2]\n    [backends.backend1.maxconn]\n    amount = 10\n    extractorfunc = \nrequest.host\n\n    [backends.backend2.LoadBalancer]\n    method = \ndrr\n\n    [backends.backend2.servers.server1]\n    url = \nhttp://172.17.0.4:80\n\n    weight = 1\n    [backends.backend2.servers.server2]\n    url = \nhttp://172.17.0.5:80\n\n    weight = 2\n\n[frontends]\n  [frontends.frontend1]\n  backend = \nbackend2\n\n    [frontends.frontend1.routes.test_1]\n    rule = \nHost:test.localhost\n\n  [frontends.frontend2]\n  backend = \nbackend1\n\n  passHostHeader = true\n  priority = 10\n      [frontends.frontend2.auth.basic]\n      users = [\n        \ntest:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\n,\n        \ntest2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\n,\n      ]\n  entrypoints = [\nhttps\n] # overrides defaultEntryPoints\n    [frontends.frontend2.routes.test_1]\n    rule = \nHost:{subdomain:[a-z]+}.localhost\n\n  [frontends.frontend3]\n  entrypoints = [\nhttp\n, \nhttps\n] # overrides defaultEntryPoints\n  backend = \nbackend2\n\n  rule = \nPath:/test\n\n\n[[tls]]\n  [tls.certificate]\n    certFile = \npath/to/your.cert\n\n    keyFile = \npath/to/your.key\n\n\n[[tls]]\n  entryPoints = [\nhttps\n,\nother-https\n]\n  [tls.certificate]\n    certFile = \n-----BEGIN CERTIFICATE-----\n                      \ncert file content\n\n                      -----END CERTIFICATE-----\n\n    keyFile = \n-----BEGIN CERTIFICATE-----\n                      \nkey file content\n\n                      -----END CERTIFICATE-----\n\n\n\n\n\nAnd there, the same dynamic configuration in a KV Store (using \nprefix = \"traefik\"\n):\n\n\n\n\nbackend 1\n\n\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\n\n\n\n\n/traefik/backends/backend1/circuitbreaker/expression\n\n\nNetworkErrorRatio() \n 0.5\n\n\n\n\n\n\n/traefik/backends/backend1/servers/server1/url\n\n\nhttp://172.17.0.2:80\n\n\n\n\n\n\n/traefik/backends/backend1/servers/server1/weight\n\n\n10\n\n\n\n\n\n\n/traefik/backends/backend1/servers/server2/url\n\n\nhttp://172.17.0.3:80\n\n\n\n\n\n\n/traefik/backends/backend1/servers/server2/weight\n\n\n1\n\n\n\n\n\n\n/traefik/backends/backend1/servers/server2/tags\n\n\napi,helloworld\n\n\n\n\n\n\n\n\n\n\nbackend 2\n\n\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\n\n\n\n\n/traefik/backends/backend2/maxconn/amount\n\n\n10\n\n\n\n\n\n\n/traefik/backends/backend2/maxconn/extractorfunc\n\n\nrequest.host\n\n\n\n\n\n\n/traefik/backends/backend2/loadbalancer/method\n\n\ndrr\n\n\n\n\n\n\n/traefik/backends/backend2/servers/server1/url\n\n\nhttp://172.17.0.4:80\n\n\n\n\n\n\n/traefik/backends/backend2/servers/server1/weight\n\n\n1\n\n\n\n\n\n\n/traefik/backends/backend2/servers/server2/url\n\n\nhttp://172.17.0.5:80\n\n\n\n\n\n\n/traefik/backends/backend2/servers/server2/weight\n\n\n2\n\n\n\n\n\n\n/traefik/backends/backend2/servers/server2/tags\n\n\nweb\n\n\n\n\n\n\n\n\n\n\nfrontend 1\n\n\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\n\n\n\n\n/traefik/frontends/frontend1/backend\n\n\nbackend2\n\n\n\n\n\n\n/traefik/frontends/frontend1/routes/test_1/rule\n\n\nHost:test.localhost\n\n\n\n\n\n\n\n\n\n\nfrontend 2\n\n\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\n\n\n\n\n/traefik/frontends/frontend2/backend\n\n\nbackend1\n\n\n\n\n\n\n/traefik/frontends/frontend2/passhostheader\n\n\ntrue\n\n\n\n\n\n\n/traefik/frontends/frontend2/priority\n\n\n10\n\n\n\n\n\n\n/traefik/frontends/frontend2/auth/basic/users/0\n\n\ntest:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\n\n\n\n\n\n\n/traefik/frontends/frontend2/auth/basic/users/1\n\n\ntest2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\n\n\n\n\n\n\n/traefik/frontends/frontend2/entrypoints\n\n\nhttp,https\n\n\n\n\n\n\n/traefik/frontends/frontend2/routes/test_2/rule\n\n\nPathPrefix:/test\n\n\n\n\n\n\n\n\n\n\ncertificate 1\n\n\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\n\n\n\n\n/traefik/tls/1/certificate/certfile\n\n\npath/to/your.cert\n\n\n\n\n\n\n/traefik/tls/1/certificate/keyfile\n\n\npath/to/your.key\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nAs \n/traefik/tls/1/entrypoints\n is not defined, the certificate will be attached to all \ndefaulEntryPoints\n with a TLS configuration (in the example, the entryPoint \nhttps\n)\n\n\n\n\n\n\ncertificate 2\n\n\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\n\n\n\n\n/traefik/tls/2/entrypoints\n\n\nhttps,other-https\n\n\n\n\n\n\n/traefik/tls/2/certificate/certfile\n\n\ncert file content\n\n\n\n\n\n\n/traefik/tls/2/certificate/keyfile\n\n\nkey file content\n\n\n\n\n\n\n\n\nAtomic configuration changes\n\n\nTraefik can watch the backends/frontends configuration changes and generate its configuration automatically.\n\n\n\n\nNote\n\n\nOnly backends/frontends rules are dynamic, the rest of the Traefik configuration stay static.\n\n\n\n\nThe \nEtcd\n and \nConsul\n backends do not support updating multiple keys atomically.\n\nAs a result, it may be possible for Traefik to read an intermediate configuration state despite judicious use of the \n--providersThrottleDuration\n flag.\n\nTo solve this problem, Traefik supports a special key called \n/traefik/alias\n.\nIf set, Traefik use the value as an alternative key prefix.\n\n\n\n\nNote\n\n\nThe field \nuseAPIV3\n allows using Etcd V3 API which should support updating multiple keys atomically with Etcd.\nEtcd API V2 is deprecated and, in the future, Traefik will support API V3 by default.\n\n\n\n\nGiven the key structure below, Traefik will use the \nhttp://172.17.0.2:80\n as its only backend (frontend keys have been omitted for brevity).\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\n\n\n\n\n/traefik/alias\n\n\n/traefik_configurations/1\n\n\n\n\n\n\n/traefik_configurations/1/backends/backend1/servers/server1/url\n\n\nhttp://172.17.0.2:80\n\n\n\n\n\n\n/traefik_configurations/1/backends/backend1/servers/server1/weight\n\n\n10\n\n\n\n\n\n\n\n\nWhen an atomic configuration change is required, you may write a new configuration at an alternative prefix.\n\n\nHere, although the \n/traefik_configurations/2/...\n keys have been set, the old configuration is still active because the \n/traefik/alias\n key still points to \n/traefik_configurations/1\n:\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\n\n\n\n\n/traefik/alias\n\n\n/traefik_configurations/1\n\n\n\n\n\n\n/traefik_configurations/1/backends/backend1/servers/server1/url\n\n\nhttp://172.17.0.2:80\n\n\n\n\n\n\n/traefik_configurations/1/backends/backend1/servers/server1/weight\n\n\n10\n\n\n\n\n\n\n/traefik_configurations/2/backends/backend1/servers/server1/url\n\n\nhttp://172.17.0.2:80\n\n\n\n\n\n\n/traefik_configurations/2/backends/backend1/servers/server1/weight\n\n\n5\n\n\n\n\n\n\n/traefik_configurations/2/backends/backend1/servers/server2/url\n\n\nhttp://172.17.0.3:80\n\n\n\n\n\n\n/traefik_configurations/2/backends/backend1/servers/server2/weight\n\n\n5\n\n\n\n\n\n\n\n\nOnce the \n/traefik/alias\n key is updated, the new \n/traefik_configurations/2\n configuration becomes active atomically.\n\n\nHere, we have a 50% balance between the \nhttp://172.17.0.3:80\n and the \nhttp://172.17.0.4:80\n hosts while no traffic is sent to the \n172.17.0.2:80\n host:\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\n\n\n\n\n\n\n\n\n/traefik/alias\n\n\n/traefik_configurations/2\n\n\n\n\n\n\n/traefik_configurations/1/backends/backend1/servers/server1/url\n\n\nhttp://172.17.0.2:80\n\n\n\n\n\n\n/traefik_configurations/1/backends/backend1/servers/server1/weight\n\n\n10\n\n\n\n\n\n\n/traefik_configurations/2/backends/backend1/servers/server1/url\n\n\nhttp://172.17.0.3:80\n\n\n\n\n\n\n/traefik_configurations/2/backends/backend1/servers/server1/weight\n\n\n5\n\n\n\n\n\n\n/traefik_configurations/2/backends/backend1/servers/server2/url\n\n\nhttp://172.17.0.4:80\n\n\n\n\n\n\n/traefik_configurations/2/backends/backend1/servers/server2/weight\n\n\n5\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nTraefik \nwill not watch for key changes in the \n/traefik_configurations\n prefix\n. It will only watch for changes in the \n/traefik/alias\n.\n\nFurther, if the \n/traefik/alias\n key is set, all other configuration with \n/traefik/backends\n or \n/traefik/frontends\n prefix are ignored.\n\n\n\n\nStore configuration in Key-value store\n\n\n\n\nNote\n\n\nDon't forget to \nsetup the connection between Traefik and Key-value store\n.\n\n\n\n\nThe static Traefik configuration in a key-value store can be automatically created and updated, using the \nstoreconfig\n subcommand\n.\n\n\ntraefik storeconfig [flags] ...\n\n\n\n\nThis command is here only to automate the \nprocess which upload the configuration into the Key-value store\n.\nTraefik will not start but the \nstatic configuration\n will be uploaded into the Key-value store.  \n\n\nIf you configured ACME (Let's Encrypt), your registration account and your certificates will also be uploaded.\n\n\nIf you configured a file provider \n[file]\n, all your dynamic configuration (backends, frontends...) will be uploaded to the Key-value store.\n\n\nTo upload your ACME certificates to the KV store, get your Traefik TOML file and add the new \nstorage\n option in the \nacme\n section:\n\n\n[acme]\nemail = \ntest@traefik.io\n\nstorage = \ntraefik/acme/account\n # the key where to store your certificates in the KV store\nstorageFile = \nacme.json\n # your old certificates store\n\n\n\n\nCall \ntraefik\u00a0storeconfig\n to upload your config in the KV store.\nThen remove the line \nstorageFile = \"acme.json\"\n from your TOML config file.\n\n\nThat's it!", 
            "title": "Key-value Store Configuration"
        }, 
        {
            "location": "/user-guide/kv-config/#key-value-store-configuration", 
            "text": "Both  static global configuration  and  dynamic  configuration can be stored in a Key-value store.  This section explains how to launch Traefik using a configuration loaded from a Key-value store.  Traefik supports several Key-value stores:   Consul  etcd  ZooKeeper  boltdb", 
            "title": "Key-value store configuration"
        }, 
        {
            "location": "/user-guide/kv-config/#static-configuration-in-key-value-store", 
            "text": "We will see the steps to set it up with an easy example.   Note  We could do the same with any other Key-value Store.", 
            "title": "Static configuration in Key-value store"
        }, 
        {
            "location": "/user-guide/kv-config/#docker-compose-file-for-consul", 
            "text": "The Traefik global configuration will be retrieved from a  Consul  store.  First we have to launch Consul in a container.  The  docker-compose file  allows us to launch Consul and four instances of the trivial app  containous/whoami  :  consul:\n  image: progrium/consul\n  command: -server -bootstrap -log-level debug -ui-dir /ui\n  ports:\n    -  8400:8400 \n    -  8500:8500 \n    -  8600:53/udp \n  expose:\n    -  8300 \n    -  8301 \n    -  8301/udp \n    -  8302 \n    -  8302/udp \n\nwhoami1:\n  image: containous/whoami\n\nwhoami2:\n  image: containous/whoami\n\nwhoami3:\n  image: containous/whoami\n\nwhoami4:\n  image: containous/whoami", 
            "title": "docker-compose file for Consul"
        }, 
        {
            "location": "/user-guide/kv-config/#upload-the-configuration-in-the-key-value-store", 
            "text": "We should now fill the store with the Traefik global configuration. \nTo do that, we can send the Key-value pairs via  curl commands  or via the  Web UI .  Fortunately, Traefik allows automation of this process using the  storeconfig  subcommand. \nPlease refer to the  store Traefik configuration  section to get documentation on it.  Here is the toml configuration we would like to store in the Key-value Store  :  logLevel =  DEBUG \n\ndefaultEntryPoints = [ http ,  https ]\n\n[entryPoints]\n  [entryPoints.api]\n    address =  :8081 \n  [entryPoints.http]\n  address =  :80 \n  [entryPoints.https]\n  address =  :443 \n\n    [entryPoints.https.tls]\n      [[entryPoints.https.tls.certificates]]\n      certFile =  integration/fixtures/https/snitest.com.cert \n      keyFile =  integration/fixtures/https/snitest.com.key \n      [[entryPoints.https.tls.certificates]]\n      certFile =  -----BEGIN CERTIFICATE-----\n                       cert file content \n                      -----END CERTIFICATE----- \n      keyFile =  -----BEGIN PRIVATE KEY-----\n                       key file content \n                      -----END PRIVATE KEY----- \n    [entryPoints.other-https]\n    address =  :4443 \n      [entryPoints.other-https.tls]\n\n[consul]\n  endpoint =  127.0.0.1:8500 \n  watch = true\n  prefix =  traefik \n\n[api]\n  entrypoint =  api   And there, the same global configuration in the Key-value Store (using  prefix = \"traefik\" ):     Key  Value      /traefik/loglevel  DEBUG    /traefik/defaultentrypoints/0  http    /traefik/defaultentrypoints/1  https    /traefik/entrypoints/api/address  :8081    /traefik/entrypoints/http/address  :80    /traefik/entrypoints/https/address  :443    /traefik/entrypoints/https/tls/certificates/0/certfile  integration/fixtures/https/snitest.com.cert    /traefik/entrypoints/https/tls/certificates/0/keyfile  integration/fixtures/https/snitest.com.key    /traefik/entrypoints/https/tls/certificates/1/certfile  --BEGIN CERTIFICATE-- cert file content --END CERTIFICATE--    /traefik/entrypoints/https/tls/certificates/1/keyfile  --BEGIN CERTIFICATE-- key file content --END CERTIFICATE--    /traefik/entrypoints/other-https/address  :4443    /traefik/consul/endpoint  127.0.0.1:8500    /traefik/consul/watch  true    /traefik/consul/prefix  traefik    /traefik/api/entrypoint  api     In case you are setting key values manually:   Remember to specify the indexes ( 0 , 1 ,  2 , ... ) under prefixes  /traefik/defaultentrypoints/  and  /traefik/entrypoints/https/tls/certificates/  in order to match the global configuration structure.  Be careful to give the correct IP address and port on the key  /traefik/consul/endpoint .   Note that we can either give path to certificate file or directly the file content itself.", 
            "title": "Upload the configuration in the Key-value store"
        }, 
        {
            "location": "/user-guide/kv-config/#launch-traefik", 
            "text": "We will now launch Traefik in a container.  We use CLI flags to setup the connection between Traefik and Consul.\nAll the rest of the global configuration is stored in Consul.  Here is the  docker-compose file  :  traefik:\n  image: traefik: stable v1.7 from https://hub.docker.com/_/traefik \n  command: --consul --consul.endpoint=127.0.0.1:8500\n  ports:\n    -  80:80 \n    -  8080:8080    Warning  Be careful to give the correct IP address and port in the flag  --consul.endpoint .", 
            "title": "Launch Traefik"
        }, 
        {
            "location": "/user-guide/kv-config/#consul-acl-token-support", 
            "text": "To specify a Consul ACL token for Traefik, we have to set a System Environment variable named  CONSUL_HTTP_TOKEN  prior to starting Traefik.\nThis variable must be initialized with the ACL token value.  If Traefik is launched into a Docker container, the variable  CONSUL_HTTP_TOKEN  can be initialized with the  -e  Docker option :  -e \"CONSUL_HTTP_TOKEN=[consul-acl-token-value]\"  If a Consul ACL is used to restrict Traefik read/write access, one of the following configurations is needed.   HCL format :       key  traefik  {\n        policy =  write \n    },\n\n    session   {\n        policy =  write \n    }   JSON format :   {\n     key : {\n         traefik : {\n           policy :  write \n        }\n    },\n     session : {\n         : {\n         policy :  write \n        }\n    }\n}", 
            "title": "Consul ACL Token support"
        }, 
        {
            "location": "/user-guide/kv-config/#tls-support", 
            "text": "To connect to a Consul endpoint using SSL, simply specify  https://  in the  consul.endpoint  property   --consul.endpoint=https://[consul-host]:[consul-ssl-port]", 
            "title": "TLS support"
        }, 
        {
            "location": "/user-guide/kv-config/#tls-support-with-client-certificates", 
            "text": "So far, only  Consul  and  etcd  support TLS connections with client certificates.  To set it up, we should enable  consul security  (or  etcd security ).  Then, we have to provide CA, Cert and Key to Traefik using  consul  flags :   --consul.tls  --consul.tls.ca=path/to/the/file  --consul.tls.cert=path/to/the/file  --consul.tls.key=path/to/the/file   Or etcd flags :   --etcd.tls  --etcd.tls.ca=path/to/the/file  --etcd.tls.cert=path/to/the/file  --etcd.tls.key=path/to/the/file   !! note\n    We can either give directly directly the file content itself (instead of the path to certificate) in a TOML file configuration.  Remember the command  traefik --help  to display the updated list of flags.", 
            "title": "TLS support with client certificates"
        }, 
        {
            "location": "/user-guide/kv-config/#dynamic-configuration-in-key-value-store", 
            "text": "Following our example, we will provide backends/frontends  rules and HTTPS certificates to Traefik.   Note  This section is independent of the way Traefik got its static configuration.\nIt means that the static configuration can either come from the same Key-value store or from any other sources.", 
            "title": "Dynamic configuration in Key-value store"
        }, 
        {
            "location": "/user-guide/kv-config/#key-value-storage-structure", 
            "text": "Here is the toml configuration we would like to store in the store :  [file]\n\n# rules\n[backends]\n  [backends.backend1]\n    [backends.backend1.circuitbreaker]\n    expression =  NetworkErrorRatio()   0.5 \n    [backends.backend1.servers.server1]\n    url =  http://172.17.0.2:80 \n    weight = 10\n    [backends.backend1.servers.server2]\n    url =  http://172.17.0.3:80 \n    weight = 1\n  [backends.backend2]\n    [backends.backend1.maxconn]\n    amount = 10\n    extractorfunc =  request.host \n    [backends.backend2.LoadBalancer]\n    method =  drr \n    [backends.backend2.servers.server1]\n    url =  http://172.17.0.4:80 \n    weight = 1\n    [backends.backend2.servers.server2]\n    url =  http://172.17.0.5:80 \n    weight = 2\n\n[frontends]\n  [frontends.frontend1]\n  backend =  backend2 \n    [frontends.frontend1.routes.test_1]\n    rule =  Host:test.localhost \n  [frontends.frontend2]\n  backend =  backend1 \n  passHostHeader = true\n  priority = 10\n      [frontends.frontend2.auth.basic]\n      users = [\n         test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ ,\n         test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 ,\n      ]\n  entrypoints = [ https ] # overrides defaultEntryPoints\n    [frontends.frontend2.routes.test_1]\n    rule =  Host:{subdomain:[a-z]+}.localhost \n  [frontends.frontend3]\n  entrypoints = [ http ,  https ] # overrides defaultEntryPoints\n  backend =  backend2 \n  rule =  Path:/test \n\n[[tls]]\n  [tls.certificate]\n    certFile =  path/to/your.cert \n    keyFile =  path/to/your.key \n\n[[tls]]\n  entryPoints = [ https , other-https ]\n  [tls.certificate]\n    certFile =  -----BEGIN CERTIFICATE-----\n                       cert file content \n                      -----END CERTIFICATE----- \n    keyFile =  -----BEGIN CERTIFICATE-----\n                       key file content \n                      -----END CERTIFICATE-----   And there, the same dynamic configuration in a KV Store (using  prefix = \"traefik\" ):   backend 1      Key  Value      /traefik/backends/backend1/circuitbreaker/expression  NetworkErrorRatio()   0.5    /traefik/backends/backend1/servers/server1/url  http://172.17.0.2:80    /traefik/backends/backend1/servers/server1/weight  10    /traefik/backends/backend1/servers/server2/url  http://172.17.0.3:80    /traefik/backends/backend1/servers/server2/weight  1    /traefik/backends/backend1/servers/server2/tags  api,helloworld      backend 2      Key  Value      /traefik/backends/backend2/maxconn/amount  10    /traefik/backends/backend2/maxconn/extractorfunc  request.host    /traefik/backends/backend2/loadbalancer/method  drr    /traefik/backends/backend2/servers/server1/url  http://172.17.0.4:80    /traefik/backends/backend2/servers/server1/weight  1    /traefik/backends/backend2/servers/server2/url  http://172.17.0.5:80    /traefik/backends/backend2/servers/server2/weight  2    /traefik/backends/backend2/servers/server2/tags  web      frontend 1      Key  Value      /traefik/frontends/frontend1/backend  backend2    /traefik/frontends/frontend1/routes/test_1/rule  Host:test.localhost      frontend 2      Key  Value      /traefik/frontends/frontend2/backend  backend1    /traefik/frontends/frontend2/passhostheader  true    /traefik/frontends/frontend2/priority  10    /traefik/frontends/frontend2/auth/basic/users/0  test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/    /traefik/frontends/frontend2/auth/basic/users/1  test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0    /traefik/frontends/frontend2/entrypoints  http,https    /traefik/frontends/frontend2/routes/test_2/rule  PathPrefix:/test      certificate 1      Key  Value      /traefik/tls/1/certificate/certfile  path/to/your.cert    /traefik/tls/1/certificate/keyfile  path/to/your.key      Note  As  /traefik/tls/1/entrypoints  is not defined, the certificate will be attached to all  defaulEntryPoints  with a TLS configuration (in the example, the entryPoint  https )    certificate 2      Key  Value      /traefik/tls/2/entrypoints  https,other-https    /traefik/tls/2/certificate/certfile  cert file content    /traefik/tls/2/certificate/keyfile  key file content", 
            "title": "Key-value storage structure"
        }, 
        {
            "location": "/user-guide/kv-config/#atomic-configuration-changes", 
            "text": "Traefik can watch the backends/frontends configuration changes and generate its configuration automatically.   Note  Only backends/frontends rules are dynamic, the rest of the Traefik configuration stay static.   The  Etcd  and  Consul  backends do not support updating multiple keys atomically. \nAs a result, it may be possible for Traefik to read an intermediate configuration state despite judicious use of the  --providersThrottleDuration  flag. \nTo solve this problem, Traefik supports a special key called  /traefik/alias .\nIf set, Traefik use the value as an alternative key prefix.   Note  The field  useAPIV3  allows using Etcd V3 API which should support updating multiple keys atomically with Etcd.\nEtcd API V2 is deprecated and, in the future, Traefik will support API V3 by default.   Given the key structure below, Traefik will use the  http://172.17.0.2:80  as its only backend (frontend keys have been omitted for brevity).     Key  Value      /traefik/alias  /traefik_configurations/1    /traefik_configurations/1/backends/backend1/servers/server1/url  http://172.17.0.2:80    /traefik_configurations/1/backends/backend1/servers/server1/weight  10     When an atomic configuration change is required, you may write a new configuration at an alternative prefix.  Here, although the  /traefik_configurations/2/...  keys have been set, the old configuration is still active because the  /traefik/alias  key still points to  /traefik_configurations/1 :     Key  Value      /traefik/alias  /traefik_configurations/1    /traefik_configurations/1/backends/backend1/servers/server1/url  http://172.17.0.2:80    /traefik_configurations/1/backends/backend1/servers/server1/weight  10    /traefik_configurations/2/backends/backend1/servers/server1/url  http://172.17.0.2:80    /traefik_configurations/2/backends/backend1/servers/server1/weight  5    /traefik_configurations/2/backends/backend1/servers/server2/url  http://172.17.0.3:80    /traefik_configurations/2/backends/backend1/servers/server2/weight  5     Once the  /traefik/alias  key is updated, the new  /traefik_configurations/2  configuration becomes active atomically.  Here, we have a 50% balance between the  http://172.17.0.3:80  and the  http://172.17.0.4:80  hosts while no traffic is sent to the  172.17.0.2:80  host:     Key  Value      /traefik/alias  /traefik_configurations/2    /traefik_configurations/1/backends/backend1/servers/server1/url  http://172.17.0.2:80    /traefik_configurations/1/backends/backend1/servers/server1/weight  10    /traefik_configurations/2/backends/backend1/servers/server1/url  http://172.17.0.3:80    /traefik_configurations/2/backends/backend1/servers/server1/weight  5    /traefik_configurations/2/backends/backend1/servers/server2/url  http://172.17.0.4:80    /traefik_configurations/2/backends/backend1/servers/server2/weight  5      Note  Traefik  will not watch for key changes in the  /traefik_configurations  prefix . It will only watch for changes in the  /traefik/alias . \nFurther, if the  /traefik/alias  key is set, all other configuration with  /traefik/backends  or  /traefik/frontends  prefix are ignored.", 
            "title": "Atomic configuration changes"
        }, 
        {
            "location": "/user-guide/kv-config/#store-configuration-in-key-value-store", 
            "text": "Note  Don't forget to  setup the connection between Traefik and Key-value store .   The static Traefik configuration in a key-value store can be automatically created and updated, using the  storeconfig  subcommand .  traefik storeconfig [flags] ...  This command is here only to automate the  process which upload the configuration into the Key-value store .\nTraefik will not start but the  static configuration  will be uploaded into the Key-value store.    If you configured ACME (Let's Encrypt), your registration account and your certificates will also be uploaded.  If you configured a file provider  [file] , all your dynamic configuration (backends, frontends...) will be uploaded to the Key-value store.  To upload your ACME certificates to the KV store, get your Traefik TOML file and add the new  storage  option in the  acme  section:  [acme]\nemail =  test@traefik.io \nstorage =  traefik/acme/account  # the key where to store your certificates in the KV store\nstorageFile =  acme.json  # your old certificates store  Call  traefik\u00a0storeconfig  to upload your config in the KV store.\nThen remove the line  storageFile = \"acme.json\"  from your TOML config file.  That's it!", 
            "title": "Store configuration in Key-value store"
        }, 
        {
            "location": "/user-guide/cluster/", 
            "text": "Clustering / High Availability (beta)\n\n\nThis guide explains how to use Traefik in high availability mode.\n\n\nIn order to deploy and configure multiple Traefik instances, without copying the same configuration file on each instance, we will use a distributed Key-Value store.\n\n\nPrerequisites\n\n\nYou will need a working KV store cluster.\n\n(Currently, we recommend \nConsul\n .)\n\n\nFile configuration to KV store migration\n\n\nWe created a special Traefik command to help configuring your Key Value store from a Traefik TOML configuration file.\n\n\nPlease refer to \nthis section\n to get more details.\n\n\nDeploy a Traefik cluster\n\n\nOnce your Traefik configuration is uploaded on your KV store, you can start each Traefik instance.\n\n\nA Traefik cluster is based on a manager/worker model.\n\n\nWhen starting, Traefik will elect a manager.\nIf this instance fails, another manager will be automatically elected.\n\n\nTraefik cluster and Let's Encrypt\n\n\nIn cluster mode, ACME certificates have to be stored in \na KV Store entry\n.\n\n\nThanks to the Traefik cluster mode algorithm (based on \nthe Raft Consensus Algorithm\n), only one instance will contact Let's encrypt to solve the challenges.\n\n\nThe others instances will get ACME certificate from the KV Store entry.", 
            "title": "Clustering/HA"
        }, 
        {
            "location": "/user-guide/cluster/#clustering-high-availability-beta", 
            "text": "This guide explains how to use Traefik in high availability mode.  In order to deploy and configure multiple Traefik instances, without copying the same configuration file on each instance, we will use a distributed Key-Value store.", 
            "title": "Clustering / High Availability (beta)"
        }, 
        {
            "location": "/user-guide/cluster/#prerequisites", 
            "text": "You will need a working KV store cluster. (Currently, we recommend  Consul  .)", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/user-guide/cluster/#file-configuration-to-kv-store-migration", 
            "text": "We created a special Traefik command to help configuring your Key Value store from a Traefik TOML configuration file.  Please refer to  this section  to get more details.", 
            "title": "File configuration to KV store migration"
        }, 
        {
            "location": "/user-guide/cluster/#deploy-a-traefik-cluster", 
            "text": "Once your Traefik configuration is uploaded on your KV store, you can start each Traefik instance.  A Traefik cluster is based on a manager/worker model.  When starting, Traefik will elect a manager.\nIf this instance fails, another manager will be automatically elected.", 
            "title": "Deploy a Traefik cluster"
        }, 
        {
            "location": "/user-guide/cluster/#traefik-cluster-and-lets-encrypt", 
            "text": "In cluster mode, ACME certificates have to be stored in  a KV Store entry .  Thanks to the Traefik cluster mode algorithm (based on  the Raft Consensus Algorithm ), only one instance will contact Let's encrypt to solve the challenges.  The others instances will get ACME certificate from the KV Store entry.", 
            "title": "Traefik cluster and Let's Encrypt"
        }, 
        {
            "location": "/user-guide/grpc/", 
            "text": "gRPC examples\n\n\nWith HTTP (h2c)\n\n\nThis section explains how to use Traefik as reverse proxy for gRPC application.\n\n\nTraefik configuration\n\n\nAt last, we configure our Traefik instance to use both self-signed certificates.\n\n\ndefaultEntryPoints = [\nhttps\n]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \n:80\n\n\n[api]\n\n[file]\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.servers.server1]\n    # Access on backend with h2c\n    url = \nh2c://backend.local:8080\n\n\n\n[frontends]\n  [frontends.frontend1]\n  backend = \nbackend1\n\n    [frontends.frontend1.routes.test_1]\n    rule = \nHost:frontend.local\n\n\n\n\n\n\n\nWarning\n\n\nFor provider with label, you will have to specify the \ntraefik.protocol=h2c\n\n\n\n\nConclusion\n\n\nWe don't need specific configuration to use gRPC in Traefik, we just need to use \nh2c\n protocol, or use HTTPS communications to have HTTP2 with the backend.\n\n\nWith HTTPS\n\n\nThis section explains how to use Traefik as reverse proxy for gRPC application with self-signed certificates.\n\n\n\n\ngRPC Server certificate\n\n\nIn order to secure the gRPC server, we generate a self-signed certificate for backend url:\n\n\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ./backend.key -out ./backend.cert\n\n\n\n\nThat will prompt for information, the important answer is:\n\n\nCommon Name (e.g. server FQDN or YOUR name) []: backend.local\n\n\n\n\ngRPC Client certificate\n\n\nGenerate your self-signed certificate for frontend url:\n\n\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ./frontend.key -out ./frontend.cert\n\n\n\n\nwith\n\n\nCommon Name (e.g. server FQDN or YOUR name) []: frontend.local\n\n\n\n\nTraefik configuration\n\n\nAt last, we configure our Traefik instance to use both self-signed certificates.\n\n\ndefaultEntryPoints = [\nhttps\n]\n\n# For secure connection on backend.local\nrootCAs = [ \n./backend.cert\n ]\n\n[entryPoints]\n  [entryPoints.https]\n  address = \n:4443\n\n    [entryPoints.https.tls]\n     # For secure connection on frontend.local\n     [[entryPoints.https.tls.certificates]]\n     certFile = \n./frontend.cert\n\n     keyFile  = \n./frontend.key\n\n\n\n[api]\n\n[file]\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.servers.server1]\n    # Access on backend with HTTPS\n    url = \nhttps://backend.local:8080\n\n\n\n[frontends]\n  [frontends.frontend1]\n  backend = \nbackend1\n\n    [frontends.frontend1.routes.test_1]\n    rule = \nHost:frontend.local\n\n\n\n\n\n\n\nWarning\n\n\nWith some backends, the server URLs use the IP, so you may need to configure \ninsecureSkipVerify\n instead of the \nrootCAS\n to activate HTTPS without hostname verification.\n\n\n\n\nA gRPC example in go (modify for https)\n\n\nWe use the gRPC greeter example in \ngrpc-go\n\n\n\n\nWarning\n\n\nIn order to use this gRPC example, we need to modify it to use HTTPS\n\n\n\n\nSo we modify the \"gRPC server example\" to use our own self-signed certificate:\n\n\n// ...\n\n// Read cert and key file\nBackendCert, _ := ioutil.ReadFile(\n./backend.cert\n)\nBackendKey, _ := ioutil.ReadFile(\n./backend.key\n)\n\n// Generate Certificate struct\ncert, err := tls.X509KeyPair(BackendCert, BackendKey)\nif err != nil {\n  log.Fatalf(\nfailed to parse certificate: %v\n, err)\n}\n\n// Create credentials\ncreds := credentials.NewServerTLSFromCert(\ncert)\n\n// Use Credentials in gRPC server options\nserverOption := grpc.Creds(creds)\nvar s *grpc.Server = grpc.NewServer(serverOption)\ndefer s.Stop()\n\npb.RegisterGreeterServer(s, \nserver{})\nerr := s.Serve(lis)\n\n// ...\n\n\n\n\nNext we will modify gRPC Client to use our Traefik self-signed certificate:\n\n\n// ...\n\n// Read cert file\nFrontendCert, _ := ioutil.ReadFile(\n./frontend.cert\n)\n\n// Create CertPool\nroots := x509.NewCertPool()\nroots.AppendCertsFromPEM(FrontendCert)\n\n// Create credentials\ncredsClient := credentials.NewClientTLSFromCert(roots, \n)\n\n// Dial with specific Transport (with credentials)\nconn, err := grpc.Dial(\nfrontend.local:4443\n, grpc.WithTransportCredentials(credsClient))\nif err != nil {\n    log.Fatalf(\ndid not connect: %v\n, err)\n}\n\ndefer conn.Close()\nclient := pb.NewGreeterClient(conn)\n\nname := \nWorld\n\nr, err := client.SayHello(context.Background(), \npb.HelloRequest{Name: name})\n\n// ...", 
            "title": "gRPC Example"
        }, 
        {
            "location": "/user-guide/grpc/#grpc-examples", 
            "text": "", 
            "title": "gRPC examples"
        }, 
        {
            "location": "/user-guide/grpc/#with-http-h2c", 
            "text": "This section explains how to use Traefik as reverse proxy for gRPC application.", 
            "title": "With HTTP (h2c)"
        }, 
        {
            "location": "/user-guide/grpc/#traefik-configuration", 
            "text": "At last, we configure our Traefik instance to use both self-signed certificates.  defaultEntryPoints = [ https ]\n\n[entryPoints]\n  [entryPoints.http]\n  address =  :80 \n\n[api]\n\n[file]\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.servers.server1]\n    # Access on backend with h2c\n    url =  h2c://backend.local:8080 \n\n\n[frontends]\n  [frontends.frontend1]\n  backend =  backend1 \n    [frontends.frontend1.routes.test_1]\n    rule =  Host:frontend.local    Warning  For provider with label, you will have to specify the  traefik.protocol=h2c", 
            "title": "Traefik configuration"
        }, 
        {
            "location": "/user-guide/grpc/#conclusion", 
            "text": "We don't need specific configuration to use gRPC in Traefik, we just need to use  h2c  protocol, or use HTTPS communications to have HTTP2 with the backend.", 
            "title": "Conclusion"
        }, 
        {
            "location": "/user-guide/grpc/#with-https", 
            "text": "This section explains how to use Traefik as reverse proxy for gRPC application with self-signed certificates.", 
            "title": "With HTTPS"
        }, 
        {
            "location": "/user-guide/grpc/#grpc-server-certificate", 
            "text": "In order to secure the gRPC server, we generate a self-signed certificate for backend url:  openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ./backend.key -out ./backend.cert  That will prompt for information, the important answer is:  Common Name (e.g. server FQDN or YOUR name) []: backend.local", 
            "title": "gRPC Server certificate"
        }, 
        {
            "location": "/user-guide/grpc/#grpc-client-certificate", 
            "text": "Generate your self-signed certificate for frontend url:  openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ./frontend.key -out ./frontend.cert  with  Common Name (e.g. server FQDN or YOUR name) []: frontend.local", 
            "title": "gRPC Client certificate"
        }, 
        {
            "location": "/user-guide/grpc/#traefik-configuration_1", 
            "text": "At last, we configure our Traefik instance to use both self-signed certificates.  defaultEntryPoints = [ https ]\n\n# For secure connection on backend.local\nrootCAs = [  ./backend.cert  ]\n\n[entryPoints]\n  [entryPoints.https]\n  address =  :4443 \n    [entryPoints.https.tls]\n     # For secure connection on frontend.local\n     [[entryPoints.https.tls.certificates]]\n     certFile =  ./frontend.cert \n     keyFile  =  ./frontend.key \n\n\n[api]\n\n[file]\n\n[backends]\n  [backends.backend1]\n    [backends.backend1.servers.server1]\n    # Access on backend with HTTPS\n    url =  https://backend.local:8080 \n\n\n[frontends]\n  [frontends.frontend1]\n  backend =  backend1 \n    [frontends.frontend1.routes.test_1]\n    rule =  Host:frontend.local    Warning  With some backends, the server URLs use the IP, so you may need to configure  insecureSkipVerify  instead of the  rootCAS  to activate HTTPS without hostname verification.", 
            "title": "Traefik configuration"
        }, 
        {
            "location": "/user-guide/grpc/#a-grpc-example-in-go-modify-for-https", 
            "text": "We use the gRPC greeter example in  grpc-go   Warning  In order to use this gRPC example, we need to modify it to use HTTPS   So we modify the \"gRPC server example\" to use our own self-signed certificate:  // ...\n\n// Read cert and key file\nBackendCert, _ := ioutil.ReadFile( ./backend.cert )\nBackendKey, _ := ioutil.ReadFile( ./backend.key )\n\n// Generate Certificate struct\ncert, err := tls.X509KeyPair(BackendCert, BackendKey)\nif err != nil {\n  log.Fatalf( failed to parse certificate: %v , err)\n}\n\n// Create credentials\ncreds := credentials.NewServerTLSFromCert( cert)\n\n// Use Credentials in gRPC server options\nserverOption := grpc.Creds(creds)\nvar s *grpc.Server = grpc.NewServer(serverOption)\ndefer s.Stop()\n\npb.RegisterGreeterServer(s,  server{})\nerr := s.Serve(lis)\n\n// ...  Next we will modify gRPC Client to use our Traefik self-signed certificate:  // ...\n\n// Read cert file\nFrontendCert, _ := ioutil.ReadFile( ./frontend.cert )\n\n// Create CertPool\nroots := x509.NewCertPool()\nroots.AppendCertsFromPEM(FrontendCert)\n\n// Create credentials\ncredsClient := credentials.NewClientTLSFromCert(roots,  )\n\n// Dial with specific Transport (with credentials)\nconn, err := grpc.Dial( frontend.local:4443 , grpc.WithTransportCredentials(credsClient))\nif err != nil {\n    log.Fatalf( did not connect: %v , err)\n}\n\ndefer conn.Close()\nclient := pb.NewGreeterClient(conn)\n\nname :=  World \nr, err := client.SayHello(context.Background(),  pb.HelloRequest{Name: name})\n\n// ...", 
            "title": "A gRPC example in go (modify for https)"
        }, 
        {
            "location": "/user-guide/cluster-docker-consul/", 
            "text": "Clustering / High Availability on Docker Swarm with Consul\n\n\nThis guide explains how to use Traefik in high availability mode in a Docker Swarm and with Let's Encrypt.\n\n\nWhy do we need Traefik in cluster mode? Running multiple instances should work out of the box?\n\n\nIf you want to use Let's Encrypt with Traefik, sharing configuration or TLS certificates between many Traefik instances, you need Traefik cluster/HA.\n\n\nOk, could we mount a shared volume used by all my instances? Yes, you can, but it will not work.\nWhen you use Let's Encrypt, you need to store certificates, but not only.\nWhen Traefik generates a new certificate, it configures a challenge and once Let's Encrypt will verify the ownership of the domain, it will ping back the challenge.\nIf the challenge is not known by other Traefik instances, the validation will fail.\n\n\nFor more information about the challenge: \nAutomatic Certificate Management Environment (ACME)\n\n\nPrerequisites\n\n\nYou will need a working Docker Swarm cluster.\n\n\nTraefik configuration\n\n\nIn this guide, we will not use a TOML configuration file, but only command line flag.\nWith that, we can use the base image without mounting configuration file or building custom image.\n\n\nWhat Traefik should do:\n\n\n\n\nListen to 80 and 443\n\n\nRedirect HTTP traffic to HTTPS\n\n\nGenerate SSL certificate when a domain is added\n\n\nListen to Docker Swarm event\n\n\n\n\nEntryPoints configuration\n\n\nTL;DR:\n\n\n$ traefik \\\n    --entrypoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n    --entrypoints='Name:https Address::443 TLS' \\\n    --defaultentrypoints=http,https\n\n\n\n\nTo listen to different ports, we need to create an entry point for each.\n\n\nThe CLI syntax is \n--entrypoints='Name:a_name Address:an_ip_or_empty:a_port options'\n.\nIf you want to redirect traffic from one entry point to another, it's the option \nRedirect.EntryPoint:entrypoint_name\n.\n\n\nBy default, we don't want to configure all our services to listen on http and https, we add a default entry point configuration: \n--defaultentrypoints=http,https\n.\n\n\nLet's Encrypt configuration\n\n\nTL;DR:\n\n\n$ traefik \\\n    --acme \\\n    --acme.storage=/etc/traefik/acme/acme.json \\\n    --acme.entryPoint=https \\\n    --acme.httpChallenge.entryPoint=http \\\n    --acme.email=contact@mydomain.ca\n\n\n\n\nLet's Encrypt needs 4 parameters: an TLS entry point to listen to, a non-TLS entry point to allow HTTP challenges, a storage for certificates, and an email for the registration.\n\n\nTo enable Let's Encrypt support, you need to add \n--acme\n flag.\n\n\nNow, Traefik needs to know where to store the certificates, we can choose between a key in a Key-Value store, or a file path: \n--acme.storage=my/key\n or \n--acme.storage=/path/to/acme.json\n.\n\n\nThe \nacme.httpChallenge.entryPoint\n flag enables the \nHTTP-01\n challenge and specifies the entryPoint to use during the challenges.\n\n\nFor your email and the entry point, it's \n--acme.entryPoint\n and \n--acme.email\n flags.\n\n\nDocker configuration\n\n\nTL;DR:\n\n\n$ traefik \\\n    --docker \\\n    --docker.swarmMode \\\n    --docker.domain=mydomain.ca \\\n    --docker.watch\n\n\n\n\nTo enable docker and swarm-mode support, you need to add \n--docker\n and \n--docker.swarmMode\n flags.\nTo watch docker events, add \n--docker.watch\n.\n\n\nFull docker-compose file\n\n\nversion: \n3\n\nservices:\n  traefik:\n    image: traefik:\nstable v1.7 from https://hub.docker.com/_/traefik\n\n    command:\n      - \n--api\n\n      - \n--entrypoints=Name:http Address::80 Redirect.EntryPoint:https\n\n      - \n--entrypoints=Name:https Address::443 TLS\n\n      - \n--defaultentrypoints=http,https\n\n      - \n--acme\n\n      - \n--acme.storage=/etc/traefik/acme/acme.json\n\n      - \n--acme.entryPoint=https\n\n      - \n--acme.httpChallenge.entryPoint=http\n\n      - \n--acme.onHostRule=true\n\n      - \n--acme.onDemand=false\n\n      - \n--acme.email=contact@mydomain.ca\n\n      - \n--docker\n\n      - \n--docker.swarmMode\n\n      - \n--docker.domain=mydomain.ca\n\n      - \n--docker.watch\n\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    networks:\n      - webgateway\n      - traefik\n    ports:\n      - target: 80\n        published: 80\n        mode: host\n      - target: 443\n        published: 443\n        mode: host\n      - target: 8080\n        published: 8080\n        mode: host\n    deploy:\n      mode: global\n      placement:\n        constraints:\n          - node.role == manager\n      update_config:\n        parallelism: 1\n        delay: 10s\n      restart_policy:\n        condition: on-failure\nnetworks:\n  webgateway:\n    driver: overlay\n    external: true\n  traefik:\n    driver: overlay\n\n\n\n\nMigrate configuration to Consul\n\n\nWe created a special Traefik command to help configuring your Key Value store from a Traefik TOML configuration file and/or CLI flags.\n\n\nDeploy a Traefik cluster\n\n\nThe best way we found is to have an initializer service.\nThis service will push the config to Consul via the \nstoreconfig\n sub-command.\n\n\nThis service will retry until finishing without error because Consul may not be ready when the service tries to push the configuration.\n\n\nThe initializer in a docker-compose file will be:\n\n\n  traefik_init:\n    image: traefik:\nstable v1.7 from https://hub.docker.com/_/traefik\n\n    command:\n      - \nstoreconfig\n\n      - \n--api\n\n      [...]\n      - \n--consul\n\n      - \n--consul.endpoint=consul:8500\n\n      - \n--consul.prefix=traefik\n\n    networks:\n      - traefik\n    deploy:\n      restart_policy:\n        condition: on-failure\n    depends_on:\n      - consul\n\n\n\n\nAnd now, the Traefik part will only have the Consul configuration.\n\n\n  traefik:\n    image: traefik:\nstable v1.7 from https://hub.docker.com/_/traefik\n\n    depends_on:\n      - traefik_init\n      - consul\n    command:\n      - \n--consul\n\n      - \n--consul.endpoint=consul:8500\n\n      - \n--consul.prefix=traefik\n\n    [...]\n\n\n\n\n\n\nNote\n\n\nFor Traefik \n1.5.0 add \nacme.storage=traefik/acme/account\n because Traefik is not reading it from Consul.\n\n\n\n\nIf you have some update to do, update the initializer service and re-deploy it.\nThe new configuration will be stored in Consul, and you need to restart the Traefik node: \ndocker service update --force traefik_traefik\n.\n\n\nFull docker-compose file\n\n\nversion: \n3.4\n\nservices:\n  traefik_init:\n    image: traefik:\nstable v1.7 from https://hub.docker.com/_/traefik\n\n    command:\n      - \nstoreconfig\n\n      - \n--api\n\n      - \n--entrypoints=Name:http Address::80 Redirect.EntryPoint:https\n\n      - \n--entrypoints=Name:https Address::443 TLS\n\n      - \n--defaultentrypoints=http,https\n\n      - \n--acme\n\n      - \n--acme.storage=traefik/acme/account\n\n      - \n--acme.entryPoint=https\n\n      - \n--acme.httpChallenge.entryPoint=http\n\n      - \n--acme.onHostRule=true\n\n      - \n--acme.onDemand=false\n\n      - \n--acme.email=foobar@example.com\n\n      - \n--docker\n\n      - \n--docker.swarmMode\n\n      - \n--docker.domain=example.com\n\n      - \n--docker.watch\n\n      - \n--consul\n\n      - \n--consul.endpoint=consul:8500\n\n      - \n--consul.prefix=traefik\n\n    networks:\n      - traefik\n    deploy:\n      restart_policy:\n        condition: on-failure\n    depends_on:\n      - consul\n  traefik:\n    image: traefik:\nstable v1.7 from https://hub.docker.com/_/traefik\n\n    depends_on:\n      - traefik_init\n      - consul\n    command:\n      - \n--consul\n\n      - \n--consul.endpoint=consul:8500\n\n      - \n--consul.prefix=traefik\n\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    networks:\n      - webgateway\n      - traefik\n    ports:\n      - target: 80\n        published: 80\n        mode: host\n      - target: 443\n        published: 443\n        mode: host\n      - target: 8080\n        published: 8080\n        mode: host\n    deploy:\n      mode: global\n      placement:\n        constraints:\n          - node.role == manager\n      update_config:\n        parallelism: 1\n        delay: 10s\n      restart_policy:\n        condition: on-failure\n  consul:\n    image: consul\n    command: agent -server -bootstrap-expect=1\n    volumes:\n      - consul-data:/consul/data\n    environment:\n      - CONSUL_LOCAL_CONFIG={\ndatacenter\n:\nus_east2\n,\nserver\n:true}\n      - CONSUL_BIND_INTERFACE=eth0\n      - CONSUL_CLIENT_INTERFACE=eth0\n    deploy:\n      replicas: 1\n      placement:\n        constraints:\n          - node.role == manager\n      restart_policy:\n        condition: on-failure\n    networks:\n      - traefik\n\nnetworks:\n  webgateway:\n    driver: overlay\n    external: true\n  traefik:\n    driver: overlay\n\nvolumes:\n  consul-data:\n      driver: [not local]", 
            "title": "Traefik cluster example with Swarm"
        }, 
        {
            "location": "/user-guide/cluster-docker-consul/#clustering-high-availability-on-docker-swarm-with-consul", 
            "text": "This guide explains how to use Traefik in high availability mode in a Docker Swarm and with Let's Encrypt.  Why do we need Traefik in cluster mode? Running multiple instances should work out of the box?  If you want to use Let's Encrypt with Traefik, sharing configuration or TLS certificates between many Traefik instances, you need Traefik cluster/HA.  Ok, could we mount a shared volume used by all my instances? Yes, you can, but it will not work.\nWhen you use Let's Encrypt, you need to store certificates, but not only.\nWhen Traefik generates a new certificate, it configures a challenge and once Let's Encrypt will verify the ownership of the domain, it will ping back the challenge.\nIf the challenge is not known by other Traefik instances, the validation will fail.  For more information about the challenge:  Automatic Certificate Management Environment (ACME)", 
            "title": "Clustering / High Availability on Docker Swarm with Consul"
        }, 
        {
            "location": "/user-guide/cluster-docker-consul/#prerequisites", 
            "text": "You will need a working Docker Swarm cluster.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/user-guide/cluster-docker-consul/#traefik-configuration", 
            "text": "In this guide, we will not use a TOML configuration file, but only command line flag.\nWith that, we can use the base image without mounting configuration file or building custom image.  What Traefik should do:   Listen to 80 and 443  Redirect HTTP traffic to HTTPS  Generate SSL certificate when a domain is added  Listen to Docker Swarm event", 
            "title": "Traefik configuration"
        }, 
        {
            "location": "/user-guide/cluster-docker-consul/#entrypoints-configuration", 
            "text": "TL;DR:  $ traefik \\\n    --entrypoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n    --entrypoints='Name:https Address::443 TLS' \\\n    --defaultentrypoints=http,https  To listen to different ports, we need to create an entry point for each.  The CLI syntax is  --entrypoints='Name:a_name Address:an_ip_or_empty:a_port options' .\nIf you want to redirect traffic from one entry point to another, it's the option  Redirect.EntryPoint:entrypoint_name .  By default, we don't want to configure all our services to listen on http and https, we add a default entry point configuration:  --defaultentrypoints=http,https .", 
            "title": "EntryPoints configuration"
        }, 
        {
            "location": "/user-guide/cluster-docker-consul/#lets-encrypt-configuration", 
            "text": "TL;DR:  $ traefik \\\n    --acme \\\n    --acme.storage=/etc/traefik/acme/acme.json \\\n    --acme.entryPoint=https \\\n    --acme.httpChallenge.entryPoint=http \\\n    --acme.email=contact@mydomain.ca  Let's Encrypt needs 4 parameters: an TLS entry point to listen to, a non-TLS entry point to allow HTTP challenges, a storage for certificates, and an email for the registration.  To enable Let's Encrypt support, you need to add  --acme  flag.  Now, Traefik needs to know where to store the certificates, we can choose between a key in a Key-Value store, or a file path:  --acme.storage=my/key  or  --acme.storage=/path/to/acme.json .  The  acme.httpChallenge.entryPoint  flag enables the  HTTP-01  challenge and specifies the entryPoint to use during the challenges.  For your email and the entry point, it's  --acme.entryPoint  and  --acme.email  flags.", 
            "title": "Let's Encrypt configuration"
        }, 
        {
            "location": "/user-guide/cluster-docker-consul/#docker-configuration", 
            "text": "TL;DR:  $ traefik \\\n    --docker \\\n    --docker.swarmMode \\\n    --docker.domain=mydomain.ca \\\n    --docker.watch  To enable docker and swarm-mode support, you need to add  --docker  and  --docker.swarmMode  flags.\nTo watch docker events, add  --docker.watch .", 
            "title": "Docker configuration"
        }, 
        {
            "location": "/user-guide/cluster-docker-consul/#full-docker-compose-file", 
            "text": "version:  3 \nservices:\n  traefik:\n    image: traefik: stable v1.7 from https://hub.docker.com/_/traefik \n    command:\n      -  --api \n      -  --entrypoints=Name:http Address::80 Redirect.EntryPoint:https \n      -  --entrypoints=Name:https Address::443 TLS \n      -  --defaultentrypoints=http,https \n      -  --acme \n      -  --acme.storage=/etc/traefik/acme/acme.json \n      -  --acme.entryPoint=https \n      -  --acme.httpChallenge.entryPoint=http \n      -  --acme.onHostRule=true \n      -  --acme.onDemand=false \n      -  --acme.email=contact@mydomain.ca \n      -  --docker \n      -  --docker.swarmMode \n      -  --docker.domain=mydomain.ca \n      -  --docker.watch \n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    networks:\n      - webgateway\n      - traefik\n    ports:\n      - target: 80\n        published: 80\n        mode: host\n      - target: 443\n        published: 443\n        mode: host\n      - target: 8080\n        published: 8080\n        mode: host\n    deploy:\n      mode: global\n      placement:\n        constraints:\n          - node.role == manager\n      update_config:\n        parallelism: 1\n        delay: 10s\n      restart_policy:\n        condition: on-failure\nnetworks:\n  webgateway:\n    driver: overlay\n    external: true\n  traefik:\n    driver: overlay", 
            "title": "Full docker-compose file"
        }, 
        {
            "location": "/user-guide/cluster-docker-consul/#migrate-configuration-to-consul", 
            "text": "We created a special Traefik command to help configuring your Key Value store from a Traefik TOML configuration file and/or CLI flags.", 
            "title": "Migrate configuration to Consul"
        }, 
        {
            "location": "/user-guide/cluster-docker-consul/#deploy-a-traefik-cluster", 
            "text": "The best way we found is to have an initializer service.\nThis service will push the config to Consul via the  storeconfig  sub-command.  This service will retry until finishing without error because Consul may not be ready when the service tries to push the configuration.  The initializer in a docker-compose file will be:    traefik_init:\n    image: traefik: stable v1.7 from https://hub.docker.com/_/traefik \n    command:\n      -  storeconfig \n      -  --api \n      [...]\n      -  --consul \n      -  --consul.endpoint=consul:8500 \n      -  --consul.prefix=traefik \n    networks:\n      - traefik\n    deploy:\n      restart_policy:\n        condition: on-failure\n    depends_on:\n      - consul  And now, the Traefik part will only have the Consul configuration.    traefik:\n    image: traefik: stable v1.7 from https://hub.docker.com/_/traefik \n    depends_on:\n      - traefik_init\n      - consul\n    command:\n      -  --consul \n      -  --consul.endpoint=consul:8500 \n      -  --consul.prefix=traefik \n    [...]   Note  For Traefik  1.5.0 add  acme.storage=traefik/acme/account  because Traefik is not reading it from Consul.   If you have some update to do, update the initializer service and re-deploy it.\nThe new configuration will be stored in Consul, and you need to restart the Traefik node:  docker service update --force traefik_traefik .", 
            "title": "Deploy a Traefik cluster"
        }, 
        {
            "location": "/user-guide/cluster-docker-consul/#full-docker-compose-file_1", 
            "text": "version:  3.4 \nservices:\n  traefik_init:\n    image: traefik: stable v1.7 from https://hub.docker.com/_/traefik \n    command:\n      -  storeconfig \n      -  --api \n      -  --entrypoints=Name:http Address::80 Redirect.EntryPoint:https \n      -  --entrypoints=Name:https Address::443 TLS \n      -  --defaultentrypoints=http,https \n      -  --acme \n      -  --acme.storage=traefik/acme/account \n      -  --acme.entryPoint=https \n      -  --acme.httpChallenge.entryPoint=http \n      -  --acme.onHostRule=true \n      -  --acme.onDemand=false \n      -  --acme.email=foobar@example.com \n      -  --docker \n      -  --docker.swarmMode \n      -  --docker.domain=example.com \n      -  --docker.watch \n      -  --consul \n      -  --consul.endpoint=consul:8500 \n      -  --consul.prefix=traefik \n    networks:\n      - traefik\n    deploy:\n      restart_policy:\n        condition: on-failure\n    depends_on:\n      - consul\n  traefik:\n    image: traefik: stable v1.7 from https://hub.docker.com/_/traefik \n    depends_on:\n      - traefik_init\n      - consul\n    command:\n      -  --consul \n      -  --consul.endpoint=consul:8500 \n      -  --consul.prefix=traefik \n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    networks:\n      - webgateway\n      - traefik\n    ports:\n      - target: 80\n        published: 80\n        mode: host\n      - target: 443\n        published: 443\n        mode: host\n      - target: 8080\n        published: 8080\n        mode: host\n    deploy:\n      mode: global\n      placement:\n        constraints:\n          - node.role == manager\n      update_config:\n        parallelism: 1\n        delay: 10s\n      restart_policy:\n        condition: on-failure\n  consul:\n    image: consul\n    command: agent -server -bootstrap-expect=1\n    volumes:\n      - consul-data:/consul/data\n    environment:\n      - CONSUL_LOCAL_CONFIG={ datacenter : us_east2 , server :true}\n      - CONSUL_BIND_INTERFACE=eth0\n      - CONSUL_CLIENT_INTERFACE=eth0\n    deploy:\n      replicas: 1\n      placement:\n        constraints:\n          - node.role == manager\n      restart_policy:\n        condition: on-failure\n    networks:\n      - traefik\n\nnetworks:\n  webgateway:\n    driver: overlay\n    external: true\n  traefik:\n    driver: overlay\n\nvolumes:\n  consul-data:\n      driver: [not local]", 
            "title": "Full docker-compose file"
        }
    ]
}