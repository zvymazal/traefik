<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="containo.us">
        
        <link rel="shortcut icon" href="img/traefik.icon.png">
        

	<title>Basics - Træfik</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/base.css" rel="stylesheet">
        <link href="../css/traefik.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="..">Træfik</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="..">Getting Started</a>
                </li>
            
            
            
                <li class="active">
                    <a href="./">Basics</a>
                </li>
            
            
            
                <li >
                    <a href="../toml/">traefik.toml</a>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">User Guide <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../user-guide/examples/">Configuration examples</a>
</li>

                    
                        
<li >
    <a href="../user-guide/swarm/">Swarm cluster</a>
</li>

                    
                        
<li >
    <a href="../user-guide/swarm-mode/">Swarm mode cluster</a>
</li>

                    
                        
<li >
    <a href="../user-guide/kubernetes/">Kubernetes</a>
</li>

                    
                        
<li >
    <a href="../user-guide/marathon/">Marathon</a>
</li>

                    
                        
<li >
    <a href="../user-guide/kv-config/">Key-value store configuration</a>
</li>

                    
                        
<li >
    <a href="../user-guide/cluster/">Clustering/HA</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li >
                    <a href="../benchmarks/">Benchmarks</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                <li >
                    <a rel="next" href="..">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../toml/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/containous/traefik">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#concepts">Concepts</a></li>
        
            <li><a href="#entrypoints">Entrypoints</a></li>
        
            <li><a href="#frontends">Frontends</a></li>
        
            <li><a href="#backends">Backends</a></li>
        
            <li><a href="#servers">Servers</a></li>
        
    
        <li class="main "><a href="#configuration">Configuration</a></li>
        
            <li><a href="#static-trfik-configuration">Static Træfik configuration</a></li>
        
            <li><a href="#dynamic-trfik-configuration">Dynamic Træfik configuration</a></li>
        
    
        <li class="main "><a href="#commands">Commands</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="concepts">Concepts</h1>
<p>Let's take our example from the <a href="https://docs.traefik.io/#overview">overview</a> again:</p>
<blockquote>
<p>Imagine that you have deployed a bunch of microservices on your infrastructure. You probably used a service registry (like etcd or consul) and/or an orchestrator (swarm, Mesos/Marathon) to manage all these services.
If you want your users to access some of your microservices from the Internet, you will have to use a reverse proxy and configure it using virtual hosts or prefix paths:</p>
<ul>
<li>domain <code>api.domain.com</code> will point the microservice <code>api</code> in your private network</li>
<li>path <code>domain.com/web</code> will point the microservice <code>web</code> in your private network</li>
<li>domain <code>backoffice.domain.com</code> will point the microservices <code>backoffice</code> in your private network, load-balancing between your multiple instances</li>
</ul>
<p><img alt="Architecture" src="../img/architecture.png" /></p>
</blockquote>
<p>Let's zoom on Træfik and have an overview of its internal architecture:</p>
<p><img alt="Architecture" src="../img/internal.png" /></p>
<ul>
<li>Incoming requests end on <a href="#entrypoints">entrypoints</a>, as the name suggests, they are the network entry points into Træfik (listening port, SSL, traffic redirection...).</li>
<li>Traffic is then forwarded to a matching <a href="#frontends">frontend</a>. A frontend defines routes from <a href="#entrypoints">entrypoints</a> to <a href="#backends">backends</a>.
Routes are created using requests fields (<code>Host</code>, <code>Path</code>, <code>Headers</code>...) and can match or not a request.</li>
<li>The <a href="#frontends">frontend</a> will then send the request to a <a href="#backends">backend</a>. A backend can be composed by one or more <a href="#servers">servers</a>, and by a load-balancing strategy.</li>
<li>Finally, the <a href="#servers">server</a> will forward the request to the corresponding microservice in the private network.</li>
</ul>
<h2 id="entrypoints">Entrypoints</h2>
<p>Entrypoints are the network entry points into Træfik.
They can be defined using:</p>
<ul>
<li>a port (80, 443...)</li>
<li>SSL (Certificates, Keys, authentication with a client certificate signed by a trusted CA...)</li>
<li>redirection to another entrypoint (redirect <code>HTTP</code> to <code>HTTPS</code>)</li>
</ul>
<p>Here is an example of entrypoints definition:</p>
<pre><code class="toml">[entryPoints]
  [entryPoints.http]
  address = &quot;:80&quot;
    [entryPoints.http.redirect]
    entryPoint = &quot;https&quot;
  [entryPoints.https]
  address = &quot;:443&quot;
    [entryPoints.https.tls]
      [[entryPoints.https.tls.certificates]]
      certFile = &quot;tests/traefik.crt&quot;
      keyFile = &quot;tests/traefik.key&quot;
</code></pre>

<ul>
<li>Two entrypoints are defined <code>http</code> and <code>https</code>.</li>
<li><code>http</code> listens on port <code>80</code> and <code>https</code> on port <code>443</code>.</li>
<li>We enable SSL on <code>https</code> by giving a certificate and a key.</li>
<li>We also redirect all the traffic from entrypoint <code>http</code> to <code>https</code>.</li>
</ul>
<p>And here is another example with client certificate authentication:</p>
<pre><code class="toml">[entryPoints]
  [entryPoints.https]
  address = &quot;:443&quot;
  [entryPoints.https.tls]
  clientCAFiles = [&quot;tests/clientca1.crt&quot;, &quot;tests/clientca2.crt&quot;]
    [[entryPoints.https.tls.certificates]]
    certFile = &quot;tests/traefik.crt&quot;
    keyFile = &quot;tests/traefik.key&quot;
</code></pre>

<ul>
<li>We enable SSL on <code>https</code> by giving a certificate and a key.</li>
<li>One or several files containing Certificate Authorities in PEM format are added.</li>
<li>It is possible to have multiple CA:s in the same file or keep them in separate files.</li>
</ul>
<h2 id="frontends">Frontends</h2>
<p>A frontend consists of a set of rules that determine how incoming requests are forwarded from an entrypoint to a backend.</p>
<p>Rules may be classified in one of two groups: Modifiers and matchers.</p>
<h3 id="modifiers">Modifiers</h3>
<p>Modifier rules only modify the request. They do not have any impact on routing decisions being made.</p>
<p>Following is the list of existing modifier rules:</p>
<ul>
<li><code>AddPrefix: /products</code>: Add path prefix to the existing request path prior to forwarding the request to the backend.</li>
<li><code>ReplacePath: /serverless-path</code>: Replaces the path and adds the old path to the <code>X-Replaced-Path</code> header. Useful for mapping to AWS Lambda or Google Cloud Functions.</li>
</ul>
<h3 id="matchers">Matchers</h3>
<p>Matcher rules determine if a particular request should be forwarded to a backend.</p>
<p>Separate multiple rule values by <code>,</code> (comma) in order to enable ANY semantics (i.e., forward a request if any rule matches). Does not work for <code>Headers</code> and <code>HeadersRegexp</code>.</p>
<p>Separate multiple rule values by <code>;</code> (semicolon) in order to enable ALL semantics (i.e., forward a request if all rules match).</p>
<p>You can optionally enable <code>passHostHeader</code> to forward client <code>Host</code> header to the backend.</p>
<p>Following is the list of existing matcher rules along with examples:</p>
<ul>
<li><code>Headers: Content-Type, application/json</code>: Match HTTP header. It accepts a comma-separated key/value pair where both key and value must be literals.</li>
<li><code>HeadersRegexp: Content-Type, application/(text|json)</code>: Match HTTP header. It accepts a comma-separated key/value pair where the key must be a literal and the value may be a literal or a regular expression.</li>
<li><code>Host: traefik.io, www.traefik.io</code>: Match request host. It accepts a sequence of literal hosts.</li>
<li><code>HostRegexp: traefik.io, {subdomain:[a-z]+}.traefik.io</code>: Match request host. It accepts a sequence of literal and regular expression hosts.</li>
<li><code>Method: GET, POST, PUT</code>: Match request HTTP method. It accepts a sequence of HTTP methods.</li>
<li><code>Path: /products/, /articles/{category}/{id:[0-9]+}</code>: Match exact request path. It accepts a sequence of literal and regular expression paths.</li>
<li><code>PathStrip: /products/</code>: Match exact path and strip off the path prior to forwarding the request to the backend. It accepts a sequence of literal paths.</li>
<li><code>PathStripRegex: /articles/{category}/{id:[0-9]+}</code>: Match exact path and strip off the path prior to forwarding the request to the backend. It accepts a sequence of literal and regular expression paths.</li>
<li><code>PathPrefix: /products/, /articles/{category}/{id:[0-9]+}</code>: Match request prefix path. It accepts a sequence of literal and regular expression prefix paths.</li>
<li><code>PathPrefixStrip: /products/</code>: Match request prefix path and strip off the path prefix prior to forwarding the request to the backend. It accepts a sequence of literal prefix paths. Starting with Traefik 1.3, the stripped prefix path will be available in the <code>X-Forwarded-Prefix</code> header.</li>
<li><code>PathPrefixStripRegex: /articles/{category}/{id:[0-9]+}</code>: Match request prefix path and strip off the path prefix prior to forwarding the request to the backend. It accepts a sequence of literal and regular expression prefix paths. Starting with Traefik 1.3, the stripped prefix path will be available in the <code>X-Forwarded-Prefix</code> header.</li>
</ul>
<p>In order to use regular expressions with Host and Path matchers, you must declare an arbitrarily named variable followed by the colon-separated regular expression, all enclosed in curly braces. Any pattern supported by <a href="https://golang.org/pkg/regexp/">Go's regexp package</a> may be used. Example: <code>/posts/{id:[0-9]+}</code>.</p>
<p>(Note that the variable has no special meaning; however, it is required by the gorilla/mux dependency which embeds the regular expression and defines the syntax.)</p>
<h4 id="path-matcher-usage-guidelines">Path Matcher Usage Guidelines</h4>
<p>This section explains when to use the various path matchers.</p>
<p>Use <code>Path</code> if your backend listens on the exact path only. For instance, <code>Path: /products</code> would match <code>/products</code> but not <code>/products/shoes</code>.</p>
<p>Use a <code>*Prefix*</code> matcher if your backend listens on a particular base path but also serves requests on sub-paths. For instance, <code>PathPrefix: /products</code> would match <code>/products</code> but also <code>/products/shoes</code> and <code>/products/shirts</code>. Since the path is forwarded as-is, your backend is expected to listen on <code>/products</code>.</p>
<p>Use a <code>*Strip</code> matcher if your backend listens on the root path (<code>/</code>) but should be routeable on a specific prefix. For instance, <code>PathPrefixStrip: /products</code> would match <code>/products</code> but also <code>/products/shoes</code> and <code>/products/shirts</code>. Since the path is stripped prior to forwarding, your backend is expected to listen on <code>/</code>.
If your backend is serving assets (e.g., images or Javascript files), chances are it must return properly constructed relative URLs. Continuing on the example, the backend should return <code>/products/shoes/image.png</code> (and not <code>/images.png</code> which Traefik would likely not be able to associate with the same backend). The <code>X-Forwarded-Prefix</code> header (available since Traefik 1.3) can be queried to build such URLs dynamically.</p>
<p>Instead of distinguishing your backends by path only, you can add a Host matcher to the mix. That way, namespacing of your backends happens on the basis of hosts in addition to paths.</p>
<h3 id="examples">Examples</h3>
<p>Here is an example of frontends definition:</p>
<pre><code class="toml">[frontends]
  [frontends.frontend1]
  backend = &quot;backend2&quot;
    [frontends.frontend1.routes.test_1]
    rule = &quot;Host:test.localhost,test2.localhost&quot;
  [frontends.frontend2]
  backend = &quot;backend1&quot;
  passHostHeader = true
  priority = 10
  entrypoints = [&quot;https&quot;] # overrides defaultEntryPoints
    [frontends.frontend2.routes.test_1]
    rule = &quot;HostRegexp:localhost,{subdomain:[a-z]+}.localhost&quot;
  [frontends.frontend3]
  backend = &quot;backend2&quot;
    [frontends.frontend3.routes.test_1]
    rule = &quot;Host:test3.localhost;Path:/test&quot;
</code></pre>

<ul>
<li>Three frontends are defined: <code>frontend1</code>, <code>frontend2</code> and <code>frontend3</code></li>
<li><code>frontend1</code> will forward the traffic to the <code>backend2</code> if the rule <code>Host:test.localhost,test2.localhost</code> is matched</li>
<li><code>frontend2</code> will forward the traffic to the <code>backend1</code> if the rule <code>Host:localhost,{subdomain:[a-z]+}.localhost</code> is matched (forwarding client <code>Host</code> header to the backend)</li>
<li><code>frontend3</code> will forward the traffic to the <code>backend2</code> if the rules <code>Host:test3.localhost</code> <strong>AND</strong> <code>Path:/test</code> are matched</li>
</ul>
<h3 id="combining-multiple-rules">Combining multiple rules</h3>
<p>As seen in the previous example, you can combine multiple rules.
In TOML file, you can use multiple routes:</p>
<pre><code class="toml">[frontends.frontend3]
backend = &quot;backend2&quot;
  [frontends.frontend3.routes.test_1]
  rule = &quot;Host:test3.localhost&quot;
  [frontends.frontend3.routes.test_2]
  rule = &quot;Path:/test&quot;
</code></pre>

<p>Here <code>frontend3</code> will forward the traffic to the <code>backend2</code> if the rules <code>Host:test3.localhost</code> <strong>AND</strong> <code>Path:/test</code> are matched.
You can also use the notation using a <code>;</code> separator, same result:</p>
<pre><code class="toml">[frontends.frontend3]
backend = &quot;backend2&quot;
  [frontends.frontend3.routes.test_1]
  rule = &quot;Host:test3.localhost;Path:/test&quot;
</code></pre>

<p>Finally, you can create a rule to bind multiple domains or Path to a frontend, using the <code>,</code> separator:</p>
<pre><code class="toml">[frontends.frontend2]
   [frontends.frontend2.routes.test_1]
   rule = &quot;Host:test1.localhost,test2.localhost&quot;
[frontends.frontend3]
backend = &quot;backend2&quot;
  [frontends.frontend3.routes.test_1]
  rule = &quot;Path:/test1,/test2&quot;
</code></pre>

<h3 id="rules-order">Rules Order</h3>
<p>When combining <code>Modifier</code> rules with <code>Matcher</code> rules, it is important to remember that <code>Modifier</code> rules <strong>ALWAYS</strong> apply after the <code>Matcher</code> rules.<br />
The following rules are both <code>Matchers</code> and <code>Modifiers</code>, so the <code>Matcher</code> portion of the rule will apply first, and the <code>Modifier</code> will apply later.</p>
<ul>
<li><code>PathStrip</code></li>
<li><code>PathStripRegex</code></li>
<li><code>PathPrefixStrip</code></li>
<li><code>PathPrefixStripRegex</code></li>
</ul>
<p><code>Modifiers</code> will be applied in a pre-determined order regardless of their order in the <code>rule</code> configuration section.</p>
<ol>
<li><code>PathStrip</code></li>
<li><code>PathPrefixStrip</code></li>
<li><code>PathStripRegex</code></li>
<li><code>PathPrefixStripRegex</code></li>
<li><code>AddPrefix</code></li>
<li><code>ReplacePath</code> </li>
</ol>
<h3 id="priorities">Priorities</h3>
<p>By default, routes will be sorted (in descending order) using rules length (to avoid path overlap):
<code>PathPrefix:/12345</code> will be matched before <code>PathPrefix:/1234</code> that will be matched before <code>PathPrefix:/1</code>.</p>
<p>You can customize priority by frontend:</p>
<pre><code class="toml">[frontends]
  [frontends.frontend1]
  backend = &quot;backend1&quot;
  priority = 10
  passHostHeader = true
    [frontends.frontend1.routes.test_1]
    rule = &quot;PathPrefix:/to&quot;
  [frontends.frontend2]
  priority = 5
  backend = &quot;backend2&quot;
  passHostHeader = true
    [frontends.frontend2.routes.test_1]
    rule = &quot;PathPrefix:/toto&quot;
</code></pre>

<p>Here, <code>frontend1</code> will be matched before <code>frontend2</code> (<code>10 &gt; 5</code>).</p>
<h2 id="backends">Backends</h2>
<p>A backend is responsible to load-balance the traffic coming from one or more frontends to a set of http servers.
Various methods of load-balancing are supported:</p>
<ul>
<li><code>wrr</code>: Weighted Round Robin</li>
<li><code>drr</code>: Dynamic Round Robin: increases weights on servers that perform better than others. It also rolls back to original weights if the servers have changed.</li>
</ul>
<p>A circuit breaker can also be applied to a backend, preventing high loads on failing servers.
Initial state is Standby. CB observes the statistics and does not modify the request.
In case the condition matches, CB enters Tripped state, where it responds with predefined code or redirects to another frontend.
Once Tripped timer expires, CB enters Recovering state and resets all stats.
In case the condition does not match and recovery timer expires, CB enters Standby state.</p>
<p>It can be configured using:</p>
<ul>
<li>Methods: <code>LatencyAtQuantileMS</code>, <code>NetworkErrorRatio</code>, <code>ResponseCodeRatio</code></li>
<li>Operators:  <code>AND</code>, <code>OR</code>, <code>EQ</code>, <code>NEQ</code>, <code>LT</code>, <code>LE</code>, <code>GT</code>, <code>GE</code></li>
</ul>
<p>For example:</p>
<ul>
<li><code>NetworkErrorRatio() &gt; 0.5</code>: watch error ratio over 10 second sliding window for a frontend</li>
<li><code>LatencyAtQuantileMS(50.0) &gt; 50</code>:  watch latency at quantile in milliseconds.</li>
<li><code>ResponseCodeRatio(500, 600, 0, 600) &gt; 0.5</code>: ratio of response codes in range [500-600) to  [0-600)</li>
</ul>
<p>To proactively prevent backends from being overwhelmed with high load, a maximum connection limit can
also be applied to each backend.</p>
<p>Maximum connections can be configured by specifying an integer value for <code>maxconn.amount</code> and
<code>maxconn.extractorfunc</code> which is a strategy used to determine how to categorize requests in order to
evaluate the maximum connections.</p>
<p>For example:</p>
<pre><code class="toml">[backends]
  [backends.backend1]
    [backends.backend1.maxconn]
       amount = 10
       extractorfunc = &quot;request.host&quot;
</code></pre>

<ul>
<li><code>backend1</code> will return <code>HTTP code 429 Too Many Requests</code> if there are already 10 requests in progress for the same Host header.</li>
<li>Another possible value for <code>extractorfunc</code> is <code>client.ip</code> which will categorize requests based on client source ip.</li>
<li>Lastly <code>extractorfunc</code> can take the value of <code>request.header.ANY_HEADER</code> which will categorize requests based on <code>ANY_HEADER</code> that you provide.</li>
</ul>
<p>Sticky sessions are supported with both load balancers. When sticky sessions are enabled, a cookie called <code>_TRAEFIK_BACKEND</code> is set on the initial
request. On subsequent requests, the client will be directed to the backend stored in the cookie if it is still healthy. If not, a new backend
will be assigned.</p>
<p>For example:</p>
<pre><code class="toml">[backends]
  [backends.backend1]
    [backends.backend1.loadbalancer]
      sticky = true
</code></pre>

<p>A health check can be configured in order to remove a backend from LB rotation
as long as it keeps returning HTTP status codes other than 200 OK to HTTP GET
requests periodically carried out by Traefik. The check is defined by a path
appended to the backend URL and an interval (given in a format understood by <a href="https://golang.org/pkg/time/#ParseDuration">time.ParseDuration</a>) specifying how
often the health check should be executed (the default being 30 seconds). Each
backend must respond to the health check within 5 seconds.</p>
<p>A recovering backend returning 200 OK responses again is being returned to the
LB rotation pool.</p>
<p>For example:</p>
<pre><code class="toml">[backends]
  [backends.backend1]
    [backends.backend1.healthcheck]
      path = &quot;/health&quot;
      interval = &quot;10s&quot;
</code></pre>

<h2 id="servers">Servers</h2>
<p>Servers are simply defined using a <code>URL</code>. You can also apply a custom <code>weight</code> to each server (this will be used by load-balancing).</p>
<p>Here is an example of backends and servers definition:</p>
<pre><code class="toml">[backends]
  [backends.backend1]
    [backends.backend1.circuitbreaker]
      expression = &quot;NetworkErrorRatio() &gt; 0.5&quot;
    [backends.backend1.servers.server1]
    url = &quot;http://172.17.0.2:80&quot;
    weight = 10
    [backends.backend1.servers.server2]
    url = &quot;http://172.17.0.3:80&quot;
    weight = 1
  [backends.backend2]
    [backends.backend2.LoadBalancer]
      method = &quot;drr&quot;
    [backends.backend2.servers.server1]
    url = &quot;http://172.17.0.4:80&quot;
    weight = 1
    [backends.backend2.servers.server2]
    url = &quot;http://172.17.0.5:80&quot;
    weight = 2
</code></pre>

<ul>
<li>Two backends are defined: <code>backend1</code> and <code>backend2</code></li>
<li><code>backend1</code> will forward the traffic to two servers: <code>http://172.17.0.2:80"</code> with weight <code>10</code> and <code>http://172.17.0.3:80</code> with weight <code>1</code> using default <code>wrr</code> load-balancing strategy.</li>
<li><code>backend2</code> will forward the traffic to two servers: <code>http://172.17.0.4:80"</code> with weight <code>1</code> and <code>http://172.17.0.5:80</code> with weight <code>2</code> using <code>drr</code> load-balancing strategy.</li>
<li>a circuit breaker is added on <code>backend1</code> using the expression <code>NetworkErrorRatio() &gt; 0.5</code>: watch error ratio over 10 second sliding window</li>
</ul>
<h1 id="configuration">Configuration</h1>
<p>Træfik's configuration has two parts: </p>
<ul>
<li>The <a href="../basics#static-trfk-configuration">static Træfik configuration</a> which is loaded only at the beginning. </li>
<li>The <a href="../basics#dynamic-trfk-configuration">dynamic Træfik configuration</a> which can be hot-reloaded (no need to restart the process).</li>
</ul>
<h2 id="static-trfik-configuration">Static Træfik configuration</h2>
<p>The static configuration is the global configuration which is setting up connections to configuration backends and entrypoints. </p>
<p>Træfik can be configured using many configuration sources with the following precedence order. 
Each item takes precedence over the item below it:</p>
<ul>
<li><a href="../basics/#key-value-stores">Key-value Store</a></li>
<li><a href="../basics/#arguments">Arguments</a></li>
<li><a href="../basics/#configuration-file">Configuration file</a></li>
<li>Default</li>
</ul>
<p>It means that arguments override configuration file, and Key-value Store overrides arguments.</p>
<h3 id="configuration-file">Configuration file</h3>
<p>By default, Træfik will try to find a <code>traefik.toml</code> in the following places:</p>
<ul>
<li><code>/etc/traefik/</code></li>
<li><code>$HOME/.traefik/</code></li>
<li><code>.</code> <em>the working directory</em></li>
</ul>
<p>You can override this by setting a <code>configFile</code> argument:</p>
<pre><code class="bash">$ traefik --configFile=foo/bar/myconfigfile.toml
</code></pre>

<p>Please refer to the <a href="../toml/#global-configuration">global configuration</a> section to get documentation on it.</p>
<h3 id="arguments">Arguments</h3>
<p>Each argument (and command) is described in the help section:</p>
<pre><code class="bash">$ traefik --help
</code></pre>

<p>Note that all default values will be displayed as well.</p>
<h3 id="key-value-stores">Key-value stores</h3>
<p>Træfik supports several Key-value stores:</p>
<ul>
<li><a href="https://consul.io">Consul</a></li>
<li><a href="https://coreos.com/etcd/">etcd</a></li>
<li><a href="https://zookeeper.apache.org/">ZooKeeper</a> </li>
<li><a href="https://github.com/boltdb/bolt">boltdb</a></li>
</ul>
<p>Please refer to the <a href="../user-guide/kv-config/">User Guide Key-value store configuration</a> section to get documentation on it.</p>
<h2 id="dynamic-trfik-configuration">Dynamic Træfik configuration</h2>
<p>The dynamic configuration concerns : </p>
<ul>
<li><a href="../basics/#frontends">Frontends</a></li>
<li><a href="../basics/#backends">Backends</a> </li>
<li><a href="../basics/#servers">Servers</a> </li>
</ul>
<p>Træfik can hot-reload those rules which could be provided by <a href="../toml/#configuration-backends">multiple configuration backends</a>.</p>
<p>We only need to enable <code>watch</code> option to make Træfik watch configuration backend changes and generate its configuration automatically.
Routes to services will be created and updated instantly at any changes.</p>
<p>Please refer to the <a href="../toml/#configuration-backends">configuration backends</a> section to get documentation on it.</p>
<h1 id="commands">Commands</h1>
<p>Usage: <code>traefik [command] [--flag=flag_argument]</code></p>
<p>List of Træfik available commands with description :                                                             </p>
<ul>
<li><code>version</code> : Print version </li>
<li><code>storeconfig</code> : Store the static traefik configuration into a Key-value stores. Please refer to the <a href="../user-guide/kv-config/#store-trfk-configuration">Store Træfik configuration</a> section to get documentation on it.</li>
</ul>
<p>Each command may have related flags. 
All those related flags will be displayed with :</p>
<pre><code class="bash">$ traefik [command] --help
</code></pre>

<p>Note that each command is described at the beginning of the help section:</p>
<pre><code class="bash">$ traefik --help
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
                <center>Copyright &copy; 2016-2017 Containous SAS</center>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>
        <script src="../theme/js/structor-menu.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>