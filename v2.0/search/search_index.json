{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Traefik is an open-source Edge Router that makes publishing your services a fun and easy experience. It receives requests on behalf of your system and finds out which components are responsible for handling them. What sets Traefik apart, besides its many features, is that it automatically discovers the right configuration for your services. The magic happens when Traefik inspects your infrastructure, where it finds relevant information and discovers which service serves which request. Traefik is natively compliant with every major cluster technology, such as Kubernetes, Docker, Docker Swarm, AWS, Mesos, Marathon, and the list goes on ; and can handle many at the same time. (It even works for legacy software running on bare metal.) With Traefik, there is no need to maintain and synchronize a separate configuration file: everything happens automatically, in real time (no restarts, no connection interruptions). With Traefik, you spend time developing and deploying new features to your system, not on configuring and maintaining its working state. Developing Traefik, our main goal is to make it simple to use, and we're sure you'll enjoy it. -- The Traefik Maintainer Team Info If you're a business running critical services behind Traefik, know that Containous , the company that sponsors Traefik's development, can provide commercial support and develops an Enterprise Edition of Traefik.","title":"Welcome"},{"location":"#welcome","text":"Traefik is an open-source Edge Router that makes publishing your services a fun and easy experience. It receives requests on behalf of your system and finds out which components are responsible for handling them. What sets Traefik apart, besides its many features, is that it automatically discovers the right configuration for your services. The magic happens when Traefik inspects your infrastructure, where it finds relevant information and discovers which service serves which request. Traefik is natively compliant with every major cluster technology, such as Kubernetes, Docker, Docker Swarm, AWS, Mesos, Marathon, and the list goes on ; and can handle many at the same time. (It even works for legacy software running on bare metal.) With Traefik, there is no need to maintain and synchronize a separate configuration file: everything happens automatically, in real time (no restarts, no connection interruptions). With Traefik, you spend time developing and deploying new features to your system, not on configuring and maintaining its working state. Developing Traefik, our main goal is to make it simple to use, and we're sure you'll enjoy it. -- The Traefik Maintainer Team Info If you're a business running critical services behind Traefik, know that Containous , the company that sponsors Traefik's development, can provide commercial support and develops an Enterprise Edition of Traefik.","title":"Welcome"},{"location":"glossary/","text":"TODO -- Glossary \u00b6 Where Every Technical Word finds its Definition` Provider Types of providers (KV, annotation based, label based, configuration based) Entrypoint Routers Middleware Service Static configuration Dynamic configuration ACME TraefikEE Tracing Metrics Orchestrator Key Value Store Logs Traefiker Traefik (How to pronounce)","title":"TODO -- Glossary"},{"location":"glossary/#todo-glossary","text":"Where Every Technical Word finds its Definition` Provider Types of providers (KV, annotation based, label based, configuration based) Entrypoint Routers Middleware Service Static configuration Dynamic configuration ACME TraefikEE Tracing Metrics Orchestrator Key Value Store Logs Traefiker Traefik (How to pronounce)","title":"TODO -- Glossary"},{"location":"contributing/advocating/","text":"Advocating \u00b6 Spread the Love & Tell Us about It There are many ways to contribute to the project, and there is one that always spark joy: when we see/read about users talking about how Traefik helps them solve their problems. If you're talking about Traefik, let us know and we'll promote your enthusiasm! Also, if you've written about Traefik or shared useful information you'd like to promote, feel free to add links in the dedicated wiki page on Github .","title":"Advocating"},{"location":"contributing/advocating/#advocating","text":"Spread the Love & Tell Us about It There are many ways to contribute to the project, and there is one that always spark joy: when we see/read about users talking about how Traefik helps them solve their problems. If you're talking about Traefik, let us know and we'll promote your enthusiasm! Also, if you've written about Traefik or shared useful information you'd like to promote, feel free to add links in the dedicated wiki page on Github .","title":"Advocating"},{"location":"contributing/building-testing/","text":"Building and Testing \u00b6 Compile and Test Your Own Traefik! So you want to build your own Traefik binary from the sources? Let's see how. Building \u00b6 You need either Docker and make (Method 1), or go (Method 2) in order to build Traefik. For changes to its dependencies, the dep dependency management tool is required. Method 1: Using Docker and Makefile \u00b6 Run make with the binary target. This will create binaries for the Linux platform in the dist folder. $ make binary docker build -t traefik-webui -f webui/Dockerfile webui Sending build context to Docker daemon 2.686MB Step 1/11 : FROM node:8.15.0 ---> 1f6c34f7921c [...] Successfully built ce4ff439c06a Successfully tagged traefik-webui:latest [...] docker build -t \"traefik-dev:4475--feature-documentation\" -f build.Dockerfile . Sending build context to Docker daemon 279MB Step 1/10 : FROM golang:1.13-alpine ---> f4bfb3d22bda [...] Successfully built 5c3c1a911277 Successfully tagged traefik-dev:4475--feature-documentation docker run -e \"TEST_CONTAINER=1\" -v \"/var/run/docker.sock:/var/run/docker.sock\" -it -e OS_ARCH_ARG -e OS_PLATFORM_ARG -e TESTFLAGS -e VERBOSE -e VERSION -e CODENAME -e TESTDIRS -e CI -e CONTAINER=DOCKER -v \"/home/ldez/sources/go/src/github.com/containous/traefik/\"dist\":/go/src/github.com/containous/traefik/\"dist\"\" \"traefik-dev:4475--feature-documentation\" ./script/make.sh generate binary ---> Making bundle: generate (in .) removed 'autogen/genstatic/gen.go' ---> Making bundle: binary (in .) $ ls dist/ traefik* The following targets can be executed outside Docker by setting the variable PRE_TARGET to an empty string (we don't recommend that): test-unit test-integration validate binary (the webUI is still generated by using Docker) ex: PRE_TARGET= make test-unit Method 2: Using go \u00b6 Requirements: go v1.13+ environment variable GO111MODULE=on go-bindata GO111MODULE=off go get -u github.com/containous/go-bindata/... Source Directory It is recommended that you clone Traefik into the ~/go/src/github.com/containous/traefik directory. This is the official golang workspace hierarchy that will allow dependencies to be properly resolved. Environment Set your GOPATH and PATH variable to be set to ~/go via: export GOPATH=~/go export PATH=$PATH:$GOPATH/bin For convenience, add GOPATH and PATH to your .bashrc or .bash_profile Verify your environment is setup properly by running $ go env . Depending on your OS and environment, you should see an output similar to: GOARCH=\"amd64\" GOBIN=\"\" GOEXE=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"linux\" GOOS=\"linux\" GOPATH=\"/home/<yourusername>/go\" GORACE=\"\" ## ... and the list goes on Build Traefik \u00b6 Once you've set up your go environment and cloned the source repository, you can build Traefik. Beforehand, you need to get go-bindata (the first time) in order to be able to use the go generate command (which is part of the build process). cd ~/go/src/github.com/containous/traefik # Get go-bindata. (Important: the ellipses are required.) GO111MODULE=off go get github.com/containous/go-bindata/... # Let's build # generate # (required to merge non-code components into the final binary, such as the web dashboard and the provider's templates) go generate # Standard go build go build ./cmd/traefik You will find the Traefik executable ( traefik ) in the ~/go/src/github.com/containous/traefik directory. Updating the templates \u00b6 If you happen to update the provider's templates (located in /templates ), you must run go generate to update the autogen package. Testing \u00b6 Method 1: Docker and make \u00b6 Run unit tests using the test-unit target. Run integration tests using the test-integration target. Run all tests (unit and integration) using the test target. $ make test-unit docker build -t \"traefik-dev:your-feature-branch\" -f build.Dockerfile . # [\u2026] docker run --rm -it -e OS_ARCH_ARG -e OS_PLATFORM_ARG -e TESTFLAGS -v \"/home/user/go/src/github/containous/traefik/dist:/go/src/github.com/containous/traefik/dist\" \"traefik-dev:your-feature-branch\" ./script/make.sh generate test-unit ---> Making bundle: generate (in .) removed 'gen.go' ---> Making bundle: test-unit (in .) + go test -cover -coverprofile=cover.out . ok github.com/containous/traefik 0.005s coverage: 4.1% of statements Test success For development purposes, you can specify which tests to run by using (only works the test-integration target): # Run every tests in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite\" make test-integration # Run the test \"MyTest\" in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.MyTest\" make test-integration # Run every tests starting with \"My\", in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.My\" make test-integration # Run every tests ending with \"Test\", in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.*Test\" make test-integration More: https://labix.org/gocheck Method 2: go \u00b6 Unit tests can be run from the cloned directory using $ go test ./... which should return ok , similar to: ok _/home/user/go/src/github/containous/traefik 0.004s Integration tests must be run from the integration/ directory and require the -integration switch: $ cd integration && go test -integration ./... .","title":"Building and Testing"},{"location":"contributing/building-testing/#building-and-testing","text":"Compile and Test Your Own Traefik! So you want to build your own Traefik binary from the sources? Let's see how.","title":"Building and Testing"},{"location":"contributing/building-testing/#building","text":"You need either Docker and make (Method 1), or go (Method 2) in order to build Traefik. For changes to its dependencies, the dep dependency management tool is required.","title":"Building"},{"location":"contributing/building-testing/#method-1-using-docker-and-makefile","text":"Run make with the binary target. This will create binaries for the Linux platform in the dist folder. $ make binary docker build -t traefik-webui -f webui/Dockerfile webui Sending build context to Docker daemon 2.686MB Step 1/11 : FROM node:8.15.0 ---> 1f6c34f7921c [...] Successfully built ce4ff439c06a Successfully tagged traefik-webui:latest [...] docker build -t \"traefik-dev:4475--feature-documentation\" -f build.Dockerfile . Sending build context to Docker daemon 279MB Step 1/10 : FROM golang:1.13-alpine ---> f4bfb3d22bda [...] Successfully built 5c3c1a911277 Successfully tagged traefik-dev:4475--feature-documentation docker run -e \"TEST_CONTAINER=1\" -v \"/var/run/docker.sock:/var/run/docker.sock\" -it -e OS_ARCH_ARG -e OS_PLATFORM_ARG -e TESTFLAGS -e VERBOSE -e VERSION -e CODENAME -e TESTDIRS -e CI -e CONTAINER=DOCKER -v \"/home/ldez/sources/go/src/github.com/containous/traefik/\"dist\":/go/src/github.com/containous/traefik/\"dist\"\" \"traefik-dev:4475--feature-documentation\" ./script/make.sh generate binary ---> Making bundle: generate (in .) removed 'autogen/genstatic/gen.go' ---> Making bundle: binary (in .) $ ls dist/ traefik* The following targets can be executed outside Docker by setting the variable PRE_TARGET to an empty string (we don't recommend that): test-unit test-integration validate binary (the webUI is still generated by using Docker) ex: PRE_TARGET= make test-unit","title":"Method 1: Using Docker and Makefile"},{"location":"contributing/building-testing/#method-2-using-go","text":"Requirements: go v1.13+ environment variable GO111MODULE=on go-bindata GO111MODULE=off go get -u github.com/containous/go-bindata/... Source Directory It is recommended that you clone Traefik into the ~/go/src/github.com/containous/traefik directory. This is the official golang workspace hierarchy that will allow dependencies to be properly resolved. Environment Set your GOPATH and PATH variable to be set to ~/go via: export GOPATH=~/go export PATH=$PATH:$GOPATH/bin For convenience, add GOPATH and PATH to your .bashrc or .bash_profile Verify your environment is setup properly by running $ go env . Depending on your OS and environment, you should see an output similar to: GOARCH=\"amd64\" GOBIN=\"\" GOEXE=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"linux\" GOOS=\"linux\" GOPATH=\"/home/<yourusername>/go\" GORACE=\"\" ## ... and the list goes on","title":"Method 2: Using go"},{"location":"contributing/building-testing/#build-traefik","text":"Once you've set up your go environment and cloned the source repository, you can build Traefik. Beforehand, you need to get go-bindata (the first time) in order to be able to use the go generate command (which is part of the build process). cd ~/go/src/github.com/containous/traefik # Get go-bindata. (Important: the ellipses are required.) GO111MODULE=off go get github.com/containous/go-bindata/... # Let's build # generate # (required to merge non-code components into the final binary, such as the web dashboard and the provider's templates) go generate # Standard go build go build ./cmd/traefik You will find the Traefik executable ( traefik ) in the ~/go/src/github.com/containous/traefik directory.","title":"Build Traefik"},{"location":"contributing/building-testing/#updating-the-templates","text":"If you happen to update the provider's templates (located in /templates ), you must run go generate to update the autogen package.","title":"Updating the templates"},{"location":"contributing/building-testing/#testing","text":"","title":"Testing"},{"location":"contributing/building-testing/#method-1-docker-and-make","text":"Run unit tests using the test-unit target. Run integration tests using the test-integration target. Run all tests (unit and integration) using the test target. $ make test-unit docker build -t \"traefik-dev:your-feature-branch\" -f build.Dockerfile . # [\u2026] docker run --rm -it -e OS_ARCH_ARG -e OS_PLATFORM_ARG -e TESTFLAGS -v \"/home/user/go/src/github/containous/traefik/dist:/go/src/github.com/containous/traefik/dist\" \"traefik-dev:your-feature-branch\" ./script/make.sh generate test-unit ---> Making bundle: generate (in .) removed 'gen.go' ---> Making bundle: test-unit (in .) + go test -cover -coverprofile=cover.out . ok github.com/containous/traefik 0.005s coverage: 4.1% of statements Test success For development purposes, you can specify which tests to run by using (only works the test-integration target): # Run every tests in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite\" make test-integration # Run the test \"MyTest\" in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.MyTest\" make test-integration # Run every tests starting with \"My\", in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.My\" make test-integration # Run every tests ending with \"Test\", in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.*Test\" make test-integration More: https://labix.org/gocheck","title":"Method 1: Docker and make"},{"location":"contributing/building-testing/#method-2-go","text":"Unit tests can be run from the cloned directory using $ go test ./... which should return ok , similar to: ok _/home/user/go/src/github/containous/traefik 0.004s Integration tests must be run from the integration/ directory and require the -integration switch: $ cd integration && go test -integration ./... .","title":"Method 2: go"},{"location":"contributing/data-collection/","text":"Data Collection \u00b6 Understanding How Traefik is Being Used Configuration Example \u00b6 Understanding how you use Traefik is very important to us: it helps us improve the solution in many different ways. For this very reason, the sendAnonymousUsage option is mandatory: we want you to take time to consider whether or not you wish to share anonymous data with us so we can benefit from your experience and use cases. Enabling Data Collection File (TOML) [global] # Send anonymous usage data sendAnonymousUsage = true File (YAML) global: # Send anonymous usage data sendAnonymousUsage: true CLI # Send anonymous usage data --global.sendAnonymousUsage Collected Data \u00b6 This feature comes from the public proposal here . In order to help us learn more about how Traefik is being used and improve it, we collect anonymous usage statistics from running instances. Those data help us prioritize our developments and focus on what's important for our users (for example, which provider is popular, and which is not). What's collected / when ? \u00b6 Once a day (the first call begins 10 minutes after the start of Traefik), we collect: the Traefik version number a hash of the configuration an anonymized version of the static configuration (token, user name, password, URL, IP, domain, email, etc, are removed). Info We do not collect the dynamic configuration information (routers & services). We do not collect this data to run advertising programs. We do not sell this data to third-parties. Example of Collected Data \u00b6 Original configuration [entryPoints] [entryPoints.web] address = \":80\" [api] [providers.docker] endpoint = \"tcp://10.10.10.10:2375\" exposedByDefault = true swarmMode = true [providers.docker.TLS] ca = \"dockerCA\" cert = \"dockerCert\" key = \"dockerKey\" insecureSkipVerify = true Resulting Obfuscated Configuration [entryPoints] [entryPoints.web] address = \":80\" [api] [providers.docker] endpoint = \"xxxx\" exposedByDefault = true swarmMode = true [providers.docker.TLS] ca = \"xxxx\" cert = \"xxxx\" key = \"xxxx\" insecureSkipVerify = false The Code for Data Collection \u00b6 If you want to dig into more details, here is the source code of the collecting system: collector.go By default we anonymize all configuration fields, except fields tagged with export=true .","title":"Data Collection"},{"location":"contributing/data-collection/#data-collection","text":"Understanding How Traefik is Being Used","title":"Data Collection"},{"location":"contributing/data-collection/#configuration-example","text":"Understanding how you use Traefik is very important to us: it helps us improve the solution in many different ways. For this very reason, the sendAnonymousUsage option is mandatory: we want you to take time to consider whether or not you wish to share anonymous data with us so we can benefit from your experience and use cases. Enabling Data Collection File (TOML) [global] # Send anonymous usage data sendAnonymousUsage = true File (YAML) global: # Send anonymous usage data sendAnonymousUsage: true CLI # Send anonymous usage data --global.sendAnonymousUsage","title":"Configuration Example"},{"location":"contributing/data-collection/#collected-data","text":"This feature comes from the public proposal here . In order to help us learn more about how Traefik is being used and improve it, we collect anonymous usage statistics from running instances. Those data help us prioritize our developments and focus on what's important for our users (for example, which provider is popular, and which is not).","title":"Collected Data"},{"location":"contributing/data-collection/#whats-collected-when","text":"Once a day (the first call begins 10 minutes after the start of Traefik), we collect: the Traefik version number a hash of the configuration an anonymized version of the static configuration (token, user name, password, URL, IP, domain, email, etc, are removed). Info We do not collect the dynamic configuration information (routers & services). We do not collect this data to run advertising programs. We do not sell this data to third-parties.","title":"What's collected / when ?"},{"location":"contributing/data-collection/#example-of-collected-data","text":"Original configuration [entryPoints] [entryPoints.web] address = \":80\" [api] [providers.docker] endpoint = \"tcp://10.10.10.10:2375\" exposedByDefault = true swarmMode = true [providers.docker.TLS] ca = \"dockerCA\" cert = \"dockerCert\" key = \"dockerKey\" insecureSkipVerify = true Resulting Obfuscated Configuration [entryPoints] [entryPoints.web] address = \":80\" [api] [providers.docker] endpoint = \"xxxx\" exposedByDefault = true swarmMode = true [providers.docker.TLS] ca = \"xxxx\" cert = \"xxxx\" key = \"xxxx\" insecureSkipVerify = false","title":"Example of Collected Data"},{"location":"contributing/data-collection/#the-code-for-data-collection","text":"If you want to dig into more details, here is the source code of the collecting system: collector.go By default we anonymize all configuration fields, except fields tagged with export=true .","title":"The Code for Data Collection"},{"location":"contributing/documentation/","text":"Documentation \u00b6 Features Are Better When You Know How to Use Them You've found something unclear in the documentation and want to give a try at explaining it better? Let's see how. Building Documentation \u00b6 General \u00b6 This documentation is built with mkdocs . Method 1: Docker and make \u00b6 You can build the documentation and test it locally (with live reloading), using the docs target: $ make docs docker build -t traefik-docs -f docs.Dockerfile . # [\u2026] docker run --rm -v /home/user/go/github/containous/traefik:/mkdocs -p 8000:8000 traefik-docs mkdocs serve # [\u2026] [I 170828 20:47:48 server:283] Serving on http://0.0.0.0:8000 [I 170828 20:47:48 handlers:60] Start watching changes [I 170828 20:47:48 handlers:62] Start detecting changes Default URL Your local documentation server will run by default on http://127.0.0.1:8000 . If you only want to build the documentation without serving it locally, you can use the following command: $ make docs-build ... Method 2: mkdocs \u00b6 First, make sure you have python and pip installed. $ python --version Python 2.7.2 $ pip --version pip 1.5.2 Then, install mkdocs with pip . pip install --user -r requirements.txt To build the documentation locally and serve it locally, run mkdocs serve from the root directory. This will start a local server. $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [I 160505 22:31:24 server:281] Serving on http://127.0.0.1:8000 [I 160505 22:31:24 handlers:59] Start watching changes [I 160505 22:31:24 handlers:61] Start detecting changes Check the Documentation \u00b6 To check that the documentation meets standard expectations (no dead links, html markup validity, ...), use the docs-verify target. $ make docs-verify docker build -t traefik-docs-verify ./script/docs-verify-docker-image ## Build Validator image ... docker run --rm -v /home/travis/build/containous/traefik:/app traefik-docs-verify ## Check for dead links and w3c compliance === Checking HTML content... Running [\"HtmlCheck\", \"ImageCheck\", \"ScriptCheck\", \"LinkCheck\"] on /app/site/basics/index.html on *.html... Clean & Verify If you've made changes to the documentation, it's safter to clean it before verifying it. $ make docs-clean docs-verify ... Disabling Documentation Verification Verification can be disabled by setting the environment variable DOCS_VERIFY_SKIP to true : DOCS_VERIFY_SKIP=true make docs-verify ... DOCS_LINT_SKIP is true: no linting done.","title":"Documentation"},{"location":"contributing/documentation/#documentation","text":"Features Are Better When You Know How to Use Them You've found something unclear in the documentation and want to give a try at explaining it better? Let's see how.","title":"Documentation"},{"location":"contributing/documentation/#building-documentation","text":"","title":"Building Documentation"},{"location":"contributing/documentation/#general","text":"This documentation is built with mkdocs .","title":"General"},{"location":"contributing/documentation/#method-1-docker-and-make","text":"You can build the documentation and test it locally (with live reloading), using the docs target: $ make docs docker build -t traefik-docs -f docs.Dockerfile . # [\u2026] docker run --rm -v /home/user/go/github/containous/traefik:/mkdocs -p 8000:8000 traefik-docs mkdocs serve # [\u2026] [I 170828 20:47:48 server:283] Serving on http://0.0.0.0:8000 [I 170828 20:47:48 handlers:60] Start watching changes [I 170828 20:47:48 handlers:62] Start detecting changes Default URL Your local documentation server will run by default on http://127.0.0.1:8000 . If you only want to build the documentation without serving it locally, you can use the following command: $ make docs-build ...","title":"Method 1: Docker and make"},{"location":"contributing/documentation/#method-2-mkdocs","text":"First, make sure you have python and pip installed. $ python --version Python 2.7.2 $ pip --version pip 1.5.2 Then, install mkdocs with pip . pip install --user -r requirements.txt To build the documentation locally and serve it locally, run mkdocs serve from the root directory. This will start a local server. $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [I 160505 22:31:24 server:281] Serving on http://127.0.0.1:8000 [I 160505 22:31:24 handlers:59] Start watching changes [I 160505 22:31:24 handlers:61] Start detecting changes","title":"Method 2: mkdocs"},{"location":"contributing/documentation/#check-the-documentation","text":"To check that the documentation meets standard expectations (no dead links, html markup validity, ...), use the docs-verify target. $ make docs-verify docker build -t traefik-docs-verify ./script/docs-verify-docker-image ## Build Validator image ... docker run --rm -v /home/travis/build/containous/traefik:/app traefik-docs-verify ## Check for dead links and w3c compliance === Checking HTML content... Running [\"HtmlCheck\", \"ImageCheck\", \"ScriptCheck\", \"LinkCheck\"] on /app/site/basics/index.html on *.html... Clean & Verify If you've made changes to the documentation, it's safter to clean it before verifying it. $ make docs-clean docs-verify ... Disabling Documentation Verification Verification can be disabled by setting the environment variable DOCS_VERIFY_SKIP to true : DOCS_VERIFY_SKIP=true make docs-verify ... DOCS_LINT_SKIP is true: no linting done.","title":"Check the Documentation"},{"location":"contributing/maintainers/","text":"Maintainers \u00b6 The team \u00b6 Emile Vauge @emilevauge Vincent Demeester @vdemeester Ed Robinson @errm Daniel Tomcej @dtomcej Manuel Zapf @SantoDE Timo Reimann @timoreimann Ludovic Fernandez @ldez Julien Salleyron @juliens Nicolas Mengin @nmengin Marco Jantke @marco-jantke Micha\u00ebl Matur @mmatur G\u00e9rald Cro\u00ebs @geraldcroes Jean-Baptiste Doumenjou @jbdoumenjou Damien Duportal @dduportal Mathieu Lonjaret @mpl Contributions Daily Meeting \u00b6 3 Maintainers should attend to a Contributions Daily Meeting where we sort and label new issues ( is:issue label:status/0-needs-triage ), and review every Pull Requests Every pull request should be checked during the Contributions Daily Meeting Even if it\u2019s already assigned Even PR labelled with contributor/waiting-for-corrections or contributor/waiting-for-feedback Issues labeled with priority/P0 and priority/P1 should be assigned. Modifying an issue or a pull request (labels, assignees, milestone) is only possible: During the Contributions Daily Meeting By an assigned maintainer In case of emergency, if a change proposal is approved by 2 other maintainers (on Slack, Discord, Discourse, etc) PR review process: \u00b6 The status needs-design-review is only used in complex/heavy/tricky PRs. From 1 to 2 : 1 comment that says \u201cdesign LGTM\u201d (by a senior maintainer). From 2 to 3 : 3 LGTM approvals by any maintainer. If needed, a specific maintainer familiar with a particular domain can be requested for the review. If a PR has been implemented in pair programming, one peer's LGTM goes into the review for free Amending someone else's pull request is authorized only in emergency, if a rebase is needed, or if the initial contributor is silent We use PRM to manage locally pull requests. Bots \u00b6 Myrmica Lobicornis \u00b6 Update and Merge Pull Request. The maintainer giving the final LGTM must add the status/3-needs-merge label to trigger the merge bot. By default, a squash-rebase merge will be carried out. To preserve commits, add bot/merge-method-rebase before status/3-needs-merge . The status status/4-merge-in-progress is only used by the bot. If the bot is not able to perform the merge, the label bot/need-human-merge is added. In such a situation, solve the conflicts/CI/... and then remove the label bot/need-human-merge . To prevent the bot from automatically merging a PR, add the label bot/no-merge . The label bot/light-review decreases the number of required LGTM from 3 to 1. This label is used when: Updating the vendors from previously reviewed PRs Merging branches into the master Preparing the release Myrmica Bibikoffi \u00b6 closes stale issues [cron] use some criterion as number of days between creation, last update, labels, ... Myrmica Aloba \u00b6 Manage GitHub labels. Add labels on new PR [GitHub WebHook] Add milestone to a new PR based on a branch version (1.4, 1.3, ...) [GitHub WebHook] Add and remove contributor/waiting-for-corrections label when a review request changes [GitHub WebHook] Weekly report of PR status on Slack (CaptainPR) [cron] Labels \u00b6 A maintainer that looks at an issue/PR must define its kind/* , area/* , and status/* . Status - Workflow \u00b6 The status/* labels represent the desired state in the workflow. status/0-needs-triage : all the new issues and PRs have this status. [bot only] status/1-needs-design-review : needs a design review. (only for PR) status/2-needs-review : needs a code/documentation review. (only for PR) status/3-needs-merge : ready to merge. (only for PR) status/4-merge-in-progress : merge is in progress. [bot only] Contributor \u00b6 contributor/need-more-information : we need more information from the contributor in order to analyze a problem. contributor/waiting-for-feedback : we need the contributor to give us feedback. contributor/waiting-for-corrections : we need the contributor to take actions in order to move forward with a PR. (only for PR) [bot, humans] contributor/needs-resolve-conflicts : use it only when there is some conflicts (and an automatic rebase is not possible). (only for PR) [bot, humans] Kind \u00b6 kind/enhancement : a new or improved feature. kind/question : a question. (only for issue) kind/proposal : a proposal that needs to be discussed. Proposal issues are design proposals Proposal PRs are technical prototypes that need to be refined with multiple contributors. kind/bug/possible : a possible bug that needs analysis before it is confirmed or fixed. (only for issues) kind/bug/confirmed : a confirmed bug (reproducible). (only for issues) kind/bug/fix : a bug fix. (only for PR) Resolution \u00b6 resolution/duplicate : a duplicate issue/PR. resolution/declined : declined (Rule #1 of open-source: no is temporary, yes is forever). WIP : Work In Progress. (only for PR) Platform \u00b6 platform/windows : Windows related. Area \u00b6 area/acme : ACME related. area/api : Traefik API related. area/authentication : Authentication related. area/cluster : Traefik clustering related. area/documentation : Documentation related. area/infrastructure : CI or Traefik building scripts related. area/healthcheck : Health-check related. area/logs : Logs related. area/middleware : Middleware related. area/middleware/metrics : Metrics related. (Prometheus, StatsD, ...) area/middleware/tracing : Tracing related. (Jaeger, Zipkin, ...) area/oxy : Oxy related. area/provider : related to all providers. area/provider/boltdb : Boltd DB related. area/provider/consul : Consul related. area/provider/docker : Docker and Swarm related. area/provider/ecs : ECS related. area/provider/etcd : Etcd related. area/provider/eureka : Eureka related. area/provider/file : file provider related. area/provider/k8s : Kubernetes related. area/provider/kv : KV related. area/provider/marathon : Marathon related. area/provider/mesos : Mesos related. area/provider/rancher : Rancher related. area/provider/servicefabric : Azure service fabric related. area/provider/zk : Zoo Keeper related. area/rules : Rules related. area/server : Server related. area/sticky-session : Sticky session related. area/tls : TLS related. area/websocket : WebSocket related. area/webui : Web UI related. Issues Priority \u00b6 priority/P0 : needs hot fix. priority/P1 : need to be fixed in next release. priority/P2 : need to be fixed in the future. priority/P3 : maybe. PR size \u00b6 Automatically set by a bot. size/S : small PR. size/M : medium PR. size/L : Large PR.","title":"Maintainers"},{"location":"contributing/maintainers/#maintainers","text":"","title":"Maintainers"},{"location":"contributing/maintainers/#the-team","text":"Emile Vauge @emilevauge Vincent Demeester @vdemeester Ed Robinson @errm Daniel Tomcej @dtomcej Manuel Zapf @SantoDE Timo Reimann @timoreimann Ludovic Fernandez @ldez Julien Salleyron @juliens Nicolas Mengin @nmengin Marco Jantke @marco-jantke Micha\u00ebl Matur @mmatur G\u00e9rald Cro\u00ebs @geraldcroes Jean-Baptiste Doumenjou @jbdoumenjou Damien Duportal @dduportal Mathieu Lonjaret @mpl","title":"The team"},{"location":"contributing/maintainers/#contributions-daily-meeting","text":"3 Maintainers should attend to a Contributions Daily Meeting where we sort and label new issues ( is:issue label:status/0-needs-triage ), and review every Pull Requests Every pull request should be checked during the Contributions Daily Meeting Even if it\u2019s already assigned Even PR labelled with contributor/waiting-for-corrections or contributor/waiting-for-feedback Issues labeled with priority/P0 and priority/P1 should be assigned. Modifying an issue or a pull request (labels, assignees, milestone) is only possible: During the Contributions Daily Meeting By an assigned maintainer In case of emergency, if a change proposal is approved by 2 other maintainers (on Slack, Discord, Discourse, etc)","title":"Contributions Daily Meeting"},{"location":"contributing/maintainers/#pr-review-process","text":"The status needs-design-review is only used in complex/heavy/tricky PRs. From 1 to 2 : 1 comment that says \u201cdesign LGTM\u201d (by a senior maintainer). From 2 to 3 : 3 LGTM approvals by any maintainer. If needed, a specific maintainer familiar with a particular domain can be requested for the review. If a PR has been implemented in pair programming, one peer's LGTM goes into the review for free Amending someone else's pull request is authorized only in emergency, if a rebase is needed, or if the initial contributor is silent We use PRM to manage locally pull requests.","title":"PR review process:"},{"location":"contributing/maintainers/#bots","text":"","title":"Bots"},{"location":"contributing/maintainers/#myrmica-lobicornis","text":"Update and Merge Pull Request. The maintainer giving the final LGTM must add the status/3-needs-merge label to trigger the merge bot. By default, a squash-rebase merge will be carried out. To preserve commits, add bot/merge-method-rebase before status/3-needs-merge . The status status/4-merge-in-progress is only used by the bot. If the bot is not able to perform the merge, the label bot/need-human-merge is added. In such a situation, solve the conflicts/CI/... and then remove the label bot/need-human-merge . To prevent the bot from automatically merging a PR, add the label bot/no-merge . The label bot/light-review decreases the number of required LGTM from 3 to 1. This label is used when: Updating the vendors from previously reviewed PRs Merging branches into the master Preparing the release","title":"Myrmica Lobicornis"},{"location":"contributing/maintainers/#myrmica-bibikoffi","text":"closes stale issues [cron] use some criterion as number of days between creation, last update, labels, ...","title":"Myrmica Bibikoffi"},{"location":"contributing/maintainers/#myrmica-aloba","text":"Manage GitHub labels. Add labels on new PR [GitHub WebHook] Add milestone to a new PR based on a branch version (1.4, 1.3, ...) [GitHub WebHook] Add and remove contributor/waiting-for-corrections label when a review request changes [GitHub WebHook] Weekly report of PR status on Slack (CaptainPR) [cron]","title":"Myrmica Aloba"},{"location":"contributing/maintainers/#labels","text":"A maintainer that looks at an issue/PR must define its kind/* , area/* , and status/* .","title":"Labels"},{"location":"contributing/maintainers/#status-workflow","text":"The status/* labels represent the desired state in the workflow. status/0-needs-triage : all the new issues and PRs have this status. [bot only] status/1-needs-design-review : needs a design review. (only for PR) status/2-needs-review : needs a code/documentation review. (only for PR) status/3-needs-merge : ready to merge. (only for PR) status/4-merge-in-progress : merge is in progress. [bot only]","title":"Status - Workflow"},{"location":"contributing/maintainers/#contributor","text":"contributor/need-more-information : we need more information from the contributor in order to analyze a problem. contributor/waiting-for-feedback : we need the contributor to give us feedback. contributor/waiting-for-corrections : we need the contributor to take actions in order to move forward with a PR. (only for PR) [bot, humans] contributor/needs-resolve-conflicts : use it only when there is some conflicts (and an automatic rebase is not possible). (only for PR) [bot, humans]","title":"Contributor"},{"location":"contributing/maintainers/#kind","text":"kind/enhancement : a new or improved feature. kind/question : a question. (only for issue) kind/proposal : a proposal that needs to be discussed. Proposal issues are design proposals Proposal PRs are technical prototypes that need to be refined with multiple contributors. kind/bug/possible : a possible bug that needs analysis before it is confirmed or fixed. (only for issues) kind/bug/confirmed : a confirmed bug (reproducible). (only for issues) kind/bug/fix : a bug fix. (only for PR)","title":"Kind"},{"location":"contributing/maintainers/#resolution","text":"resolution/duplicate : a duplicate issue/PR. resolution/declined : declined (Rule #1 of open-source: no is temporary, yes is forever). WIP : Work In Progress. (only for PR)","title":"Resolution"},{"location":"contributing/maintainers/#platform","text":"platform/windows : Windows related.","title":"Platform"},{"location":"contributing/maintainers/#area","text":"area/acme : ACME related. area/api : Traefik API related. area/authentication : Authentication related. area/cluster : Traefik clustering related. area/documentation : Documentation related. area/infrastructure : CI or Traefik building scripts related. area/healthcheck : Health-check related. area/logs : Logs related. area/middleware : Middleware related. area/middleware/metrics : Metrics related. (Prometheus, StatsD, ...) area/middleware/tracing : Tracing related. (Jaeger, Zipkin, ...) area/oxy : Oxy related. area/provider : related to all providers. area/provider/boltdb : Boltd DB related. area/provider/consul : Consul related. area/provider/docker : Docker and Swarm related. area/provider/ecs : ECS related. area/provider/etcd : Etcd related. area/provider/eureka : Eureka related. area/provider/file : file provider related. area/provider/k8s : Kubernetes related. area/provider/kv : KV related. area/provider/marathon : Marathon related. area/provider/mesos : Mesos related. area/provider/rancher : Rancher related. area/provider/servicefabric : Azure service fabric related. area/provider/zk : Zoo Keeper related. area/rules : Rules related. area/server : Server related. area/sticky-session : Sticky session related. area/tls : TLS related. area/websocket : WebSocket related. area/webui : Web UI related.","title":"Area"},{"location":"contributing/maintainers/#issues-priority","text":"priority/P0 : needs hot fix. priority/P1 : need to be fixed in next release. priority/P2 : need to be fixed in the future. priority/P3 : maybe.","title":"Issues Priority"},{"location":"contributing/maintainers/#pr-size","text":"Automatically set by a bot. size/S : small PR. size/M : medium PR. size/L : Large PR.","title":"PR size"},{"location":"contributing/submitting-issues/","text":"Submitting Issues \u00b6 Help Us Help You! We use the GitHub issue tracker to keep track of issues in Traefik. The process of sorting and checking the issues is a daunting task, and requires a lot of work (more than an hour a day ... just for sorting). To save us some time and get quicker feedback, be sure to follow the guide lines below. Getting Help Vs Reporting an Issue The issue tracker is not a general support forum, but a place to report bugs and asks for new features. For end-user related support questions, try using first: the Traefik community forum: Issue Title \u00b6 The title must be short and descriptive. (~60 characters) Description \u00b6 Follow the issue template as much as possible. Explain us in which conditions you encountered the issue, what is your context. Remain as clear and concise as possible Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ). Feature Request \u00b6 Traefik is an open-source project and aims to be the best edge router possible. Remember when asking for new features that these must be useful to the majority (and not only useful in edge case scenarios, or hack-like setups). Do you best to explain what you're looking for, and why it would improve Traefik for everyone. International English \u00b6 Every maintainer / Traefik user is not a native English speaker, so if you feel sometimes that some messages sound rude, remember that it probably is a language barrier problem from someone willing to help you.","title":"Submitting Issues"},{"location":"contributing/submitting-issues/#submitting-issues","text":"Help Us Help You! We use the GitHub issue tracker to keep track of issues in Traefik. The process of sorting and checking the issues is a daunting task, and requires a lot of work (more than an hour a day ... just for sorting). To save us some time and get quicker feedback, be sure to follow the guide lines below. Getting Help Vs Reporting an Issue The issue tracker is not a general support forum, but a place to report bugs and asks for new features. For end-user related support questions, try using first: the Traefik community forum:","title":"Submitting Issues"},{"location":"contributing/submitting-issues/#issue-title","text":"The title must be short and descriptive. (~60 characters)","title":"Issue Title"},{"location":"contributing/submitting-issues/#description","text":"Follow the issue template as much as possible. Explain us in which conditions you encountered the issue, what is your context. Remain as clear and concise as possible Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ).","title":"Description"},{"location":"contributing/submitting-issues/#feature-request","text":"Traefik is an open-source project and aims to be the best edge router possible. Remember when asking for new features that these must be useful to the majority (and not only useful in edge case scenarios, or hack-like setups). Do you best to explain what you're looking for, and why it would improve Traefik for everyone.","title":"Feature Request"},{"location":"contributing/submitting-issues/#international-english","text":"Every maintainer / Traefik user is not a native English speaker, so if you feel sometimes that some messages sound rude, remember that it probably is a language barrier problem from someone willing to help you.","title":"International English"},{"location":"contributing/submitting-pull-requests/","text":"Submitting Pull Requests \u00b6 A Quick Guide for Efficient Contributions So you've decide to improve Traefik? Thank You! Now the last step is to submit your Pull Request in a way that makes sure it gets the attention it deserves. Let's go though the classic pitfalls to make sure everything is right. Title \u00b6 The title must be short and descriptive. (~60 characters) Description \u00b6 Follow the pull request template as much as possible. Explain the conditions which led you to write this PR: give us context. The context should lead to something, an idea or a problem that you\u2019re facing. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ). PR Content \u00b6 Make it small. One feature per Pull Request. Write useful descriptions and titles. Avoid re-formatting code that is not on the path of your PR. Make sure the code builds . Make sure all tests pass . Add tests. Address review comments in terms of additional commits (and don't amend/squash existing ones unless the PR is trivial). third-party dependencies If a PR involves changes to third-party dependencies, the commits pertaining to the vendor folder and the manifest/lock file(s) should be committed separated. 10 Tips for Better Pull Requests We enjoyed this article, maybe you will too! 10 tips for better pull requests .","title":"Submitting PRs"},{"location":"contributing/submitting-pull-requests/#submitting-pull-requests","text":"A Quick Guide for Efficient Contributions So you've decide to improve Traefik? Thank You! Now the last step is to submit your Pull Request in a way that makes sure it gets the attention it deserves. Let's go though the classic pitfalls to make sure everything is right.","title":"Submitting Pull Requests"},{"location":"contributing/submitting-pull-requests/#title","text":"The title must be short and descriptive. (~60 characters)","title":"Title"},{"location":"contributing/submitting-pull-requests/#description","text":"Follow the pull request template as much as possible. Explain the conditions which led you to write this PR: give us context. The context should lead to something, an idea or a problem that you\u2019re facing. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ).","title":"Description"},{"location":"contributing/submitting-pull-requests/#pr-content","text":"Make it small. One feature per Pull Request. Write useful descriptions and titles. Avoid re-formatting code that is not on the path of your PR. Make sure the code builds . Make sure all tests pass . Add tests. Address review comments in terms of additional commits (and don't amend/squash existing ones unless the PR is trivial). third-party dependencies If a PR involves changes to third-party dependencies, the commits pertaining to the vendor folder and the manifest/lock file(s) should be committed separated. 10 Tips for Better Pull Requests We enjoyed this article, maybe you will too! 10 tips for better pull requests .","title":"PR Content"},{"location":"contributing/submitting-security-issues/","text":"Security \u00b6 Security Advisories \u00b6 We strongly advise you to join our mailing list to be aware of the latest announcements from our security team. You can subscribe sending a mail to security+subscribe@traefik.io or on the online viewer . CVE \u00b6 Reported vulnerabilities can be found on cve.mitre.org . Report a Vulnerability \u00b6 We want to keep Traefik safe for everyone. If you've discovered a security vulnerability in Traefik, we appreciate your help in disclosing it to us in a responsible manner, using this form .","title":"Security"},{"location":"contributing/submitting-security-issues/#security","text":"","title":"Security"},{"location":"contributing/submitting-security-issues/#security-advisories","text":"We strongly advise you to join our mailing list to be aware of the latest announcements from our security team. You can subscribe sending a mail to security+subscribe@traefik.io or on the online viewer .","title":"Security Advisories"},{"location":"contributing/submitting-security-issues/#cve","text":"Reported vulnerabilities can be found on cve.mitre.org .","title":"CVE"},{"location":"contributing/submitting-security-issues/#report-a-vulnerability","text":"We want to keep Traefik safe for everyone. If you've discovered a security vulnerability in Traefik, we appreciate your help in disclosing it to us in a responsible manner, using this form .","title":"Report a Vulnerability"},{"location":"contributing/thank-you/","text":"Thank You! \u00b6 You Made It Traefik truly is an open-source project , and wouldn't have become what it is today without the help of our many contributors (at the time of writing this), not accounting for people having helped with issues, tests, comments, articles, ... or just enjoying it and letting others know. So once again, thank you for your invaluable help on making Traefik such a good product. Where to Go Next? If you want to: Propose and idea, request a feature a report a bug, read the page Submitting Issues . Discover how to make an efficient contribution, read the page Submitting Pull Requests . Learn how to build and test Traefik, the page Building and Testing is for you. Contribute to the documentation, read the related page Documentation . Understand how do we learn about Traefik usage, read the Data Collection page. Spread the love about Traefik, please check the Advocating page. Learn about who are the maintainers and how they work on the project, read the Maintainers page.","title":"Thank You!"},{"location":"contributing/thank-you/#thank-you","text":"You Made It Traefik truly is an open-source project , and wouldn't have become what it is today without the help of our many contributors (at the time of writing this), not accounting for people having helped with issues, tests, comments, articles, ... or just enjoying it and letting others know. So once again, thank you for your invaluable help on making Traefik such a good product. Where to Go Next? If you want to: Propose and idea, request a feature a report a bug, read the page Submitting Issues . Discover how to make an efficient contribution, read the page Submitting Pull Requests . Learn how to build and test Traefik, the page Building and Testing is for you. Contribute to the documentation, read the related page Documentation . Understand how do we learn about Traefik usage, read the Data Collection page. Spread the love about Traefik, please check the Advocating page. Learn about who are the maintainers and how they work on the project, read the Maintainers page.","title":"Thank You!"},{"location":"getting-started/concepts/","text":"Concepts \u00b6 Everything You Need to Know Edge Router \u00b6 Traefik is an Edge Router , it means that it's the door to your platform, and that it intercepts and routes every incoming request: it knows all the logic and every rule that determine which services handle which requests (based on the path , the host , headers , and so on ...). Auto Service Discovery \u00b6 Where traditionally edge routers (or reverse proxies) need a configuration file that contains every possible route to your services, Traefik gets them from the services themselves. Deploying your services, you attach information that tells Traefik the characteristics of the requests the services can handle. It means that when a service is deployed, Traefik detects it immediately and updates the routing rules in real time. The opposite is true: when you remove a service from your infrastructure, the route will disappear accordingly. You no longer need to create and synchronize configuration files cluttered with IP addresses or other rules. Many different rules In the example above, we used the request path to determine which service was in charge, but of course you can use many other different rules . Updating the requests In the middleware section, you can learn about how to update the requests before forwarding them to the services. How does Traefik discover the services? Traefik is able to use your cluster API to discover the services and read the attached information. In Traefik, these connectors are called providers because they provide the configuration to Traefik. To learn more about them, read the provider overview section.","title":"Concepts"},{"location":"getting-started/concepts/#concepts","text":"Everything You Need to Know","title":"Concepts"},{"location":"getting-started/concepts/#edge-router","text":"Traefik is an Edge Router , it means that it's the door to your platform, and that it intercepts and routes every incoming request: it knows all the logic and every rule that determine which services handle which requests (based on the path , the host , headers , and so on ...).","title":"Edge Router"},{"location":"getting-started/concepts/#auto-service-discovery","text":"Where traditionally edge routers (or reverse proxies) need a configuration file that contains every possible route to your services, Traefik gets them from the services themselves. Deploying your services, you attach information that tells Traefik the characteristics of the requests the services can handle. It means that when a service is deployed, Traefik detects it immediately and updates the routing rules in real time. The opposite is true: when you remove a service from your infrastructure, the route will disappear accordingly. You no longer need to create and synchronize configuration files cluttered with IP addresses or other rules. Many different rules In the example above, we used the request path to determine which service was in charge, but of course you can use many other different rules . Updating the requests In the middleware section, you can learn about how to update the requests before forwarding them to the services. How does Traefik discover the services? Traefik is able to use your cluster API to discover the services and read the attached information. In Traefik, these connectors are called providers because they provide the configuration to Traefik. To learn more about them, read the provider overview section.","title":"Auto Service Discovery"},{"location":"getting-started/configuration-overview/","text":"Configuration Introduction \u00b6 How the Magic Happens Configuration in Traefik can refer to two different things: The fully dynamic routing configuration (referred to as the dynamic configuration ) The startup configuration (referred to as the static configuration ) Elements in the static configuration set up connections to providers and define the entrypoints Traefik will listen to (these elements don't change often). The dynamic configuration contains everything that defines how the requests are handled by your system. This configuration can change and is seamlessly hot-reloaded, without any request interruption or connection loss. Incompatible Configuration Please be aware that the old configurations for Traefik v1.x are NOT compatible with the v2.x config as of now. If you are running v2, please ensure you are using a v2 configuration. The Dynamic Configuration \u00b6 Traefik gets its dynamic configuration from providers : whether an orchestrator, a service registry, or a plain old configuration file. Since this configuration is specific to your infrastructure choices, we invite you to refer to the dedicated section of this documentation . In the Quick Start example , the dynamic configuration comes from docker in the form of labels attached to your containers. HTTPS Certificates also belong to the dynamic configuration. You can add / update / remove them without restarting your Traefik instance. The Static Configuration \u00b6 There are three different, mutually exclusive (e.g. you can use only one at the same time), ways to define static configuration options in Traefik: In a configuration file In the command-line arguments As environment variables These ways are evaluated in the order listed above. If no value was provided for a given option, a default value applies. Moreover, if an option has sub-options, and any of these sub-options is not specified, a default value will apply as well. For example, the --providers.docker option is enough by itself to enable the docker provider, even though sub-options like --providers.docker.endpoint exist. Once positioned, this option sets (and resets) all the default values of the sub-options of --providers.docker . Configuration File \u00b6 At startup, Traefik searches for a file named traefik.toml (or traefik.yml or traefik.yaml ) in: /etc/traefik/ $XDG_CONFIG_HOME/ $HOME/.config/ . ( the working directory ). You can override this using the configFile argument. traefik --configFile=foo/bar/myconfigfile.toml Arguments \u00b6 To get the list of all available arguments: traefik --help # or docker run traefik[:version] --help # ex: docker run traefik:2.0 --help All available arguments can also be found here . Environment Variables \u00b6 All available environment variables can be found here Available Configuration Options \u00b6 All the configuration options are documented in their related section. You can browse the available features in the menu, the providers , or the routing section to see them in action.","title":"Configuration Introduction"},{"location":"getting-started/configuration-overview/#configuration-introduction","text":"How the Magic Happens Configuration in Traefik can refer to two different things: The fully dynamic routing configuration (referred to as the dynamic configuration ) The startup configuration (referred to as the static configuration ) Elements in the static configuration set up connections to providers and define the entrypoints Traefik will listen to (these elements don't change often). The dynamic configuration contains everything that defines how the requests are handled by your system. This configuration can change and is seamlessly hot-reloaded, without any request interruption or connection loss. Incompatible Configuration Please be aware that the old configurations for Traefik v1.x are NOT compatible with the v2.x config as of now. If you are running v2, please ensure you are using a v2 configuration.","title":"Configuration Introduction"},{"location":"getting-started/configuration-overview/#the-dynamic-configuration","text":"Traefik gets its dynamic configuration from providers : whether an orchestrator, a service registry, or a plain old configuration file. Since this configuration is specific to your infrastructure choices, we invite you to refer to the dedicated section of this documentation . In the Quick Start example , the dynamic configuration comes from docker in the form of labels attached to your containers. HTTPS Certificates also belong to the dynamic configuration. You can add / update / remove them without restarting your Traefik instance.","title":"The Dynamic Configuration"},{"location":"getting-started/configuration-overview/#the-static-configuration","text":"There are three different, mutually exclusive (e.g. you can use only one at the same time), ways to define static configuration options in Traefik: In a configuration file In the command-line arguments As environment variables These ways are evaluated in the order listed above. If no value was provided for a given option, a default value applies. Moreover, if an option has sub-options, and any of these sub-options is not specified, a default value will apply as well. For example, the --providers.docker option is enough by itself to enable the docker provider, even though sub-options like --providers.docker.endpoint exist. Once positioned, this option sets (and resets) all the default values of the sub-options of --providers.docker .","title":"The Static Configuration"},{"location":"getting-started/configuration-overview/#configuration-file","text":"At startup, Traefik searches for a file named traefik.toml (or traefik.yml or traefik.yaml ) in: /etc/traefik/ $XDG_CONFIG_HOME/ $HOME/.config/ . ( the working directory ). You can override this using the configFile argument. traefik --configFile=foo/bar/myconfigfile.toml","title":"Configuration File"},{"location":"getting-started/configuration-overview/#arguments","text":"To get the list of all available arguments: traefik --help # or docker run traefik[:version] --help # ex: docker run traefik:2.0 --help All available arguments can also be found here .","title":"Arguments"},{"location":"getting-started/configuration-overview/#environment-variables","text":"All available environment variables can be found here","title":"Environment Variables"},{"location":"getting-started/configuration-overview/#available-configuration-options","text":"All the configuration options are documented in their related section. You can browse the available features in the menu, the providers , or the routing section to see them in action.","title":"Available Configuration Options"},{"location":"getting-started/install-traefik/","text":"Install Traefik \u00b6 You can install Traefik with the following flavors: Use the official Docker image (Experimental) Use the Helm Chart Use the binary distribution Compile your binary from the sources Use the Official Docker Image \u00b6 Choose one of the official Docker images and run it with the sample configuration file : docker run -d -p 8080:8080 -p 80:80 \\ -v $PWD/traefik.toml:/etc/traefik/traefik.toml traefik:v2.0 For more details, go to the Docker provider documentation Tip Prefer a fixed version than the latest that could be an unexpected version. ex: traefik:v2.0.0 Docker images are based from the Alpine Linux Official image . All the orchestrator using docker images could fetch the official Traefik docker image. Use the Helm Chart \u00b6 Experimental Helm Chart Please note that the Helm Chart for Traefik v2 is still experimental. The Traefik Stable Chart from Helm's default charts repository is still using Traefik v1.7 . Traefik can be installed in Kubernetes using the v2.0 Helm chart from https://github.com/containous/traefik-helm-chart . Ensure that the following requirements are met: Kubernetes 1.14+ Helm version 2.x is installed and initialized with Tiller Retrieve the latest chart version from the repository: # Retrieve Chart from the repository git clone https://github.com/containous/traefik-helm-chart And install it with the helm command line: helm install ./traefik-helm-chart Helm Features All Helm features are supported. For instance, installing the chart in a dedicated namespace: Install in a Dedicated Namespace # Install in the namespace \"traefik-v2\" helm install --namespace=traefik-v2 \\ ./traefik-helm-chart Installing with Custom Values You can customize the installation by specifying custom values, as with any helm chart . The values are not (yet) documented, but are self-explanatory: you can look at the default values.yaml file to explore possibilities. Example of installation with logging set to DEBUG : Using Helm CLI helm install --namespace=traefik-v2 \\ --set=\"logs.loglevel=DEBUG\" \\ ./traefik-helm-chart With a custom values file # File custom-values.yml ## Install with \"helm install --values=./custom-values.yml ./traefik-helm-chart logs: loglevel: DEBUG Use the Binary Distribution \u00b6 Grab the latest binary from the releases page. Check the integrity of the downloaded file Linux # Compare this value to the one found in traefik-${traefik_version}_checksums.txt sha256sum ./traefik_${traefik_version}_linux_${arch}.tar.gz macOS # Compare this value to the one found in traefik-${traefik_version}_checksums.txt shasum -a256 ./traefik_${traefik_version}_darwin_amd64.tar.gz Windows PowerShell # Compare this value to the one found in traefik-${traefik_version}_checksums.txt Get-FileHash ./traefik_${traefik_version}_windows_${arch}.zip -Algorithm SHA256 Extract the downloaded archive Linux tar -zxvf traefik_${traefik_version}_linux_${arch}.tar.gz macOS tar -zxvf ./traefik_${traefik_version}_darwin_amd64.tar.gz Windows PowerShell Expand-Archive traefik_${traefik_version}_windows_${arch}.zip And run it: ./traefik --help Compile your Binary from the Sources \u00b6 All the details are available in the Contributing Guide","title":"Install Traefik"},{"location":"getting-started/install-traefik/#install-traefik","text":"You can install Traefik with the following flavors: Use the official Docker image (Experimental) Use the Helm Chart Use the binary distribution Compile your binary from the sources","title":"Install Traefik"},{"location":"getting-started/install-traefik/#use-the-official-docker-image","text":"Choose one of the official Docker images and run it with the sample configuration file : docker run -d -p 8080:8080 -p 80:80 \\ -v $PWD/traefik.toml:/etc/traefik/traefik.toml traefik:v2.0 For more details, go to the Docker provider documentation Tip Prefer a fixed version than the latest that could be an unexpected version. ex: traefik:v2.0.0 Docker images are based from the Alpine Linux Official image . All the orchestrator using docker images could fetch the official Traefik docker image.","title":"Use the Official Docker Image"},{"location":"getting-started/install-traefik/#use-the-helm-chart","text":"Experimental Helm Chart Please note that the Helm Chart for Traefik v2 is still experimental. The Traefik Stable Chart from Helm's default charts repository is still using Traefik v1.7 . Traefik can be installed in Kubernetes using the v2.0 Helm chart from https://github.com/containous/traefik-helm-chart . Ensure that the following requirements are met: Kubernetes 1.14+ Helm version 2.x is installed and initialized with Tiller Retrieve the latest chart version from the repository: # Retrieve Chart from the repository git clone https://github.com/containous/traefik-helm-chart And install it with the helm command line: helm install ./traefik-helm-chart Helm Features All Helm features are supported. For instance, installing the chart in a dedicated namespace: Install in a Dedicated Namespace # Install in the namespace \"traefik-v2\" helm install --namespace=traefik-v2 \\ ./traefik-helm-chart Installing with Custom Values You can customize the installation by specifying custom values, as with any helm chart . The values are not (yet) documented, but are self-explanatory: you can look at the default values.yaml file to explore possibilities. Example of installation with logging set to DEBUG : Using Helm CLI helm install --namespace=traefik-v2 \\ --set=\"logs.loglevel=DEBUG\" \\ ./traefik-helm-chart With a custom values file # File custom-values.yml ## Install with \"helm install --values=./custom-values.yml ./traefik-helm-chart logs: loglevel: DEBUG","title":"Use the Helm Chart"},{"location":"getting-started/install-traefik/#use-the-binary-distribution","text":"Grab the latest binary from the releases page. Check the integrity of the downloaded file Linux # Compare this value to the one found in traefik-${traefik_version}_checksums.txt sha256sum ./traefik_${traefik_version}_linux_${arch}.tar.gz macOS # Compare this value to the one found in traefik-${traefik_version}_checksums.txt shasum -a256 ./traefik_${traefik_version}_darwin_amd64.tar.gz Windows PowerShell # Compare this value to the one found in traefik-${traefik_version}_checksums.txt Get-FileHash ./traefik_${traefik_version}_windows_${arch}.zip -Algorithm SHA256 Extract the downloaded archive Linux tar -zxvf traefik_${traefik_version}_linux_${arch}.tar.gz macOS tar -zxvf ./traefik_${traefik_version}_darwin_amd64.tar.gz Windows PowerShell Expand-Archive traefik_${traefik_version}_windows_${arch}.zip And run it: ./traefik --help","title":"Use the Binary Distribution"},{"location":"getting-started/install-traefik/#compile-your-binary-from-the-sources","text":"All the details are available in the Contributing Guide","title":"Compile your Binary from the Sources"},{"location":"getting-started/quick-start/","text":"Quick Start \u00b6 A Simple Use Case Using Docker Launch Traefik With the Docker Provider \u00b6 Create a docker-compose.yml file where you will define a reverse-proxy service that uses the official Traefik image: version: '3' services: reverse-proxy: # The official v2.0 Traefik docker image image: traefik:v2.0 # Enables the web UI and tells Traefik to listen to docker command: --api.insecure=true --providers.docker ports: # The HTTP port - \"80:80\" # The Web UI (enabled by --api.insecure=true) - \"8080:8080\" volumes: # So that Traefik can listen to the Docker events - /var/run/docker.sock:/var/run/docker.sock That's it. Now you can launch Traefik! Start your reverse-proxy with the following command: docker-compose up -d reverse-proxy You can open a browser and go to http://localhost:8080/api/rawdata to see Traefik's API rawdata (we'll go back there once we have launched a service in step 2). Traefik Detects New Services and Creates the Route for You \u00b6 Now that we have a Traefik instance up and running, we will deploy new services. Edit your docker-compose.yml file and add the following at the end of your file. # ... whoami: # A container that exposes an API to show its IP address image: containous/whoami labels: - \"traefik.http.routers.whoami.rule=Host(`whoami.docker.localhost`)\" The above defines whoami : a simple web service that outputs information about the machine it is deployed on (its IP address, host, and so on). Start the whoami service with the following command: docker-compose up -d whoami Go back to your browser ( http://localhost:8080/api/rawdata ) and see that Traefik has automatically detected the new container and updated its own configuration. When Traefik detects new services, it creates the corresponding routes so you can call them ... let's see! (Here, we're using curl) curl -H Host:whoami.docker.localhost http://127.0.0.1 Shows the following output: Hostname: a656c8ddca6c IP: 172.27.0.3 #... More Instances? Traefik Load Balances Them \u00b6 Run more instances of your whoami service with the following command: docker-compose up -d --scale whoami=2 Go back to your browser ( http://localhost:8080/api/rawdata ) and see that Traefik has automatically detected the new instance of the container. Finally, see that Traefik load-balances between the two instances of your service by running the following command twice: curl -H Host:whoami.docker.localhost http://127.0.0.1 The output will show alternatively one of the followings: Hostname: a656c8ddca6c IP: 172.27.0.3 #... Hostname: s458f154e1f1 IP: 172.27.0.4 # ... Where to Go Next? Now that you have a basic understanding of how Traefik can automatically create the routes to your services and load balance them, it is time to dive into the documentation and let Traefik work for you!","title":"Quick Start"},{"location":"getting-started/quick-start/#quick-start","text":"A Simple Use Case Using Docker","title":"Quick Start"},{"location":"getting-started/quick-start/#launch-traefik-with-the-docker-provider","text":"Create a docker-compose.yml file where you will define a reverse-proxy service that uses the official Traefik image: version: '3' services: reverse-proxy: # The official v2.0 Traefik docker image image: traefik:v2.0 # Enables the web UI and tells Traefik to listen to docker command: --api.insecure=true --providers.docker ports: # The HTTP port - \"80:80\" # The Web UI (enabled by --api.insecure=true) - \"8080:8080\" volumes: # So that Traefik can listen to the Docker events - /var/run/docker.sock:/var/run/docker.sock That's it. Now you can launch Traefik! Start your reverse-proxy with the following command: docker-compose up -d reverse-proxy You can open a browser and go to http://localhost:8080/api/rawdata to see Traefik's API rawdata (we'll go back there once we have launched a service in step 2).","title":"Launch Traefik With the Docker Provider"},{"location":"getting-started/quick-start/#traefik-detects-new-services-and-creates-the-route-for-you","text":"Now that we have a Traefik instance up and running, we will deploy new services. Edit your docker-compose.yml file and add the following at the end of your file. # ... whoami: # A container that exposes an API to show its IP address image: containous/whoami labels: - \"traefik.http.routers.whoami.rule=Host(`whoami.docker.localhost`)\" The above defines whoami : a simple web service that outputs information about the machine it is deployed on (its IP address, host, and so on). Start the whoami service with the following command: docker-compose up -d whoami Go back to your browser ( http://localhost:8080/api/rawdata ) and see that Traefik has automatically detected the new container and updated its own configuration. When Traefik detects new services, it creates the corresponding routes so you can call them ... let's see! (Here, we're using curl) curl -H Host:whoami.docker.localhost http://127.0.0.1 Shows the following output: Hostname: a656c8ddca6c IP: 172.27.0.3 #...","title":"Traefik Detects New Services and Creates the Route for You"},{"location":"getting-started/quick-start/#more-instances-traefik-load-balances-them","text":"Run more instances of your whoami service with the following command: docker-compose up -d --scale whoami=2 Go back to your browser ( http://localhost:8080/api/rawdata ) and see that Traefik has automatically detected the new instance of the container. Finally, see that Traefik load-balances between the two instances of your service by running the following command twice: curl -H Host:whoami.docker.localhost http://127.0.0.1 The output will show alternatively one of the followings: Hostname: a656c8ddca6c IP: 172.27.0.3 #... Hostname: s458f154e1f1 IP: 172.27.0.4 # ... Where to Go Next? Now that you have a basic understanding of how Traefik can automatically create the routes to your services and load balance them, it is time to dive into the documentation and let Traefik work for you!","title":"More Instances? Traefik Load Balances Them"},{"location":"https/acme/","text":"Let's Encrypt \u00b6 Automatic HTTPS You can configure Traefik to use an ACME provider (like Let's Encrypt) for automatic certificate generation. Let's Encrypt and Rate Limiting Note that Let's Encrypt API has rate limiting . Use Let's Encrypt staging server with the caServer configuration option when experimenting to avoid hitting this limit too fast. Certificate Resolvers \u00b6 Traefik requires you to define \"Certificate Resolvers\" in the static configuration , which are responsible for retrieving certificates from an ACME server. Then, each \"router\" is configured to enable TLS, and is associated to a certificate resolver through the tls.certresolver configuration option . Certificates are requested for domain names retrieved from the router's dynamic configuration . You can read more about this retrieval mechanism in the following section: ACME Domain Definition . Domain Definition \u00b6 Certificate resolvers request certificates for a set of the domain names inferred from routers, with the following logic: If the router has a tls.domains option set, then the certificate resolver uses the main (and optionally sans ) option of tls.domains to know the domain names for this router. If no tls.domains option is set, then the certificate resolver uses the router's rule , by checking the Host() matchers. Please note that multiple Host() matchers can be used ) for specifying multiple domain names for this router. Please note that: When multiple domain names are inferred from a given router, only one certificate is requested with the first domain name as the main domain, and the other domains as \"SANs\" (Subject Alternative Name) . As ACME V2 supports \"wildcard domains\" , any router can provide a wildcard domain name, as \"main\" domain or as \"SAN\" domain. Please check the configuration examples below for more details. Configuration Examples \u00b6 Enabling ACME File (TOML) [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web-secure] address = \":443\" [certificatesResolvers.sample.acme] email = \"your-email@your-domain.org\" storage = \"acme.json\" [certificatesResolvers.sample.acme.httpChallenge] # used during the challenge entryPoint = \"web\" File (YAML) entryPoints: web: address: \":80\" web-secure: address: \":443\" certificatesResolvers: sample: acme: email: your-email@your-domain.org storage: acme.json httpChallenge: # used during the challenge entryPoint: web CLI --entryPoints.web.address=:80 --entryPoints.websecure.address=:443 # ... --certificatesResolvers.sample.acme.email=your-email@your-domain.org --certificatesResolvers.sample.acme.storage=acme.json # used during the challenge --certificatesResolvers.sample.acme.httpChallenge.entryPoint=web Defining a certificates resolver does not result in all routers automatically using it. Each router that is supposed to use the resolver must reference it. Configuration Reference There are many available options for ACME. For a quick glance at what's possible, browse the configuration reference: File (TOML) # Enable ACME (Let's Encrypt): automatic SSL. [certificatesResolvers.sample.acme] # Email address used for registration. # # Required # email = \"test@traefik.io\" # File or key used for certificates storage. # # Required # storage = \"acme.json\" # CA server to use. # Uncomment the line to use Let's Encrypt's staging server, # leave commented to go to prod. # # Optional # Default: \"https://acme-v02.api.letsencrypt.org/directory\" # # caServer = \"https://acme-staging-v02.api.letsencrypt.org/directory\" # KeyType to use. # # Optional # Default: \"RSA4096\" # # Available values : \"EC256\", \"EC384\", \"RSA2048\", \"RSA4096\", \"RSA8192\" # # keyType = \"RSA4096\" # Use a TLS-ALPN-01 ACME challenge. # # Optional (but recommended) # [certificatesResolvers.sample.acme.tlsChallenge] # Use a HTTP-01 ACME challenge. # # Optional # # [certificatesResolvers.sample.acme.httpChallenge] # EntryPoint to use for the HTTP-01 challenges. # # Required # # entryPoint = \"web\" # Use a DNS-01 ACME challenge rather than HTTP-01 challenge. # Note: mandatory for wildcard certificate generation. # # Optional # # [certificatesResolvers.sample.acme.dnsChallenge] # DNS provider used. # # Required # # provider = \"digitalocean\" # By default, the provider will verify the TXT DNS challenge record before letting ACME verify. # If delayBeforeCheck is greater than zero, this check is delayed for the configured duration in seconds. # Useful if internal networks block external DNS queries. # # Optional # Default: 0 # # delayBeforeCheck = 0 # Use following DNS servers to resolve the FQDN authority. # # Optional # Default: empty # # resolvers = [\"1.1.1.1:53\", \"8.8.8.8:53\"] # Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. # # NOT RECOMMENDED: # Increase the risk of reaching Let's Encrypt's rate limits. # # Optional # Default: false # # disablePropagationCheck = true File (YAML) certificatesResolvers: sample: # Enable ACME (Let's Encrypt): automatic SSL. acme: # Email address used for registration. # # Required # email: \"test@traefik.io\" # File or key used for certificates storage. # # Required # storage: \"acme.json\" # CA server to use. # Uncomment the line to use Let's Encrypt's staging server, # leave commented to go to prod. # # Optional # Default: \"https://acme-v02.api.letsencrypt.org/directory\" # # caServer: \"https://acme-staging-v02.api.letsencrypt.org/directory\" # KeyType to use. # # Optional # Default: \"RSA4096\" # # Available values : \"EC256\", \"EC384\", \"RSA2048\", \"RSA4096\", \"RSA8192\" # # keyType: RSA4096 # Use a TLS-ALPN-01 ACME challenge. # # Optional (but recommended) # tlsChallenge: # Use a HTTP-01 ACME challenge. # # Optional # # httpChallenge: # EntryPoint to use for the HTTP-01 challenges. # # Required # # entryPoint: web # Use a DNS-01 ACME challenge rather than HTTP-01 challenge. # Note: mandatory for wildcard certificate generation. # # Optional # # dnsChallenge: # DNS provider used. # # Required # # provider: digitalocean # By default, the provider will verify the TXT DNS challenge record before letting ACME verify. # If delayBeforeCheck is greater than zero, this check is delayed for the configured duration in seconds. # Useful if internal networks block external DNS queries. # # Optional # Default: 0 # # delayBeforeCheck: 0 # Use following DNS servers to resolve the FQDN authority. # # Optional # Default: empty # # resolvers # - \"1.1.1.1:53\" # - \"8.8.8.8:53\" # Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. # # NOT RECOMMENDED: # Increase the risk of reaching Let's Encrypt's rate limits. # # Optional # Default: false # # disablePropagationCheck: true CLI # Enable ACME (Let's Encrypt): automatic SSL. # Email address used for registration. # # Required # --certificatesResolvers.sample.acme.email=test@traefik.io # File or key used for certificates storage. # # Required # --certificatesResolvers.sample.acme.storage=acme.json # CA server to use. # Uncomment the line to use Let's Encrypt's staging server, # leave commented to go to prod. # # Optional # Default: \"https://acme-v02.api.letsencrypt.org/directory\" # --certificatesResolvers.sample.acme.caServer=https://acme-staging-v02.api.letsencrypt.org/directory # KeyType to use. # # Optional # Default: \"RSA4096\" # # Available values : \"EC256\", \"EC384\", \"RSA2048\", \"RSA4096\", \"RSA8192\" # --certificatesResolvers.sample.acme.keyType=RSA4096 # Use a TLS-ALPN-01 ACME challenge. # # Optional (but recommended) # --certificatesResolvers.sample.acme.tlsChallenge=true # Use a HTTP-01 ACME challenge. # # Optional # --certificatesResolvers.sample.acme.httpChallenge=true # EntryPoint to use for the HTTP-01 challenges. # # Required # --certificatesResolvers.sample.acme.httpChallenge.entryPoint=web # Use a DNS-01 ACME challenge rather than HTTP-01 challenge. # Note: mandatory for wildcard certificate generation. # # Optional # --certificatesResolvers.sample.acme.dnsChallenge=true # DNS provider used. # # Required # --certificatesResolvers.sample.acme.dnsChallenge.provider=digitalocean # By default, the provider will verify the TXT DNS challenge record before letting ACME verify. # If delayBeforeCheck is greater than zero, this check is delayed for the configured duration in seconds. # Useful if internal networks block external DNS queries. # # Optional # Default: 0 # --certificatesResolvers.sample.acme.dnsChallenge.delayBeforeCheck=0 # Use following DNS servers to resolve the FQDN authority. # # Optional # Default: empty # --certificatesResolvers.sample.acme.dnsChallenge.resolvers=1.1.1.1:53,8.8.8.8:53 # Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. # # NOT RECOMMENDED: # Increase the risk of reaching Let's Encrypt's rate limits. # # Optional # Default: false # --certificatesResolvers.sample.acme.dnsChallenge.disablePropagationCheck=true Single Domain from Router's Rule Example A certificate for the domain company.com is requested: Docker ## Dynamic configuration labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le Docker (Swarm) ## Dynamic configuration deploy: labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.services.blog-svc.loadbalancer.server.port=8080\" - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le Kubernetes --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: blogtls spec: entryPoints: - websecure routes: - match: Host(`company.com`) && Path(`/blog`) kind: Rule services: - name: blog port: 8080 tls: {} Marathon labels: { \"traefik.http.routers.blog.rule\": \"Host(`company.com`) && Path(`/blog`)\", \"traefik.http.routers.blog.tls\": \"true\", \"traefik.http.routers.blog.tls.certresolver\": \"le\", \"traefik.http.services.blog-svc.loadbalancer.server.port\": \"8080\" } Rancher ## Dynamic configuration labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le Single Domain ## Dynamic configuration [http.routers] [http.routers.blog] rule = \"Host(`company.com`) && Path(`/blog`)\" [http.routers.blog.tls] certResolver = \"le\" # From static configuration File (YAML) ## Dynamic configuration http: routers: blog: rule: \"Host(`company.com`) && Path(`/blog`)\" tls: certResolver: le Multiple Domains from Router's Rule Example A certificate for the domains company.com (main) and blog.company.org is requested: Docker ## Dynamic configuration labels: - traefik.http.routers.blog.rule=(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le Docker (Swarm) ## Dynamic configuration deploy: labels: - traefik.http.routers.blog.rule=(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`) - traefik.http.services.blog-svc.loadbalancer.server.port=8080\" - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le Kubernetes --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: blogtls spec: entryPoints: - websecure routes: - match: (Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`) kind: Rule services: - name: blog port: 8080 tls: {} Marathon labels: { \"traefik.http.routers.blog.rule\": \"(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`)\", \"traefik.http.routers.blog.tls\": \"true\", \"traefik.http.routers.blog.tls.certresolver\": \"le\", \"traefik.http.services.blog-svc.loadbalancer.server.port\": \"8080\" } Rancher ## Dynamic configuration labels: - traefik.http.routers.blog.rule=(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le File (TOML) ## Dynamic configuration [http.routers] [http.routers.blog] rule = \"(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`)\" [http.routers.blog.tls] certResolver = \"le\" # From static configuration File (YAML) ## Dynamic configuration http: routers: blog: rule: \"(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`)\" tls: certResolver: le Multiple Domains from Router's tls.domain Example A certificate for the domains company.com (main) and *.company.org (SAN) is requested: Docker ## Dynamic configuration labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le - traefik.http.routers.blog.tls.domains[0].main=company.org - traefik.http.routers.blog.tls.domains[0].sans=*.company.org Docker (Swarm) ## Dynamic configuration deploy: labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.services.blog-svc.loadbalancer.server.port=8080\" - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le - traefik.http.routers.blog.tls.domains[0].main=company.org - traefik.http.routers.blog.tls.domains[0].sans=*.company.org Kubernetes --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: blogtls spec: entryPoints: - websecure routes: - match: Host(`company.com`) && Path(`/blog`) kind: Rule services: - name: blog port: 8080 tls: certResolver: le Marathon labels: { \"traefik.http.routers.blog.rule\": \"Host(`company.com`) && Path(`/blog`)\", \"traefik.http.routers.blog.tls\": \"true\", \"traefik.http.routers.blog.tls.certresolver\": \"le\", \"traefik.http.routers.blog.tls.domains[0].main\": \"company.com\", \"traefik.http.routers.blog.tls.domains[0].sans\": \"*.company.com\", \"traefik.http.services.blog-svc.loadbalancer.server.port\": \"8080\" } Rancher ## Dynamic configuration labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le - traefik.http.routers.blog.tls.domains[0].main=company.org - traefik.http.routers.blog.tls.domains[0].sans=*.company.org File (TOML) ## Dynamic configuration [http.routers] [http.routers.blog] rule = \"Host(`company.com`) && Path(`/blog`)\" [http.routers.blog.tls] certResolver = \"le\" # From static configuration [[http.routers.blog.tls.domains]] main = \"company.org\" sans = [\"*.company.org\"] File (YAML) ## Dynamic configuration http: routers: blog: rule: \"Host(`company.com`) && Path(`/blog`)\" tls: certResolver: le domains: - main: \"company.org\" sans: - \"*.company.org\" Automatic Renewals \u00b6 Traefik automatically tracks the expiry date of ACME certificates it generates. If there are less than 30 days remaining before the certificate expires, Traefik will attempt to renew it automatically. Certificates that are no longer used may still be renewed, as Traefik does not currently check if the certificate is being used before renewing. Using LetsEncrypt with Kubernetes \u00b6 When using LetsEncrypt with kubernetes, there are some known caveats with both the ingress and crd providers. If you intend to run multiple instances of Traefik with LetsEncrypt, please ensure you read the sections on those provider pages. The Different ACME Challenges \u00b6 Defining a certificates resolver does not result in all routers automatically using it. Each router that is supposed to use the resolver must reference it. tlsChallenge \u00b6 Use the TLS-ALPN-01 challenge to generate and renew ACME certificates by provisioning a TLS certificate. As described on the Let's Encrypt community forum , when using the TLS-ALPN-01 challenge, Traefik must be reachable by Let's Encrypt through port 443. Configuring the tlsChallenge File (TOML) [certificatesResolvers.sample.acme] # ... [certificatesResolvers.sample.acme.tlsChallenge] File (YAML) certificatesResolvers: sample: acme: # ... tlsChallenge: {} CLI # ... --certificatesResolvers.sample.acme.tlsChallenge=true httpChallenge \u00b6 Use the HTTP-01 challenge to generate and renew ACME certificates by provisioning an HTTP resource under a well-known URI. As described on the Let's Encrypt community forum , when using the HTTP-01 challenge, certificatesResolvers.sample.acme.httpChallenge.entryPoint must be reachable by Let's Encrypt through port 80. Using an EntryPoint Called http for the httpChallenge File (TOML) [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web-secure] address = \":443\" [certificatesResolvers.sample.acme] # ... [certificatesResolvers.sample.acme.httpChallenge] entryPoint = \"web\" File (YAML) entryPoints: web: address: \":80\" web-secure: address: \":443\" certificatesResolvers: sample: acme: # ... httpChallenge: entryPoint: web CLI --entryPoints.web.address=:80 --entryPoints.websecure.address=:443 # ... --certificatesResolvers.sample.acme.httpChallenge.entryPoint=web Redirection is fully compatible with the HTTP-01 challenge. dnsChallenge \u00b6 Use the DNS-01 challenge to generate and renew ACME certificates by provisioning a DNS record. Configuring a dnsChallenge with the DigitalOcean Provider File (TOML) [certificatesResolvers.sample.acme] # ... [certificatesResolvers.sample.acme.dnsChallenge] provider = \"digitalocean\" delayBeforeCheck = 0 # ... File (YAML) certificatesResolvers: sample: acme: # ... dnsChallenge: provider: digitalocean delayBeforeCheck: 0 # ... CLI # ... --certificatesResolvers.sample.acme.dnsChallenge.provider=digitalocean --certificatesResolvers.sample.acme.dnsChallenge.delayBeforeCheck=0 # ... Important A provider is mandatory. providers \u00b6 Here is a list of supported providers , that can automate the DNS verification, along with the required environment variables and their wildcard & root domain support . Do not hesitate to complete it. Every lego environment variable can be overridden by their respective _FILE counterpart, which should have a filepath to a file that contains the secret as its value. For example, CF_API_EMAIL_FILE=/run/secrets/traefik_cf-api-email could be used to provide a Cloudflare API email address as a Docker secret named traefik_cf-api-email . Provider Name Provider Code Environment Variables ACME DNS acme-dns ACME_DNS_API_BASE , ACME_DNS_STORAGE_PATH Additional configuration Alibaba Cloud alidns ALICLOUD_ACCESS_KEY , ALICLOUD_SECRET_KEY , ALICLOUD_REGION_ID Additional configuration Auroradns auroradns AURORA_USER_ID , AURORA_KEY , AURORA_ENDPOINT Additional configuration Autodns autodns AUTODNS_API_USER , AUTODNS_API_PASSWORD Additional configuration Azure azure AZURE_CLIENT_ID , AZURE_CLIENT_SECRET , AZURE_SUBSCRIPTION_ID , AZURE_TENANT_ID , AZURE_RESOURCE_GROUP , [AZURE_METADATA_ENDPOINT] Additional configuration Bindman bindman BINDMAN_MANAGER_ADDRESS Additional configuration Blue Cat bluecat BLUECAT_SERVER_URL , BLUECAT_USER_NAME , BLUECAT_PASSWORD , BLUECAT_CONFIG_NAME , BLUECAT_DNS_VIEW Additional configuration ClouDNS cloudns CLOUDNS_AUTH_ID , CLOUDNS_AUTH_PASSWORD Additional configuration Cloudflare cloudflare CF_API_EMAIL , CF_API_KEY 5 or CF_DNS_API_TOKEN , [CF_ZONE_API_TOKEN] Additional configuration CloudXNS cloudxns CLOUDXNS_API_KEY , CLOUDXNS_SECRET_KEY Additional configuration ConoHa conoha CONOHA_TENANT_ID , CONOHA_API_USERNAME , CONOHA_API_PASSWORD Additional configuration DigitalOcean digitalocean DO_AUTH_TOKEN Additional configuration DNSimple dnsimple DNSIMPLE_OAUTH_TOKEN , DNSIMPLE_BASE_URL Additional configuration DNS Made Easy dnsmadeeasy DNSMADEEASY_API_KEY , DNSMADEEASY_API_SECRET , DNSMADEEASY_SANDBOX Additional configuration DNSPod dnspod DNSPOD_API_KEY Additional configuration Domain Offensive (do.de) dode DODE_TOKEN Additional configuration DreamHost dreamhost DREAMHOST_API_KEY Additional configuration Duck DNS duckdns DUCKDNS_TOKEN Additional configuration Dyn dyn DYN_CUSTOMER_NAME , DYN_USER_NAME , DYN_PASSWORD Additional configuration EasyDNS easydns EASYDNS_TOKEN , EASYDNS_KEY Additional configuration External Program exec EXEC_PATH Additional configuration Exoscale exoscale EXOSCALE_API_KEY , EXOSCALE_API_SECRET , EXOSCALE_ENDPOINT Additional configuration Fast DNS fastdns AKAMAI_CLIENT_TOKEN , AKAMAI_CLIENT_SECRET , AKAMAI_ACCESS_TOKEN Additional configuration Gandi gandi GANDI_API_KEY Additional configuration Gandi v5 gandiv5 GANDIV5_API_KEY Additional configuration Glesys glesys GLESYS_API_USER , GLESYS_API_KEY , GLESYS_DOMAIN Additional configuration GoDaddy godaddy GODADDY_API_KEY , GODADDY_API_SECRET Additional configuration Google Cloud DNS gcloud GCE_PROJECT , Application Default Credentials 2 3 , [ GCE_SERVICE_ACCOUNT_FILE ] Additional configuration hosting.de hostingde HOSTINGDE_API_KEY , HOSTINGDE_ZONE_NAME Additional configuration HTTP request httpreq HTTPREQ_ENDPOINT , HTTPREQ_MODE , HTTPREQ_USERNAME , HTTPREQ_PASSWORD 1 Additional configuration IIJ iij IIJ_API_ACCESS_KEY , IIJ_API_SECRET_KEY , IIJ_DO_SERVICE_CODE Additional configuration INWX inwx INWX_USERNAME , INWX_PASSWORD Additional configuration Joker.com joker JOKER_API_KEY or JOKER_USERNAME , JOKER_PASSWORD Additional configuration Lightsail lightsail AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , DNS_ZONE Additional configuration Linode linode LINODE_API_KEY Additional configuration Linode v4 linodev4 LINODE_TOKEN Additional configuration Liquid Web liquidweb LIQUID_WEB_PASSWORD , LIQUID_WEB_USERNAME , LIQUID_WEB_ZONE Additional configuration manual - none, but you need to run Traefik interactively 4 , turn on debug log to see instructions and press Enter . MyDNS.jp mydnsjp MYDNSJP_MASTER_ID , MYDNSJP_PASSWORD Additional configuration Namecheap namecheap NAMECHEAP_API_USER , NAMECHEAP_API_KEY Additional configuration name.com namedotcom NAMECOM_USERNAME , NAMECOM_API_TOKEN , NAMECOM_SERVER Additional configuration Namesilo namesilo NAMESILO_API_KEY Additional configuration Netcup netcup NETCUP_CUSTOMER_NUMBER , NETCUP_API_KEY , NETCUP_API_PASSWORD Additional configuration NIFCloud nifcloud NIFCLOUD_ACCESS_KEY_ID , NIFCLOUD_SECRET_ACCESS_KEY Additional configuration Ns1 ns1 NS1_API_KEY Additional configuration Open Telekom Cloud otc OTC_DOMAIN_NAME , OTC_USER_NAME , OTC_PASSWORD , OTC_PROJECT_NAME , OTC_IDENTITY_ENDPOINT Additional configuration OVH ovh OVH_ENDPOINT , OVH_APPLICATION_KEY , OVH_APPLICATION_SECRET , OVH_CONSUMER_KEY Additional configuration Openstack Designate designate OS_AUTH_URL , OS_USERNAME , OS_PASSWORD , OS_TENANT_NAME , OS_REGION_NAME Additional configuration Oracle Cloud oraclecloud OCI_COMPARTMENT_OCID , OCI_PRIVKEY_FILE , OCI_PRIVKEY_PASS , OCI_PUBKEY_FINGERPRINT , OCI_REGION , OCI_TENANCY_OCID , OCI_USER_OCID Additional configuration PowerDNS pdns PDNS_API_KEY , PDNS_API_URL Additional configuration Rackspace rackspace RACKSPACE_USER , RACKSPACE_API_KEY Additional configuration RFC2136 rfc2136 RFC2136_TSIG_KEY , RFC2136_TSIG_SECRET , RFC2136_TSIG_ALGORITHM , RFC2136_NAMESERVER Additional configuration Route 53 route53 AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , [AWS_REGION] , [AWS_HOSTED_ZONE_ID] or a configured user/instance IAM profile. Additional configuration Sakura Cloud sakuracloud SAKURACLOUD_ACCESS_TOKEN , SAKURACLOUD_ACCESS_TOKEN_SECRET Additional configuration Selectel selectel SELECTEL_API_TOKEN Additional configuration Stackpath stackpath STACKPATH_CLIENT_ID , STACKPATH_CLIENT_SECRET , STACKPATH_STACK_ID Additional configuration TransIP transip TRANSIP_ACCOUNT_NAME , TRANSIP_PRIVATE_KEY_PATH Additional configuration VegaDNS vegadns SECRET_VEGADNS_KEY , SECRET_VEGADNS_SECRET , VEGADNS_URL Additional configuration Versio versio VERSIO_USERNAME , VERSIO_PASSWORD Additional configuration Vscale vscale VSCALE_API_TOKEN Additional configuration VULTR vultr VULTR_API_KEY Additional configuration Zone.ee zoneee ZONEEE_API_USER , ZONEEE_API_KEY Additional configuration delayBeforeCheck By default, the provider verifies the TXT record before letting ACME verify. You can delay this operation by specifying a delay (in seconds) with delayBeforeCheck (value must be greater than zero). This option is useful when internal networks block external DNS queries. resolvers \u00b6 Use custom DNS servers to resolve the FQDN authority. File (TOML) [certificatesResolvers.sample.acme] # ... [certificatesResolvers.sample.acme.dnsChallenge] # ... resolvers = [\"1.1.1.1:53\", \"8.8.8.8:53\"] File (YAML) certificatesResolvers: sample: acme: # ... dnsChallenge: # ... resolvers: - \"1.1.1.1:53\" - \"8.8.8.8:53\" CLI # ... --certificatesResolvers.sample.acme.dnsChallenge.resolvers:=1.1.1.1:53,8.8.8.8:53 Wildcard Domains \u00b6 ACME V2 supports wildcard certificates. As described in Let's Encrypt's post wildcard certificates can only be generated through a DNS-01 challenge . More Configuration \u00b6 caServer \u00b6 Using the Let's Encrypt staging server File (TOML) [certificatesResolvers.sample.acme] # ... caServer = \"https://acme-staging-v02.api.letsencrypt.org/directory\" # ... File (YAML) certificatesResolvers: sample: acme: # ... caServer: https://acme-staging-v02.api.letsencrypt.org/directory # ... CLI # ... --certificatesResolvers.sample.acme.caServer=https://acme-staging-v02.api.letsencrypt.org/directory # ... storage \u00b6 The storage option sets the location where your ACME certificates are saved to. File (TOML) [certificatesResolvers.sample.acme] # ... storage = \"acme.json\" # ... File (YAML) certificatesResolvers: sample: acme: # ... storage: acme.json # ... CLI # ... --certificatesResolvers.sample.acme.storage=acme.json # ... The value can refer to some kinds of storage: a JSON file In a File \u00b6 ACME certificates can be stored in a JSON file that needs to have a 600 file mode . In Docker you can mount either the JSON file, or the folder containing it: docker run -v \"/my/host/acme.json:/acme.json\" traefik docker run -v \"/my/host/acme:/etc/traefik/acme\" traefik Warning For concurrency reason, this file cannot be shared across multiple instances of Traefik. Fallback \u00b6 If Let's Encrypt is not reachable, the following certificates will apply: Previously generated ACME certificates (before downtime) Expired ACME certificates Provided certificates Important For new (sub)domains which need Let's Encrypt authentication, the default Traefik certificate will be used until Traefik is restarted. more information about the HTTP message format can be found here \u21a9 providing_credentials_to_your_application \u21a9 google/default.go \u21a9 docker stack remark: there is no way to support terminal attached to container when deploying with docker stack , so you might need to run container with docker run -it to generate certificates using manual provider. \u21a9 The Global API Key needs to be used, not the Origin CA Key . \u21a9","title":"Let's Encrypt"},{"location":"https/acme/#lets-encrypt","text":"Automatic HTTPS You can configure Traefik to use an ACME provider (like Let's Encrypt) for automatic certificate generation. Let's Encrypt and Rate Limiting Note that Let's Encrypt API has rate limiting . Use Let's Encrypt staging server with the caServer configuration option when experimenting to avoid hitting this limit too fast.","title":"Let's Encrypt"},{"location":"https/acme/#certificate-resolvers","text":"Traefik requires you to define \"Certificate Resolvers\" in the static configuration , which are responsible for retrieving certificates from an ACME server. Then, each \"router\" is configured to enable TLS, and is associated to a certificate resolver through the tls.certresolver configuration option . Certificates are requested for domain names retrieved from the router's dynamic configuration . You can read more about this retrieval mechanism in the following section: ACME Domain Definition .","title":"Certificate Resolvers"},{"location":"https/acme/#domain-definition","text":"Certificate resolvers request certificates for a set of the domain names inferred from routers, with the following logic: If the router has a tls.domains option set, then the certificate resolver uses the main (and optionally sans ) option of tls.domains to know the domain names for this router. If no tls.domains option is set, then the certificate resolver uses the router's rule , by checking the Host() matchers. Please note that multiple Host() matchers can be used ) for specifying multiple domain names for this router. Please note that: When multiple domain names are inferred from a given router, only one certificate is requested with the first domain name as the main domain, and the other domains as \"SANs\" (Subject Alternative Name) . As ACME V2 supports \"wildcard domains\" , any router can provide a wildcard domain name, as \"main\" domain or as \"SAN\" domain. Please check the configuration examples below for more details.","title":"Domain Definition"},{"location":"https/acme/#configuration-examples","text":"Enabling ACME File (TOML) [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web-secure] address = \":443\" [certificatesResolvers.sample.acme] email = \"your-email@your-domain.org\" storage = \"acme.json\" [certificatesResolvers.sample.acme.httpChallenge] # used during the challenge entryPoint = \"web\" File (YAML) entryPoints: web: address: \":80\" web-secure: address: \":443\" certificatesResolvers: sample: acme: email: your-email@your-domain.org storage: acme.json httpChallenge: # used during the challenge entryPoint: web CLI --entryPoints.web.address=:80 --entryPoints.websecure.address=:443 # ... --certificatesResolvers.sample.acme.email=your-email@your-domain.org --certificatesResolvers.sample.acme.storage=acme.json # used during the challenge --certificatesResolvers.sample.acme.httpChallenge.entryPoint=web Defining a certificates resolver does not result in all routers automatically using it. Each router that is supposed to use the resolver must reference it. Configuration Reference There are many available options for ACME. For a quick glance at what's possible, browse the configuration reference: File (TOML) # Enable ACME (Let's Encrypt): automatic SSL. [certificatesResolvers.sample.acme] # Email address used for registration. # # Required # email = \"test@traefik.io\" # File or key used for certificates storage. # # Required # storage = \"acme.json\" # CA server to use. # Uncomment the line to use Let's Encrypt's staging server, # leave commented to go to prod. # # Optional # Default: \"https://acme-v02.api.letsencrypt.org/directory\" # # caServer = \"https://acme-staging-v02.api.letsencrypt.org/directory\" # KeyType to use. # # Optional # Default: \"RSA4096\" # # Available values : \"EC256\", \"EC384\", \"RSA2048\", \"RSA4096\", \"RSA8192\" # # keyType = \"RSA4096\" # Use a TLS-ALPN-01 ACME challenge. # # Optional (but recommended) # [certificatesResolvers.sample.acme.tlsChallenge] # Use a HTTP-01 ACME challenge. # # Optional # # [certificatesResolvers.sample.acme.httpChallenge] # EntryPoint to use for the HTTP-01 challenges. # # Required # # entryPoint = \"web\" # Use a DNS-01 ACME challenge rather than HTTP-01 challenge. # Note: mandatory for wildcard certificate generation. # # Optional # # [certificatesResolvers.sample.acme.dnsChallenge] # DNS provider used. # # Required # # provider = \"digitalocean\" # By default, the provider will verify the TXT DNS challenge record before letting ACME verify. # If delayBeforeCheck is greater than zero, this check is delayed for the configured duration in seconds. # Useful if internal networks block external DNS queries. # # Optional # Default: 0 # # delayBeforeCheck = 0 # Use following DNS servers to resolve the FQDN authority. # # Optional # Default: empty # # resolvers = [\"1.1.1.1:53\", \"8.8.8.8:53\"] # Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. # # NOT RECOMMENDED: # Increase the risk of reaching Let's Encrypt's rate limits. # # Optional # Default: false # # disablePropagationCheck = true File (YAML) certificatesResolvers: sample: # Enable ACME (Let's Encrypt): automatic SSL. acme: # Email address used for registration. # # Required # email: \"test@traefik.io\" # File or key used for certificates storage. # # Required # storage: \"acme.json\" # CA server to use. # Uncomment the line to use Let's Encrypt's staging server, # leave commented to go to prod. # # Optional # Default: \"https://acme-v02.api.letsencrypt.org/directory\" # # caServer: \"https://acme-staging-v02.api.letsencrypt.org/directory\" # KeyType to use. # # Optional # Default: \"RSA4096\" # # Available values : \"EC256\", \"EC384\", \"RSA2048\", \"RSA4096\", \"RSA8192\" # # keyType: RSA4096 # Use a TLS-ALPN-01 ACME challenge. # # Optional (but recommended) # tlsChallenge: # Use a HTTP-01 ACME challenge. # # Optional # # httpChallenge: # EntryPoint to use for the HTTP-01 challenges. # # Required # # entryPoint: web # Use a DNS-01 ACME challenge rather than HTTP-01 challenge. # Note: mandatory for wildcard certificate generation. # # Optional # # dnsChallenge: # DNS provider used. # # Required # # provider: digitalocean # By default, the provider will verify the TXT DNS challenge record before letting ACME verify. # If delayBeforeCheck is greater than zero, this check is delayed for the configured duration in seconds. # Useful if internal networks block external DNS queries. # # Optional # Default: 0 # # delayBeforeCheck: 0 # Use following DNS servers to resolve the FQDN authority. # # Optional # Default: empty # # resolvers # - \"1.1.1.1:53\" # - \"8.8.8.8:53\" # Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. # # NOT RECOMMENDED: # Increase the risk of reaching Let's Encrypt's rate limits. # # Optional # Default: false # # disablePropagationCheck: true CLI # Enable ACME (Let's Encrypt): automatic SSL. # Email address used for registration. # # Required # --certificatesResolvers.sample.acme.email=test@traefik.io # File or key used for certificates storage. # # Required # --certificatesResolvers.sample.acme.storage=acme.json # CA server to use. # Uncomment the line to use Let's Encrypt's staging server, # leave commented to go to prod. # # Optional # Default: \"https://acme-v02.api.letsencrypt.org/directory\" # --certificatesResolvers.sample.acme.caServer=https://acme-staging-v02.api.letsencrypt.org/directory # KeyType to use. # # Optional # Default: \"RSA4096\" # # Available values : \"EC256\", \"EC384\", \"RSA2048\", \"RSA4096\", \"RSA8192\" # --certificatesResolvers.sample.acme.keyType=RSA4096 # Use a TLS-ALPN-01 ACME challenge. # # Optional (but recommended) # --certificatesResolvers.sample.acme.tlsChallenge=true # Use a HTTP-01 ACME challenge. # # Optional # --certificatesResolvers.sample.acme.httpChallenge=true # EntryPoint to use for the HTTP-01 challenges. # # Required # --certificatesResolvers.sample.acme.httpChallenge.entryPoint=web # Use a DNS-01 ACME challenge rather than HTTP-01 challenge. # Note: mandatory for wildcard certificate generation. # # Optional # --certificatesResolvers.sample.acme.dnsChallenge=true # DNS provider used. # # Required # --certificatesResolvers.sample.acme.dnsChallenge.provider=digitalocean # By default, the provider will verify the TXT DNS challenge record before letting ACME verify. # If delayBeforeCheck is greater than zero, this check is delayed for the configured duration in seconds. # Useful if internal networks block external DNS queries. # # Optional # Default: 0 # --certificatesResolvers.sample.acme.dnsChallenge.delayBeforeCheck=0 # Use following DNS servers to resolve the FQDN authority. # # Optional # Default: empty # --certificatesResolvers.sample.acme.dnsChallenge.resolvers=1.1.1.1:53,8.8.8.8:53 # Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. # # NOT RECOMMENDED: # Increase the risk of reaching Let's Encrypt's rate limits. # # Optional # Default: false # --certificatesResolvers.sample.acme.dnsChallenge.disablePropagationCheck=true Single Domain from Router's Rule Example A certificate for the domain company.com is requested: Docker ## Dynamic configuration labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le Docker (Swarm) ## Dynamic configuration deploy: labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.services.blog-svc.loadbalancer.server.port=8080\" - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le Kubernetes --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: blogtls spec: entryPoints: - websecure routes: - match: Host(`company.com`) && Path(`/blog`) kind: Rule services: - name: blog port: 8080 tls: {} Marathon labels: { \"traefik.http.routers.blog.rule\": \"Host(`company.com`) && Path(`/blog`)\", \"traefik.http.routers.blog.tls\": \"true\", \"traefik.http.routers.blog.tls.certresolver\": \"le\", \"traefik.http.services.blog-svc.loadbalancer.server.port\": \"8080\" } Rancher ## Dynamic configuration labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le Single Domain ## Dynamic configuration [http.routers] [http.routers.blog] rule = \"Host(`company.com`) && Path(`/blog`)\" [http.routers.blog.tls] certResolver = \"le\" # From static configuration File (YAML) ## Dynamic configuration http: routers: blog: rule: \"Host(`company.com`) && Path(`/blog`)\" tls: certResolver: le Multiple Domains from Router's Rule Example A certificate for the domains company.com (main) and blog.company.org is requested: Docker ## Dynamic configuration labels: - traefik.http.routers.blog.rule=(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le Docker (Swarm) ## Dynamic configuration deploy: labels: - traefik.http.routers.blog.rule=(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`) - traefik.http.services.blog-svc.loadbalancer.server.port=8080\" - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le Kubernetes --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: blogtls spec: entryPoints: - websecure routes: - match: (Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`) kind: Rule services: - name: blog port: 8080 tls: {} Marathon labels: { \"traefik.http.routers.blog.rule\": \"(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`)\", \"traefik.http.routers.blog.tls\": \"true\", \"traefik.http.routers.blog.tls.certresolver\": \"le\", \"traefik.http.services.blog-svc.loadbalancer.server.port\": \"8080\" } Rancher ## Dynamic configuration labels: - traefik.http.routers.blog.rule=(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le File (TOML) ## Dynamic configuration [http.routers] [http.routers.blog] rule = \"(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`)\" [http.routers.blog.tls] certResolver = \"le\" # From static configuration File (YAML) ## Dynamic configuration http: routers: blog: rule: \"(Host(`company.com`) && Path(`/blog`)) || Host(`blog.company.org`)\" tls: certResolver: le Multiple Domains from Router's tls.domain Example A certificate for the domains company.com (main) and *.company.org (SAN) is requested: Docker ## Dynamic configuration labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le - traefik.http.routers.blog.tls.domains[0].main=company.org - traefik.http.routers.blog.tls.domains[0].sans=*.company.org Docker (Swarm) ## Dynamic configuration deploy: labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.services.blog-svc.loadbalancer.server.port=8080\" - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le - traefik.http.routers.blog.tls.domains[0].main=company.org - traefik.http.routers.blog.tls.domains[0].sans=*.company.org Kubernetes --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: blogtls spec: entryPoints: - websecure routes: - match: Host(`company.com`) && Path(`/blog`) kind: Rule services: - name: blog port: 8080 tls: certResolver: le Marathon labels: { \"traefik.http.routers.blog.rule\": \"Host(`company.com`) && Path(`/blog`)\", \"traefik.http.routers.blog.tls\": \"true\", \"traefik.http.routers.blog.tls.certresolver\": \"le\", \"traefik.http.routers.blog.tls.domains[0].main\": \"company.com\", \"traefik.http.routers.blog.tls.domains[0].sans\": \"*.company.com\", \"traefik.http.services.blog-svc.loadbalancer.server.port\": \"8080\" } Rancher ## Dynamic configuration labels: - traefik.http.routers.blog.rule=Host(`company.com`) && Path(`/blog`) - traefik.http.routers.blog.tls=true - traefik.http.routers.blog.tls.certresolver=le - traefik.http.routers.blog.tls.domains[0].main=company.org - traefik.http.routers.blog.tls.domains[0].sans=*.company.org File (TOML) ## Dynamic configuration [http.routers] [http.routers.blog] rule = \"Host(`company.com`) && Path(`/blog`)\" [http.routers.blog.tls] certResolver = \"le\" # From static configuration [[http.routers.blog.tls.domains]] main = \"company.org\" sans = [\"*.company.org\"] File (YAML) ## Dynamic configuration http: routers: blog: rule: \"Host(`company.com`) && Path(`/blog`)\" tls: certResolver: le domains: - main: \"company.org\" sans: - \"*.company.org\"","title":"Configuration Examples"},{"location":"https/acme/#automatic-renewals","text":"Traefik automatically tracks the expiry date of ACME certificates it generates. If there are less than 30 days remaining before the certificate expires, Traefik will attempt to renew it automatically. Certificates that are no longer used may still be renewed, as Traefik does not currently check if the certificate is being used before renewing.","title":"Automatic Renewals"},{"location":"https/acme/#using-letsencrypt-with-kubernetes","text":"When using LetsEncrypt with kubernetes, there are some known caveats with both the ingress and crd providers. If you intend to run multiple instances of Traefik with LetsEncrypt, please ensure you read the sections on those provider pages.","title":"Using LetsEncrypt with Kubernetes"},{"location":"https/acme/#the-different-acme-challenges","text":"Defining a certificates resolver does not result in all routers automatically using it. Each router that is supposed to use the resolver must reference it.","title":"The Different ACME Challenges"},{"location":"https/acme/#tlschallenge","text":"Use the TLS-ALPN-01 challenge to generate and renew ACME certificates by provisioning a TLS certificate. As described on the Let's Encrypt community forum , when using the TLS-ALPN-01 challenge, Traefik must be reachable by Let's Encrypt through port 443. Configuring the tlsChallenge File (TOML) [certificatesResolvers.sample.acme] # ... [certificatesResolvers.sample.acme.tlsChallenge] File (YAML) certificatesResolvers: sample: acme: # ... tlsChallenge: {} CLI # ... --certificatesResolvers.sample.acme.tlsChallenge=true","title":"tlsChallenge"},{"location":"https/acme/#httpchallenge","text":"Use the HTTP-01 challenge to generate and renew ACME certificates by provisioning an HTTP resource under a well-known URI. As described on the Let's Encrypt community forum , when using the HTTP-01 challenge, certificatesResolvers.sample.acme.httpChallenge.entryPoint must be reachable by Let's Encrypt through port 80. Using an EntryPoint Called http for the httpChallenge File (TOML) [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web-secure] address = \":443\" [certificatesResolvers.sample.acme] # ... [certificatesResolvers.sample.acme.httpChallenge] entryPoint = \"web\" File (YAML) entryPoints: web: address: \":80\" web-secure: address: \":443\" certificatesResolvers: sample: acme: # ... httpChallenge: entryPoint: web CLI --entryPoints.web.address=:80 --entryPoints.websecure.address=:443 # ... --certificatesResolvers.sample.acme.httpChallenge.entryPoint=web Redirection is fully compatible with the HTTP-01 challenge.","title":"httpChallenge"},{"location":"https/acme/#dnschallenge","text":"Use the DNS-01 challenge to generate and renew ACME certificates by provisioning a DNS record. Configuring a dnsChallenge with the DigitalOcean Provider File (TOML) [certificatesResolvers.sample.acme] # ... [certificatesResolvers.sample.acme.dnsChallenge] provider = \"digitalocean\" delayBeforeCheck = 0 # ... File (YAML) certificatesResolvers: sample: acme: # ... dnsChallenge: provider: digitalocean delayBeforeCheck: 0 # ... CLI # ... --certificatesResolvers.sample.acme.dnsChallenge.provider=digitalocean --certificatesResolvers.sample.acme.dnsChallenge.delayBeforeCheck=0 # ... Important A provider is mandatory.","title":"dnsChallenge"},{"location":"https/acme/#providers","text":"Here is a list of supported providers , that can automate the DNS verification, along with the required environment variables and their wildcard & root domain support . Do not hesitate to complete it. Every lego environment variable can be overridden by their respective _FILE counterpart, which should have a filepath to a file that contains the secret as its value. For example, CF_API_EMAIL_FILE=/run/secrets/traefik_cf-api-email could be used to provide a Cloudflare API email address as a Docker secret named traefik_cf-api-email . Provider Name Provider Code Environment Variables ACME DNS acme-dns ACME_DNS_API_BASE , ACME_DNS_STORAGE_PATH Additional configuration Alibaba Cloud alidns ALICLOUD_ACCESS_KEY , ALICLOUD_SECRET_KEY , ALICLOUD_REGION_ID Additional configuration Auroradns auroradns AURORA_USER_ID , AURORA_KEY , AURORA_ENDPOINT Additional configuration Autodns autodns AUTODNS_API_USER , AUTODNS_API_PASSWORD Additional configuration Azure azure AZURE_CLIENT_ID , AZURE_CLIENT_SECRET , AZURE_SUBSCRIPTION_ID , AZURE_TENANT_ID , AZURE_RESOURCE_GROUP , [AZURE_METADATA_ENDPOINT] Additional configuration Bindman bindman BINDMAN_MANAGER_ADDRESS Additional configuration Blue Cat bluecat BLUECAT_SERVER_URL , BLUECAT_USER_NAME , BLUECAT_PASSWORD , BLUECAT_CONFIG_NAME , BLUECAT_DNS_VIEW Additional configuration ClouDNS cloudns CLOUDNS_AUTH_ID , CLOUDNS_AUTH_PASSWORD Additional configuration Cloudflare cloudflare CF_API_EMAIL , CF_API_KEY 5 or CF_DNS_API_TOKEN , [CF_ZONE_API_TOKEN] Additional configuration CloudXNS cloudxns CLOUDXNS_API_KEY , CLOUDXNS_SECRET_KEY Additional configuration ConoHa conoha CONOHA_TENANT_ID , CONOHA_API_USERNAME , CONOHA_API_PASSWORD Additional configuration DigitalOcean digitalocean DO_AUTH_TOKEN Additional configuration DNSimple dnsimple DNSIMPLE_OAUTH_TOKEN , DNSIMPLE_BASE_URL Additional configuration DNS Made Easy dnsmadeeasy DNSMADEEASY_API_KEY , DNSMADEEASY_API_SECRET , DNSMADEEASY_SANDBOX Additional configuration DNSPod dnspod DNSPOD_API_KEY Additional configuration Domain Offensive (do.de) dode DODE_TOKEN Additional configuration DreamHost dreamhost DREAMHOST_API_KEY Additional configuration Duck DNS duckdns DUCKDNS_TOKEN Additional configuration Dyn dyn DYN_CUSTOMER_NAME , DYN_USER_NAME , DYN_PASSWORD Additional configuration EasyDNS easydns EASYDNS_TOKEN , EASYDNS_KEY Additional configuration External Program exec EXEC_PATH Additional configuration Exoscale exoscale EXOSCALE_API_KEY , EXOSCALE_API_SECRET , EXOSCALE_ENDPOINT Additional configuration Fast DNS fastdns AKAMAI_CLIENT_TOKEN , AKAMAI_CLIENT_SECRET , AKAMAI_ACCESS_TOKEN Additional configuration Gandi gandi GANDI_API_KEY Additional configuration Gandi v5 gandiv5 GANDIV5_API_KEY Additional configuration Glesys glesys GLESYS_API_USER , GLESYS_API_KEY , GLESYS_DOMAIN Additional configuration GoDaddy godaddy GODADDY_API_KEY , GODADDY_API_SECRET Additional configuration Google Cloud DNS gcloud GCE_PROJECT , Application Default Credentials 2 3 , [ GCE_SERVICE_ACCOUNT_FILE ] Additional configuration hosting.de hostingde HOSTINGDE_API_KEY , HOSTINGDE_ZONE_NAME Additional configuration HTTP request httpreq HTTPREQ_ENDPOINT , HTTPREQ_MODE , HTTPREQ_USERNAME , HTTPREQ_PASSWORD 1 Additional configuration IIJ iij IIJ_API_ACCESS_KEY , IIJ_API_SECRET_KEY , IIJ_DO_SERVICE_CODE Additional configuration INWX inwx INWX_USERNAME , INWX_PASSWORD Additional configuration Joker.com joker JOKER_API_KEY or JOKER_USERNAME , JOKER_PASSWORD Additional configuration Lightsail lightsail AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , DNS_ZONE Additional configuration Linode linode LINODE_API_KEY Additional configuration Linode v4 linodev4 LINODE_TOKEN Additional configuration Liquid Web liquidweb LIQUID_WEB_PASSWORD , LIQUID_WEB_USERNAME , LIQUID_WEB_ZONE Additional configuration manual - none, but you need to run Traefik interactively 4 , turn on debug log to see instructions and press Enter . MyDNS.jp mydnsjp MYDNSJP_MASTER_ID , MYDNSJP_PASSWORD Additional configuration Namecheap namecheap NAMECHEAP_API_USER , NAMECHEAP_API_KEY Additional configuration name.com namedotcom NAMECOM_USERNAME , NAMECOM_API_TOKEN , NAMECOM_SERVER Additional configuration Namesilo namesilo NAMESILO_API_KEY Additional configuration Netcup netcup NETCUP_CUSTOMER_NUMBER , NETCUP_API_KEY , NETCUP_API_PASSWORD Additional configuration NIFCloud nifcloud NIFCLOUD_ACCESS_KEY_ID , NIFCLOUD_SECRET_ACCESS_KEY Additional configuration Ns1 ns1 NS1_API_KEY Additional configuration Open Telekom Cloud otc OTC_DOMAIN_NAME , OTC_USER_NAME , OTC_PASSWORD , OTC_PROJECT_NAME , OTC_IDENTITY_ENDPOINT Additional configuration OVH ovh OVH_ENDPOINT , OVH_APPLICATION_KEY , OVH_APPLICATION_SECRET , OVH_CONSUMER_KEY Additional configuration Openstack Designate designate OS_AUTH_URL , OS_USERNAME , OS_PASSWORD , OS_TENANT_NAME , OS_REGION_NAME Additional configuration Oracle Cloud oraclecloud OCI_COMPARTMENT_OCID , OCI_PRIVKEY_FILE , OCI_PRIVKEY_PASS , OCI_PUBKEY_FINGERPRINT , OCI_REGION , OCI_TENANCY_OCID , OCI_USER_OCID Additional configuration PowerDNS pdns PDNS_API_KEY , PDNS_API_URL Additional configuration Rackspace rackspace RACKSPACE_USER , RACKSPACE_API_KEY Additional configuration RFC2136 rfc2136 RFC2136_TSIG_KEY , RFC2136_TSIG_SECRET , RFC2136_TSIG_ALGORITHM , RFC2136_NAMESERVER Additional configuration Route 53 route53 AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , [AWS_REGION] , [AWS_HOSTED_ZONE_ID] or a configured user/instance IAM profile. Additional configuration Sakura Cloud sakuracloud SAKURACLOUD_ACCESS_TOKEN , SAKURACLOUD_ACCESS_TOKEN_SECRET Additional configuration Selectel selectel SELECTEL_API_TOKEN Additional configuration Stackpath stackpath STACKPATH_CLIENT_ID , STACKPATH_CLIENT_SECRET , STACKPATH_STACK_ID Additional configuration TransIP transip TRANSIP_ACCOUNT_NAME , TRANSIP_PRIVATE_KEY_PATH Additional configuration VegaDNS vegadns SECRET_VEGADNS_KEY , SECRET_VEGADNS_SECRET , VEGADNS_URL Additional configuration Versio versio VERSIO_USERNAME , VERSIO_PASSWORD Additional configuration Vscale vscale VSCALE_API_TOKEN Additional configuration VULTR vultr VULTR_API_KEY Additional configuration Zone.ee zoneee ZONEEE_API_USER , ZONEEE_API_KEY Additional configuration delayBeforeCheck By default, the provider verifies the TXT record before letting ACME verify. You can delay this operation by specifying a delay (in seconds) with delayBeforeCheck (value must be greater than zero). This option is useful when internal networks block external DNS queries.","title":"providers"},{"location":"https/acme/#resolvers","text":"Use custom DNS servers to resolve the FQDN authority. File (TOML) [certificatesResolvers.sample.acme] # ... [certificatesResolvers.sample.acme.dnsChallenge] # ... resolvers = [\"1.1.1.1:53\", \"8.8.8.8:53\"] File (YAML) certificatesResolvers: sample: acme: # ... dnsChallenge: # ... resolvers: - \"1.1.1.1:53\" - \"8.8.8.8:53\" CLI # ... --certificatesResolvers.sample.acme.dnsChallenge.resolvers:=1.1.1.1:53,8.8.8.8:53","title":"resolvers"},{"location":"https/acme/#wildcard-domains","text":"ACME V2 supports wildcard certificates. As described in Let's Encrypt's post wildcard certificates can only be generated through a DNS-01 challenge .","title":"Wildcard Domains"},{"location":"https/acme/#more-configuration","text":"","title":"More Configuration"},{"location":"https/acme/#caserver","text":"Using the Let's Encrypt staging server File (TOML) [certificatesResolvers.sample.acme] # ... caServer = \"https://acme-staging-v02.api.letsencrypt.org/directory\" # ... File (YAML) certificatesResolvers: sample: acme: # ... caServer: https://acme-staging-v02.api.letsencrypt.org/directory # ... CLI # ... --certificatesResolvers.sample.acme.caServer=https://acme-staging-v02.api.letsencrypt.org/directory # ...","title":"caServer"},{"location":"https/acme/#storage","text":"The storage option sets the location where your ACME certificates are saved to. File (TOML) [certificatesResolvers.sample.acme] # ... storage = \"acme.json\" # ... File (YAML) certificatesResolvers: sample: acme: # ... storage: acme.json # ... CLI # ... --certificatesResolvers.sample.acme.storage=acme.json # ... The value can refer to some kinds of storage: a JSON file","title":"storage"},{"location":"https/acme/#in-a-file","text":"ACME certificates can be stored in a JSON file that needs to have a 600 file mode . In Docker you can mount either the JSON file, or the folder containing it: docker run -v \"/my/host/acme.json:/acme.json\" traefik docker run -v \"/my/host/acme:/etc/traefik/acme\" traefik Warning For concurrency reason, this file cannot be shared across multiple instances of Traefik.","title":"In a File"},{"location":"https/acme/#fallback","text":"If Let's Encrypt is not reachable, the following certificates will apply: Previously generated ACME certificates (before downtime) Expired ACME certificates Provided certificates Important For new (sub)domains which need Let's Encrypt authentication, the default Traefik certificate will be used until Traefik is restarted. more information about the HTTP message format can be found here \u21a9 providing_credentials_to_your_application \u21a9 google/default.go \u21a9 docker stack remark: there is no way to support terminal attached to container when deploying with docker stack , so you might need to run container with docker run -it to generate certificates using manual provider. \u21a9 The Global API Key needs to be used, not the Origin CA Key . \u21a9","title":"Fallback"},{"location":"https/overview/","text":"HTTPS & TLS \u00b6 Overview Traefik supports HTTPS & TLS, which concerns roughly two parts of the configuration: routers, and the TLS connection (and its underlying certificates). When a router has to handle HTTPS traffic, it should be specified with a tls field of the router definition. See the TLS section of the routers documentation . The next sections of this documentation explain how to configure the TLS connection itself. That is to say, how to obtain TLS certificates : either through a definition in the dynamic configuration, or through Let's Encrypt (ACME). And how to configure TLS options , and certificates stores .","title":"Overview"},{"location":"https/overview/#https-tls","text":"Overview Traefik supports HTTPS & TLS, which concerns roughly two parts of the configuration: routers, and the TLS connection (and its underlying certificates). When a router has to handle HTTPS traffic, it should be specified with a tls field of the router definition. See the TLS section of the routers documentation . The next sections of this documentation explain how to configure the TLS connection itself. That is to say, how to obtain TLS certificates : either through a definition in the dynamic configuration, or through Let's Encrypt (ACME). And how to configure TLS options , and certificates stores .","title":"HTTPS &amp; TLS"},{"location":"https/tls/","text":"TLS \u00b6 Transport Layer Security Certificates Definition \u00b6 Automated \u00b6 See the Let's Encrypt page. User defined \u00b6 To add / remove TLS certificates, even when Traefik is already running, their definition can be added to the dynamic configuration , in the [[tls.certificates]] section: File (TOML) # Dynamic configuration [[tls.certificates]] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" [[tls.certificates]] certFile = \"/path/to/other-domain.cert\" keyFile = \"/path/to/other-domain.key\" File (YAML) # Dynamic configuration tls: certificates: - certFile: /path/to/domain.cert keyFile: /path/to/domain.key - certFile: /path/to/other-domain.cert keyFile: /path/to/other-domain.key Restriction In the above example, we've used the file provider to handle these definitions. It is the only available method to configure the certificates (as well as the options and the stores). However, in Kubernetes , the certificates can and must be provided by secrets . Certificates Stores \u00b6 In Traefik, certificates are grouped together in certificates stores, which are defined as such: File (TOML) # Dynamic configuration [tls.stores] [tls.stores.default] File (YAML) # Dynamic configuration tls: stores: default: {} Restriction Any store definition other than the default one (named default ) will be ignored, and there is thefore only one globally available TLS store. In the tls.certificates section, a list of stores can then be specified to indicate where the certificates should be stored: File (TOML) # Dynamic configuration [[tls.certificates]] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" stores = [\"default\"] [[tls.certificates]] # Note that since no store is defined, # the certificate below will be stored in the `default` store. certFile = \"/path/to/other-domain.cert\" keyFile = \"/path/to/other-domain.key\" File (YAML) # Dynamic configuration tls: certificates: - certFile: /path/to/domain.cert keyFile: /path/to/domain.key stores: - default # Note that since no store is defined, # the certificate below will be stored in the `default` store. - certFile: /path/to/other-domain.cert keyFile: /path/to/other-domain.key Restriction The stores list will actually be ignored and automatically set to [\"default\"] . Default Certificate \u00b6 Traefik can use a default certificate for connections without a SNI, or without a matching domain. This default certificate should be defined in a TLS store: File (TOML) # Dynamic configuration [tls.stores] [tls.stores.default] [tls.stores.default.defaultCertificate] certFile = \"path/to/cert.crt\" keyFile = \"path/to/cert.key\" File (YAML) # Dynamic configuration tls: stores: default: defaultCertificate: certFile: path/to/cert.crt keyFile: path/to/cert.key If no default certificate is provided, Traefik generates and uses a self-signed certificate. TLS Options \u00b6 The TLS options allow one to configure some parameters of the TLS connection. Minimum TLS Version \u00b6 File (TOML) # Dynamic configuration [tls.options] [tls.options.default] minVersion = \"VersionTLS12\" [tls.options.mintls13] minVersion = \"VersionTLS13\" File (YAML) # Dynamic configuration tls: options: default: minVersion: VersionTLS12 mintls13: minVersion: VersionTLS13 Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: default namespace: default spec: minVersion: VersionTLS12 --- apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: mintls13 namespace: default spec: minVersion: VersionTLS13 Cipher Suites \u00b6 See cipherSuites for more information. File (TOML) # Dynamic configuration [tls.options] [tls.options.default] cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\" ] File (YAML) # Dynamic configuration tls: options: default: cipherSuites: - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: default namespace: default spec: cipherSuites: - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS 1.3 Cipher suites defined for TLS 1.2 and below cannot be used in TLS 1.3, and vice versa. ( https://tools.ietf.org/html/rfc8446 ) With TLS 1.3, the cipher suites are not configurable (all supported cipher suites are safe in this case). https://golang.org/doc/go1.12#tls_1_3 Strict SNI Checking \u00b6 With strict SNI checking, Traefik won't allow connections from clients connections that do not specify a server_name extension. File (TOML) # Dynamic configuration [tls.options] [tls.options.default] sniStrict = true File (YAML) # Dynamic configuration tls: options: default: sniStrict: true Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: default namespace: default spec: sniStrict: true Client Authentication (mTLS) \u00b6 Traefik supports mutual authentication, through the clientAuth section. For authentication policies that require verification of the client certificate, the certificate authority for the certificate should be set in clientAuth.caFiles . The clientAuth.clientAuthType option governs the behaviour as follows: NoClientCert : disregards any client certificate. RequestClientCert : asks for a certificate but proceeds anyway if none is provided. RequireAnyClientCert : requires a certificate but does not verify if it is signed by a CA listed in clientAuth.caFiles . VerifyClientCertIfGiven : if a certificate is provided, verifies if it is signed by a CA listed in clientAuth.caFiles . Otherwise proceeds without any certificate. RequireAndVerifyClientCert : requires a certificate, which must be signed by a CA listed in clientAuth.caFiles . File (TOML) # Dynamic configuration [tls.options] [tls.options.default] [tls.options.default.clientAuth] # in PEM format. each file can contain multiple CAs. caFiles = [\"tests/clientca1.crt\", \"tests/clientca2.crt\"] clientAuthType = \"RequireAndVerifyClientCert\" File (YAML) # Dynamic configuration tls: options: default: clientAuth: # in PEM format. each file can contain multiple CAs. caFiles: - tests/clientca1.crt - tests/clientca2.crt clientAuthType: RequireAndVerifyClientCert Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: default namespace: default spec: clientAuth: secretNames: - secretCA clientAuthType: RequireAndVerifyClientCert","title":"TLS"},{"location":"https/tls/#tls","text":"Transport Layer Security","title":"TLS"},{"location":"https/tls/#certificates-definition","text":"","title":"Certificates Definition"},{"location":"https/tls/#automated","text":"See the Let's Encrypt page.","title":"Automated"},{"location":"https/tls/#user-defined","text":"To add / remove TLS certificates, even when Traefik is already running, their definition can be added to the dynamic configuration , in the [[tls.certificates]] section: File (TOML) # Dynamic configuration [[tls.certificates]] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" [[tls.certificates]] certFile = \"/path/to/other-domain.cert\" keyFile = \"/path/to/other-domain.key\" File (YAML) # Dynamic configuration tls: certificates: - certFile: /path/to/domain.cert keyFile: /path/to/domain.key - certFile: /path/to/other-domain.cert keyFile: /path/to/other-domain.key Restriction In the above example, we've used the file provider to handle these definitions. It is the only available method to configure the certificates (as well as the options and the stores). However, in Kubernetes , the certificates can and must be provided by secrets .","title":"User defined"},{"location":"https/tls/#certificates-stores","text":"In Traefik, certificates are grouped together in certificates stores, which are defined as such: File (TOML) # Dynamic configuration [tls.stores] [tls.stores.default] File (YAML) # Dynamic configuration tls: stores: default: {} Restriction Any store definition other than the default one (named default ) will be ignored, and there is thefore only one globally available TLS store. In the tls.certificates section, a list of stores can then be specified to indicate where the certificates should be stored: File (TOML) # Dynamic configuration [[tls.certificates]] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" stores = [\"default\"] [[tls.certificates]] # Note that since no store is defined, # the certificate below will be stored in the `default` store. certFile = \"/path/to/other-domain.cert\" keyFile = \"/path/to/other-domain.key\" File (YAML) # Dynamic configuration tls: certificates: - certFile: /path/to/domain.cert keyFile: /path/to/domain.key stores: - default # Note that since no store is defined, # the certificate below will be stored in the `default` store. - certFile: /path/to/other-domain.cert keyFile: /path/to/other-domain.key Restriction The stores list will actually be ignored and automatically set to [\"default\"] .","title":"Certificates Stores"},{"location":"https/tls/#default-certificate","text":"Traefik can use a default certificate for connections without a SNI, or without a matching domain. This default certificate should be defined in a TLS store: File (TOML) # Dynamic configuration [tls.stores] [tls.stores.default] [tls.stores.default.defaultCertificate] certFile = \"path/to/cert.crt\" keyFile = \"path/to/cert.key\" File (YAML) # Dynamic configuration tls: stores: default: defaultCertificate: certFile: path/to/cert.crt keyFile: path/to/cert.key If no default certificate is provided, Traefik generates and uses a self-signed certificate.","title":"Default Certificate"},{"location":"https/tls/#tls-options","text":"The TLS options allow one to configure some parameters of the TLS connection.","title":"TLS Options"},{"location":"https/tls/#minimum-tls-version","text":"File (TOML) # Dynamic configuration [tls.options] [tls.options.default] minVersion = \"VersionTLS12\" [tls.options.mintls13] minVersion = \"VersionTLS13\" File (YAML) # Dynamic configuration tls: options: default: minVersion: VersionTLS12 mintls13: minVersion: VersionTLS13 Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: default namespace: default spec: minVersion: VersionTLS12 --- apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: mintls13 namespace: default spec: minVersion: VersionTLS13","title":"Minimum TLS Version"},{"location":"https/tls/#cipher-suites","text":"See cipherSuites for more information. File (TOML) # Dynamic configuration [tls.options] [tls.options.default] cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\" ] File (YAML) # Dynamic configuration tls: options: default: cipherSuites: - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: default namespace: default spec: cipherSuites: - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS 1.3 Cipher suites defined for TLS 1.2 and below cannot be used in TLS 1.3, and vice versa. ( https://tools.ietf.org/html/rfc8446 ) With TLS 1.3, the cipher suites are not configurable (all supported cipher suites are safe in this case). https://golang.org/doc/go1.12#tls_1_3","title":"Cipher Suites"},{"location":"https/tls/#strict-sni-checking","text":"With strict SNI checking, Traefik won't allow connections from clients connections that do not specify a server_name extension. File (TOML) # Dynamic configuration [tls.options] [tls.options.default] sniStrict = true File (YAML) # Dynamic configuration tls: options: default: sniStrict: true Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: default namespace: default spec: sniStrict: true","title":"Strict SNI Checking"},{"location":"https/tls/#client-authentication-mtls","text":"Traefik supports mutual authentication, through the clientAuth section. For authentication policies that require verification of the client certificate, the certificate authority for the certificate should be set in clientAuth.caFiles . The clientAuth.clientAuthType option governs the behaviour as follows: NoClientCert : disregards any client certificate. RequestClientCert : asks for a certificate but proceeds anyway if none is provided. RequireAnyClientCert : requires a certificate but does not verify if it is signed by a CA listed in clientAuth.caFiles . VerifyClientCertIfGiven : if a certificate is provided, verifies if it is signed by a CA listed in clientAuth.caFiles . Otherwise proceeds without any certificate. RequireAndVerifyClientCert : requires a certificate, which must be signed by a CA listed in clientAuth.caFiles . File (TOML) # Dynamic configuration [tls.options] [tls.options.default] [tls.options.default.clientAuth] # in PEM format. each file can contain multiple CAs. caFiles = [\"tests/clientca1.crt\", \"tests/clientca2.crt\"] clientAuthType = \"RequireAndVerifyClientCert\" File (YAML) # Dynamic configuration tls: options: default: clientAuth: # in PEM format. each file can contain multiple CAs. caFiles: - tests/clientca1.crt - tests/clientca2.crt clientAuthType: RequireAndVerifyClientCert Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: default namespace: default spec: clientAuth: secretNames: - secretCA clientAuthType: RequireAndVerifyClientCert","title":"Client Authentication (mTLS)"},{"location":"middlewares/addprefix/","text":"Add Prefix \u00b6 Prefixing the Path The AddPrefix middleware updates the URL Path of the request before forwarding it. Configuration Examples \u00b6 Docker # Prefixing with /foo labels: - \"traefik.http.middlewares.add-foo.addprefix.prefix=/foo\" Kubernetes # Prefixing with /foo apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: add-foo spec: addPrefix: prefix: /foo Marathon \"labels\": { \"traefik.http.middlewares.add-foo.addprefix.prefix\": \"/foo\" } Rancher # Prefixing with /foo labels: - \"traefik.http.middlewares.add-foo.addprefix.prefix=/foo\" File (TOML) # Prefixing with /foo [http.middlewares] [http.middlewares.add-foo.addPrefix] prefix = \"/foo\" File (YAML) # Prefixing with /foo http: middlewares: add-foo: addPrefix: prefix: \"/foo\" Configuration Options \u00b6 prefix \u00b6 prefix is the string to add before the current path in the requested URL. It should include the leading slash ( / ).","title":"AddPrefix"},{"location":"middlewares/addprefix/#add-prefix","text":"Prefixing the Path The AddPrefix middleware updates the URL Path of the request before forwarding it.","title":"Add Prefix"},{"location":"middlewares/addprefix/#configuration-examples","text":"Docker # Prefixing with /foo labels: - \"traefik.http.middlewares.add-foo.addprefix.prefix=/foo\" Kubernetes # Prefixing with /foo apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: add-foo spec: addPrefix: prefix: /foo Marathon \"labels\": { \"traefik.http.middlewares.add-foo.addprefix.prefix\": \"/foo\" } Rancher # Prefixing with /foo labels: - \"traefik.http.middlewares.add-foo.addprefix.prefix=/foo\" File (TOML) # Prefixing with /foo [http.middlewares] [http.middlewares.add-foo.addPrefix] prefix = \"/foo\" File (YAML) # Prefixing with /foo http: middlewares: add-foo: addPrefix: prefix: \"/foo\"","title":"Configuration Examples"},{"location":"middlewares/addprefix/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/addprefix/#prefix","text":"prefix is the string to add before the current path in the requested URL. It should include the leading slash ( / ).","title":"prefix"},{"location":"middlewares/basicauth/","text":"BasicAuth \u00b6 Adding Basic Authentication The BasicAuth middleware is a quick way to restrict access to your services to known users. Configuration Examples \u00b6 Docker # Declaring the user list # # Note: all dollar signs in the hash need to be doubled for escaping. # To create user:password pair, it's possible to use this command: # echo $(htpasswd -nb user password) | sed -e s/\\\\$/\\\\$\\\\$/g labels: - \"traefik.http.middlewares.test-auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" Kubernetes # Declaring the user list apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: basicAuth: secret: secretName Marathon \"labels\": { \"traefik.http.middlewares.test-auth.basicauth.users\": \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" } Rancher # Declaring the user list labels: - \"traefik.http.middlewares.test-auth.basicauth.users=test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" File (TOML) # Declaring the user list [http.middlewares] [http.middlewares.test-auth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] File (YAML) # Declaring the user list http: middlewares: test-auth: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" Configuration Options \u00b6 General \u00b6 Passwords must be encoded using MD5, SHA1, or BCrypt. Tip Use htpasswd to generate the passwords. users \u00b6 The users option is an array of authorized users. Each user will be declared using the name:encoded-password format. If both users and usersFile are provided, the two are merged. The contents of usersFile have precedence over the values in users . For security reasons, the field users doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead. Docker # Declaring the user list # # Note: all dollar signs in the hash need to be doubled for escaping. # To create user:password pair, it's possible to use this command: # echo $(htpasswd -nb user password) | sed -e s/\\\\$/\\\\$\\\\$/g labels: - \"traefik.http.middlewares.test-auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" Kubernetes # Declaring the user list apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: basicAuth: secret: authsecret --- apiVersion: v1 kind: Secret metadata: name: authsecret namespace: default data: users: |2 dGVzdDokYXByMSRINnVza2trVyRJZ1hMUDZld1RyU3VCa1RycUU4d2ovCnRlc3QyOiRhcHIxJGQ5 aHI5SEJCJDRIeHdnVWlyM0hQNEVzZ2dQL1FObzAK Marathon \"labels\": { \"traefik.http.middlewares.test-auth.basicauth.users\": \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" } Rancher # Declaring the user list labels: - \"traefik.http.middlewares.test-auth.basicauth.users=test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" File (TOML) # Declaring the user list [http.middlewares] [http.middlewares.test-auth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] File (YAML) # Declaring the user list http: middlewares: test-auth: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" usersFile \u00b6 The usersFile option is the path to an external file that contains the authorized users for the middleware. The file content is a list of name:encoded-password . If both users and usersFile are provided, the two are merged. The contents of usersFile have precedence over the values in users . Because it does not make much sense to refer to a file path on Kubernetes, the usersFile field doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead. Docker labels: - \"traefik.http.middlewares.test-auth.basicauth.usersfile=/path/to/my/usersfile\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: basicAuth: secret: authsecret --- apiVersion: v1 kind: Secret metadata: name: authsecret namespace: default data: users: |2 dGVzdDokYXByMSRINnVza2trVyRJZ1hMUDZld1RyU3VCa1RycUU4d2ovCnRlc3QyOiRhcHIxJGQ5 aHI5SEJCJDRIeHdnVWlyM0hQNEVzZ2dQL1FObzAK Marathon \"labels\": { \"traefik.http.middlewares.test-auth.basicauth.usersfile\": \"/path/to/my/usersfile\" } Rancher labels: - \"traefik.http.middlewares.test-auth.basicauth.usersfile=/path/to/my/usersfile\" File (TOML) [http.middlewares] [http.middlewares.test-auth.basicAuth] usersFile = \"/path/to/my/usersfile\" File (YAML) http: middlewares: test-auth: basicAuth: usersFile: \"/path/to/my/usersfile\" A file containing test/test and test2/test2 test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 realm \u00b6 You can customize the realm for the authentication with the realm option. The default value is traefik . Docker labels: - \"traefik.http.middlewares.test-auth.basicauth.realm=MyRealm\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: basicAuth: realm: MyRealm Marathon \"labels\": { \"traefik.http.middlewares.test-auth.basicauth.realm\": \"MyRealm\" } Rancher labels: - \"traefik.http.middlewares.test-auth.basicauth.realm=MyRealm\" File (TOML) [http.middlewares] [http.middlewares.test-auth.basicAuth] realm = \"MyRealm\" File (YAML) http: middlewares: test-auth: basicAuth: realm: \"MyRealm\" headerField \u00b6 You can define a header field to store the authenticated user using the headerField option. Docker labels: - \"traefik.http.middlewares.my-auth.basicauth.headerField=X-WebAuth-User\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: my-auth spec: basicAuth: # ... headerField: X-WebAuth-User Marathon \"labels\": { \"traefik.http.middlewares.my-auth.basicauth.headerField\": \"X-WebAuth-User\" } File (TOML) [http.middlewares.my-auth.basicAuth] # ... headerField = \"X-WebAuth-User\" File (YAML) http: middlewares: my-auth: basicAuth: # ... headerField: \"X-WebAuth-User\" removeHeader \u00b6 Set the removeHeader option to true to remove the authorization header before forwarding the request to your service. (Default value is false .) Docker labels: - \"traefik.http.middlewares.test-auth.basicauth.removeheader=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: basicAuth: removeHeader: true Marathon \"labels\": { \"traefik.http.middlewares.test-auth.basicauth.removeheader\": \"true\" } Rancher labels: - \"traefik.http.middlewares.test-auth.basicauth.removeheader=true\" File (TOML) [http.middlewares] [http.middlewares.test-auth.basicAuth] removeHeader = true File (YAML) http: middlewares: test-auth: basicAuth: removeHeader: true","title":"BasicAuth"},{"location":"middlewares/basicauth/#basicauth","text":"Adding Basic Authentication The BasicAuth middleware is a quick way to restrict access to your services to known users.","title":"BasicAuth"},{"location":"middlewares/basicauth/#configuration-examples","text":"Docker # Declaring the user list # # Note: all dollar signs in the hash need to be doubled for escaping. # To create user:password pair, it's possible to use this command: # echo $(htpasswd -nb user password) | sed -e s/\\\\$/\\\\$\\\\$/g labels: - \"traefik.http.middlewares.test-auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" Kubernetes # Declaring the user list apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: basicAuth: secret: secretName Marathon \"labels\": { \"traefik.http.middlewares.test-auth.basicauth.users\": \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" } Rancher # Declaring the user list labels: - \"traefik.http.middlewares.test-auth.basicauth.users=test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" File (TOML) # Declaring the user list [http.middlewares] [http.middlewares.test-auth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] File (YAML) # Declaring the user list http: middlewares: test-auth: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"","title":"Configuration Examples"},{"location":"middlewares/basicauth/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/basicauth/#general","text":"Passwords must be encoded using MD5, SHA1, or BCrypt. Tip Use htpasswd to generate the passwords.","title":"General"},{"location":"middlewares/basicauth/#users","text":"The users option is an array of authorized users. Each user will be declared using the name:encoded-password format. If both users and usersFile are provided, the two are merged. The contents of usersFile have precedence over the values in users . For security reasons, the field users doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead. Docker # Declaring the user list # # Note: all dollar signs in the hash need to be doubled for escaping. # To create user:password pair, it's possible to use this command: # echo $(htpasswd -nb user password) | sed -e s/\\\\$/\\\\$\\\\$/g labels: - \"traefik.http.middlewares.test-auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" Kubernetes # Declaring the user list apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: basicAuth: secret: authsecret --- apiVersion: v1 kind: Secret metadata: name: authsecret namespace: default data: users: |2 dGVzdDokYXByMSRINnVza2trVyRJZ1hMUDZld1RyU3VCa1RycUU4d2ovCnRlc3QyOiRhcHIxJGQ5 aHI5SEJCJDRIeHdnVWlyM0hQNEVzZ2dQL1FObzAK Marathon \"labels\": { \"traefik.http.middlewares.test-auth.basicauth.users\": \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" } Rancher # Declaring the user list labels: - \"traefik.http.middlewares.test-auth.basicauth.users=test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" File (TOML) # Declaring the user list [http.middlewares] [http.middlewares.test-auth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] File (YAML) # Declaring the user list http: middlewares: test-auth: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"","title":"users"},{"location":"middlewares/basicauth/#usersfile","text":"The usersFile option is the path to an external file that contains the authorized users for the middleware. The file content is a list of name:encoded-password . If both users and usersFile are provided, the two are merged. The contents of usersFile have precedence over the values in users . Because it does not make much sense to refer to a file path on Kubernetes, the usersFile field doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead. Docker labels: - \"traefik.http.middlewares.test-auth.basicauth.usersfile=/path/to/my/usersfile\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: basicAuth: secret: authsecret --- apiVersion: v1 kind: Secret metadata: name: authsecret namespace: default data: users: |2 dGVzdDokYXByMSRINnVza2trVyRJZ1hMUDZld1RyU3VCa1RycUU4d2ovCnRlc3QyOiRhcHIxJGQ5 aHI5SEJCJDRIeHdnVWlyM0hQNEVzZ2dQL1FObzAK Marathon \"labels\": { \"traefik.http.middlewares.test-auth.basicauth.usersfile\": \"/path/to/my/usersfile\" } Rancher labels: - \"traefik.http.middlewares.test-auth.basicauth.usersfile=/path/to/my/usersfile\" File (TOML) [http.middlewares] [http.middlewares.test-auth.basicAuth] usersFile = \"/path/to/my/usersfile\" File (YAML) http: middlewares: test-auth: basicAuth: usersFile: \"/path/to/my/usersfile\" A file containing test/test and test2/test2 test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0","title":"usersFile"},{"location":"middlewares/basicauth/#realm","text":"You can customize the realm for the authentication with the realm option. The default value is traefik . Docker labels: - \"traefik.http.middlewares.test-auth.basicauth.realm=MyRealm\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: basicAuth: realm: MyRealm Marathon \"labels\": { \"traefik.http.middlewares.test-auth.basicauth.realm\": \"MyRealm\" } Rancher labels: - \"traefik.http.middlewares.test-auth.basicauth.realm=MyRealm\" File (TOML) [http.middlewares] [http.middlewares.test-auth.basicAuth] realm = \"MyRealm\" File (YAML) http: middlewares: test-auth: basicAuth: realm: \"MyRealm\"","title":"realm"},{"location":"middlewares/basicauth/#headerfield","text":"You can define a header field to store the authenticated user using the headerField option. Docker labels: - \"traefik.http.middlewares.my-auth.basicauth.headerField=X-WebAuth-User\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: my-auth spec: basicAuth: # ... headerField: X-WebAuth-User Marathon \"labels\": { \"traefik.http.middlewares.my-auth.basicauth.headerField\": \"X-WebAuth-User\" } File (TOML) [http.middlewares.my-auth.basicAuth] # ... headerField = \"X-WebAuth-User\" File (YAML) http: middlewares: my-auth: basicAuth: # ... headerField: \"X-WebAuth-User\"","title":"headerField"},{"location":"middlewares/basicauth/#removeheader","text":"Set the removeHeader option to true to remove the authorization header before forwarding the request to your service. (Default value is false .) Docker labels: - \"traefik.http.middlewares.test-auth.basicauth.removeheader=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: basicAuth: removeHeader: true Marathon \"labels\": { \"traefik.http.middlewares.test-auth.basicauth.removeheader\": \"true\" } Rancher labels: - \"traefik.http.middlewares.test-auth.basicauth.removeheader=true\" File (TOML) [http.middlewares] [http.middlewares.test-auth.basicAuth] removeHeader = true File (YAML) http: middlewares: test-auth: basicAuth: removeHeader: true","title":"removeHeader"},{"location":"middlewares/buffering/","text":"Buffering \u00b6 How to Read the Request before Forwarding It The Buffering middleware gives you control on how you want to read the requests before sending them to services. With Buffering, Traefik reads the entire request into memory (possibly buffering large requests into disk), and rejects requests that are over a specified limit. This can help services deal with large data (multipart/form-data for example), and can minimize time spent sending data to a service. Configuration Examples \u00b6 Docker # Sets the maximum request body to 2Mb labels: - \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes=2000000\" Kubernetes # Sets the maximum request body to 2Mb apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: maxRequestBodyBytes: 2000000 Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes\": \"2000000\" } Rancher # Sets the maximum request body to 2Mb labels: - \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes=2000000\" File (TOML) # Sets the maximum request body to 2Mb [http.middlewares] [http.middlewares.limit.buffering] maxRequestBodyBytes = 2000000 File (YAML) # Sets the maximum request body to 2Mb http: middlewares: limit: buffering: maxRequestBodyBytes: 2000000 Configuration Options \u00b6 maxRequestBodyBytes \u00b6 With the maxRequestBodyBytes option, you can configure the maximum allowed body size for the request (in Bytes). If the request exceeds the allowed size, it is not forwarded to the service and the client gets a 413 (Request Entity Too Large) response. Docker labels: - \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes=2000000\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: maxRequestBodyBytes: 2000000 Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes\": \"2000000\" } Rancher labels: - \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes=2000000\" File (TOML) [http.middlewares] [http.middlewares.limit.buffering] maxRequestBodyBytes = 2000000 File (YAML) http: middlewares: limit: buffering: maxRequestBodyBytes: 2000000 memRequestBodyBytes \u00b6 You can configure a threshold (in Bytes) from which the request will be buffered on disk instead of in memory with the memRequestBodyBytes option. Docker labels: - \"traefik.http.middlewares.limit.buffering.memRequestBodyBytes=2000000\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: memRequestBodyBytes: 2000000 Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.memRequestBodyBytes\": \"2000000\" } Rancher labels: - \"traefik.http.middlewares.limit.buffering.memRequestBodyBytes=2000000\" File (TOML) [http.middlewares] [http.middlewares.limit.buffering] memRequestBodyBytes = 2000000 File (YAML) http: middlewares: limit: buffering: memRequestBodyBytes: 2000000 maxResponseBodyBytes \u00b6 With the maxReesponseBodyBytes option, you can configure the maximum allowed response size from the service (in Bytes). If the response exceeds the allowed size, it is not forwarded to the client. The client gets a 413 (Request Entity Too Large) response instead. Docker labels: - \"traefik.http.middlewares.limit.buffering.maxResponseBodyBytes=2000000\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: maxResponseBodyBytes: 2000000 Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.maxResponseBodyBytes\": \"2000000\" } Rancher labels: - \"traefik.http.middlewares.limit.buffering.maxResponseBodyBytes=2000000\" File (TOML) [http.middlewares] [http.middlewares.limit.buffering] maxResponseBodyBytes = 2000000 File (YAML) http: middlewares: limit: buffering: maxResponseBodyBytes: 2000000 memResponseBodyBytes \u00b6 You can configure a threshold (in Bytes) from which the response will be buffered on disk instead of in memory with the memResponseBodyBytes option. Docker labels: - \"traefik.http.middlewares.limit.buffering.memResponseBodyBytes=2000000\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: memResponseBodyBytes: 2000000 Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.memResponseBodyBytes\": \"2000000\" } Rancher labels: - \"traefik.http.middlewares.limit.buffering.memResponseBodyBytes=2000000\" File (TOML) [http.middlewares] [http.middlewares.limit.buffering] memResponseBodyBytes = 2000000 File (YAML) http: middlewares: limit: buffering: memResponseBodyBytes: 2000000 retryExpression \u00b6 You can have the Buffering middleware replay the request with the help of the retryExpression option. Retries once in case of a network error Docker labels: - \"traefik.http.middlewares.limit.buffering.retryExpression=IsNetworkError() && Attempts() < 2\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: retryExpression: \"IsNetworkError() && Attempts() < 2\" Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.retryExpression\": \"IsNetworkError() && Attempts() < 2\" } Rancher labels: - \"traefik.http.middlewares.limit.buffering.retryExpression=IsNetworkError() && Attempts() < 2\" File (TOML) [http.middlewares] [http.middlewares.limit.buffering] retryExpression = \"IsNetworkError() && Attempts() < 2\" File (YAML) http: middlewares: limit: buffering: retryExpression: \"IsNetworkError() && Attempts() < 2\" The retry expression is defined as a logical combination of the functions below with the operators AND ( && ) and OR ( || ). At least one function is required: Attempts() number of attempts (the first one counts) ResponseCode() response code of the service IsNetworkError() - if the response code is related to networking error","title":"Buffering"},{"location":"middlewares/buffering/#buffering","text":"How to Read the Request before Forwarding It The Buffering middleware gives you control on how you want to read the requests before sending them to services. With Buffering, Traefik reads the entire request into memory (possibly buffering large requests into disk), and rejects requests that are over a specified limit. This can help services deal with large data (multipart/form-data for example), and can minimize time spent sending data to a service.","title":"Buffering"},{"location":"middlewares/buffering/#configuration-examples","text":"Docker # Sets the maximum request body to 2Mb labels: - \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes=2000000\" Kubernetes # Sets the maximum request body to 2Mb apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: maxRequestBodyBytes: 2000000 Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes\": \"2000000\" } Rancher # Sets the maximum request body to 2Mb labels: - \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes=2000000\" File (TOML) # Sets the maximum request body to 2Mb [http.middlewares] [http.middlewares.limit.buffering] maxRequestBodyBytes = 2000000 File (YAML) # Sets the maximum request body to 2Mb http: middlewares: limit: buffering: maxRequestBodyBytes: 2000000","title":"Configuration Examples"},{"location":"middlewares/buffering/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/buffering/#maxrequestbodybytes","text":"With the maxRequestBodyBytes option, you can configure the maximum allowed body size for the request (in Bytes). If the request exceeds the allowed size, it is not forwarded to the service and the client gets a 413 (Request Entity Too Large) response. Docker labels: - \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes=2000000\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: maxRequestBodyBytes: 2000000 Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes\": \"2000000\" } Rancher labels: - \"traefik.http.middlewares.limit.buffering.maxRequestBodyBytes=2000000\" File (TOML) [http.middlewares] [http.middlewares.limit.buffering] maxRequestBodyBytes = 2000000 File (YAML) http: middlewares: limit: buffering: maxRequestBodyBytes: 2000000","title":"maxRequestBodyBytes"},{"location":"middlewares/buffering/#memrequestbodybytes","text":"You can configure a threshold (in Bytes) from which the request will be buffered on disk instead of in memory with the memRequestBodyBytes option. Docker labels: - \"traefik.http.middlewares.limit.buffering.memRequestBodyBytes=2000000\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: memRequestBodyBytes: 2000000 Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.memRequestBodyBytes\": \"2000000\" } Rancher labels: - \"traefik.http.middlewares.limit.buffering.memRequestBodyBytes=2000000\" File (TOML) [http.middlewares] [http.middlewares.limit.buffering] memRequestBodyBytes = 2000000 File (YAML) http: middlewares: limit: buffering: memRequestBodyBytes: 2000000","title":"memRequestBodyBytes"},{"location":"middlewares/buffering/#maxresponsebodybytes","text":"With the maxReesponseBodyBytes option, you can configure the maximum allowed response size from the service (in Bytes). If the response exceeds the allowed size, it is not forwarded to the client. The client gets a 413 (Request Entity Too Large) response instead. Docker labels: - \"traefik.http.middlewares.limit.buffering.maxResponseBodyBytes=2000000\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: maxResponseBodyBytes: 2000000 Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.maxResponseBodyBytes\": \"2000000\" } Rancher labels: - \"traefik.http.middlewares.limit.buffering.maxResponseBodyBytes=2000000\" File (TOML) [http.middlewares] [http.middlewares.limit.buffering] maxResponseBodyBytes = 2000000 File (YAML) http: middlewares: limit: buffering: maxResponseBodyBytes: 2000000","title":"maxResponseBodyBytes"},{"location":"middlewares/buffering/#memresponsebodybytes","text":"You can configure a threshold (in Bytes) from which the response will be buffered on disk instead of in memory with the memResponseBodyBytes option. Docker labels: - \"traefik.http.middlewares.limit.buffering.memResponseBodyBytes=2000000\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: memResponseBodyBytes: 2000000 Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.memResponseBodyBytes\": \"2000000\" } Rancher labels: - \"traefik.http.middlewares.limit.buffering.memResponseBodyBytes=2000000\" File (TOML) [http.middlewares] [http.middlewares.limit.buffering] memResponseBodyBytes = 2000000 File (YAML) http: middlewares: limit: buffering: memResponseBodyBytes: 2000000","title":"memResponseBodyBytes"},{"location":"middlewares/buffering/#retryexpression","text":"You can have the Buffering middleware replay the request with the help of the retryExpression option. Retries once in case of a network error Docker labels: - \"traefik.http.middlewares.limit.buffering.retryExpression=IsNetworkError() && Attempts() < 2\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: limit spec: buffering: retryExpression: \"IsNetworkError() && Attempts() < 2\" Marathon \"labels\": { \"traefik.http.middlewares.limit.buffering.retryExpression\": \"IsNetworkError() && Attempts() < 2\" } Rancher labels: - \"traefik.http.middlewares.limit.buffering.retryExpression=IsNetworkError() && Attempts() < 2\" File (TOML) [http.middlewares] [http.middlewares.limit.buffering] retryExpression = \"IsNetworkError() && Attempts() < 2\" File (YAML) http: middlewares: limit: buffering: retryExpression: \"IsNetworkError() && Attempts() < 2\" The retry expression is defined as a logical combination of the functions below with the operators AND ( && ) and OR ( || ). At least one function is required: Attempts() number of attempts (the first one counts) ResponseCode() response code of the service IsNetworkError() - if the response code is related to networking error","title":"retryExpression"},{"location":"middlewares/chain/","text":"Chain \u00b6 When One Isn't Enough The Chain middleware enables you to define reusable combinations of other pieces of middleware. It makes reusing the same groups easier. Configuration Example \u00b6 Example \"A Chain for WhiteList, BasicAuth, and HTTPS\" Docker labels: - \"traefik.http.routers.router1.service=service1\" - \"traefik.http.routers.router1.middlewares=secured\" - \"traefik.http.routers.router1.rule=Host(`mydomain`)\" - \"traefik.http.middlewares.secured.chain.middlewares=https-only,known-ips,auth-users\" - \"traefik.http.middlewares.auth-users.basicauth.users=test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"traefik.http.middlewares.https-only.redirectscheme.scheme=https\" - \"traefik.http.middlewares.known-ips.ipwhitelist.sourceRange=192.168.1.7,127.0.0.1/32\" - \"http.services.service1.loadbalancer.server.port=80\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: test namespace: default spec: entryPoints: - web routes: - match: Host(`mydomain`) kind: Rule services: - name: whoami port: 80 middlewares: - name: secured --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: secured spec: chain: middlewares: - name: https-only - name: known-ips - name: auth-users --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: auth-users spec: basicAuth: users: - test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: https-only spec: redirectScheme: scheme: https --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: known-ips spec: ipWhiteList: sourceRange: - 192.168.1.7 - 127.0.0.1/32 Marathon \"labels\": { \"traefik.http.routers.router1.service\": \"service1\", \"traefik.http.routers.router1.middlewares\": \"secured\", \"traefik.http.routers.router1.rule\": \"Host(`mydomain`)\", \"traefik.http.middlewares.secured.chain.middlewares\": \"https-only,known-ips,auth-users\", \"traefik.http.middlewares.auth-users.basicauth.users\": \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"traefik.http.middlewares.https-only.redirectscheme.scheme\": \"https\", \"traefik.http.middlewares.known-ips.ipwhitelist.sourceRange\": \"192.168.1.7,127.0.0.1/32\", \"http.services.service1.loadbalancer.server.port\": \"80\" } Rancher labels: - \"traefik.http.routers.router1.service=service1\" - \"traefik.http.routers.router1.middlewares=secured\" - \"traefik.http.routers.router1.rule=Host(`mydomain`)\" - \"traefik.http.middlewares.secured.chain.middlewares=https-only,known-ips,auth-users\" - \"traefik.http.middlewares.auth-users.basicauth.users=test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"traefik.http.middlewares.https-only.redirectscheme.scheme=https\" - \"traefik.http.middlewares.known-ips.ipwhitelist.sourceRange=192.168.1.7,127.0.0.1/32\" - \"http.services.service1.loadbalancer.server.port=80\" File (TOML) # ... [http.routers] [http.routers.router1] service = \"service1\" middlewares = [\"secured\"] rule = \"Host(`mydomain`)\" [http.middlewares] [http.middlewares.secured.chain] middlewares = [\"https-only\", \"known-ips\", \"auth-users\"] [http.middlewares.auth-users.basicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.middlewares.https-only.redirectScheme] scheme = \"https\" [http.middlewares.known-ips.ipWhiteList] sourceRange = [\"192.168.1.7\", \"127.0.0.1/32\"] [http.services] [http.services.service1] [http.services.service1.loadBalancer] [[http.services.service1.loadBalancer.servers]] url = \"http://127.0.0.1:80\" File (YAML) # ... http: routers: router1: service: service1 middlewares: - secured rule: \"Host(`mydomain`)\" middlewares: secured: chain: middlewares: - https-only - known-ips - auth-users auth-users: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" https-only: redirectScheme: scheme: https known-ips: ipWhiteList: sourceRange: - \"192.168.1.7\" - \"127.0.0.1/32\" services: service1: loadBalancer: servers: - url: \"http://127.0.0.1:80\"","title":"Chain"},{"location":"middlewares/chain/#chain","text":"When One Isn't Enough The Chain middleware enables you to define reusable combinations of other pieces of middleware. It makes reusing the same groups easier.","title":"Chain"},{"location":"middlewares/chain/#configuration-example","text":"Example \"A Chain for WhiteList, BasicAuth, and HTTPS\" Docker labels: - \"traefik.http.routers.router1.service=service1\" - \"traefik.http.routers.router1.middlewares=secured\" - \"traefik.http.routers.router1.rule=Host(`mydomain`)\" - \"traefik.http.middlewares.secured.chain.middlewares=https-only,known-ips,auth-users\" - \"traefik.http.middlewares.auth-users.basicauth.users=test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"traefik.http.middlewares.https-only.redirectscheme.scheme=https\" - \"traefik.http.middlewares.known-ips.ipwhitelist.sourceRange=192.168.1.7,127.0.0.1/32\" - \"http.services.service1.loadbalancer.server.port=80\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: test namespace: default spec: entryPoints: - web routes: - match: Host(`mydomain`) kind: Rule services: - name: whoami port: 80 middlewares: - name: secured --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: secured spec: chain: middlewares: - name: https-only - name: known-ips - name: auth-users --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: auth-users spec: basicAuth: users: - test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: https-only spec: redirectScheme: scheme: https --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: known-ips spec: ipWhiteList: sourceRange: - 192.168.1.7 - 127.0.0.1/32 Marathon \"labels\": { \"traefik.http.routers.router1.service\": \"service1\", \"traefik.http.routers.router1.middlewares\": \"secured\", \"traefik.http.routers.router1.rule\": \"Host(`mydomain`)\", \"traefik.http.middlewares.secured.chain.middlewares\": \"https-only,known-ips,auth-users\", \"traefik.http.middlewares.auth-users.basicauth.users\": \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"traefik.http.middlewares.https-only.redirectscheme.scheme\": \"https\", \"traefik.http.middlewares.known-ips.ipwhitelist.sourceRange\": \"192.168.1.7,127.0.0.1/32\", \"http.services.service1.loadbalancer.server.port\": \"80\" } Rancher labels: - \"traefik.http.routers.router1.service=service1\" - \"traefik.http.routers.router1.middlewares=secured\" - \"traefik.http.routers.router1.rule=Host(`mydomain`)\" - \"traefik.http.middlewares.secured.chain.middlewares=https-only,known-ips,auth-users\" - \"traefik.http.middlewares.auth-users.basicauth.users=test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"traefik.http.middlewares.https-only.redirectscheme.scheme=https\" - \"traefik.http.middlewares.known-ips.ipwhitelist.sourceRange=192.168.1.7,127.0.0.1/32\" - \"http.services.service1.loadbalancer.server.port=80\" File (TOML) # ... [http.routers] [http.routers.router1] service = \"service1\" middlewares = [\"secured\"] rule = \"Host(`mydomain`)\" [http.middlewares] [http.middlewares.secured.chain] middlewares = [\"https-only\", \"known-ips\", \"auth-users\"] [http.middlewares.auth-users.basicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.middlewares.https-only.redirectScheme] scheme = \"https\" [http.middlewares.known-ips.ipWhiteList] sourceRange = [\"192.168.1.7\", \"127.0.0.1/32\"] [http.services] [http.services.service1] [http.services.service1.loadBalancer] [[http.services.service1.loadBalancer.servers]] url = \"http://127.0.0.1:80\" File (YAML) # ... http: routers: router1: service: service1 middlewares: - secured rule: \"Host(`mydomain`)\" middlewares: secured: chain: middlewares: - https-only - known-ips - auth-users auth-users: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" https-only: redirectScheme: scheme: https known-ips: ipWhiteList: sourceRange: - \"192.168.1.7\" - \"127.0.0.1/32\" services: service1: loadBalancer: servers: - url: \"http://127.0.0.1:80\"","title":"Configuration Example"},{"location":"middlewares/circuitbreaker/","text":"CircuitBreaker \u00b6 Don't Waste Time Calling Unhealthy Services The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is close (normal operations). When your system becomes unhealthy, the circuit becomes open and the requests are no longer forwarded (but handled by a fallback mechanism). To assess if your system is healthy, the circuit breaker constantly monitors the services. The CircuitBreaker only analyses what happens after it is positioned in the middleware chain. What happens before has no impact on its state. The CircuitBreaker only affects the routers that use it. Routers that don't use the CircuitBreaker won't be affected by its state. Important Each router will eventually gets its own instance of a given circuit breaker. If two different routers refer to the same circuit breaker definition, they will get one instance each. It means that one circuit breaker can be open while the other stays closed: their state is not shared. This is the expected behavior, we want you to be able to define what makes a service healthy without having to declare a circuit breaker for each route. Configuration Examples \u00b6 Docker # Latency Check labels: - \"traefik.http.middlewares.latency-check.circuitbreaker.expression=LatencyAtQuantileMS(50.0) > 100\" Kubernetes # Latency Check apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: latency-check spec: circuitBreaker: expression: LatencyAtQuantileMS(50.0) > 100 Marathon \"labels\": { \"traefik.http.middlewares.latency-check.circuitbreaker.expression\": \"LatencyAtQuantileMS(50.0) > 100\" } Rancher # Latency Check labels: - \"traefik.http.middlewares.latency-check.circuitbreaker.expression=LatencyAtQuantileMS(50.0) > 100\" File (TOML) # Latency Check [http.middlewares] [http.middlewares.latency-check.circuitBreaker] expression = \"LatencyAtQuantileMS(50.0) > 100\" File (YAML) # Latency Check http: middlewares: latency-check: circuitBreaker: expression: \"LatencyAtQuantileMS(50.0) > 100\" Possible States \u00b6 There are three possible states for your circuit breaker: Close (your service operates normally) Open (the fallback mechanism takes over your service) Recovering (the circuit breaker tries to resume normal operations by progressively sending requests to your service) Close \u00b6 While close, the circuit breaker only collects metrics to analyze the behavior of the requests. At specified intervals ( checkPeriod ), it will evaluate expression to decide if its state must change. Open \u00b6 While open, the fallback mechanism takes over the normal service calls for a duration of FallbackDuration . After this duration, it will enter the recovering state. Recovering \u00b6 While recovering, the circuit breaker will progressively send requests to your service again (in a linear way, for RecoveryDuration ). If your service fails during recovery, the circuit breaker becomes open again. If the service operates normally during the whole recovering duration, then the circuit breaker returns to close. Configuration Options \u00b6 Configuring the Trigger \u00b6 You can specify an expression that, once matched, will trigger the circuit breaker (and apply the fallback mechanism instead of calling your services). The expression can check three different metrics: The network error ratio ( NetworkErrorRatio ) The status code ratio ( ResponseCodeRatio ) The latency at quantile, in milliseconds ( LatencyAtQuantileMS ) NetworkErrorRatio \u00b6 If you want the circuit breaker to trigger at a 30% ratio of network errors, the expression will be NetworkErrorRatio() > 0.30 ResponseCodeRatio \u00b6 You can trigger the circuit breaker based on the ratio of a given range of status codes. The ResponseCodeRatio accepts four parameters, from , to , dividedByFrom , dividedByTo . The operation that will be computed is sum( to -> from ) / sum ( dividedByFrom -> dividedByTo ). If sum ( dividedByFrom -> dividedByTo ) equals 0, then ResponseCodeRatio returns 0. from is inclusive, to is exclusive. For example, the expression ResponseCodeRatio(500, 600, 0, 600) > 0.25 will trigger the circuit breaker if 25% of the requests returned a 5XX status (amongst the request that returned a status code from 0 to 5XX). LatencyAtQuantileMS \u00b6 You can trigger the circuit breaker when a given proportion of your requests become too slow. For example, the expression LatencyAtQuantileMS(50.0) > 100 will trigger the circuit breaker when the median latency (quantile 50) reaches 100MS. You must provide a float number (with the trailing .0) for the quantile value Using multiple metrics \u00b6 You can combine multiple metrics using operators in your expression. Supported operators are: AND ( && ) OR ( || ) For example, ResponseCodeRatio(500, 600, 0, 600) > 0.30 || NetworkErrorRatio() > 0.10 triggers the circuit breaker when 30% of the requests return a 5XX status code, or when the ratio of network errors reaches 10%. Operators \u00b6 Here is the list of supported operators: Greater than ( > ) Greater or equal than ( >= ) Lesser than ( < ) Lesser or equal than ( <= ) Equal ( == ) Not Equal ( != ) Fallback mechanism \u00b6 The fallback mechanism returns a HTTP 503 Service Unavailable to the client (instead of calling the target service). This behavior cannot be configured. CheckPeriod \u00b6 The interval used to evaluate expression and decide if the state of the circuit breaker must change. By default, CheckPeriod is 100ms. This value cannot be configured. FallbackDuration \u00b6 By default, FallbackDuration is 10 seconds. This value cannot be configured. RecoveringDuration \u00b6 The duration of the recovering mode (recovering state). By default, RecoveringDuration is 10 seconds. This value cannot be configured.","title":"CircuitBreaker"},{"location":"middlewares/circuitbreaker/#circuitbreaker","text":"Don't Waste Time Calling Unhealthy Services The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is close (normal operations). When your system becomes unhealthy, the circuit becomes open and the requests are no longer forwarded (but handled by a fallback mechanism). To assess if your system is healthy, the circuit breaker constantly monitors the services. The CircuitBreaker only analyses what happens after it is positioned in the middleware chain. What happens before has no impact on its state. The CircuitBreaker only affects the routers that use it. Routers that don't use the CircuitBreaker won't be affected by its state. Important Each router will eventually gets its own instance of a given circuit breaker. If two different routers refer to the same circuit breaker definition, they will get one instance each. It means that one circuit breaker can be open while the other stays closed: their state is not shared. This is the expected behavior, we want you to be able to define what makes a service healthy without having to declare a circuit breaker for each route.","title":"CircuitBreaker"},{"location":"middlewares/circuitbreaker/#configuration-examples","text":"Docker # Latency Check labels: - \"traefik.http.middlewares.latency-check.circuitbreaker.expression=LatencyAtQuantileMS(50.0) > 100\" Kubernetes # Latency Check apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: latency-check spec: circuitBreaker: expression: LatencyAtQuantileMS(50.0) > 100 Marathon \"labels\": { \"traefik.http.middlewares.latency-check.circuitbreaker.expression\": \"LatencyAtQuantileMS(50.0) > 100\" } Rancher # Latency Check labels: - \"traefik.http.middlewares.latency-check.circuitbreaker.expression=LatencyAtQuantileMS(50.0) > 100\" File (TOML) # Latency Check [http.middlewares] [http.middlewares.latency-check.circuitBreaker] expression = \"LatencyAtQuantileMS(50.0) > 100\" File (YAML) # Latency Check http: middlewares: latency-check: circuitBreaker: expression: \"LatencyAtQuantileMS(50.0) > 100\"","title":"Configuration Examples"},{"location":"middlewares/circuitbreaker/#possible-states","text":"There are three possible states for your circuit breaker: Close (your service operates normally) Open (the fallback mechanism takes over your service) Recovering (the circuit breaker tries to resume normal operations by progressively sending requests to your service)","title":"Possible States"},{"location":"middlewares/circuitbreaker/#close","text":"While close, the circuit breaker only collects metrics to analyze the behavior of the requests. At specified intervals ( checkPeriod ), it will evaluate expression to decide if its state must change.","title":"Close"},{"location":"middlewares/circuitbreaker/#open","text":"While open, the fallback mechanism takes over the normal service calls for a duration of FallbackDuration . After this duration, it will enter the recovering state.","title":"Open"},{"location":"middlewares/circuitbreaker/#recovering","text":"While recovering, the circuit breaker will progressively send requests to your service again (in a linear way, for RecoveryDuration ). If your service fails during recovery, the circuit breaker becomes open again. If the service operates normally during the whole recovering duration, then the circuit breaker returns to close.","title":"Recovering"},{"location":"middlewares/circuitbreaker/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/circuitbreaker/#configuring-the-trigger","text":"You can specify an expression that, once matched, will trigger the circuit breaker (and apply the fallback mechanism instead of calling your services). The expression can check three different metrics: The network error ratio ( NetworkErrorRatio ) The status code ratio ( ResponseCodeRatio ) The latency at quantile, in milliseconds ( LatencyAtQuantileMS )","title":"Configuring the Trigger"},{"location":"middlewares/circuitbreaker/#networkerrorratio","text":"If you want the circuit breaker to trigger at a 30% ratio of network errors, the expression will be NetworkErrorRatio() > 0.30","title":"NetworkErrorRatio"},{"location":"middlewares/circuitbreaker/#responsecoderatio","text":"You can trigger the circuit breaker based on the ratio of a given range of status codes. The ResponseCodeRatio accepts four parameters, from , to , dividedByFrom , dividedByTo . The operation that will be computed is sum( to -> from ) / sum ( dividedByFrom -> dividedByTo ). If sum ( dividedByFrom -> dividedByTo ) equals 0, then ResponseCodeRatio returns 0. from is inclusive, to is exclusive. For example, the expression ResponseCodeRatio(500, 600, 0, 600) > 0.25 will trigger the circuit breaker if 25% of the requests returned a 5XX status (amongst the request that returned a status code from 0 to 5XX).","title":"ResponseCodeRatio"},{"location":"middlewares/circuitbreaker/#latencyatquantilems","text":"You can trigger the circuit breaker when a given proportion of your requests become too slow. For example, the expression LatencyAtQuantileMS(50.0) > 100 will trigger the circuit breaker when the median latency (quantile 50) reaches 100MS. You must provide a float number (with the trailing .0) for the quantile value","title":"LatencyAtQuantileMS"},{"location":"middlewares/circuitbreaker/#using-multiple-metrics","text":"You can combine multiple metrics using operators in your expression. Supported operators are: AND ( && ) OR ( || ) For example, ResponseCodeRatio(500, 600, 0, 600) > 0.30 || NetworkErrorRatio() > 0.10 triggers the circuit breaker when 30% of the requests return a 5XX status code, or when the ratio of network errors reaches 10%.","title":"Using multiple metrics"},{"location":"middlewares/circuitbreaker/#operators","text":"Here is the list of supported operators: Greater than ( > ) Greater or equal than ( >= ) Lesser than ( < ) Lesser or equal than ( <= ) Equal ( == ) Not Equal ( != )","title":"Operators"},{"location":"middlewares/circuitbreaker/#fallback-mechanism","text":"The fallback mechanism returns a HTTP 503 Service Unavailable to the client (instead of calling the target service). This behavior cannot be configured.","title":"Fallback mechanism"},{"location":"middlewares/circuitbreaker/#checkperiod","text":"The interval used to evaluate expression and decide if the state of the circuit breaker must change. By default, CheckPeriod is 100ms. This value cannot be configured.","title":"CheckPeriod"},{"location":"middlewares/circuitbreaker/#fallbackduration","text":"By default, FallbackDuration is 10 seconds. This value cannot be configured.","title":"FallbackDuration"},{"location":"middlewares/circuitbreaker/#recoveringduration","text":"The duration of the recovering mode (recovering state). By default, RecoveringDuration is 10 seconds. This value cannot be configured.","title":"RecoveringDuration"},{"location":"middlewares/compress/","text":"Compress \u00b6 Compressing the Response before Sending it to the Client The Compress middleware enables the gzip compression. Configuration Examples \u00b6 Docker # Enable gzip compression labels: - \"traefik.http.middlewares.test-compress.compress=true\" Kubernetes # Enable gzip compression apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-compress spec: compress: {} Marathon \"labels\": { \"traefik.http.middlewares.test-compress.compress\": \"true\" } Rancher # Enable gzip compression labels: - \"traefik.http.middlewares.test-compress.compress=true\" File (TOML) # Enable gzip compression [http.middlewares] [http.middlewares.test-compress.compress] File (YAML) # Enable gzip compression http: middlewares: test-compress: compress: {} Info Responses are compressed when: The response body is larger than 1400 bytes. The Accept-Encoding request header contains gzip . The response is not already compressed, i.e. the Content-Encoding response header is not already set.","title":"Compress"},{"location":"middlewares/compress/#compress","text":"Compressing the Response before Sending it to the Client The Compress middleware enables the gzip compression.","title":"Compress"},{"location":"middlewares/compress/#configuration-examples","text":"Docker # Enable gzip compression labels: - \"traefik.http.middlewares.test-compress.compress=true\" Kubernetes # Enable gzip compression apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-compress spec: compress: {} Marathon \"labels\": { \"traefik.http.middlewares.test-compress.compress\": \"true\" } Rancher # Enable gzip compression labels: - \"traefik.http.middlewares.test-compress.compress=true\" File (TOML) # Enable gzip compression [http.middlewares] [http.middlewares.test-compress.compress] File (YAML) # Enable gzip compression http: middlewares: test-compress: compress: {} Info Responses are compressed when: The response body is larger than 1400 bytes. The Accept-Encoding request header contains gzip . The response is not already compressed, i.e. the Content-Encoding response header is not already set.","title":"Configuration Examples"},{"location":"middlewares/digestauth/","text":"DigestAuth \u00b6 Adding Digest Authentication The DigestAuth middleware is a quick way to restrict access to your services to known users. Configuration Examples \u00b6 Docker # Declaring the user list labels: - \"traefik.http.middlewares.test-auth.digestauth.users=test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" Kubernetes # Declaring the user list apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: digestAuth: secret: userssecret Marathon \"labels\": { \"traefik.http.middlewares.test-auth.digestauth.users\": \"test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" } Rancher # Declaring the user list labels: - \"traefik.http.middlewares.test-auth.digestauth.users=test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" File (TOML) # Declaring the user list [http.middlewares] [http.middlewares.test-auth.digestAuth] users = [ \"test:traefik:a2688e031edb4be6a3797f3882655c05\", \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\", ] File (YAML) # Declaring the user list http: middlewares: test-auth: digestAuth: users: - \"test:traefik:a2688e031edb4be6a3797f3882655c05\" - \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" Configuration Options \u00b6 Tip Use htdigest to generate passwords. users \u00b6 The users option is an array of authorized users. Each user will be declared using the name:realm:encoded-password format. If both users and usersFile are provided, the two are merged. The contents of usersFile have precedence over the values in users . For security reasons, the field users doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead. Docker labels: - \"traefik.http.middlewares.test-auth.digestauth.users=test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: digestAuth: secret: authsecret --- apiVersion: v1 kind: Secret metadata: name: authsecret namespace: default data: users: |2 dGVzdDp0cmFlZmlrOmEyNjg4ZTAzMWVkYjRiZTZhMzc5N2YzODgyNjU1YzA1CnRlc3QyOnRyYWVmaWs6NTE4ODQ1ODAwZjllMmJmYjFmMWY3NDBlYzI0ZjA3NGUKCg== Marathon \"labels\": { \"traefik.http.middlewares.test-auth.digestauth.users\": \"test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" } Rancher labels: - \"traefik.http.middlewares.test-auth.digestauth.users=test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" File (TOML) [http.middlewares] [http.middlewares.test-auth.digestAuth] users = [ \"test:traefik:a2688e031edb4be6a3797f3882655c05\", \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\", ] File (YAML) http: middlewares: test-auth: digestAuth: users: - \"test:traefik:a2688e031edb4be6a3797f3882655c05\" - \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" usersFile \u00b6 The usersFile option is the path to an external file that contains the authorized users for the middleware. The file content is a list of name:realm:encoded-password . If both users and usersFile are provided, the two are merged. The contents of usersFile have precedence over the values in users . Because it does not make much sense to refer to a file path on Kubernetes, the usersFile field doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead. Docker labels: - \"traefik.http.middlewares.test-auth.digestauth.usersfile=/path/to/my/usersfile\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: digestAuth: secret: authsecret --- apiVersion: v1 kind: Secret metadata: name: authsecret namespace: default data: users: |2 dGVzdDokYXByMSRINnVza2trVyRJZ1hMUDZld1RyU3VCa1RycUU4d2ovCnRlc3QyOiRhcHIxJGQ5 aHI5SEJCJDRIeHdnVWlyM0hQNEVzZ2dQL1FObzAK Marathon \"labels\": { \"traefik.http.middlewares.test-auth.digestauth.usersfile\": \"/path/to/my/usersfile\" } Rancher labels: - \"traefik.http.middlewares.test-auth.digestauth.usersfile=/path/to/my/usersfile\" File (TOML) [http.middlewares] [http.middlewares.test-auth.digestAuth] usersFile = \"/path/to/my/usersfile\" File (YAML) http: middlewares: test-auth: digestAuth: usersFile: \"/path/to/my/usersfile\" A file containing test/test and test2/test2 test:traefik:a2688e031edb4be6a3797f3882655c05 test2:traefik:518845800f9e2bfb1f1f740ec24f074e realm \u00b6 You can customize the realm for the authentication with the realm option. The default value is traefik . Docker labels: - \"traefik.http.middlewares.test-auth.digestauth.realm=MyRealm\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: digestAuth: realm: MyRealm Marathon \"labels\": { \"traefik.http.middlewares.test-auth.digestauth.realm\": \"MyRealm\" } Rancher labels: - \"traefik.http.middlewares.test-auth.digestauth.realm=MyRealm\" File (TOML) [http.middlewares] [http.middlewares.test-auth.digestAuth] realm = \"MyRealm\" File (YAML) http: middlewares: test-auth: digestAuth: realm: \"MyRealm\" headerField \u00b6 You can customize the header field for the authenticated user using the headerField option. Docker labels: - \"traefik.http.middlewares.my-auth.digestauth.headerField=X-WebAuth-User\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: my-auth spec: digestAuth: # ... headerField: X-WebAuth-User Rancher labels: - \"traefik.http.middlewares.my-auth.digestauth.headerField=X-WebAuth-User\" Marathon \"labels\": { \"traefik.http.middlewares.my-auth.digestauth.headerField\": \"X-WebAuth-User\" } File (TOML) [http.middlewares.my-auth.digestAuth] # ... headerField = \"X-WebAuth-User\" File (YAML) http: middlewares: my-auth: digestAuth: # ... headerField: \"X-WebAuth-User\" removeHeader \u00b6 Set the removeHeader option to true to remove the authorization header before forwarding the request to your service. (Default value is false .) Docker labels: - \"traefik.http.middlewares.test-auth.digestauth.removeheader=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: digestAuth: removeHeader: true Marathon \"labels\": { \"traefik.http.middlewares.test-auth.digestauth.removeheader\": \"true\" } Rancher labels: - \"traefik.http.middlewares.test-auth.digestauth.removeheader=true\" File (TOML) [http.middlewares] [http.middlewares.test-auth.digestAuth] removeHeader = true File (YAML) http: middlewares: test-auth: digestAuth: removeHeader: true","title":"DigestAuth"},{"location":"middlewares/digestauth/#digestauth","text":"Adding Digest Authentication The DigestAuth middleware is a quick way to restrict access to your services to known users.","title":"DigestAuth"},{"location":"middlewares/digestauth/#configuration-examples","text":"Docker # Declaring the user list labels: - \"traefik.http.middlewares.test-auth.digestauth.users=test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" Kubernetes # Declaring the user list apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: digestAuth: secret: userssecret Marathon \"labels\": { \"traefik.http.middlewares.test-auth.digestauth.users\": \"test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" } Rancher # Declaring the user list labels: - \"traefik.http.middlewares.test-auth.digestauth.users=test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" File (TOML) # Declaring the user list [http.middlewares] [http.middlewares.test-auth.digestAuth] users = [ \"test:traefik:a2688e031edb4be6a3797f3882655c05\", \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\", ] File (YAML) # Declaring the user list http: middlewares: test-auth: digestAuth: users: - \"test:traefik:a2688e031edb4be6a3797f3882655c05\" - \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\"","title":"Configuration Examples"},{"location":"middlewares/digestauth/#configuration-options","text":"Tip Use htdigest to generate passwords.","title":"Configuration Options"},{"location":"middlewares/digestauth/#users","text":"The users option is an array of authorized users. Each user will be declared using the name:realm:encoded-password format. If both users and usersFile are provided, the two are merged. The contents of usersFile have precedence over the values in users . For security reasons, the field users doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead. Docker labels: - \"traefik.http.middlewares.test-auth.digestauth.users=test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: digestAuth: secret: authsecret --- apiVersion: v1 kind: Secret metadata: name: authsecret namespace: default data: users: |2 dGVzdDp0cmFlZmlrOmEyNjg4ZTAzMWVkYjRiZTZhMzc5N2YzODgyNjU1YzA1CnRlc3QyOnRyYWVmaWs6NTE4ODQ1ODAwZjllMmJmYjFmMWY3NDBlYzI0ZjA3NGUKCg== Marathon \"labels\": { \"traefik.http.middlewares.test-auth.digestauth.users\": \"test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" } Rancher labels: - \"traefik.http.middlewares.test-auth.digestauth.users=test:traefik:a2688e031edb4be6a3797f3882655c05,test2:traefik:518845800f9e2bfb1f1f740ec24f074e\" File (TOML) [http.middlewares] [http.middlewares.test-auth.digestAuth] users = [ \"test:traefik:a2688e031edb4be6a3797f3882655c05\", \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\", ] File (YAML) http: middlewares: test-auth: digestAuth: users: - \"test:traefik:a2688e031edb4be6a3797f3882655c05\" - \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\"","title":"users"},{"location":"middlewares/digestauth/#usersfile","text":"The usersFile option is the path to an external file that contains the authorized users for the middleware. The file content is a list of name:realm:encoded-password . If both users and usersFile are provided, the two are merged. The contents of usersFile have precedence over the values in users . Because it does not make much sense to refer to a file path on Kubernetes, the usersFile field doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead. Docker labels: - \"traefik.http.middlewares.test-auth.digestauth.usersfile=/path/to/my/usersfile\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: digestAuth: secret: authsecret --- apiVersion: v1 kind: Secret metadata: name: authsecret namespace: default data: users: |2 dGVzdDokYXByMSRINnVza2trVyRJZ1hMUDZld1RyU3VCa1RycUU4d2ovCnRlc3QyOiRhcHIxJGQ5 aHI5SEJCJDRIeHdnVWlyM0hQNEVzZ2dQL1FObzAK Marathon \"labels\": { \"traefik.http.middlewares.test-auth.digestauth.usersfile\": \"/path/to/my/usersfile\" } Rancher labels: - \"traefik.http.middlewares.test-auth.digestauth.usersfile=/path/to/my/usersfile\" File (TOML) [http.middlewares] [http.middlewares.test-auth.digestAuth] usersFile = \"/path/to/my/usersfile\" File (YAML) http: middlewares: test-auth: digestAuth: usersFile: \"/path/to/my/usersfile\" A file containing test/test and test2/test2 test:traefik:a2688e031edb4be6a3797f3882655c05 test2:traefik:518845800f9e2bfb1f1f740ec24f074e","title":"usersFile"},{"location":"middlewares/digestauth/#realm","text":"You can customize the realm for the authentication with the realm option. The default value is traefik . Docker labels: - \"traefik.http.middlewares.test-auth.digestauth.realm=MyRealm\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: digestAuth: realm: MyRealm Marathon \"labels\": { \"traefik.http.middlewares.test-auth.digestauth.realm\": \"MyRealm\" } Rancher labels: - \"traefik.http.middlewares.test-auth.digestauth.realm=MyRealm\" File (TOML) [http.middlewares] [http.middlewares.test-auth.digestAuth] realm = \"MyRealm\" File (YAML) http: middlewares: test-auth: digestAuth: realm: \"MyRealm\"","title":"realm"},{"location":"middlewares/digestauth/#headerfield","text":"You can customize the header field for the authenticated user using the headerField option. Docker labels: - \"traefik.http.middlewares.my-auth.digestauth.headerField=X-WebAuth-User\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: my-auth spec: digestAuth: # ... headerField: X-WebAuth-User Rancher labels: - \"traefik.http.middlewares.my-auth.digestauth.headerField=X-WebAuth-User\" Marathon \"labels\": { \"traefik.http.middlewares.my-auth.digestauth.headerField\": \"X-WebAuth-User\" } File (TOML) [http.middlewares.my-auth.digestAuth] # ... headerField = \"X-WebAuth-User\" File (YAML) http: middlewares: my-auth: digestAuth: # ... headerField: \"X-WebAuth-User\"","title":"headerField"},{"location":"middlewares/digestauth/#removeheader","text":"Set the removeHeader option to true to remove the authorization header before forwarding the request to your service. (Default value is false .) Docker labels: - \"traefik.http.middlewares.test-auth.digestauth.removeheader=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: digestAuth: removeHeader: true Marathon \"labels\": { \"traefik.http.middlewares.test-auth.digestauth.removeheader\": \"true\" } Rancher labels: - \"traefik.http.middlewares.test-auth.digestauth.removeheader=true\" File (TOML) [http.middlewares] [http.middlewares.test-auth.digestAuth] removeHeader = true File (YAML) http: middlewares: test-auth: digestAuth: removeHeader: true","title":"removeHeader"},{"location":"middlewares/errorpages/","text":"ErrorPage \u00b6 It Has Never Been Easier to Say That Something Went Wrong The ErrorPage middleware returns a custom page in lieu of the default, according to configured ranges of HTTP Status codes. Important The error page itself is not hosted by Traefik. Configuration Examples \u00b6 Docker # Dynamic Custom Error Page for 5XX Status Code labels: - \"traefik.http.middlewares.test-errorpage.errors.status=500-599\" - \"traefik.http.middlewares.test-errorpage.errors.service=serviceError\" - \"traefik.http.middlewares.test-errorpage.errors.query=/{status}.html\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-errorpage spec: errors: status: - 500-599 query: /{status}.html service: name: whoami port: 80 Marathon \"labels\": { \"traefik.http.middlewares.test-errorpage.errors.status\": \"500-599\", \"traefik.http.middlewares.test-errorpage.errors.service\": \"serviceError\", \"traefik.http.middlewares.test-errorpage.errors.query\": \"/{status}.html\" } Rancher # Dynamic Custom Error Page for 5XX Status Code labels: - \"traefik.http.middlewares.test-errorpage.errors.status=500-599\" - \"traefik.http.middlewares.test-errorpage.errors.service=serviceError\" - \"traefik.http.middlewares.test-errorpage.errors.query=/{status}.html\" File (TOML) # Custom Error Page for 5XX [http.middlewares] [http.middlewares.test-errorpage.errors] status = [\"500-599\"] service = \"serviceError\" query = \"/{status}.html\" [http.services] # ... definition of error-handler-service and my-service File (YAML) # Custom Error Page for 5XX http: middlewares: test-errorpage: errors: status: - \"500-599\" service: serviceError query: \"/{status}.html\" [http.services] # ... definition of error-handler-service and my-service In this example, the error page URL is based on the status code ( query=/{status}.html ). Configuration Options \u00b6 status \u00b6 The status that will trigger the error page. The status code ranges are inclusive ( 500-599 will trigger with every code between 500 and 599 , 500 and 599 included). You can define either a status code like 500 or ranges with a syntax like 500-599 . service \u00b6 The service that will serve the new requested error page. In kubernetes, you need to reference a kubernetes service instead of a traefik service. query \u00b6 The URL for the error page (hosted by service ). You can use {status} in the query, that will be replaced by the received status code.","title":"Errors"},{"location":"middlewares/errorpages/#errorpage","text":"It Has Never Been Easier to Say That Something Went Wrong The ErrorPage middleware returns a custom page in lieu of the default, according to configured ranges of HTTP Status codes. Important The error page itself is not hosted by Traefik.","title":"ErrorPage"},{"location":"middlewares/errorpages/#configuration-examples","text":"Docker # Dynamic Custom Error Page for 5XX Status Code labels: - \"traefik.http.middlewares.test-errorpage.errors.status=500-599\" - \"traefik.http.middlewares.test-errorpage.errors.service=serviceError\" - \"traefik.http.middlewares.test-errorpage.errors.query=/{status}.html\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-errorpage spec: errors: status: - 500-599 query: /{status}.html service: name: whoami port: 80 Marathon \"labels\": { \"traefik.http.middlewares.test-errorpage.errors.status\": \"500-599\", \"traefik.http.middlewares.test-errorpage.errors.service\": \"serviceError\", \"traefik.http.middlewares.test-errorpage.errors.query\": \"/{status}.html\" } Rancher # Dynamic Custom Error Page for 5XX Status Code labels: - \"traefik.http.middlewares.test-errorpage.errors.status=500-599\" - \"traefik.http.middlewares.test-errorpage.errors.service=serviceError\" - \"traefik.http.middlewares.test-errorpage.errors.query=/{status}.html\" File (TOML) # Custom Error Page for 5XX [http.middlewares] [http.middlewares.test-errorpage.errors] status = [\"500-599\"] service = \"serviceError\" query = \"/{status}.html\" [http.services] # ... definition of error-handler-service and my-service File (YAML) # Custom Error Page for 5XX http: middlewares: test-errorpage: errors: status: - \"500-599\" service: serviceError query: \"/{status}.html\" [http.services] # ... definition of error-handler-service and my-service In this example, the error page URL is based on the status code ( query=/{status}.html ).","title":"Configuration Examples"},{"location":"middlewares/errorpages/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/errorpages/#status","text":"The status that will trigger the error page. The status code ranges are inclusive ( 500-599 will trigger with every code between 500 and 599 , 500 and 599 included). You can define either a status code like 500 or ranges with a syntax like 500-599 .","title":"status"},{"location":"middlewares/errorpages/#service","text":"The service that will serve the new requested error page. In kubernetes, you need to reference a kubernetes service instead of a traefik service.","title":"service"},{"location":"middlewares/errorpages/#query","text":"The URL for the error page (hosted by service ). You can use {status} in the query, that will be replaced by the received status code.","title":"query"},{"location":"middlewares/forwardauth/","text":"ForwardAuth \u00b6 Using an External Service to Check for Credentials The ForwardAuth middleware delegate the authentication to an external service. If the service response code is 2XX, access is granted and the original request is performed. Otherwise, the response from the authentication server is returned. Configuration Examples \u00b6 Docker # Forward authentication to authserver.com labels: - \"traefik.http.middlewares.test-auth.forwardauth.address=https://authserver.com/auth\" Kubernetes # Forward authentication to authserver.com apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.address\": \"https://authserver.com/auth\" } Rancher # Forward authentication to authserver.com labels: - \"traefik.http.middlewares.test-auth.forwardauth.address=https://authserver.com/auth\" File (TOML) # Forward authentication to authserver.com [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" File (YAML) # Forward authentication to authserver.com http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" Configuration Options \u00b6 address \u00b6 The address option defines the authentication server address. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.address=https://authserver.com/auth\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.address\": \"https://authserver.com/auth\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.address=https://authserver.com/auth\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" trustForwardHeader \u00b6 Set the trustForwardHeader option to true to trust all the existing X-Forwarded-* headers. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.trustForwardHeader=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth trustForwardHeader: true Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.trustForwardHeader\": \"true\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.trustForwardHeader=true\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" trustForwardHeader = true File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" trustForwardHeader: true authResponseHeaders \u00b6 The authResponseHeaders option is the list of the headers to copy from the authentication server to the request. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.authResponseHeaders=X-Auth-User, X-Secret\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth authResponseHeaders: - X-Auth-User - X-Secret Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.authResponseHeaders\": \"X-Auth-User,X-Secret\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.authResponseHeaders=X-Auth-User, X-Secret\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" authResponseHeaders = [\"X-Auth-User\", \"X-Secret\"] File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" authResponseHeaders: - \"X-Auth-User\" - \"X-Secret\" tls \u00b6 The tls option is the TLS configuration from Traefik to the authentication server. tls.ca \u00b6 Certificate Authority used for the secured connection to the authentication server. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.ca=path/to/local.crt\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth tls: caSecret: mycasercret --- apiVersion: v1 kind: Secret metadata: name: mycasercret namespace: default data: ca: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0= Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.tls.ca\": \"path/to/local.crt\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.ca=path/to/local.crt\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" [http.middlewares.test-auth.forwardAuth.tls] ca = \"path/to/local.crt\" File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" tls: ca: \"path/to/local.crt\" tls.caOptional \u00b6 Policy used for the secured connection with TLS Client Authentication to the authentication server. Requires tls.ca to be defined. true : VerifyClientCertIfGiven false : RequireAndVerifyClientCert if tls.ca is undefined NoClientCert Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.caOptional=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth tls: caOptional: true Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.tls.caOptional\": \"true\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.caOptional=true\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" [http.middlewares.test-auth.forwardAuth.tls] caOptional = true File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" tls: caOptional: true tls.cert \u00b6 Public certificate used for the secured connection to the authentication server. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.cert=path/to/foo.cert\" - \"traefik.http.middlewares.test-auth.forwardauth.tls.key=path/to/foo.key\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth tls: certSecret: mytlscert --- apiVersion: v1 kind: Secret metadata: name: mytlscert namespace: default data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0= tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0= Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.tls.cert\": \"path/to/foo.cert\", \"traefik.http.middlewares.test-auth.forwardauth.tls.key\": \"path/to/foo.key\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.cert=path/to/foo.cert\" - \"traefik.http.middlewares.test-auth.forwardauth.tls.key=path/to/foo.key\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" [http.middlewares.test-auth.forwardAuth.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" tls: cert: \"path/to/foo.cert\" key: \"path/to/foo.key\" Info For security reasons, the field doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead. tls.key \u00b6 Private certificate used for the secure connection to the authentication server. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.cert=path/to/foo.cert\" - \"traefik.http.middlewares.test-auth.forwardauth.tls.key=path/to/foo.key\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth tls: certSecret: mytlscert --- apiVersion: v1 kind: Secret metadata: name: mytlscert namespace: default data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0= tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0= Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.tls.cert\": \"path/to/foo.cert\", \"traefik.http.middlewares.test-auth.forwardauth.tls.key\": \"path/to/foo.key\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.cert=path/to/foo.cert\" - \"traefik.http.middlewares.test-auth.forwardauth.tls.key=path/to/foo.key\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" [http.middlewares.test-auth.forwardAuth.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" tls: cert: \"path/to/foo.cert\" key: \"path/to/foo.key\" Info For security reasons, the field doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead. tls.insecureSkipVerify \u00b6 If insecureSkipVerify is true , TLS for the connection to authentication server accepts any certificate presented by the server and any host name in that certificate. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.insecureSkipVerify=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth tls: insecureSkipVerify: true Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.tls.insecureSkipVerify\": \"true\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.InsecureSkipVerify=true\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" [http.middlewares.test-auth.forwardAuth.tls] insecureSkipVerify: true File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" tls: insecureSkipVerify: true","title":"ForwardAuth"},{"location":"middlewares/forwardauth/#forwardauth","text":"Using an External Service to Check for Credentials The ForwardAuth middleware delegate the authentication to an external service. If the service response code is 2XX, access is granted and the original request is performed. Otherwise, the response from the authentication server is returned.","title":"ForwardAuth"},{"location":"middlewares/forwardauth/#configuration-examples","text":"Docker # Forward authentication to authserver.com labels: - \"traefik.http.middlewares.test-auth.forwardauth.address=https://authserver.com/auth\" Kubernetes # Forward authentication to authserver.com apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.address\": \"https://authserver.com/auth\" } Rancher # Forward authentication to authserver.com labels: - \"traefik.http.middlewares.test-auth.forwardauth.address=https://authserver.com/auth\" File (TOML) # Forward authentication to authserver.com [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" File (YAML) # Forward authentication to authserver.com http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\"","title":"Configuration Examples"},{"location":"middlewares/forwardauth/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/forwardauth/#address","text":"The address option defines the authentication server address. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.address=https://authserver.com/auth\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.address\": \"https://authserver.com/auth\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.address=https://authserver.com/auth\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\"","title":"address"},{"location":"middlewares/forwardauth/#trustforwardheader","text":"Set the trustForwardHeader option to true to trust all the existing X-Forwarded-* headers. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.trustForwardHeader=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth trustForwardHeader: true Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.trustForwardHeader\": \"true\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.trustForwardHeader=true\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" trustForwardHeader = true File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" trustForwardHeader: true","title":"trustForwardHeader"},{"location":"middlewares/forwardauth/#authresponseheaders","text":"The authResponseHeaders option is the list of the headers to copy from the authentication server to the request. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.authResponseHeaders=X-Auth-User, X-Secret\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth authResponseHeaders: - X-Auth-User - X-Secret Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.authResponseHeaders\": \"X-Auth-User,X-Secret\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.authResponseHeaders=X-Auth-User, X-Secret\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" authResponseHeaders = [\"X-Auth-User\", \"X-Secret\"] File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" authResponseHeaders: - \"X-Auth-User\" - \"X-Secret\"","title":"authResponseHeaders"},{"location":"middlewares/forwardauth/#tls","text":"The tls option is the TLS configuration from Traefik to the authentication server.","title":"tls"},{"location":"middlewares/forwardauth/#tlsca","text":"Certificate Authority used for the secured connection to the authentication server. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.ca=path/to/local.crt\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth tls: caSecret: mycasercret --- apiVersion: v1 kind: Secret metadata: name: mycasercret namespace: default data: ca: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0= Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.tls.ca\": \"path/to/local.crt\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.ca=path/to/local.crt\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" [http.middlewares.test-auth.forwardAuth.tls] ca = \"path/to/local.crt\" File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" tls: ca: \"path/to/local.crt\"","title":"tls.ca"},{"location":"middlewares/forwardauth/#tlscaoptional","text":"Policy used for the secured connection with TLS Client Authentication to the authentication server. Requires tls.ca to be defined. true : VerifyClientCertIfGiven false : RequireAndVerifyClientCert if tls.ca is undefined NoClientCert Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.caOptional=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth tls: caOptional: true Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.tls.caOptional\": \"true\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.caOptional=true\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" [http.middlewares.test-auth.forwardAuth.tls] caOptional = true File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" tls: caOptional: true","title":"tls.caOptional"},{"location":"middlewares/forwardauth/#tlscert","text":"Public certificate used for the secured connection to the authentication server. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.cert=path/to/foo.cert\" - \"traefik.http.middlewares.test-auth.forwardauth.tls.key=path/to/foo.key\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth tls: certSecret: mytlscert --- apiVersion: v1 kind: Secret metadata: name: mytlscert namespace: default data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0= tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0= Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.tls.cert\": \"path/to/foo.cert\", \"traefik.http.middlewares.test-auth.forwardauth.tls.key\": \"path/to/foo.key\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.cert=path/to/foo.cert\" - \"traefik.http.middlewares.test-auth.forwardauth.tls.key=path/to/foo.key\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" [http.middlewares.test-auth.forwardAuth.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" tls: cert: \"path/to/foo.cert\" key: \"path/to/foo.key\" Info For security reasons, the field doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead.","title":"tls.cert"},{"location":"middlewares/forwardauth/#tlskey","text":"Private certificate used for the secure connection to the authentication server. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.cert=path/to/foo.cert\" - \"traefik.http.middlewares.test-auth.forwardauth.tls.key=path/to/foo.key\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth tls: certSecret: mytlscert --- apiVersion: v1 kind: Secret metadata: name: mytlscert namespace: default data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0= tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0= Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.tls.cert\": \"path/to/foo.cert\", \"traefik.http.middlewares.test-auth.forwardauth.tls.key\": \"path/to/foo.key\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.cert=path/to/foo.cert\" - \"traefik.http.middlewares.test-auth.forwardauth.tls.key=path/to/foo.key\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" [http.middlewares.test-auth.forwardAuth.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" tls: cert: \"path/to/foo.cert\" key: \"path/to/foo.key\" Info For security reasons, the field doesn't exist for Kubernetes IngressRoute, and one should use the secret field instead.","title":"tls.key"},{"location":"middlewares/forwardauth/#tlsinsecureskipverify","text":"If insecureSkipVerify is true , TLS for the connection to authentication server accepts any certificate presented by the server and any host name in that certificate. Docker labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.insecureSkipVerify=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-auth spec: forwardAuth: address: https://authserver.com/auth tls: insecureSkipVerify: true Marathon \"labels\": { \"traefik.http.middlewares.test-auth.forwardauth.tls.insecureSkipVerify\": \"true\" } Rancher labels: - \"traefik.http.middlewares.test-auth.forwardauth.tls.InsecureSkipVerify=true\" File (TOML) [http.middlewares] [http.middlewares.test-auth.forwardAuth] address = \"https://authserver.com/auth\" [http.middlewares.test-auth.forwardAuth.tls] insecureSkipVerify: true File (YAML) http: middlewares: test-auth: forwardAuth: address: \"https://authserver.com/auth\" tls: insecureSkipVerify: true","title":"tls.insecureSkipVerify"},{"location":"middlewares/headers/","text":"Headers \u00b6 Adding Headers to the Request / Response The Headers middleware can manage the requests/responses headers. Configuration Examples \u00b6 Adding Headers to the Request and the Response \u00b6 Add the X-Script-Name header to the proxied request and the X-Custom-Response-Header to the response Docker labels: - \"traefik.http.middlewares.testHeader.headers.customrequestheaders.X-Script-Name=test\" - \"traefik.http.middlewares.testHeader.headers.customresponseheaders.X-Custom-Response-Header=value\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: testHeader spec: headers: customRequestHeaders: X-Script-Name: \"test\" customResponseHeaders: X-Custom-Response-Header: \"value\" Marathon \"labels\": { \"traefik.http.middlewares.testheader.headers.customrequestheaders.X-Script-Name\": \"test\", \"traefik.http.middlewares.testheader.headers.customresponseheaders.X-Custom-Response-Header\": \"value\" } Rancher labels: - \"traefik.http.middlewares.testheader.headers.customrequestheaders.X-Script-Name=test\" - \"traefik.http.middlewares.testheader.headers.customresponseheaders.X-Custom-Response-Header=value\" File (TOML) [http.middlewares] [http.middlewares.testHeader.headers] [http.middlewares.testHeader.headers.customRequestHeaders] X-Script-Name = \"test\" [http.middlewares.testHeader.headers.customResponseHeaders] X-Custom-Response-Header = \"value\" File (YAML) http: middlewares: testHeader: headers: customRequestHeaders: X-Script-Name: \"test\" customResponseHeaders: X-Custom-Response-Header: \"value\" Adding and Removing Headers \u00b6 X-Script-Name header added to the proxied request, the X-Custom-Request-Header header removed from the request, and the X-Custom-Response-Header header removed from the response. Please note that it is not possible to remove headers through the use of labels (Docker, Rancher, Marathon, ...) for now. Docker labels: - \"traefik.http.middlewares.testheader.headers.customrequestheaders.X-Script-Name=test\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: testHeader spec: headers: customRequestHeaders: X-Script-Name: \"test\" # Adds X-Custom-Request-Header: \"\" # Removes customResponseHeaders: X-Custom-Response-Header: \"\" # Removes Marathon \"labels\": { \"traefik.http.middlewares.testheader.headers.customrequestheaders.X-Script-Name\": \"test\", } Rancher labels: - \"traefik.http.middlewares.testheader.headers.customrequestheaders.X-Script-Name=test\" File (TOML) [http.middlewares] [http.middlewares.testHeader.headers] [http.middlewares.testHeader.headers.customRequestHeaders] X-Script-Name = \"test\" # Adds X-Custom-Request-Header = \"\" # Removes [http.middlewares.testHeader.headers.customResponseHeaders] X-Custom-Response-Header = \"\" # Removes File (YAML) http: middlewares: testHeader: headers: customRequestHeaders: X-Script-Name: \"test\" # Adds X-Custom-Request-Header: \"\" # Removes customResponseHeaders: X-Custom-Response-Header: \"\" # Removes Using Security Headers \u00b6 Security related headers (HSTS headers, SSL redirection, Browser XSS filter, etc) can be added and configured in a manner similar to the custom headers above. This functionality allows for some easy security features to quickly be set. Docker labels: - \"traefik.http.middlewares.testHeader.headers.framedeny=true\" - \"traefik.http.middlewares.testHeader.headers.sslredirect=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: testHeader spec: headers: frameDeny: \"true\" sslRedirect: \"true\" Marathon \"labels\": { \"traefik.http.middlewares.testheader.headers.framedeny\": \"true\", \"traefik.http.middlewares.testheader.headers.sslredirect\": \"true\" } Rancher labels: - \"traefik.http.middlewares.testheader.headers.framedeny=true\" - \"traefik.http.middlewares.testheader.headers.sslredirect=true\" File (TOML) [http.middlewares] [http.middlewares.testHeader.headers] frameDeny = true sslRedirect = true File (YAML) http: middlewares: testHeader: headers: frameDeny: true sslRedirect: true CORS Headers \u00b6 CORS (Cross-Origin Resource Sharing) headers can be added and configured in a manner similar to the custom headers above. This functionality allows for more advanced security features to quickly be set. Docker labels: - \"traefik.http.middlewares.testheader.headers.accesscontrolallowmethods=GET,OPTIONS,PUT\" - \"traefik.http.middlewares.testheader.headers.accesscontrolalloworigin=origin-list-or-null\" - \"traefik.http.middlewares.testheader.headers.accesscontrolmaxage=100\" - \"traefik.http.middlewares.testheader.headers.addvaryheader=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: testHeader spec: headers: accessControlAllowMethods: - \"GET\" - \"OPTIONS\" - \"PUT\" accessControlAllowOrigin: \"origin-list-or-null\" accessControlMaxAge: 100 addVaryHeader: \"true\" Marathon \"labels\": { \"traefik.http.middlewares.testheader.headers.accesscontrolallowmethods\": \"GET,OPTIONS,PUT\", \"traefik.http.middlewares.testheader.headers.accesscontrolalloworigin\": \"origin-list-or-null\", \"traefik.http.middlewares.testheader.headers.accesscontrolmaxage\": \"100\", \"traefik.http.middlewares.testheader.headers.addvaryheader\": \"true\" } Rancher labels: - \"traefik.http.middlewares.testheader.headers.accesscontrolallowmethods=GET,OPTIONS,PUT\" - \"traefik.http.middlewares.testheader.headers.accesscontrolalloworigin=origin-list-or-null\" - \"traefik.http.middlewares.testheader.headers.accesscontrolmaxage=100\" - \"traefik.http.middlewares.testheader.headers.addvaryheader=true\" File (TOML) [http.middlewares] [http.middlewares.testHeader.headers] accessControlAllowMethods= [\"GET\", \"OPTIONS\", \"PUT\"] accessControlAllowOrigin = \"origin-list-or-null\" accessControlMaxAge = 100 addVaryHeader = true File (YAML) http: middlewares: testHeader: headers: accessControlAllowMethods: - GET - OPTIONS - PUT accessControlAllowOrigin: \"origin-list-or-null\" accessControlMaxAge: 100 addVaryHeader: true Configuration Options \u00b6 General \u00b6 Warning If the custom header name is the same as one header name of the request or response, it will be replaced. The detailed documentation for the security headers can be found in unrolled/secure . customRequestHeaders \u00b6 The customRequestHeaders option lists the Header names and values to apply to the request. customResponseHeaders \u00b6 The customResponseHeaders option lists the Header names and values to apply to the response. accessControlAllowCredentials \u00b6 The accessControlAllowCredentials indicates whether the request can include user credentials. accessControlAllowHeaders \u00b6 The accessControlAllowHeaders indicates which header field names can be used as part of the request. accessControlAllowMethods \u00b6 The accessControlAllowMethods indicates which methods can be used during requests. accessControlAllowOrigin \u00b6 The accessControlAllowOrigin indicates whether a resource can be shared by returning different values. The three options for this value are: origin-list-or-null * null accessControlExposeHeaders \u00b6 The accessControlExposeHeaders indicates which headers are safe to expose to the api of a CORS API specification. accessControlMaxAge \u00b6 The accessControlMaxAge indicates how long a preflight request can be cached. addVaryHeader \u00b6 The addVaryHeader is used in conjunction with accessControlAllowOrigin to determine whether the vary header should be added or modified to demonstrate that server responses can differ beased on the value of the origin header. allowedHosts \u00b6 The allowedHosts option lists fully qualified domain names that are allowed. hostsProxyHeaders \u00b6 The hostsProxyHeaders option is a set of header keys that may hold a proxied hostname value for the request. sslRedirect \u00b6 The sslRedirect is set to true, then only allow https requests. sslTemporaryRedirect \u00b6 Set the sslTemporaryRedirect to true to force an SSL redirection using a 302 (instead of a 301). sslHost \u00b6 The sslHost option is the host name that is used to redirect http requests to https. sslProxyHeaders \u00b6 The sslProxyHeaders option is set of header keys with associated values that would indicate a valid https request. Useful when using other proxies with header like: \"X-Forwarded-Proto\": \"https\" . sslForceHost \u00b6 Set sslForceHost to true and set SSLHost to forced requests to use SSLHost even the ones that are already using SSL. stsSeconds \u00b6 The stsSeconds is the max-age of the Strict-Transport-Security header. If set to 0, would NOT include the header. stsIncludeSubdomains \u00b6 The stsIncludeSubdomains is set to true, the includeSubDomains directive will be appended to the Strict-Transport-Security header. stsPreload \u00b6 Set stsPreload to true to have the preload flag appended to the Strict-Transport-Security header. forceSTSHeader \u00b6 Set forceSTSHeader to true, to add the STS header even when the connection is HTTP. frameDeny \u00b6 Set frameDeny to true to add the X-Frame-Options header with the value of DENY . customFrameOptionsValue \u00b6 The customFrameOptionsValue allows the X-Frame-Options header value to be set with a custom value. This overrides the FrameDeny option. contentTypeNosniff \u00b6 Set contentTypeNosniff to true to add the X-Content-Type-Options header with the value nosniff . browserXssFilter \u00b6 Set browserXssFilter to true to add the X-XSS-Protection header with the value 1; mode=block . customBrowserXSSValue \u00b6 The customBrowserXssValue option allows the X-XSS-Protection header value to be set with a custom value. This overrides the BrowserXssFilter option. contentSecurityPolicy \u00b6 The contentSecurityPolicy option allows the Content-Security-Policy header value to be set with a custom value. publicKey \u00b6 The publicKey implements HPKP to prevent MITM attacks with forged certificates. referrerPolicy \u00b6 The referrerPolicy allows sites to control when browsers will pass the Referer header to other sites. featurePolicy \u00b6 The featurePolicy allows sites to control browser features. isDevelopment \u00b6 Set isDevelopment to true when developing. The AllowedHosts, SSL, and STS options can cause some unwanted effects. Usually testing happens on http, not https, and on localhost, not your production domain. If you would like your development environment to mimic production with complete Host blocking, SSL redirects, and STS headers, leave this as false.","title":"Headers"},{"location":"middlewares/headers/#headers","text":"Adding Headers to the Request / Response The Headers middleware can manage the requests/responses headers.","title":"Headers"},{"location":"middlewares/headers/#configuration-examples","text":"","title":"Configuration Examples"},{"location":"middlewares/headers/#adding-headers-to-the-request-and-the-response","text":"Add the X-Script-Name header to the proxied request and the X-Custom-Response-Header to the response Docker labels: - \"traefik.http.middlewares.testHeader.headers.customrequestheaders.X-Script-Name=test\" - \"traefik.http.middlewares.testHeader.headers.customresponseheaders.X-Custom-Response-Header=value\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: testHeader spec: headers: customRequestHeaders: X-Script-Name: \"test\" customResponseHeaders: X-Custom-Response-Header: \"value\" Marathon \"labels\": { \"traefik.http.middlewares.testheader.headers.customrequestheaders.X-Script-Name\": \"test\", \"traefik.http.middlewares.testheader.headers.customresponseheaders.X-Custom-Response-Header\": \"value\" } Rancher labels: - \"traefik.http.middlewares.testheader.headers.customrequestheaders.X-Script-Name=test\" - \"traefik.http.middlewares.testheader.headers.customresponseheaders.X-Custom-Response-Header=value\" File (TOML) [http.middlewares] [http.middlewares.testHeader.headers] [http.middlewares.testHeader.headers.customRequestHeaders] X-Script-Name = \"test\" [http.middlewares.testHeader.headers.customResponseHeaders] X-Custom-Response-Header = \"value\" File (YAML) http: middlewares: testHeader: headers: customRequestHeaders: X-Script-Name: \"test\" customResponseHeaders: X-Custom-Response-Header: \"value\"","title":"Adding Headers to the Request and the Response"},{"location":"middlewares/headers/#adding-and-removing-headers","text":"X-Script-Name header added to the proxied request, the X-Custom-Request-Header header removed from the request, and the X-Custom-Response-Header header removed from the response. Please note that it is not possible to remove headers through the use of labels (Docker, Rancher, Marathon, ...) for now. Docker labels: - \"traefik.http.middlewares.testheader.headers.customrequestheaders.X-Script-Name=test\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: testHeader spec: headers: customRequestHeaders: X-Script-Name: \"test\" # Adds X-Custom-Request-Header: \"\" # Removes customResponseHeaders: X-Custom-Response-Header: \"\" # Removes Marathon \"labels\": { \"traefik.http.middlewares.testheader.headers.customrequestheaders.X-Script-Name\": \"test\", } Rancher labels: - \"traefik.http.middlewares.testheader.headers.customrequestheaders.X-Script-Name=test\" File (TOML) [http.middlewares] [http.middlewares.testHeader.headers] [http.middlewares.testHeader.headers.customRequestHeaders] X-Script-Name = \"test\" # Adds X-Custom-Request-Header = \"\" # Removes [http.middlewares.testHeader.headers.customResponseHeaders] X-Custom-Response-Header = \"\" # Removes File (YAML) http: middlewares: testHeader: headers: customRequestHeaders: X-Script-Name: \"test\" # Adds X-Custom-Request-Header: \"\" # Removes customResponseHeaders: X-Custom-Response-Header: \"\" # Removes","title":"Adding and Removing Headers"},{"location":"middlewares/headers/#using-security-headers","text":"Security related headers (HSTS headers, SSL redirection, Browser XSS filter, etc) can be added and configured in a manner similar to the custom headers above. This functionality allows for some easy security features to quickly be set. Docker labels: - \"traefik.http.middlewares.testHeader.headers.framedeny=true\" - \"traefik.http.middlewares.testHeader.headers.sslredirect=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: testHeader spec: headers: frameDeny: \"true\" sslRedirect: \"true\" Marathon \"labels\": { \"traefik.http.middlewares.testheader.headers.framedeny\": \"true\", \"traefik.http.middlewares.testheader.headers.sslredirect\": \"true\" } Rancher labels: - \"traefik.http.middlewares.testheader.headers.framedeny=true\" - \"traefik.http.middlewares.testheader.headers.sslredirect=true\" File (TOML) [http.middlewares] [http.middlewares.testHeader.headers] frameDeny = true sslRedirect = true File (YAML) http: middlewares: testHeader: headers: frameDeny: true sslRedirect: true","title":"Using Security Headers"},{"location":"middlewares/headers/#cors-headers","text":"CORS (Cross-Origin Resource Sharing) headers can be added and configured in a manner similar to the custom headers above. This functionality allows for more advanced security features to quickly be set. Docker labels: - \"traefik.http.middlewares.testheader.headers.accesscontrolallowmethods=GET,OPTIONS,PUT\" - \"traefik.http.middlewares.testheader.headers.accesscontrolalloworigin=origin-list-or-null\" - \"traefik.http.middlewares.testheader.headers.accesscontrolmaxage=100\" - \"traefik.http.middlewares.testheader.headers.addvaryheader=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: testHeader spec: headers: accessControlAllowMethods: - \"GET\" - \"OPTIONS\" - \"PUT\" accessControlAllowOrigin: \"origin-list-or-null\" accessControlMaxAge: 100 addVaryHeader: \"true\" Marathon \"labels\": { \"traefik.http.middlewares.testheader.headers.accesscontrolallowmethods\": \"GET,OPTIONS,PUT\", \"traefik.http.middlewares.testheader.headers.accesscontrolalloworigin\": \"origin-list-or-null\", \"traefik.http.middlewares.testheader.headers.accesscontrolmaxage\": \"100\", \"traefik.http.middlewares.testheader.headers.addvaryheader\": \"true\" } Rancher labels: - \"traefik.http.middlewares.testheader.headers.accesscontrolallowmethods=GET,OPTIONS,PUT\" - \"traefik.http.middlewares.testheader.headers.accesscontrolalloworigin=origin-list-or-null\" - \"traefik.http.middlewares.testheader.headers.accesscontrolmaxage=100\" - \"traefik.http.middlewares.testheader.headers.addvaryheader=true\" File (TOML) [http.middlewares] [http.middlewares.testHeader.headers] accessControlAllowMethods= [\"GET\", \"OPTIONS\", \"PUT\"] accessControlAllowOrigin = \"origin-list-or-null\" accessControlMaxAge = 100 addVaryHeader = true File (YAML) http: middlewares: testHeader: headers: accessControlAllowMethods: - GET - OPTIONS - PUT accessControlAllowOrigin: \"origin-list-or-null\" accessControlMaxAge: 100 addVaryHeader: true","title":"CORS Headers"},{"location":"middlewares/headers/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/headers/#general","text":"Warning If the custom header name is the same as one header name of the request or response, it will be replaced. The detailed documentation for the security headers can be found in unrolled/secure .","title":"General"},{"location":"middlewares/headers/#customrequestheaders","text":"The customRequestHeaders option lists the Header names and values to apply to the request.","title":"customRequestHeaders"},{"location":"middlewares/headers/#customresponseheaders","text":"The customResponseHeaders option lists the Header names and values to apply to the response.","title":"customResponseHeaders"},{"location":"middlewares/headers/#accesscontrolallowcredentials","text":"The accessControlAllowCredentials indicates whether the request can include user credentials.","title":"accessControlAllowCredentials"},{"location":"middlewares/headers/#accesscontrolallowheaders","text":"The accessControlAllowHeaders indicates which header field names can be used as part of the request.","title":"accessControlAllowHeaders"},{"location":"middlewares/headers/#accesscontrolallowmethods","text":"The accessControlAllowMethods indicates which methods can be used during requests.","title":"accessControlAllowMethods"},{"location":"middlewares/headers/#accesscontrolalloworigin","text":"The accessControlAllowOrigin indicates whether a resource can be shared by returning different values. The three options for this value are: origin-list-or-null * null","title":"accessControlAllowOrigin"},{"location":"middlewares/headers/#accesscontrolexposeheaders","text":"The accessControlExposeHeaders indicates which headers are safe to expose to the api of a CORS API specification.","title":"accessControlExposeHeaders"},{"location":"middlewares/headers/#accesscontrolmaxage","text":"The accessControlMaxAge indicates how long a preflight request can be cached.","title":"accessControlMaxAge"},{"location":"middlewares/headers/#addvaryheader","text":"The addVaryHeader is used in conjunction with accessControlAllowOrigin to determine whether the vary header should be added or modified to demonstrate that server responses can differ beased on the value of the origin header.","title":"addVaryHeader"},{"location":"middlewares/headers/#allowedhosts","text":"The allowedHosts option lists fully qualified domain names that are allowed.","title":"allowedHosts"},{"location":"middlewares/headers/#hostsproxyheaders","text":"The hostsProxyHeaders option is a set of header keys that may hold a proxied hostname value for the request.","title":"hostsProxyHeaders"},{"location":"middlewares/headers/#sslredirect","text":"The sslRedirect is set to true, then only allow https requests.","title":"sslRedirect"},{"location":"middlewares/headers/#ssltemporaryredirect","text":"Set the sslTemporaryRedirect to true to force an SSL redirection using a 302 (instead of a 301).","title":"sslTemporaryRedirect"},{"location":"middlewares/headers/#sslhost","text":"The sslHost option is the host name that is used to redirect http requests to https.","title":"sslHost"},{"location":"middlewares/headers/#sslproxyheaders","text":"The sslProxyHeaders option is set of header keys with associated values that would indicate a valid https request. Useful when using other proxies with header like: \"X-Forwarded-Proto\": \"https\" .","title":"sslProxyHeaders"},{"location":"middlewares/headers/#sslforcehost","text":"Set sslForceHost to true and set SSLHost to forced requests to use SSLHost even the ones that are already using SSL.","title":"sslForceHost"},{"location":"middlewares/headers/#stsseconds","text":"The stsSeconds is the max-age of the Strict-Transport-Security header. If set to 0, would NOT include the header.","title":"stsSeconds"},{"location":"middlewares/headers/#stsincludesubdomains","text":"The stsIncludeSubdomains is set to true, the includeSubDomains directive will be appended to the Strict-Transport-Security header.","title":"stsIncludeSubdomains"},{"location":"middlewares/headers/#stspreload","text":"Set stsPreload to true to have the preload flag appended to the Strict-Transport-Security header.","title":"stsPreload"},{"location":"middlewares/headers/#forcestsheader","text":"Set forceSTSHeader to true, to add the STS header even when the connection is HTTP.","title":"forceSTSHeader"},{"location":"middlewares/headers/#framedeny","text":"Set frameDeny to true to add the X-Frame-Options header with the value of DENY .","title":"frameDeny"},{"location":"middlewares/headers/#customframeoptionsvalue","text":"The customFrameOptionsValue allows the X-Frame-Options header value to be set with a custom value. This overrides the FrameDeny option.","title":"customFrameOptionsValue"},{"location":"middlewares/headers/#contenttypenosniff","text":"Set contentTypeNosniff to true to add the X-Content-Type-Options header with the value nosniff .","title":"contentTypeNosniff"},{"location":"middlewares/headers/#browserxssfilter","text":"Set browserXssFilter to true to add the X-XSS-Protection header with the value 1; mode=block .","title":"browserXssFilter"},{"location":"middlewares/headers/#custombrowserxssvalue","text":"The customBrowserXssValue option allows the X-XSS-Protection header value to be set with a custom value. This overrides the BrowserXssFilter option.","title":"customBrowserXSSValue"},{"location":"middlewares/headers/#contentsecuritypolicy","text":"The contentSecurityPolicy option allows the Content-Security-Policy header value to be set with a custom value.","title":"contentSecurityPolicy"},{"location":"middlewares/headers/#publickey","text":"The publicKey implements HPKP to prevent MITM attacks with forged certificates.","title":"publicKey"},{"location":"middlewares/headers/#referrerpolicy","text":"The referrerPolicy allows sites to control when browsers will pass the Referer header to other sites.","title":"referrerPolicy"},{"location":"middlewares/headers/#featurepolicy","text":"The featurePolicy allows sites to control browser features.","title":"featurePolicy"},{"location":"middlewares/headers/#isdevelopment","text":"Set isDevelopment to true when developing. The AllowedHosts, SSL, and STS options can cause some unwanted effects. Usually testing happens on http, not https, and on localhost, not your production domain. If you would like your development environment to mimic production with complete Host blocking, SSL redirects, and STS headers, leave this as false.","title":"isDevelopment"},{"location":"middlewares/inflightreq/","text":"InFlightReq \u00b6 Limiting the Number of Simultaneous In-Flight Requests To proactively prevent services from being overwhelmed with high load, a limit on the number of simultaneous in-flight requests can be applied. Configuration Examples \u00b6 Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.amount=10\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: amount: 10 Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.amount\": \"10\" } Rancher # Limiting to 10 simultaneous connections labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.amount=10\" File (TOML) # Limiting to 10 simultaneous connections [http.middlewares] [http.middlewares.test-inflightreq.inFlightReq] amount = 10 File (YAML) # Limiting to 10 simultaneous connections http: middlewares: test-inflightreq: inFlightReq: amount: 10 Configuration Options \u00b6 amount \u00b6 The amount option defines the maximum amount of allowed simultaneous in-flight request. The middleware will return an HTTP 429 Too Many Requests if there are already amount requests in progress (based on the same sourceCriterion strategy). Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.amount=10\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: amount: 10 Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.amount\": \"10\" } Rancher # Limiting to 10 simultaneous connections labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.amount=10\" File (TOML) # Limiting to 10 simultaneous connections [http.middlewares] [http.middlewares.test-inflightreq.inFlightReq] amount = 10 File (YAML) # Limiting to 10 simultaneous connections http: middlewares: test-inflightreq: inFlightReq: amount: 10 sourceCriterion \u00b6 SourceCriterion defines what criterion is used to group requests as originating from a common source. The precedence order is ipStrategy , then requestHeaderName , then requestHost . If none are set, the default is to use the requestHost . sourceCriterion.ipStrategy \u00b6 The ipStrategy option defines two parameters that sets how Traefik will determine the client IP: depth , and excludedIPs . ipStrategy.depth \u00b6 The depth option tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right). If depth is greater than the total number of IPs in X-Forwarded-For , then the client IP will be empty. depth is ignored if its value is lesser than or equal to 0. Example of Depth & X-Forwarded-For If depth was equal to 2, and the request X-Forwarded-For header was \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" then the \"real\" client IP would be \"10.0.0.1\" (at depth 4) but the IP used as the criterion would be \"12.0.0.1\" ( depth=2 ). X-Forwarded-For depth clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 1 \"13.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 3 \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 5 \"\" Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.depth=2\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: sourceCriterion: ipStrategy: depth: 2 Rancher labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.depth=2\" Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.depth\": \"2\" } File (TOML) [http.middlewares] [http.middlewares.test-inflightreq.inflightreq] [http.middlewares.test-inflightreq.inFlightReq.sourceCriterion.ipStrategy] depth = 2 File (YAML) http: middlewares: test-inflightreq: inFlightReq: sourceCriterion: ipStrategy: depth: 2 ipStrategy.excludedIPs \u00b6 excludedIPs tells Traefik to scan the X-Forwarded-For header and pick the first IP not in the list. If depth is specified, excludedIPs is ignored. Example of ExcludedIPs & X-Forwarded-For X-Forwarded-For excludedIPs clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"12.0.0.1,13.0.0.1\" \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"10.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,16.0.0.1\" \"13.0.0.1\" \"10.0.0.1,11.0.0.1\" \"10.0.0.1,11.0.0.1\" \"\" Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: sourceCriterion: ipStrategy: excludedIPs: - 127.0.0.1/32 - 192.168.1.7 Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.excludedips\": \"127.0.0.1/32, 192.168.1.7\" } Rancher labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" File (TOML) [http.middlewares] [http.middlewares.test-inflightreq.inflightreq] [http.middlewares.test-inflightreq.inFlightReq.sourceCriterion.ipStrategy] excludedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) http: middlewares: test-inflightreq: inFlightReq: sourceCriterion: ipStrategy: excludedIPs: - \"127.0.0.1/32\" - \"192.168.1.7\" sourceCriterion.requestHeaderName \u00b6 Requests having the same value for the given header are grouped as coming from the same source. Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requestheadername=username\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: sourceCriterion: requestHeaderName: username Rancher labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requestheadername=username\" Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requestheadername\": \"username\" } File (TOML) [http.middlewares] [http.middlewares.test-inflightreq.inflightreq] [http.middlewares.test-inflightreq.inFlightReq.sourceCriterion] requestHeaderName = \"username\" File (YAML) http: middlewares: test-inflightreq: inFlightReq: sourceCriterion: requestHeaderName: username sourceCriterion.requestHost \u00b6 Whether to consider the request host as the source. Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requesthost=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: sourceCriterion: requestHost: true Rancher labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requesthost=true\" Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requesthost\": \"true\" } File (TOML) [http.middlewares] [http.middlewares.test-inflightreq.inflightreq] [http.middlewares.test-inflightreq.inFlightReq.sourceCriterion] requestHost = true File (YAML) http: middlewares: test-inflightreq: inFlightReq: sourceCriterion: requestHost: true","title":"InFlightReq"},{"location":"middlewares/inflightreq/#inflightreq","text":"Limiting the Number of Simultaneous In-Flight Requests To proactively prevent services from being overwhelmed with high load, a limit on the number of simultaneous in-flight requests can be applied.","title":"InFlightReq"},{"location":"middlewares/inflightreq/#configuration-examples","text":"Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.amount=10\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: amount: 10 Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.amount\": \"10\" } Rancher # Limiting to 10 simultaneous connections labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.amount=10\" File (TOML) # Limiting to 10 simultaneous connections [http.middlewares] [http.middlewares.test-inflightreq.inFlightReq] amount = 10 File (YAML) # Limiting to 10 simultaneous connections http: middlewares: test-inflightreq: inFlightReq: amount: 10","title":"Configuration Examples"},{"location":"middlewares/inflightreq/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/inflightreq/#amount","text":"The amount option defines the maximum amount of allowed simultaneous in-flight request. The middleware will return an HTTP 429 Too Many Requests if there are already amount requests in progress (based on the same sourceCriterion strategy). Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.amount=10\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: amount: 10 Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.amount\": \"10\" } Rancher # Limiting to 10 simultaneous connections labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.amount=10\" File (TOML) # Limiting to 10 simultaneous connections [http.middlewares] [http.middlewares.test-inflightreq.inFlightReq] amount = 10 File (YAML) # Limiting to 10 simultaneous connections http: middlewares: test-inflightreq: inFlightReq: amount: 10","title":"amount"},{"location":"middlewares/inflightreq/#sourcecriterion","text":"SourceCriterion defines what criterion is used to group requests as originating from a common source. The precedence order is ipStrategy , then requestHeaderName , then requestHost . If none are set, the default is to use the requestHost .","title":"sourceCriterion"},{"location":"middlewares/inflightreq/#sourcecriterionipstrategy","text":"The ipStrategy option defines two parameters that sets how Traefik will determine the client IP: depth , and excludedIPs .","title":"sourceCriterion.ipStrategy"},{"location":"middlewares/inflightreq/#ipstrategydepth","text":"The depth option tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right). If depth is greater than the total number of IPs in X-Forwarded-For , then the client IP will be empty. depth is ignored if its value is lesser than or equal to 0. Example of Depth & X-Forwarded-For If depth was equal to 2, and the request X-Forwarded-For header was \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" then the \"real\" client IP would be \"10.0.0.1\" (at depth 4) but the IP used as the criterion would be \"12.0.0.1\" ( depth=2 ). X-Forwarded-For depth clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 1 \"13.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 3 \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 5 \"\" Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.depth=2\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: sourceCriterion: ipStrategy: depth: 2 Rancher labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.depth=2\" Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.depth\": \"2\" } File (TOML) [http.middlewares] [http.middlewares.test-inflightreq.inflightreq] [http.middlewares.test-inflightreq.inFlightReq.sourceCriterion.ipStrategy] depth = 2 File (YAML) http: middlewares: test-inflightreq: inFlightReq: sourceCriterion: ipStrategy: depth: 2","title":"ipStrategy.depth"},{"location":"middlewares/inflightreq/#ipstrategyexcludedips","text":"excludedIPs tells Traefik to scan the X-Forwarded-For header and pick the first IP not in the list. If depth is specified, excludedIPs is ignored. Example of ExcludedIPs & X-Forwarded-For X-Forwarded-For excludedIPs clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"12.0.0.1,13.0.0.1\" \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"10.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,16.0.0.1\" \"13.0.0.1\" \"10.0.0.1,11.0.0.1\" \"10.0.0.1,11.0.0.1\" \"\" Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: sourceCriterion: ipStrategy: excludedIPs: - 127.0.0.1/32 - 192.168.1.7 Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.excludedips\": \"127.0.0.1/32, 192.168.1.7\" } Rancher labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" File (TOML) [http.middlewares] [http.middlewares.test-inflightreq.inflightreq] [http.middlewares.test-inflightreq.inFlightReq.sourceCriterion.ipStrategy] excludedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) http: middlewares: test-inflightreq: inFlightReq: sourceCriterion: ipStrategy: excludedIPs: - \"127.0.0.1/32\" - \"192.168.1.7\"","title":"ipStrategy.excludedIPs"},{"location":"middlewares/inflightreq/#sourcecriterionrequestheadername","text":"Requests having the same value for the given header are grouped as coming from the same source. Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requestheadername=username\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: sourceCriterion: requestHeaderName: username Rancher labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requestheadername=username\" Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requestheadername\": \"username\" } File (TOML) [http.middlewares] [http.middlewares.test-inflightreq.inflightreq] [http.middlewares.test-inflightreq.inFlightReq.sourceCriterion] requestHeaderName = \"username\" File (YAML) http: middlewares: test-inflightreq: inFlightReq: sourceCriterion: requestHeaderName: username","title":"sourceCriterion.requestHeaderName"},{"location":"middlewares/inflightreq/#sourcecriterionrequesthost","text":"Whether to consider the request host as the source. Docker labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requesthost=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-inflightreq spec: inFlightReq: sourceCriterion: requestHost: true Rancher labels: - \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requesthost=true\" Marathon \"labels\": { \"traefik.http.middlewares.test-inflightreq.inflightreq.sourcecriterion.requesthost\": \"true\" } File (TOML) [http.middlewares] [http.middlewares.test-inflightreq.inflightreq] [http.middlewares.test-inflightreq.inFlightReq.sourceCriterion] requestHost = true File (YAML) http: middlewares: test-inflightreq: inFlightReq: sourceCriterion: requestHost: true","title":"sourceCriterion.requestHost"},{"location":"middlewares/ipwhitelist/","text":"IPWhiteList \u00b6 Limiting Clients to Specific IPs IPWhitelist accepts / refuses requests based on the client IP. Configuration Examples \u00b6 Docker # Accepts request from defined IP labels: - \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.sourcerange=127.0.0.1/32, 192.168.1.7\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ipwhitelist spec: ipWhiteList: sourceRange: - 127.0.0.1/32 - 192.168.1.7 Marathon \"labels\": { \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.sourcerange\": \"127.0.0.1/32,192.168.1.7\" } Rancher # Accepts request from defined IP labels: - \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.sourcerange=127.0.0.1/32, 192.168.1.7\" File (TOML) # Accepts request from defined IP [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] sourceRange = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) # Accepts request from defined IP http: middlewares: test-ipwhitelist: ipWhiteList: sourceRange: - \"127.0.0.1/32\" - \"192.168.1.7\" Configuration Options \u00b6 sourceRange \u00b6 The sourceRange option sets the allowed IPs (or ranges of allowed IPs). ipStrategy \u00b6 The ipStrategy option defines two parameters that sets how Traefik will determine the client IP: depth , and excludedIPs . ipStrategy.depth \u00b6 The depth option tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right). Examples of Depth & X-Forwarded-For Docker # Whitelisting Based on `X-Forwarded-For` with `depth=2` labels: - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.sourcerange=127.0.0.1/32, 192.168.1.7\" - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.ipstrategy.depth=2\" Kubernetes # Whitelisting Based on `X-Forwarded-For` with `depth=2` apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: testIPwhitelist spec: ipWhiteList: sourceRange: - 127.0.0.1/32 - 192.168.1.7 ipStrategy: depth: 2 Rancher # Whitelisting Based on `X-Forwarded-For` with `depth=2` labels: - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.sourcerange=127.0.0.1/32, 192.168.1.7\" - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.ipstrategy.depth=2\" Marathon \"labels\": { \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.sourcerange\": \"127.0.0.1/32, 192.168.1.7\", \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.ipstrategy.depth\": \"2\" } File (TOML) # Whitelisting Based on `X-Forwarded-For` with `depth=2` [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] sourceRange = [\"127.0.0.1/32\", \"192.168.1.7\"] [http.middlewares.test-ipwhitelist.ipWhiteList.ipStrategy] depth = 2 File (YAML) # Whitelisting Based on `X-Forwarded-For` with `depth=2` http: middlewares: test-ipwhitelist: ipWhiteList: sourceRange: - \"127.0.0.1/32\" - \"192.168.1.7\" ipStrategy: depth: 2 If depth was equal to 2, and the request X-Forwarded-For header was \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" then the \"real\" client IP would be \"10.0.0.1\" (at depth 4) but the IP used for the whitelisting would be \"12.0.0.1\" ( depth=2 ). More examples X-Forwarded-For depth clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 1 \"13.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 3 \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 5 \"\" Info If depth is greater than the total number of IPs in X-Forwarded-For , then the client IP will be empty. depth is ignored if its value is lesser than or equal to 0. ipStrategy.excludedIPs \u00b6 Docker # Exclude from `X-Forwarded-For` labels: - \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" Kubernetes # Exclude from `X-Forwarded-For` apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ipwhitelist spec: ipWhiteList: ipStrategy: excludedIPs: - 127.0.0.1/32 - 192.168.1.7 Rancher # Exclude from `X-Forwarded-For` labels: - \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" Marathon \"labels\": { \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.ipstrategy.excludedips\": \"127.0.0.1/32, 192.168.1.7\" } File (TOML) # Exclude from `X-Forwarded-For` [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] [http.middlewares.test-ipwhitelist.ipWhiteList.ipStrategy] excludedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) # Exclude from `X-Forwarded-For` http: middlewares: test-ipwhitelist: ipWhiteList: ipStrategy: excludedIPs: - \"127.0.0.1/32\" - \"192.168.1.7\" excludedIPs tells Traefik to scan the X-Forwarded-For header and pick the first IP not in the list. If depth is specified, excludedIPs is ignored. Examples of ExcludedIPs & X-Forwarded-For X-Forwarded-For excludedIPs clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"12.0.0.1,13.0.0.1\" \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"10.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,16.0.0.1\" \"13.0.0.1\" \"10.0.0.1,11.0.0.1\" \"10.0.0.1,11.0.0.1\" \"\"","title":"IpWhitelist"},{"location":"middlewares/ipwhitelist/#ipwhitelist","text":"Limiting Clients to Specific IPs IPWhitelist accepts / refuses requests based on the client IP.","title":"IPWhiteList"},{"location":"middlewares/ipwhitelist/#configuration-examples","text":"Docker # Accepts request from defined IP labels: - \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.sourcerange=127.0.0.1/32, 192.168.1.7\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ipwhitelist spec: ipWhiteList: sourceRange: - 127.0.0.1/32 - 192.168.1.7 Marathon \"labels\": { \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.sourcerange\": \"127.0.0.1/32,192.168.1.7\" } Rancher # Accepts request from defined IP labels: - \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.sourcerange=127.0.0.1/32, 192.168.1.7\" File (TOML) # Accepts request from defined IP [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] sourceRange = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) # Accepts request from defined IP http: middlewares: test-ipwhitelist: ipWhiteList: sourceRange: - \"127.0.0.1/32\" - \"192.168.1.7\"","title":"Configuration Examples"},{"location":"middlewares/ipwhitelist/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/ipwhitelist/#sourcerange","text":"The sourceRange option sets the allowed IPs (or ranges of allowed IPs).","title":"sourceRange"},{"location":"middlewares/ipwhitelist/#ipstrategy","text":"The ipStrategy option defines two parameters that sets how Traefik will determine the client IP: depth , and excludedIPs .","title":"ipStrategy"},{"location":"middlewares/ipwhitelist/#ipstrategydepth","text":"The depth option tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right). Examples of Depth & X-Forwarded-For Docker # Whitelisting Based on `X-Forwarded-For` with `depth=2` labels: - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.sourcerange=127.0.0.1/32, 192.168.1.7\" - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.ipstrategy.depth=2\" Kubernetes # Whitelisting Based on `X-Forwarded-For` with `depth=2` apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: testIPwhitelist spec: ipWhiteList: sourceRange: - 127.0.0.1/32 - 192.168.1.7 ipStrategy: depth: 2 Rancher # Whitelisting Based on `X-Forwarded-For` with `depth=2` labels: - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.sourcerange=127.0.0.1/32, 192.168.1.7\" - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.ipstrategy.depth=2\" Marathon \"labels\": { \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.sourcerange\": \"127.0.0.1/32, 192.168.1.7\", \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.ipstrategy.depth\": \"2\" } File (TOML) # Whitelisting Based on `X-Forwarded-For` with `depth=2` [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] sourceRange = [\"127.0.0.1/32\", \"192.168.1.7\"] [http.middlewares.test-ipwhitelist.ipWhiteList.ipStrategy] depth = 2 File (YAML) # Whitelisting Based on `X-Forwarded-For` with `depth=2` http: middlewares: test-ipwhitelist: ipWhiteList: sourceRange: - \"127.0.0.1/32\" - \"192.168.1.7\" ipStrategy: depth: 2 If depth was equal to 2, and the request X-Forwarded-For header was \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" then the \"real\" client IP would be \"10.0.0.1\" (at depth 4) but the IP used for the whitelisting would be \"12.0.0.1\" ( depth=2 ). More examples X-Forwarded-For depth clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 1 \"13.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 3 \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 5 \"\" Info If depth is greater than the total number of IPs in X-Forwarded-For , then the client IP will be empty. depth is ignored if its value is lesser than or equal to 0.","title":"ipStrategy.depth"},{"location":"middlewares/ipwhitelist/#ipstrategyexcludedips","text":"Docker # Exclude from `X-Forwarded-For` labels: - \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" Kubernetes # Exclude from `X-Forwarded-For` apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ipwhitelist spec: ipWhiteList: ipStrategy: excludedIPs: - 127.0.0.1/32 - 192.168.1.7 Rancher # Exclude from `X-Forwarded-For` labels: - \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" Marathon \"labels\": { \"traefik.http.middlewares.test-ipwhitelist.ipwhitelist.ipstrategy.excludedips\": \"127.0.0.1/32, 192.168.1.7\" } File (TOML) # Exclude from `X-Forwarded-For` [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] [http.middlewares.test-ipwhitelist.ipWhiteList.ipStrategy] excludedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) # Exclude from `X-Forwarded-For` http: middlewares: test-ipwhitelist: ipWhiteList: ipStrategy: excludedIPs: - \"127.0.0.1/32\" - \"192.168.1.7\" excludedIPs tells Traefik to scan the X-Forwarded-For header and pick the first IP not in the list. If depth is specified, excludedIPs is ignored. Examples of ExcludedIPs & X-Forwarded-For X-Forwarded-For excludedIPs clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"12.0.0.1,13.0.0.1\" \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"10.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,16.0.0.1\" \"13.0.0.1\" \"10.0.0.1,11.0.0.1\" \"10.0.0.1,11.0.0.1\" \"\"","title":"ipStrategy.excludedIPs"},{"location":"middlewares/overview/","text":"Middlewares \u00b6 Tweaking the Request Attached to the routers, pieces of middleware are a mean of tweaking the requests before they are sent to your service (or before the answer from the services are sent to the clients). There are many different available middlewares in Traefik, some can modify the request, the headers, some are in charge of redirections, some add authentication, and so on. Pieces of middleware can be combined in chains to fit every scenario. Configuration Example \u00b6 Docker # As a Docker Label whoami: # A container that exposes an API to show its IP address image: containous/whoami labels: # Create a middleware named `foo-add-prefix` - \"traefik.http.middlewares.foo-add-prefix.addprefix.prefix=/foo\" # Apply the middleware named `foo-add-prefix` to the router named `router1` - \"traefik.http.routers.router1.middlewares=foo-add-prefix@docker\" Kubernetes # As a Kubernetes Traefik IngressRoute apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: stripprefix spec: stripPrefix: prefixes: - /stripit --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroute spec: # more fields... routes: # more fields... middlewares: - name: stripprefix Marathon \"labels\": { \"traefik.http.middlewares.foo-add-prefix.addprefix.prefix\": \"/foo\", \"traefik.http.routers.router1.middlewares\": \"foo-add-prefix@marathon\" } Rancher # As a Rancher Label labels: # Create a middleware named `foo-add-prefix` - \"traefik.http.middlewares.foo-add-prefix.addprefix.prefix=/foo\" # Apply the middleware named `foo-add-prefix` to the router named `router1` - \"traefik.http.routers.router1.middlewares=foo-add-prefix@rancher\" File (TOML) # As TOML Configuration File [http.routers] [http.routers.router1] service = \"myService\" middlewares = [\"foo-add-prefix\"] rule = \"Host(`example.com`)\" [http.middlewares] [http.middlewares.foo-add-prefix.addPrefix] prefix = \"/foo\" [http.services] [http.services.service1] [http.services.service1.loadBalancer] [[http.services.service1.loadBalancer.servers]] url = \"http://127.0.0.1:80\" File (YAML) # As YAML Configuration File http: routers: router1: service: myService middlewares: - \"foo-add-prefix\" rule: \"Host(`example.com`)\" middlewares: foo-add-prefix: addPrefix: prefix: \"/foo\" services: service1: loadBalancer: servers: - url: \"http://127.0.0.1:80\" Provider Namespace \u00b6 When you declare a middleware, it lives in its provider namespace. For example, if you declare a middleware using a Docker label, under the hoods, it will reside in the docker provider namespace. If you use multiple providers and wish to reference a middleware declared in another provider (aka referencing a cross-provider middleware), then you'll have to append to the middleware name, the @ separator, followed by the provider name. <resource-name>@<provider-name> Kubernetes Namespace As Kubernetes also has its own notion of namespace, one should not confuse the \"provider namespace\" with the \"kubernetes namespace\" of a resource when in the context of a cross-provider usage. In this case, since the definition of the middleware is not in kubernetes, specifying a \"kubernetes namespace\" when referring to the resource does not make any sense, and therefore this specification would be ignored even if present. Referencing a Middleware from Another Provider Declaring the add-foo-prefix in the file provider. File (TOML) [http.middlewares] [http.middlewares.add-foo-prefix.addPrefix] prefix = \"/foo\" File (YAML) http: middlewares: add-foo-prefix: addPrefix: prefix: \"/foo\" Using the add-foo-prefix middleware from other providers: Docker your-container: # image: your-docker-image labels: # Attach add-foo-prefix@file middleware (declared in file) - \"traefik.http.routers.my-container.middlewares=add-foo-prefix@file\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutestripprefix spec: entryPoints: - web routes: - match: Host(`bar.com`) kind: Rule services: - name: whoami port: 80 middlewares: - name: add-foo-prefix@file # namespace: bar # A namespace specification such as above is ignored # when the cross-provider syntax is used. Available Middlewares \u00b6 Middleware Purpose Area AddPrefix Add a Path Prefix Path Modifier BasicAuth Basic auth mechanism Security, Authentication Buffering Buffers the request/response Request Lifecycle Chain Combine multiple pieces of middleware Middleware tool CircuitBreaker Stop calling unhealthy services Request Lifecycle Compress Compress the response Content Modifier DigestAuth Adds Digest Authentication Security, Authentication Errors Define custom error pages Request Lifecycle ForwardAuth Authentication delegation Security, Authentication Headers Add / Update headers Security IPWhiteList Limit the allowed client IPs Security, Request lifecycle InFlightReq Limit the number of simultaneous connections Security, Request lifecycle PassTLSClientCert Adding Client Certificates in a Header Security RateLimit Limit the call frequency Security, Request lifecycle RedirectScheme Redirect easily the client elsewhere Request lifecycle RedirectRegex Redirect the client elsewhere Request lifecycle ReplacePath Change the path of the request Path Modifier ReplacePathRegex Change the path of the request Path Modifier Retry Automatically retry the request in case of errors Request lifecycle StripPrefix Change the path of the request Path Modifier StripPrefixRegex Change the path of the request Path Modifier","title":"Overview"},{"location":"middlewares/overview/#middlewares","text":"Tweaking the Request Attached to the routers, pieces of middleware are a mean of tweaking the requests before they are sent to your service (or before the answer from the services are sent to the clients). There are many different available middlewares in Traefik, some can modify the request, the headers, some are in charge of redirections, some add authentication, and so on. Pieces of middleware can be combined in chains to fit every scenario.","title":"Middlewares"},{"location":"middlewares/overview/#configuration-example","text":"Docker # As a Docker Label whoami: # A container that exposes an API to show its IP address image: containous/whoami labels: # Create a middleware named `foo-add-prefix` - \"traefik.http.middlewares.foo-add-prefix.addprefix.prefix=/foo\" # Apply the middleware named `foo-add-prefix` to the router named `router1` - \"traefik.http.routers.router1.middlewares=foo-add-prefix@docker\" Kubernetes # As a Kubernetes Traefik IngressRoute apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: stripprefix spec: stripPrefix: prefixes: - /stripit --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroute spec: # more fields... routes: # more fields... middlewares: - name: stripprefix Marathon \"labels\": { \"traefik.http.middlewares.foo-add-prefix.addprefix.prefix\": \"/foo\", \"traefik.http.routers.router1.middlewares\": \"foo-add-prefix@marathon\" } Rancher # As a Rancher Label labels: # Create a middleware named `foo-add-prefix` - \"traefik.http.middlewares.foo-add-prefix.addprefix.prefix=/foo\" # Apply the middleware named `foo-add-prefix` to the router named `router1` - \"traefik.http.routers.router1.middlewares=foo-add-prefix@rancher\" File (TOML) # As TOML Configuration File [http.routers] [http.routers.router1] service = \"myService\" middlewares = [\"foo-add-prefix\"] rule = \"Host(`example.com`)\" [http.middlewares] [http.middlewares.foo-add-prefix.addPrefix] prefix = \"/foo\" [http.services] [http.services.service1] [http.services.service1.loadBalancer] [[http.services.service1.loadBalancer.servers]] url = \"http://127.0.0.1:80\" File (YAML) # As YAML Configuration File http: routers: router1: service: myService middlewares: - \"foo-add-prefix\" rule: \"Host(`example.com`)\" middlewares: foo-add-prefix: addPrefix: prefix: \"/foo\" services: service1: loadBalancer: servers: - url: \"http://127.0.0.1:80\"","title":"Configuration Example"},{"location":"middlewares/overview/#provider-namespace","text":"When you declare a middleware, it lives in its provider namespace. For example, if you declare a middleware using a Docker label, under the hoods, it will reside in the docker provider namespace. If you use multiple providers and wish to reference a middleware declared in another provider (aka referencing a cross-provider middleware), then you'll have to append to the middleware name, the @ separator, followed by the provider name. <resource-name>@<provider-name> Kubernetes Namespace As Kubernetes also has its own notion of namespace, one should not confuse the \"provider namespace\" with the \"kubernetes namespace\" of a resource when in the context of a cross-provider usage. In this case, since the definition of the middleware is not in kubernetes, specifying a \"kubernetes namespace\" when referring to the resource does not make any sense, and therefore this specification would be ignored even if present. Referencing a Middleware from Another Provider Declaring the add-foo-prefix in the file provider. File (TOML) [http.middlewares] [http.middlewares.add-foo-prefix.addPrefix] prefix = \"/foo\" File (YAML) http: middlewares: add-foo-prefix: addPrefix: prefix: \"/foo\" Using the add-foo-prefix middleware from other providers: Docker your-container: # image: your-docker-image labels: # Attach add-foo-prefix@file middleware (declared in file) - \"traefik.http.routers.my-container.middlewares=add-foo-prefix@file\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutestripprefix spec: entryPoints: - web routes: - match: Host(`bar.com`) kind: Rule services: - name: whoami port: 80 middlewares: - name: add-foo-prefix@file # namespace: bar # A namespace specification such as above is ignored # when the cross-provider syntax is used.","title":"Provider Namespace"},{"location":"middlewares/overview/#available-middlewares","text":"Middleware Purpose Area AddPrefix Add a Path Prefix Path Modifier BasicAuth Basic auth mechanism Security, Authentication Buffering Buffers the request/response Request Lifecycle Chain Combine multiple pieces of middleware Middleware tool CircuitBreaker Stop calling unhealthy services Request Lifecycle Compress Compress the response Content Modifier DigestAuth Adds Digest Authentication Security, Authentication Errors Define custom error pages Request Lifecycle ForwardAuth Authentication delegation Security, Authentication Headers Add / Update headers Security IPWhiteList Limit the allowed client IPs Security, Request lifecycle InFlightReq Limit the number of simultaneous connections Security, Request lifecycle PassTLSClientCert Adding Client Certificates in a Header Security RateLimit Limit the call frequency Security, Request lifecycle RedirectScheme Redirect easily the client elsewhere Request lifecycle RedirectRegex Redirect the client elsewhere Request lifecycle ReplacePath Change the path of the request Path Modifier ReplacePathRegex Change the path of the request Path Modifier Retry Automatically retry the request in case of errors Request lifecycle StripPrefix Change the path of the request Path Modifier StripPrefixRegex Change the path of the request Path Modifier","title":"Available Middlewares"},{"location":"middlewares/passtlsclientcert/","text":"PassTLSClientCert \u00b6 Adding Client Certificates in a Header PassTLSClientCert adds in header the selected data from the passed client tls certificate. Configuration Examples \u00b6 Pass the escaped pem in the X-Forwarded-Tls-Client-Cert header. Docker # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. labels: - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.pem=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: addprefix spec: passTLSClientCert: pem: true Marathon \"labels\": { \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.pem\": \"true\" } Rancher # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. labels: - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.pem=true\" File (TOML) # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. [http.middlewares] [http.middlewares.test-passtlsclientcert.passTLSClientCert] pem = true File (YAML) # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. http: middlewares: test-passtlsclientcert: passTLSClientCert: pem: true Pass the escaped pem in the X-Forwarded-Tls-Client-Cert header Docker # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header labels: - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notafter=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notbefore=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.sans=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.serialnumber=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.serialnumber=true\" Kubernetes # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-passtlsclientcert spec: passTLSClientCert: info: notAfter: true notBefore: true sans: true subject: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true issuer: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true Rancher # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header labels: - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notafter=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notbefore=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.sans=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.serialnumber=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.serialnumber=true\" Marathon \"labels\": { \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notafter\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notbefore\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.sans\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.commonname\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.country\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.domaincomponent\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.locality\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.organization\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.province\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.serialnumber\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.commonname\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.country\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.domaincomponent\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.locality\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.organization\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.province\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.serialnumber\": \"true\" } File (TOML) # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header [http.middlewares] [http.middlewares.test-passtlsclientcert.passTLSClientCert] [http.middlewares.test-passtlsclientcert.passTLSClientCert.info] notAfter = true notBefore = true sans = true [http.middlewares.test-passtlsclientcert.passTLSClientCert.info.subject] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.test-passtlsclientcert.passTLSClientCert.info.issuer] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true File (YAML) # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header http: middlewares: test-passtlsclientcert: passTLSClientCert: info: notAfter: true notBefore: true sans: true subject: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true issuer: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true Configuration Options \u00b6 General \u00b6 PassTLSClientCert can add two headers to the request: X-Forwarded-Tls-Client-Cert that contains the escaped pem. X-Forwarded-Tls-Client-Cert-Info that contains all the selected certificate information in an escaped string. Info The headers are filled with escaped string so it can be safely placed inside a URL query. These options only work accordingly to the MutualTLS configuration . That is to say, only the certificates that match the clientAuth.clientAuthType policy are passed. In the following example, you can see a complete certificate. We will use each part of it to explain the middleware options. A complete client tls certificate Certificate: Data: Version: 3 (0x2) Serial Number: 1 (0x1) Signature Algorithm: sha1WithRSAEncryption Issuer: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=Simple Signing CA, CN=Simple Signing CA 2, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Signing State, ST=Signing State 2/emailAddress=simple@signing.com/emailAddress=simple2@signing.com Validity Not Before: Dec 6 11:10:16 2018 GMT Not After : Dec 5 11:10:16 2020 GMT Subject: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=*.cheese.org, CN=*.cheese.com, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Cheese org state, ST=Cheese com state/emailAddress=cert@cheese.org/emailAddress=cert@scheese.com Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:de:77:fa:8d:03:70:30:39:dd:51:1b:cc:60:db: a9:5a:13:b1:af:fe:2c:c6:38:9b:88:0a:0f:8e:d9: 1b:a1:1d:af:0d:66:e4:13:5b:bc:5d:36:92:d7:5e: d0:fa:88:29:d3:78:e1:81:de:98:b2:a9:22:3f:bf: 8a:af:12:92:63:d4:a9:c3:f2:e4:7e:d2:dc:a2:c5: 39:1c:7a:eb:d7:12:70:63:2e:41:47:e0:f0:08:e8: dc:be:09:01:ec:28:09:af:35:d7:79:9c:50:35:d1: 6b:e5:87:7b:34:f6:d2:31:65:1d:18:42:69:6c:04: 11:83:fe:44:ae:90:92:2d:0b:75:39:57:62:e6:17: 2f:47:2b:c7:53:dd:10:2d:c9:e3:06:13:d2:b9:ba: 63:2e:3c:7d:83:6b:d6:89:c9:cc:9d:4d:bf:9f:e8: a3:7b:da:c8:99:2b:ba:66:d6:8e:f8:41:41:a0:c9: d0:5e:c8:11:a4:55:4a:93:83:87:63:04:63:41:9c: fb:68:04:67:c2:71:2f:f2:65:1d:02:5d:15:db:2c: d9:04:69:85:c2:7d:0d:ea:3b:ac:85:f8:d4:8f:0f: c5:70:b2:45:e1:ec:b2:54:0b:e9:f7:82:b4:9b:1b: 2d:b9:25:d4:ab:ca:8f:5b:44:3e:15:dd:b8:7f:b7: ee:f9 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Key Usage: critical Digital Signature, Key Encipherment X509v3 Basic Constraints: CA:FALSE X509v3 Extended Key Usage: TLS Web Server Authentication, TLS Web Client Authentication X509v3 Subject Key Identifier: 94:BA:73:78:A2:87:FB:58:28:28:CF:98:3B:C2:45:70:16:6E:29:2F X509v3 Authority Key Identifier: keyid:1E:52:A2:E8:54:D5:37:EB:D5:A8:1D:E4:C2:04:1D:37:E2:F7:70:03 X509v3 Subject Alternative Name: DNS:*.cheese.org, DNS:*.cheese.net, DNS:*.cheese.com, IP Address:10.0.1.0, IP Address:10.0.1.2, email:test@cheese.org, email:test@cheese.net Signature Algorithm: sha1WithRSAEncryption 76:6b:05:b0:0e:34:11:b1:83:99:91:dc:ae:1b:e2:08:15:8b: 16:b2:9b:27:1c:02:ac:b5:df:1b:d0:d0:75:a4:2b:2c:5c:65: ed:99:ab:f7:cd:fe:38:3f:c3:9a:22:31:1b:ac:8c:1c:c2:f9: 5d:d4:75:7a:2e:72:c7:85:a9:04:af:9f:2a:cc:d3:96:75:f0: 8e:c7:c6:76:48:ac:45:a4:b9:02:1e:2f:c0:15:c4:07:08:92: cb:27:50:67:a1:c8:05:c5:3a:b3:a6:48:be:eb:d5:59:ab:a2: 1b:95:30:71:13:5b:0a:9a:73:3b:60:cc:10:d0:6a:c7:e5:d7: 8b:2f:f9:2e:98:f2:ff:81:14:24:09:e3:4b:55:57:09:1a:22: 74:f1:f6:40:13:31:43:89:71:0a:96:1a:05:82:1f:83:3a:87: 9b:17:25:ef:5a:55:f2:2d:cd:0d:4d:e4:81:58:b6:e3:8d:09: 62:9a:0c:bd:e4:e5:5c:f0:95:da:cb:c7:34:2c:34:5f:6d:fc: 60:7b:12:5b:86:fd:df:21:89:3b:48:08:30:bf:67:ff:8c:e6: 9b:53:cc:87:36:47:70:40:3b:d9:90:2a:d2:d2:82:c6:9c:f5: d1:d8:e0:e6:fd:aa:2f:95:7e:39:ac:fc:4e:d4:ce:65:b3:ec: c6:98:8a:31 -----BEGIN CERTIFICATE----- MIIGWjCCBUKgAwIBAgIBATANBgkqhkiG9w0BAQUFADCCAYQxEzARBgoJkiaJk/Is ZAEZFgNvcmcxFjAUBgoJkiaJk/IsZAEZFgZjaGVlc2UxDzANBgNVBAoMBkNoZWVz ZTERMA8GA1UECgwIQ2hlZXNlIDIxHzAdBgNVBAsMFlNpbXBsZSBTaWduaW5nIFNl Y3Rpb24xITAfBgNVBAsMGFNpbXBsZSBTaWduaW5nIFNlY3Rpb24gMjEaMBgGA1UE AwwRU2ltcGxlIFNpZ25pbmcgQ0ExHDAaBgNVBAMME1NpbXBsZSBTaWduaW5nIENB IDIxCzAJBgNVBAYTAkZSMQswCQYDVQQGEwJVUzERMA8GA1UEBwwIVE9VTE9VU0Ux DTALBgNVBAcMBExZT04xFjAUBgNVBAgMDVNpZ25pbmcgU3RhdGUxGDAWBgNVBAgM D1NpZ25pbmcgU3RhdGUgMjEhMB8GCSqGSIb3DQEJARYSc2ltcGxlQHNpZ25pbmcu Y29tMSIwIAYJKoZIhvcNAQkBFhNzaW1wbGUyQHNpZ25pbmcuY29tMB4XDTE4MTIw NjExMTAxNloXDTIwMTIwNTExMTAxNlowggF2MRMwEQYKCZImiZPyLGQBGRYDb3Jn MRYwFAYKCZImiZPyLGQBGRYGY2hlZXNlMQ8wDQYDVQQKDAZDaGVlc2UxETAPBgNV BAoMCENoZWVzZSAyMR8wHQYDVQQLDBZTaW1wbGUgU2lnbmluZyBTZWN0aW9uMSEw HwYDVQQLDBhTaW1wbGUgU2lnbmluZyBTZWN0aW9uIDIxFTATBgNVBAMMDCouY2hl ZXNlLm9yZzEVMBMGA1UEAwwMKi5jaGVlc2UuY29tMQswCQYDVQQGEwJGUjELMAkG A1UEBhMCVVMxETAPBgNVBAcMCFRPVUxPVVNFMQ0wCwYDVQQHDARMWU9OMRkwFwYD VQQIDBBDaGVlc2Ugb3JnIHN0YXRlMRkwFwYDVQQIDBBDaGVlc2UgY29tIHN0YXRl MR4wHAYJKoZIhvcNAQkBFg9jZXJ0QGNoZWVzZS5vcmcxHzAdBgkqhkiG9w0BCQEW EGNlcnRAc2NoZWVzZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB AQDed/qNA3AwOd1RG8xg26laE7Gv/izGOJuICg+O2RuhHa8NZuQTW7xdNpLXXtD6 iCnTeOGB3piyqSI/v4qvEpJj1KnD8uR+0tyixTkceuvXEnBjLkFH4PAI6Ny+CQHs KAmvNdd5nFA10Wvlh3s09tIxZR0YQmlsBBGD/kSukJItC3U5V2LmFy9HK8dT3RAt yeMGE9K5umMuPH2Da9aJycydTb+f6KN72siZK7pm1o74QUGgydBeyBGkVUqTg4dj BGNBnPtoBGfCcS/yZR0CXRXbLNkEaYXCfQ3qO6yF+NSPD8VwskXh7LJUC+n3grSb Gy25JdSryo9bRD4V3bh/t+75AgMBAAGjgeAwgd0wDgYDVR0PAQH/BAQDAgWgMAkG A1UdEwQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQW BBSUunN4oof7WCgoz5g7wkVwFm4pLzAfBgNVHSMEGDAWgBQeUqLoVNU369WoHeTC BB034vdwAzBhBgNVHREEWjBYggwqLmNoZWVzZS5vcmeCDCouY2hlZXNlLm5ldIIM Ki5jaGVlc2UuY29thwQKAAEAhwQKAAECgQ90ZXN0QGNoZWVzZS5vcmeBD3Rlc3RA Y2hlZXNlLm5ldDANBgkqhkiG9w0BAQUFAAOCAQEAdmsFsA40EbGDmZHcrhviCBWL FrKbJxwCrLXfG9DQdaQrLFxl7Zmr983+OD/DmiIxG6yMHML5XdR1ei5yx4WpBK+f KszTlnXwjsfGdkisRaS5Ah4vwBXEBwiSyydQZ6HIBcU6s6ZIvuvVWauiG5UwcRNb CppzO2DMENBqx+XXiy/5Lpjy/4EUJAnjS1VXCRoidPH2QBMxQ4lxCpYaBYIfgzqH mxcl71pV8i3NDU3kgVi2440JYpoMveTlXPCV2svHNCw0X238YHsSW4b93yGJO0gI ML9n/4zmm1PMhzZHcEA72ZAq0tKCxpz10djg5v2qL5V+Oaz8TtTOZbPsxpiKMQ== -----END CERTIFICATE----- pem \u00b6 The pem option sets the X-Forwarded-Tls-Client-Cert header with the escape certificate. In the example, it is the part between -----BEGIN CERTIFICATE----- and -----END CERTIFICATE----- delimiters : The data used by the pem option -----BEGIN CERTIFICATE----- MIIGWjCCBUKgAwIBAgIBATANBgkqhkiG9w0BAQUFADCCAYQxEzARBgoJkiaJk/Is ZAEZFgNvcmcxFjAUBgoJkiaJk/IsZAEZFgZjaGVlc2UxDzANBgNVBAoMBkNoZWVz ZTERMA8GA1UECgwIQ2hlZXNlIDIxHzAdBgNVBAsMFlNpbXBsZSBTaWduaW5nIFNl Y3Rpb24xITAfBgNVBAsMGFNpbXBsZSBTaWduaW5nIFNlY3Rpb24gMjEaMBgGA1UE AwwRU2ltcGxlIFNpZ25pbmcgQ0ExHDAaBgNVBAMME1NpbXBsZSBTaWduaW5nIENB IDIxCzAJBgNVBAYTAkZSMQswCQYDVQQGEwJVUzERMA8GA1UEBwwIVE9VTE9VU0Ux DTALBgNVBAcMBExZT04xFjAUBgNVBAgMDVNpZ25pbmcgU3RhdGUxGDAWBgNVBAgM D1NpZ25pbmcgU3RhdGUgMjEhMB8GCSqGSIb3DQEJARYSc2ltcGxlQHNpZ25pbmcu Y29tMSIwIAYJKoZIhvcNAQkBFhNzaW1wbGUyQHNpZ25pbmcuY29tMB4XDTE4MTIw NjExMTAxNloXDTIwMTIwNTExMTAxNlowggF2MRMwEQYKCZImiZPyLGQBGRYDb3Jn MRYwFAYKCZImiZPyLGQBGRYGY2hlZXNlMQ8wDQYDVQQKDAZDaGVlc2UxETAPBgNV BAoMCENoZWVzZSAyMR8wHQYDVQQLDBZTaW1wbGUgU2lnbmluZyBTZWN0aW9uMSEw HwYDVQQLDBhTaW1wbGUgU2lnbmluZyBTZWN0aW9uIDIxFTATBgNVBAMMDCouY2hl ZXNlLm9yZzEVMBMGA1UEAwwMKi5jaGVlc2UuY29tMQswCQYDVQQGEwJGUjELMAkG A1UEBhMCVVMxETAPBgNVBAcMCFRPVUxPVVNFMQ0wCwYDVQQHDARMWU9OMRkwFwYD VQQIDBBDaGVlc2Ugb3JnIHN0YXRlMRkwFwYDVQQIDBBDaGVlc2UgY29tIHN0YXRl MR4wHAYJKoZIhvcNAQkBFg9jZXJ0QGNoZWVzZS5vcmcxHzAdBgkqhkiG9w0BCQEW EGNlcnRAc2NoZWVzZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB AQDed/qNA3AwOd1RG8xg26laE7Gv/izGOJuICg+O2RuhHa8NZuQTW7xdNpLXXtD6 iCnTeOGB3piyqSI/v4qvEpJj1KnD8uR+0tyixTkceuvXEnBjLkFH4PAI6Ny+CQHs KAmvNdd5nFA10Wvlh3s09tIxZR0YQmlsBBGD/kSukJItC3U5V2LmFy9HK8dT3RAt yeMGE9K5umMuPH2Da9aJycydTb+f6KN72siZK7pm1o74QUGgydBeyBGkVUqTg4dj BGNBnPtoBGfCcS/yZR0CXRXbLNkEaYXCfQ3qO6yF+NSPD8VwskXh7LJUC+n3grSb Gy25JdSryo9bRD4V3bh/t+75AgMBAAGjgeAwgd0wDgYDVR0PAQH/BAQDAgWgMAkG A1UdEwQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQW BBSUunN4oof7WCgoz5g7wkVwFm4pLzAfBgNVHSMEGDAWgBQeUqLoVNU369WoHeTC BB034vdwAzBhBgNVHREEWjBYggwqLmNoZWVzZS5vcmeCDCouY2hlZXNlLm5ldIIM Ki5jaGVlc2UuY29thwQKAAEAhwQKAAECgQ90ZXN0QGNoZWVzZS5vcmeBD3Rlc3RA Y2hlZXNlLm5ldDANBgkqhkiG9w0BAQUFAAOCAQEAdmsFsA40EbGDmZHcrhviCBWL FrKbJxwCrLXfG9DQdaQrLFxl7Zmr983+OD/DmiIxG6yMHML5XdR1ei5yx4WpBK+f KszTlnXwjsfGdkisRaS5Ah4vwBXEBwiSyydQZ6HIBcU6s6ZIvuvVWauiG5UwcRNb CppzO2DMENBqx+XXiy/5Lpjy/4EUJAnjS1VXCRoidPH2QBMxQ4lxCpYaBYIfgzqH mxcl71pV8i3NDU3kgVi2440JYpoMveTlXPCV2svHNCw0X238YHsSW4b93yGJO0gI ML9n/4zmm1PMhzZHcEA72ZAq0tKCxpz10djg5v2qL5V+Oaz8TtTOZbPsxpiKMQ== -----END CERTIFICATE----- Extracted data The delimiters and \\n will be removed. If there are more than one certificate, they are separated by a \" , \". X-Forwarded-Tls-Client-Cert value could exceed the web server header size limit The header size limit of web servers is commonly between 4kb and 8kb. You could change the server configuration to allow bigger header or use the info option with the needed field(s). info \u00b6 The info option select the specific client certificate details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The value of the header will be an escaped concatenation of all the selected certificate details. The following example shows an unescaped result that uses all the available fields: Subject=\"DC=org,DC=cheese,C=FR,C=US,ST=Cheese org state,ST=Cheese com state,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=*.cheese.com\";Issuer=\"DC=org,DC=cheese,C=FR,C=US,ST=Signing State,ST=Signing State 2,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=Simple Signing CA 2\";NB=\"1544094616\";NA=\"1607166616\";SAN=\"*.cheese.org,*.cheese.net,*.cheese.com,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2\" Multiple certificates If there are more than one certificate, they are separated by a , . info.notAfter \u00b6 Set the info.notAfter option to true to add the Not After information from the Validity part. The data are taken from the following certificate part: Validity Not After : Dec 5 11:10:16 2020 GMT The escape notAfter info part will be like: NA=\"1607166616\" info.notBefore \u00b6 Set the info.notBefore option to true to add the Not Before information from the Validity part. The data are taken from the following certificate part: Validity Not Before: Dec 6 11:10:16 2018 GMT The escape notBefore info part will be like: NB=\"1544094616\" info.sans \u00b6 Set the info.sans option to true to add the Subject Alternative Name information from the Subject Alternative Name part. The data are taken from the following certificate part: X509v3 Subject Alternative Name: DNS:*.cheese.org, DNS:*.cheese.net, DNS:*.cheese.com, IP Address:10.0.1.0, IP Address:10.0.1.2, email:test@cheese.org, email:test@cheese.net The escape SANs info part will be like: SAN=\"*.cheese.org,*.cheese.net,*.cheese.com,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2\" multiple values All the SANs data are separated by a , . info.subject \u00b6 The info.subject select the specific client certificate subject details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The data are taken from the following certificate part : Subject: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=*.cheese.org, CN=*.cheese.com, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Cheese org state, ST=Cheese com state/emailAddress=cert@cheese.org/emailAddress=cert@scheese.com info.subject.country \u00b6 Set the info.subject.country option to true to add the country information into the subject. The data are taken from the subject part with the C key. The escape country info in the subject part will be like : C=FR,C=US info.subject.province \u00b6 Set the info.subject.province option to true to add the province information into the subject. The data are taken from the subject part with the ST key. The escape province info in the subject part will be like : ST=Cheese org state,ST=Cheese com state info.subject.locality \u00b6 Set the info.subject.locality option to true to add the locality information into the subject. The data are taken from the subject part with the L key. The escape locality info in the subject part will be like : L=TOULOUSE,L=LYON info.subject.organization \u00b6 Set the info.subject.organization option to true to add the organization information into the subject. The data are taken from the subject part with the O key. The escape organization info in the subject part will be like : O=Cheese,O=Cheese 2 info.subject.commonName \u00b6 Set the info.subject.commonName option to true to add the commonName information into the subject. The data are taken from the subject part with the CN key. The escape common name info in the subject part will be like : CN=*.cheese.com info.subject.serialNumber \u00b6 Set the info.subject.serialNumber option to true to add the serialNumber information into the subject. The data are taken from the subject part with the SN key. The escape serial number info in the subject part will be like : SN=1234567890 info.subject.domainComponent \u00b6 Set the info.subject.domainComponent option to true to add the domainComponent information into the subject. The data are taken from the subject part with the DC key. The escape domaincomponent info in the subject part will be like : DC=org,DC=cheese info.issuer \u00b6 The info.issuer select the specific client certificate issuer details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The data are taken from the following certificate part : Issuer: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=Simple Signing CA, CN=Simple Signing CA 2, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Signing State, ST=Signing State 2/emailAddress=simple@signing.com/emailAddress=simple2@signing.com info.issuer.country \u00b6 Set the info.issuer.country option to true to add the country information into the issuer. The data are taken from the issuer part with the C key. The escape country info in the issuer part will be like : C=FR,C=US info.issuer.province \u00b6 Set the info.issuer.province option to true to add the province information into the issuer. The data are taken from the issuer part with the ST key. The escape province info in the issuer part will be like : ST=Signing State,ST=Signing State 2 info.issuer.locality \u00b6 Set the info.issuer.locality option to true to add the locality information into the issuer. The data are taken from the issuer part with the L key. The escape locality info in the issuer part will be like : L=TOULOUSE,L=LYON info.issuer.organization \u00b6 Set the info.issuer.organization option to true to add the organization information into the issuer. The data are taken from the issuer part with the O key. The escape organization info in the issuer part will be like : O=Cheese,O=Cheese 2 info.issuer.commonName \u00b6 Set the info.issuer.commonName option to true to add the commonName information into the issuer. The data are taken from the issuer part with the CN key. The escape common name info in the issuer part will be like : CN=Simple Signing CA 2 info.issuer.serialNumber \u00b6 Set the info.issuer.serialNumber option to true to add the serialNumber information into the issuer. The data are taken from the issuer part with the SN key. The escape serial number info in the issuer part will be like : SN=1234567890 info.issuer.domainComponent \u00b6 Set the info.issuer.domainComponent option to true to add the domainComponent information into the issuer. The data are taken from the issuer part with the DC key. The escape domain component info in the issuer part will be like : DC=org,DC=cheese","title":"PassTLSClientCert"},{"location":"middlewares/passtlsclientcert/#passtlsclientcert","text":"Adding Client Certificates in a Header PassTLSClientCert adds in header the selected data from the passed client tls certificate.","title":"PassTLSClientCert"},{"location":"middlewares/passtlsclientcert/#configuration-examples","text":"Pass the escaped pem in the X-Forwarded-Tls-Client-Cert header. Docker # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. labels: - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.pem=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: addprefix spec: passTLSClientCert: pem: true Marathon \"labels\": { \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.pem\": \"true\" } Rancher # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. labels: - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.pem=true\" File (TOML) # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. [http.middlewares] [http.middlewares.test-passtlsclientcert.passTLSClientCert] pem = true File (YAML) # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. http: middlewares: test-passtlsclientcert: passTLSClientCert: pem: true Pass the escaped pem in the X-Forwarded-Tls-Client-Cert header Docker # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header labels: - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notafter=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notbefore=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.sans=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.serialnumber=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.serialnumber=true\" Kubernetes # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-passtlsclientcert spec: passTLSClientCert: info: notAfter: true notBefore: true sans: true subject: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true issuer: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true Rancher # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header labels: - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notafter=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notbefore=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.sans=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.serialnumber=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.serialnumber=true\" Marathon \"labels\": { \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notafter\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notbefore\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.sans\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.commonname\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.country\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.domaincomponent\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.locality\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.organization\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.province\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.serialnumber\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.commonname\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.country\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.domaincomponent\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.locality\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.organization\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.province\": \"true\", \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.serialnumber\": \"true\" } File (TOML) # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header [http.middlewares] [http.middlewares.test-passtlsclientcert.passTLSClientCert] [http.middlewares.test-passtlsclientcert.passTLSClientCert.info] notAfter = true notBefore = true sans = true [http.middlewares.test-passtlsclientcert.passTLSClientCert.info.subject] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.test-passtlsclientcert.passTLSClientCert.info.issuer] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true File (YAML) # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header http: middlewares: test-passtlsclientcert: passTLSClientCert: info: notAfter: true notBefore: true sans: true subject: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true issuer: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true","title":"Configuration Examples"},{"location":"middlewares/passtlsclientcert/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/passtlsclientcert/#general","text":"PassTLSClientCert can add two headers to the request: X-Forwarded-Tls-Client-Cert that contains the escaped pem. X-Forwarded-Tls-Client-Cert-Info that contains all the selected certificate information in an escaped string. Info The headers are filled with escaped string so it can be safely placed inside a URL query. These options only work accordingly to the MutualTLS configuration . That is to say, only the certificates that match the clientAuth.clientAuthType policy are passed. In the following example, you can see a complete certificate. We will use each part of it to explain the middleware options. A complete client tls certificate Certificate: Data: Version: 3 (0x2) Serial Number: 1 (0x1) Signature Algorithm: sha1WithRSAEncryption Issuer: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=Simple Signing CA, CN=Simple Signing CA 2, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Signing State, ST=Signing State 2/emailAddress=simple@signing.com/emailAddress=simple2@signing.com Validity Not Before: Dec 6 11:10:16 2018 GMT Not After : Dec 5 11:10:16 2020 GMT Subject: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=*.cheese.org, CN=*.cheese.com, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Cheese org state, ST=Cheese com state/emailAddress=cert@cheese.org/emailAddress=cert@scheese.com Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:de:77:fa:8d:03:70:30:39:dd:51:1b:cc:60:db: a9:5a:13:b1:af:fe:2c:c6:38:9b:88:0a:0f:8e:d9: 1b:a1:1d:af:0d:66:e4:13:5b:bc:5d:36:92:d7:5e: d0:fa:88:29:d3:78:e1:81:de:98:b2:a9:22:3f:bf: 8a:af:12:92:63:d4:a9:c3:f2:e4:7e:d2:dc:a2:c5: 39:1c:7a:eb:d7:12:70:63:2e:41:47:e0:f0:08:e8: dc:be:09:01:ec:28:09:af:35:d7:79:9c:50:35:d1: 6b:e5:87:7b:34:f6:d2:31:65:1d:18:42:69:6c:04: 11:83:fe:44:ae:90:92:2d:0b:75:39:57:62:e6:17: 2f:47:2b:c7:53:dd:10:2d:c9:e3:06:13:d2:b9:ba: 63:2e:3c:7d:83:6b:d6:89:c9:cc:9d:4d:bf:9f:e8: a3:7b:da:c8:99:2b:ba:66:d6:8e:f8:41:41:a0:c9: d0:5e:c8:11:a4:55:4a:93:83:87:63:04:63:41:9c: fb:68:04:67:c2:71:2f:f2:65:1d:02:5d:15:db:2c: d9:04:69:85:c2:7d:0d:ea:3b:ac:85:f8:d4:8f:0f: c5:70:b2:45:e1:ec:b2:54:0b:e9:f7:82:b4:9b:1b: 2d:b9:25:d4:ab:ca:8f:5b:44:3e:15:dd:b8:7f:b7: ee:f9 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Key Usage: critical Digital Signature, Key Encipherment X509v3 Basic Constraints: CA:FALSE X509v3 Extended Key Usage: TLS Web Server Authentication, TLS Web Client Authentication X509v3 Subject Key Identifier: 94:BA:73:78:A2:87:FB:58:28:28:CF:98:3B:C2:45:70:16:6E:29:2F X509v3 Authority Key Identifier: keyid:1E:52:A2:E8:54:D5:37:EB:D5:A8:1D:E4:C2:04:1D:37:E2:F7:70:03 X509v3 Subject Alternative Name: DNS:*.cheese.org, DNS:*.cheese.net, DNS:*.cheese.com, IP Address:10.0.1.0, IP Address:10.0.1.2, email:test@cheese.org, email:test@cheese.net Signature Algorithm: sha1WithRSAEncryption 76:6b:05:b0:0e:34:11:b1:83:99:91:dc:ae:1b:e2:08:15:8b: 16:b2:9b:27:1c:02:ac:b5:df:1b:d0:d0:75:a4:2b:2c:5c:65: ed:99:ab:f7:cd:fe:38:3f:c3:9a:22:31:1b:ac:8c:1c:c2:f9: 5d:d4:75:7a:2e:72:c7:85:a9:04:af:9f:2a:cc:d3:96:75:f0: 8e:c7:c6:76:48:ac:45:a4:b9:02:1e:2f:c0:15:c4:07:08:92: cb:27:50:67:a1:c8:05:c5:3a:b3:a6:48:be:eb:d5:59:ab:a2: 1b:95:30:71:13:5b:0a:9a:73:3b:60:cc:10:d0:6a:c7:e5:d7: 8b:2f:f9:2e:98:f2:ff:81:14:24:09:e3:4b:55:57:09:1a:22: 74:f1:f6:40:13:31:43:89:71:0a:96:1a:05:82:1f:83:3a:87: 9b:17:25:ef:5a:55:f2:2d:cd:0d:4d:e4:81:58:b6:e3:8d:09: 62:9a:0c:bd:e4:e5:5c:f0:95:da:cb:c7:34:2c:34:5f:6d:fc: 60:7b:12:5b:86:fd:df:21:89:3b:48:08:30:bf:67:ff:8c:e6: 9b:53:cc:87:36:47:70:40:3b:d9:90:2a:d2:d2:82:c6:9c:f5: d1:d8:e0:e6:fd:aa:2f:95:7e:39:ac:fc:4e:d4:ce:65:b3:ec: c6:98:8a:31 -----BEGIN CERTIFICATE----- MIIGWjCCBUKgAwIBAgIBATANBgkqhkiG9w0BAQUFADCCAYQxEzARBgoJkiaJk/Is ZAEZFgNvcmcxFjAUBgoJkiaJk/IsZAEZFgZjaGVlc2UxDzANBgNVBAoMBkNoZWVz ZTERMA8GA1UECgwIQ2hlZXNlIDIxHzAdBgNVBAsMFlNpbXBsZSBTaWduaW5nIFNl Y3Rpb24xITAfBgNVBAsMGFNpbXBsZSBTaWduaW5nIFNlY3Rpb24gMjEaMBgGA1UE AwwRU2ltcGxlIFNpZ25pbmcgQ0ExHDAaBgNVBAMME1NpbXBsZSBTaWduaW5nIENB IDIxCzAJBgNVBAYTAkZSMQswCQYDVQQGEwJVUzERMA8GA1UEBwwIVE9VTE9VU0Ux DTALBgNVBAcMBExZT04xFjAUBgNVBAgMDVNpZ25pbmcgU3RhdGUxGDAWBgNVBAgM D1NpZ25pbmcgU3RhdGUgMjEhMB8GCSqGSIb3DQEJARYSc2ltcGxlQHNpZ25pbmcu Y29tMSIwIAYJKoZIhvcNAQkBFhNzaW1wbGUyQHNpZ25pbmcuY29tMB4XDTE4MTIw NjExMTAxNloXDTIwMTIwNTExMTAxNlowggF2MRMwEQYKCZImiZPyLGQBGRYDb3Jn MRYwFAYKCZImiZPyLGQBGRYGY2hlZXNlMQ8wDQYDVQQKDAZDaGVlc2UxETAPBgNV BAoMCENoZWVzZSAyMR8wHQYDVQQLDBZTaW1wbGUgU2lnbmluZyBTZWN0aW9uMSEw HwYDVQQLDBhTaW1wbGUgU2lnbmluZyBTZWN0aW9uIDIxFTATBgNVBAMMDCouY2hl ZXNlLm9yZzEVMBMGA1UEAwwMKi5jaGVlc2UuY29tMQswCQYDVQQGEwJGUjELMAkG A1UEBhMCVVMxETAPBgNVBAcMCFRPVUxPVVNFMQ0wCwYDVQQHDARMWU9OMRkwFwYD VQQIDBBDaGVlc2Ugb3JnIHN0YXRlMRkwFwYDVQQIDBBDaGVlc2UgY29tIHN0YXRl MR4wHAYJKoZIhvcNAQkBFg9jZXJ0QGNoZWVzZS5vcmcxHzAdBgkqhkiG9w0BCQEW EGNlcnRAc2NoZWVzZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB AQDed/qNA3AwOd1RG8xg26laE7Gv/izGOJuICg+O2RuhHa8NZuQTW7xdNpLXXtD6 iCnTeOGB3piyqSI/v4qvEpJj1KnD8uR+0tyixTkceuvXEnBjLkFH4PAI6Ny+CQHs KAmvNdd5nFA10Wvlh3s09tIxZR0YQmlsBBGD/kSukJItC3U5V2LmFy9HK8dT3RAt yeMGE9K5umMuPH2Da9aJycydTb+f6KN72siZK7pm1o74QUGgydBeyBGkVUqTg4dj BGNBnPtoBGfCcS/yZR0CXRXbLNkEaYXCfQ3qO6yF+NSPD8VwskXh7LJUC+n3grSb Gy25JdSryo9bRD4V3bh/t+75AgMBAAGjgeAwgd0wDgYDVR0PAQH/BAQDAgWgMAkG A1UdEwQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQW BBSUunN4oof7WCgoz5g7wkVwFm4pLzAfBgNVHSMEGDAWgBQeUqLoVNU369WoHeTC BB034vdwAzBhBgNVHREEWjBYggwqLmNoZWVzZS5vcmeCDCouY2hlZXNlLm5ldIIM Ki5jaGVlc2UuY29thwQKAAEAhwQKAAECgQ90ZXN0QGNoZWVzZS5vcmeBD3Rlc3RA Y2hlZXNlLm5ldDANBgkqhkiG9w0BAQUFAAOCAQEAdmsFsA40EbGDmZHcrhviCBWL FrKbJxwCrLXfG9DQdaQrLFxl7Zmr983+OD/DmiIxG6yMHML5XdR1ei5yx4WpBK+f KszTlnXwjsfGdkisRaS5Ah4vwBXEBwiSyydQZ6HIBcU6s6ZIvuvVWauiG5UwcRNb CppzO2DMENBqx+XXiy/5Lpjy/4EUJAnjS1VXCRoidPH2QBMxQ4lxCpYaBYIfgzqH mxcl71pV8i3NDU3kgVi2440JYpoMveTlXPCV2svHNCw0X238YHsSW4b93yGJO0gI ML9n/4zmm1PMhzZHcEA72ZAq0tKCxpz10djg5v2qL5V+Oaz8TtTOZbPsxpiKMQ== -----END CERTIFICATE-----","title":"General"},{"location":"middlewares/passtlsclientcert/#pem","text":"The pem option sets the X-Forwarded-Tls-Client-Cert header with the escape certificate. In the example, it is the part between -----BEGIN CERTIFICATE----- and -----END CERTIFICATE----- delimiters : The data used by the pem option -----BEGIN CERTIFICATE----- MIIGWjCCBUKgAwIBAgIBATANBgkqhkiG9w0BAQUFADCCAYQxEzARBgoJkiaJk/Is ZAEZFgNvcmcxFjAUBgoJkiaJk/IsZAEZFgZjaGVlc2UxDzANBgNVBAoMBkNoZWVz ZTERMA8GA1UECgwIQ2hlZXNlIDIxHzAdBgNVBAsMFlNpbXBsZSBTaWduaW5nIFNl Y3Rpb24xITAfBgNVBAsMGFNpbXBsZSBTaWduaW5nIFNlY3Rpb24gMjEaMBgGA1UE AwwRU2ltcGxlIFNpZ25pbmcgQ0ExHDAaBgNVBAMME1NpbXBsZSBTaWduaW5nIENB IDIxCzAJBgNVBAYTAkZSMQswCQYDVQQGEwJVUzERMA8GA1UEBwwIVE9VTE9VU0Ux DTALBgNVBAcMBExZT04xFjAUBgNVBAgMDVNpZ25pbmcgU3RhdGUxGDAWBgNVBAgM D1NpZ25pbmcgU3RhdGUgMjEhMB8GCSqGSIb3DQEJARYSc2ltcGxlQHNpZ25pbmcu Y29tMSIwIAYJKoZIhvcNAQkBFhNzaW1wbGUyQHNpZ25pbmcuY29tMB4XDTE4MTIw NjExMTAxNloXDTIwMTIwNTExMTAxNlowggF2MRMwEQYKCZImiZPyLGQBGRYDb3Jn MRYwFAYKCZImiZPyLGQBGRYGY2hlZXNlMQ8wDQYDVQQKDAZDaGVlc2UxETAPBgNV BAoMCENoZWVzZSAyMR8wHQYDVQQLDBZTaW1wbGUgU2lnbmluZyBTZWN0aW9uMSEw HwYDVQQLDBhTaW1wbGUgU2lnbmluZyBTZWN0aW9uIDIxFTATBgNVBAMMDCouY2hl ZXNlLm9yZzEVMBMGA1UEAwwMKi5jaGVlc2UuY29tMQswCQYDVQQGEwJGUjELMAkG A1UEBhMCVVMxETAPBgNVBAcMCFRPVUxPVVNFMQ0wCwYDVQQHDARMWU9OMRkwFwYD VQQIDBBDaGVlc2Ugb3JnIHN0YXRlMRkwFwYDVQQIDBBDaGVlc2UgY29tIHN0YXRl MR4wHAYJKoZIhvcNAQkBFg9jZXJ0QGNoZWVzZS5vcmcxHzAdBgkqhkiG9w0BCQEW EGNlcnRAc2NoZWVzZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB AQDed/qNA3AwOd1RG8xg26laE7Gv/izGOJuICg+O2RuhHa8NZuQTW7xdNpLXXtD6 iCnTeOGB3piyqSI/v4qvEpJj1KnD8uR+0tyixTkceuvXEnBjLkFH4PAI6Ny+CQHs KAmvNdd5nFA10Wvlh3s09tIxZR0YQmlsBBGD/kSukJItC3U5V2LmFy9HK8dT3RAt yeMGE9K5umMuPH2Da9aJycydTb+f6KN72siZK7pm1o74QUGgydBeyBGkVUqTg4dj BGNBnPtoBGfCcS/yZR0CXRXbLNkEaYXCfQ3qO6yF+NSPD8VwskXh7LJUC+n3grSb Gy25JdSryo9bRD4V3bh/t+75AgMBAAGjgeAwgd0wDgYDVR0PAQH/BAQDAgWgMAkG A1UdEwQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQW BBSUunN4oof7WCgoz5g7wkVwFm4pLzAfBgNVHSMEGDAWgBQeUqLoVNU369WoHeTC BB034vdwAzBhBgNVHREEWjBYggwqLmNoZWVzZS5vcmeCDCouY2hlZXNlLm5ldIIM Ki5jaGVlc2UuY29thwQKAAEAhwQKAAECgQ90ZXN0QGNoZWVzZS5vcmeBD3Rlc3RA Y2hlZXNlLm5ldDANBgkqhkiG9w0BAQUFAAOCAQEAdmsFsA40EbGDmZHcrhviCBWL FrKbJxwCrLXfG9DQdaQrLFxl7Zmr983+OD/DmiIxG6yMHML5XdR1ei5yx4WpBK+f KszTlnXwjsfGdkisRaS5Ah4vwBXEBwiSyydQZ6HIBcU6s6ZIvuvVWauiG5UwcRNb CppzO2DMENBqx+XXiy/5Lpjy/4EUJAnjS1VXCRoidPH2QBMxQ4lxCpYaBYIfgzqH mxcl71pV8i3NDU3kgVi2440JYpoMveTlXPCV2svHNCw0X238YHsSW4b93yGJO0gI ML9n/4zmm1PMhzZHcEA72ZAq0tKCxpz10djg5v2qL5V+Oaz8TtTOZbPsxpiKMQ== -----END CERTIFICATE----- Extracted data The delimiters and \\n will be removed. If there are more than one certificate, they are separated by a \" , \". X-Forwarded-Tls-Client-Cert value could exceed the web server header size limit The header size limit of web servers is commonly between 4kb and 8kb. You could change the server configuration to allow bigger header or use the info option with the needed field(s).","title":"pem"},{"location":"middlewares/passtlsclientcert/#info","text":"The info option select the specific client certificate details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The value of the header will be an escaped concatenation of all the selected certificate details. The following example shows an unescaped result that uses all the available fields: Subject=\"DC=org,DC=cheese,C=FR,C=US,ST=Cheese org state,ST=Cheese com state,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=*.cheese.com\";Issuer=\"DC=org,DC=cheese,C=FR,C=US,ST=Signing State,ST=Signing State 2,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=Simple Signing CA 2\";NB=\"1544094616\";NA=\"1607166616\";SAN=\"*.cheese.org,*.cheese.net,*.cheese.com,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2\" Multiple certificates If there are more than one certificate, they are separated by a , .","title":"info"},{"location":"middlewares/passtlsclientcert/#infonotafter","text":"Set the info.notAfter option to true to add the Not After information from the Validity part. The data are taken from the following certificate part: Validity Not After : Dec 5 11:10:16 2020 GMT The escape notAfter info part will be like: NA=\"1607166616\"","title":"info.notAfter"},{"location":"middlewares/passtlsclientcert/#infonotbefore","text":"Set the info.notBefore option to true to add the Not Before information from the Validity part. The data are taken from the following certificate part: Validity Not Before: Dec 6 11:10:16 2018 GMT The escape notBefore info part will be like: NB=\"1544094616\"","title":"info.notBefore"},{"location":"middlewares/passtlsclientcert/#infosans","text":"Set the info.sans option to true to add the Subject Alternative Name information from the Subject Alternative Name part. The data are taken from the following certificate part: X509v3 Subject Alternative Name: DNS:*.cheese.org, DNS:*.cheese.net, DNS:*.cheese.com, IP Address:10.0.1.0, IP Address:10.0.1.2, email:test@cheese.org, email:test@cheese.net The escape SANs info part will be like: SAN=\"*.cheese.org,*.cheese.net,*.cheese.com,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2\" multiple values All the SANs data are separated by a , .","title":"info.sans"},{"location":"middlewares/passtlsclientcert/#infosubject","text":"The info.subject select the specific client certificate subject details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The data are taken from the following certificate part : Subject: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=*.cheese.org, CN=*.cheese.com, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Cheese org state, ST=Cheese com state/emailAddress=cert@cheese.org/emailAddress=cert@scheese.com","title":"info.subject"},{"location":"middlewares/passtlsclientcert/#infosubjectcountry","text":"Set the info.subject.country option to true to add the country information into the subject. The data are taken from the subject part with the C key. The escape country info in the subject part will be like : C=FR,C=US","title":"info.subject.country"},{"location":"middlewares/passtlsclientcert/#infosubjectprovince","text":"Set the info.subject.province option to true to add the province information into the subject. The data are taken from the subject part with the ST key. The escape province info in the subject part will be like : ST=Cheese org state,ST=Cheese com state","title":"info.subject.province"},{"location":"middlewares/passtlsclientcert/#infosubjectlocality","text":"Set the info.subject.locality option to true to add the locality information into the subject. The data are taken from the subject part with the L key. The escape locality info in the subject part will be like : L=TOULOUSE,L=LYON","title":"info.subject.locality"},{"location":"middlewares/passtlsclientcert/#infosubjectorganization","text":"Set the info.subject.organization option to true to add the organization information into the subject. The data are taken from the subject part with the O key. The escape organization info in the subject part will be like : O=Cheese,O=Cheese 2","title":"info.subject.organization"},{"location":"middlewares/passtlsclientcert/#infosubjectcommonname","text":"Set the info.subject.commonName option to true to add the commonName information into the subject. The data are taken from the subject part with the CN key. The escape common name info in the subject part will be like : CN=*.cheese.com","title":"info.subject.commonName"},{"location":"middlewares/passtlsclientcert/#infosubjectserialnumber","text":"Set the info.subject.serialNumber option to true to add the serialNumber information into the subject. The data are taken from the subject part with the SN key. The escape serial number info in the subject part will be like : SN=1234567890","title":"info.subject.serialNumber"},{"location":"middlewares/passtlsclientcert/#infosubjectdomaincomponent","text":"Set the info.subject.domainComponent option to true to add the domainComponent information into the subject. The data are taken from the subject part with the DC key. The escape domaincomponent info in the subject part will be like : DC=org,DC=cheese","title":"info.subject.domainComponent"},{"location":"middlewares/passtlsclientcert/#infoissuer","text":"The info.issuer select the specific client certificate issuer details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The data are taken from the following certificate part : Issuer: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=Simple Signing CA, CN=Simple Signing CA 2, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Signing State, ST=Signing State 2/emailAddress=simple@signing.com/emailAddress=simple2@signing.com","title":"info.issuer"},{"location":"middlewares/passtlsclientcert/#infoissuercountry","text":"Set the info.issuer.country option to true to add the country information into the issuer. The data are taken from the issuer part with the C key. The escape country info in the issuer part will be like : C=FR,C=US","title":"info.issuer.country"},{"location":"middlewares/passtlsclientcert/#infoissuerprovince","text":"Set the info.issuer.province option to true to add the province information into the issuer. The data are taken from the issuer part with the ST key. The escape province info in the issuer part will be like : ST=Signing State,ST=Signing State 2","title":"info.issuer.province"},{"location":"middlewares/passtlsclientcert/#infoissuerlocality","text":"Set the info.issuer.locality option to true to add the locality information into the issuer. The data are taken from the issuer part with the L key. The escape locality info in the issuer part will be like : L=TOULOUSE,L=LYON","title":"info.issuer.locality"},{"location":"middlewares/passtlsclientcert/#infoissuerorganization","text":"Set the info.issuer.organization option to true to add the organization information into the issuer. The data are taken from the issuer part with the O key. The escape organization info in the issuer part will be like : O=Cheese,O=Cheese 2","title":"info.issuer.organization"},{"location":"middlewares/passtlsclientcert/#infoissuercommonname","text":"Set the info.issuer.commonName option to true to add the commonName information into the issuer. The data are taken from the issuer part with the CN key. The escape common name info in the issuer part will be like : CN=Simple Signing CA 2","title":"info.issuer.commonName"},{"location":"middlewares/passtlsclientcert/#infoissuerserialnumber","text":"Set the info.issuer.serialNumber option to true to add the serialNumber information into the issuer. The data are taken from the issuer part with the SN key. The escape serial number info in the issuer part will be like : SN=1234567890","title":"info.issuer.serialNumber"},{"location":"middlewares/passtlsclientcert/#infoissuerdomaincomponent","text":"Set the info.issuer.domainComponent option to true to add the domainComponent information into the issuer. The data are taken from the issuer part with the DC key. The escape domain component info in the issuer part will be like : DC=org,DC=cheese","title":"info.issuer.domainComponent"},{"location":"middlewares/ratelimit/","text":"RateLimit \u00b6 To Control the Number of Requests Going to a Service The RateLimit middleware ensures that services will receive a fair number of requests, and allows you define what is fair. Configuration Example \u00b6 Docker # Here, an average of 100 requests per second is allowed. # In addition, a burst of 50 requests is allowed. labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.average=100\" - \"traefik.http.middlewares.test-ratelimit.ratelimit.burst=50\" Kubernetes # Here, an average of 100 requests per second is allowed. # In addition, a burst of 50 requests is allowed. apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: average: 100 burst: 50 Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.average\": \"100\", \"traefik.http.middlewares.test-ratelimit.ratelimit.burst\": \"50\" } Rancher # Here, an average of 100 requests per second is allowed. # In addition, a burst of 50 requests is allowed. labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.average=100\" - \"traefik.http.middlewares.test-ratelimit.ratelimit.burst=50\" File (TOML) # Here, an average of 100 requests per second is allowed. # In addition, a burst of 50 requests is allowed. [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] average = 100 burst = 50 File (YAML) # Here, an average of 100 requests per second is allowed. # In addition, a burst of 50 requests is allowed. http: middlewares: test-ratelimit: rateLimit: average: 100 burst: 50 Configuration Options \u00b6 average \u00b6 Average is the maximum rate, in requests/s, allowed for the given source. It defaults to 0, which means no rate limiting. Docker labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.average=100\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: average: 100 Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.average\": \"100\", } Rancher labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.average=100\" File (TOML) [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] average = 100 File (YAML) http: middlewares: test-ratelimit: rateLimit: average: 100 burst \u00b6 Burst is the maximum number of requests allowed to go through in the same arbitrarily small period of time. It defaults to 1. Docker labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.burst=100\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: burst: 100 Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.burst\": \"100\", } Rancher labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.burst=100\" File (TOML) [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] burst = 100 File (YAML) http: middlewares: test-ratelimit: rateLimit: burst: 100 sourceCriterion \u00b6 SourceCriterion defines what criterion is used to group requests as originating from a common source. The precedence order is ipStrategy , then requestHeaderName , then requestHost . If none are set, the default is to use the request's remote address field (as an ipStrategy ). sourceCriterion.ipStrategy \u00b6 The ipStrategy option defines two parameters that sets how Traefik will determine the client IP: depth , and excludedIPs . ipStrategy.depth \u00b6 The depth option tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right). If depth is greater than the total number of IPs in X-Forwarded-For , then the client IP will be empty. depth is ignored if its value is lesser than or equal to 0. Example of Depth & X-Forwarded-For If depth was equal to 2, and the request X-Forwarded-For header was \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" then the \"real\" client IP would be \"10.0.0.1\" (at depth 4) but the IP used as the criterion would be \"12.0.0.1\" ( depth=2 ). X-Forwarded-For depth clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 1 \"13.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 3 \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 5 \"\" ipStrategy.excludedIPs \u00b6 Docker labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: sourceCriterion: ipStrategy: excludedIPs: - 127.0.0.1/32 - 192.168.1.7 Rancher labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.ipstrategy.excludedips\": \"127.0.0.1/32, 192.168.1.7\" } File (TOML) [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] [http.middlewares.test-ratelimit.rateLimit.sourceCriterion.ipStrategy] excludedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) http: middlewares: test-ratelimit: rateLimit: sourceCriterion: ipStrategy: excludedIPs: - \"127.0.0.1/32\" - \"192.168.1.7\" excludedIPs tells Traefik to scan the X-Forwarded-For header and pick the first IP not in the list. If depth is specified, excludedIPs is ignored. Example of ExcludedIPs & X-Forwarded-For X-Forwarded-For excludedIPs clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"12.0.0.1,13.0.0.1\" \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"10.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,16.0.0.1\" \"13.0.0.1\" \"10.0.0.1,11.0.0.1\" \"10.0.0.1,11.0.0.1\" \"\" sourceCriterion.requestHeaderName \u00b6 Requests having the same value for the given header are grouped as coming from the same source. Docker labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requestheadername=username\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: sourceCriterion: requestHeaderName: username Rancher labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requestheadername=username\" Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requestheadername\": \"username\" } File (TOML) [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] [http.middlewares.test-ratelimit.rateLimit.sourceCriterion] requestHeaderName = \"username\" File (YAML) http: middlewares: test-ratelimit: rateLimit: sourceCriterion: requestHeaderName: username sourceCriterion.requestHost \u00b6 Whether to consider the request host as the source. Docker labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requesthost=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: sourceCriterion: requestHost: true Rancher labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requesthost=true\" Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requesthost\": \"true\" } File (TOML) [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] [http.middlewares.test-ratelimit.rateLimit.sourceCriterion] requestHost = true File (YAML) http: middlewares: test-ratelimit: rateLimit: sourceCriterion: requestHost: true","title":"RateLimit"},{"location":"middlewares/ratelimit/#ratelimit","text":"To Control the Number of Requests Going to a Service The RateLimit middleware ensures that services will receive a fair number of requests, and allows you define what is fair.","title":"RateLimit"},{"location":"middlewares/ratelimit/#configuration-example","text":"Docker # Here, an average of 100 requests per second is allowed. # In addition, a burst of 50 requests is allowed. labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.average=100\" - \"traefik.http.middlewares.test-ratelimit.ratelimit.burst=50\" Kubernetes # Here, an average of 100 requests per second is allowed. # In addition, a burst of 50 requests is allowed. apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: average: 100 burst: 50 Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.average\": \"100\", \"traefik.http.middlewares.test-ratelimit.ratelimit.burst\": \"50\" } Rancher # Here, an average of 100 requests per second is allowed. # In addition, a burst of 50 requests is allowed. labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.average=100\" - \"traefik.http.middlewares.test-ratelimit.ratelimit.burst=50\" File (TOML) # Here, an average of 100 requests per second is allowed. # In addition, a burst of 50 requests is allowed. [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] average = 100 burst = 50 File (YAML) # Here, an average of 100 requests per second is allowed. # In addition, a burst of 50 requests is allowed. http: middlewares: test-ratelimit: rateLimit: average: 100 burst: 50","title":"Configuration Example"},{"location":"middlewares/ratelimit/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/ratelimit/#average","text":"Average is the maximum rate, in requests/s, allowed for the given source. It defaults to 0, which means no rate limiting. Docker labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.average=100\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: average: 100 Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.average\": \"100\", } Rancher labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.average=100\" File (TOML) [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] average = 100 File (YAML) http: middlewares: test-ratelimit: rateLimit: average: 100","title":"average"},{"location":"middlewares/ratelimit/#burst","text":"Burst is the maximum number of requests allowed to go through in the same arbitrarily small period of time. It defaults to 1. Docker labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.burst=100\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: burst: 100 Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.burst\": \"100\", } Rancher labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.burst=100\" File (TOML) [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] burst = 100 File (YAML) http: middlewares: test-ratelimit: rateLimit: burst: 100","title":"burst"},{"location":"middlewares/ratelimit/#sourcecriterion","text":"SourceCriterion defines what criterion is used to group requests as originating from a common source. The precedence order is ipStrategy , then requestHeaderName , then requestHost . If none are set, the default is to use the request's remote address field (as an ipStrategy ).","title":"sourceCriterion"},{"location":"middlewares/ratelimit/#sourcecriterionipstrategy","text":"The ipStrategy option defines two parameters that sets how Traefik will determine the client IP: depth , and excludedIPs .","title":"sourceCriterion.ipStrategy"},{"location":"middlewares/ratelimit/#ipstrategydepth","text":"The depth option tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right). If depth is greater than the total number of IPs in X-Forwarded-For , then the client IP will be empty. depth is ignored if its value is lesser than or equal to 0. Example of Depth & X-Forwarded-For If depth was equal to 2, and the request X-Forwarded-For header was \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" then the \"real\" client IP would be \"10.0.0.1\" (at depth 4) but the IP used as the criterion would be \"12.0.0.1\" ( depth=2 ). X-Forwarded-For depth clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 1 \"13.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 3 \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 5 \"\"","title":"ipStrategy.depth"},{"location":"middlewares/ratelimit/#ipstrategyexcludedips","text":"Docker labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: sourceCriterion: ipStrategy: excludedIPs: - 127.0.0.1/32 - 192.168.1.7 Rancher labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.ipstrategy.excludedips=127.0.0.1/32, 192.168.1.7\" Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.ipstrategy.excludedips\": \"127.0.0.1/32, 192.168.1.7\" } File (TOML) [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] [http.middlewares.test-ratelimit.rateLimit.sourceCriterion.ipStrategy] excludedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) http: middlewares: test-ratelimit: rateLimit: sourceCriterion: ipStrategy: excludedIPs: - \"127.0.0.1/32\" - \"192.168.1.7\" excludedIPs tells Traefik to scan the X-Forwarded-For header and pick the first IP not in the list. If depth is specified, excludedIPs is ignored. Example of ExcludedIPs & X-Forwarded-For X-Forwarded-For excludedIPs clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"12.0.0.1,13.0.0.1\" \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"10.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,16.0.0.1\" \"13.0.0.1\" \"10.0.0.1,11.0.0.1\" \"10.0.0.1,11.0.0.1\" \"\"","title":"ipStrategy.excludedIPs"},{"location":"middlewares/ratelimit/#sourcecriterionrequestheadername","text":"Requests having the same value for the given header are grouped as coming from the same source. Docker labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requestheadername=username\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: sourceCriterion: requestHeaderName: username Rancher labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requestheadername=username\" Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requestheadername\": \"username\" } File (TOML) [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] [http.middlewares.test-ratelimit.rateLimit.sourceCriterion] requestHeaderName = \"username\" File (YAML) http: middlewares: test-ratelimit: rateLimit: sourceCriterion: requestHeaderName: username","title":"sourceCriterion.requestHeaderName"},{"location":"middlewares/ratelimit/#sourcecriterionrequesthost","text":"Whether to consider the request host as the source. Docker labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requesthost=true\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-ratelimit spec: rateLimit: sourceCriterion: requestHost: true Rancher labels: - \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requesthost=true\" Marathon \"labels\": { \"traefik.http.middlewares.test-ratelimit.ratelimit.sourcecriterion.requesthost\": \"true\" } File (TOML) [http.middlewares] [http.middlewares.test-ratelimit.rateLimit] [http.middlewares.test-ratelimit.rateLimit.sourceCriterion] requestHost = true File (YAML) http: middlewares: test-ratelimit: rateLimit: sourceCriterion: requestHost: true","title":"sourceCriterion.requestHost"},{"location":"middlewares/redirectregex/","text":"RedirectRegex \u00b6 Redirecting the Client to a Different Location RegexRedirect redirect a request from an url to another with regex matching and replacement. Configuration Examples \u00b6 Docker # Redirect with domain replacement # Note: all dollar signs need to be doubled for escaping. labels: - \"traefik.http.middlewares.test-redirectregex.redirectregex.regex=^http://localhost/(.*)\" - \"traefik.http.middlewares.test-redirectregex.redirectregex.replacement=http://mydomain/$${1}\" Kubernetes # Redirect with domain replacement apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-redirectregex spec: redirectRegex: regex: ^http://localhost/(.*) replacement: http://mydomain/${1} Marathon \"labels\": { \"traefik.http.middlewares.test-redirectregex.redirectregex.regex\": \"^http://localhost/(.*)\", \"traefik.http.middlewares.test-redirectregex.redirectregex.replacement\": \"http://mydomain/${1}\" } Rancher # Redirect with domain replacement # Note: all dollar signs need to be doubled for escaping. labels: - \"traefik.http.middlewares.test-redirectregex.redirectregex.regex=^http://localhost/(.*)\" - \"traefik.http.middlewares.test-redirectregex.redirectregex.replacement=http://mydomain/$${1}\" File (TOML) # Redirect with domain replacement [http.middlewares] [http.middlewares.test-redirectregex.redirectRegex] regex = \"^http://localhost/(.*)\" replacement = \"http://mydomain/${1}\" File (YAML) # Redirect with domain replacement http: middlewares: test-redirectregex: redirectRegex: regex: \"^http://localhost/(.*)\" replacement: \"http://mydomain/${1}\" Configuration Options \u00b6 permanent \u00b6 Set the permanent option to true to apply a permanent redirection. regex \u00b6 The regex option is the regular expression to match and capture elements from the request URL. Warning Care should be taken when defining replacement expand variables: $1x is equivalent to ${1x} , not ${1}x (see Regexp.Expand ), so use ${1} syntax. Tip Regular expressions and replacements can be tested using online tools such as Go Playground or the Regex101 . replacement \u00b6 The replacement option defines how to modify the URL to have the new target URL.","title":"RedirectRegex"},{"location":"middlewares/redirectregex/#redirectregex","text":"Redirecting the Client to a Different Location RegexRedirect redirect a request from an url to another with regex matching and replacement.","title":"RedirectRegex"},{"location":"middlewares/redirectregex/#configuration-examples","text":"Docker # Redirect with domain replacement # Note: all dollar signs need to be doubled for escaping. labels: - \"traefik.http.middlewares.test-redirectregex.redirectregex.regex=^http://localhost/(.*)\" - \"traefik.http.middlewares.test-redirectregex.redirectregex.replacement=http://mydomain/$${1}\" Kubernetes # Redirect with domain replacement apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-redirectregex spec: redirectRegex: regex: ^http://localhost/(.*) replacement: http://mydomain/${1} Marathon \"labels\": { \"traefik.http.middlewares.test-redirectregex.redirectregex.regex\": \"^http://localhost/(.*)\", \"traefik.http.middlewares.test-redirectregex.redirectregex.replacement\": \"http://mydomain/${1}\" } Rancher # Redirect with domain replacement # Note: all dollar signs need to be doubled for escaping. labels: - \"traefik.http.middlewares.test-redirectregex.redirectregex.regex=^http://localhost/(.*)\" - \"traefik.http.middlewares.test-redirectregex.redirectregex.replacement=http://mydomain/$${1}\" File (TOML) # Redirect with domain replacement [http.middlewares] [http.middlewares.test-redirectregex.redirectRegex] regex = \"^http://localhost/(.*)\" replacement = \"http://mydomain/${1}\" File (YAML) # Redirect with domain replacement http: middlewares: test-redirectregex: redirectRegex: regex: \"^http://localhost/(.*)\" replacement: \"http://mydomain/${1}\"","title":"Configuration Examples"},{"location":"middlewares/redirectregex/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/redirectregex/#permanent","text":"Set the permanent option to true to apply a permanent redirection.","title":"permanent"},{"location":"middlewares/redirectregex/#regex","text":"The regex option is the regular expression to match and capture elements from the request URL. Warning Care should be taken when defining replacement expand variables: $1x is equivalent to ${1x} , not ${1}x (see Regexp.Expand ), so use ${1} syntax. Tip Regular expressions and replacements can be tested using online tools such as Go Playground or the Regex101 .","title":"regex"},{"location":"middlewares/redirectregex/#replacement","text":"The replacement option defines how to modify the URL to have the new target URL.","title":"replacement"},{"location":"middlewares/redirectscheme/","text":"RedirectScheme \u00b6 Redirecting the Client to a Different Scheme/Port RedirectScheme redirect request from a scheme to another. Configuration Examples \u00b6 Docker # Redirect to https labels: - \"traefik.http.middlewares.test-redirectscheme.redirectscheme.scheme=https\" Kubernetes # Redirect to https apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-redirectscheme spec: redirectScheme: scheme: https Marathon \"labels\": { \"traefik.http.middlewares.test-redirectscheme.redirectscheme.scheme\": \"https\" } Rancher # Redirect to https labels: - \"traefik.http.middlewares.test-redirectscheme.redirectscheme.scheme=https\" File (TOML) # Redirect to https [http.middlewares] [http.middlewares.test-redirectscheme.redirectScheme] scheme = \"https\" File (YAML) # Redirect to https http: middlewares: test-redirectscheme: redirectScheme: scheme: https Configuration Options \u00b6 permanent \u00b6 Set the permanent option to true to apply a permanent redirection. scheme \u00b6 The scheme option defines the scheme of the new url. port \u00b6 The port option defines the port of the new url.","title":"RedirectScheme"},{"location":"middlewares/redirectscheme/#redirectscheme","text":"Redirecting the Client to a Different Scheme/Port RedirectScheme redirect request from a scheme to another.","title":"RedirectScheme"},{"location":"middlewares/redirectscheme/#configuration-examples","text":"Docker # Redirect to https labels: - \"traefik.http.middlewares.test-redirectscheme.redirectscheme.scheme=https\" Kubernetes # Redirect to https apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-redirectscheme spec: redirectScheme: scheme: https Marathon \"labels\": { \"traefik.http.middlewares.test-redirectscheme.redirectscheme.scheme\": \"https\" } Rancher # Redirect to https labels: - \"traefik.http.middlewares.test-redirectscheme.redirectscheme.scheme=https\" File (TOML) # Redirect to https [http.middlewares] [http.middlewares.test-redirectscheme.redirectScheme] scheme = \"https\" File (YAML) # Redirect to https http: middlewares: test-redirectscheme: redirectScheme: scheme: https","title":"Configuration Examples"},{"location":"middlewares/redirectscheme/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/redirectscheme/#permanent","text":"Set the permanent option to true to apply a permanent redirection.","title":"permanent"},{"location":"middlewares/redirectscheme/#scheme","text":"The scheme option defines the scheme of the new url.","title":"scheme"},{"location":"middlewares/redirectscheme/#port","text":"The port option defines the port of the new url.","title":"port"},{"location":"middlewares/replacepath/","text":"ReplacePath \u00b6 Updating the Path Before Forwarding the Request Replace the path of the request url. Configuration Examples \u00b6 Docker # Replace the path by /foo labels: - \"traefik.http.middlewares.test-replacepath.replacepath.path=/foo\" Kubernetes # Replace the path by /foo apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-replacepath spec: replacePath: path: /foo Marathon \"labels\": { \"traefik.http.middlewares.test-replacepath.replacepath.path\": \"/foo\" } Rancher # Replace the path by /foo labels: - \"traefik.http.middlewares.test-replacepath.replacepath.path=/foo\" File (TOML) # Replace the path by /foo [http.middlewares] [http.middlewares.test-replacepath.replacePath] path = \"/foo\" File (YAML) # Replace the path by /foo http: middlewares: test-replacepath: replacePath: path: \"/foo\" Configuration Options \u00b6 General \u00b6 The ReplacePath middleware will: replace the actual path by the specified one. store the original path in a X-Replaced-Path header. path \u00b6 The path option defines the path to use as replacement in the request url.","title":"ReplacePath"},{"location":"middlewares/replacepath/#replacepath","text":"Updating the Path Before Forwarding the Request Replace the path of the request url.","title":"ReplacePath"},{"location":"middlewares/replacepath/#configuration-examples","text":"Docker # Replace the path by /foo labels: - \"traefik.http.middlewares.test-replacepath.replacepath.path=/foo\" Kubernetes # Replace the path by /foo apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-replacepath spec: replacePath: path: /foo Marathon \"labels\": { \"traefik.http.middlewares.test-replacepath.replacepath.path\": \"/foo\" } Rancher # Replace the path by /foo labels: - \"traefik.http.middlewares.test-replacepath.replacepath.path=/foo\" File (TOML) # Replace the path by /foo [http.middlewares] [http.middlewares.test-replacepath.replacePath] path = \"/foo\" File (YAML) # Replace the path by /foo http: middlewares: test-replacepath: replacePath: path: \"/foo\"","title":"Configuration Examples"},{"location":"middlewares/replacepath/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/replacepath/#general","text":"The ReplacePath middleware will: replace the actual path by the specified one. store the original path in a X-Replaced-Path header.","title":"General"},{"location":"middlewares/replacepath/#path","text":"The path option defines the path to use as replacement in the request url.","title":"path"},{"location":"middlewares/replacepathregex/","text":"ReplacePathRegex \u00b6 Updating the Path Before Forwarding the Request (Using a Regex) The ReplaceRegex replace a path from an url to another with regex matching and replacement. Configuration Examples \u00b6 Docker # Replace path with regex labels: - \"traefik.http.middlewares.test-replacepathregex.replacepathregex.regex=^/foo/(.*)\" - \"traefik.http.middlewares.test-replacepathregex.replacepathregex.replacement=/bar/$$1\" Kubernetes # Replace path with regex apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-replacepathregex spec: replacePathRegex: regex: ^/foo/(.*) replacement: /bar/$1 Marathon \"labels\": { \"traefik.http.middlewares.test-replacepathregex.replacepathregex.regex\": \"^/foo/(.*)\", \"traefik.http.middlewares.test-replacepathregex.replacepathregex.replacement\": \"/bar/$1\" } Rancher # Replace path with regex labels: - \"traefik.http.middlewares.test-replacepathregex.replacepathregex.regex=^/foo/(.*)\" - \"traefik.http.middlewares.test-replacepathregex.replacepathregex.replacement=/bar/$1\" File (TOML) # Redirect with domain replacement [http.middlewares] [http.middlewares.test-replacepathregex.replacePathRegex] regex = \"^/foo/(.*)\" replacement = \"/bar/$1\" File (YAML) # Redirect with domain replacement http: middlewares: test-replacepathregex: replacePathRegex: regex: \"^/foo/(.*)\" replacement: \"/bar/$1\" Configuration Options \u00b6 General \u00b6 The ReplacePathRegex middleware will: replace the matching path by the specified one. store the original path in a X-Replaced-Path header. regex \u00b6 The regex option is the regular expression to match and capture the path from the request URL. Warning Care should be taken when defining replacement expand variables: $1x is equivalent to ${1x} , not ${1}x (see Regexp.Expand ), so use ${1} syntax. Tip Regular expressions and replacements can be tested using online tools such as Go Playground or the Regex101 . replacement \u00b6 The replacement option defines how to modify the path to have the new target path.","title":"ReplacePathRegex"},{"location":"middlewares/replacepathregex/#replacepathregex","text":"Updating the Path Before Forwarding the Request (Using a Regex) The ReplaceRegex replace a path from an url to another with regex matching and replacement.","title":"ReplacePathRegex"},{"location":"middlewares/replacepathregex/#configuration-examples","text":"Docker # Replace path with regex labels: - \"traefik.http.middlewares.test-replacepathregex.replacepathregex.regex=^/foo/(.*)\" - \"traefik.http.middlewares.test-replacepathregex.replacepathregex.replacement=/bar/$$1\" Kubernetes # Replace path with regex apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-replacepathregex spec: replacePathRegex: regex: ^/foo/(.*) replacement: /bar/$1 Marathon \"labels\": { \"traefik.http.middlewares.test-replacepathregex.replacepathregex.regex\": \"^/foo/(.*)\", \"traefik.http.middlewares.test-replacepathregex.replacepathregex.replacement\": \"/bar/$1\" } Rancher # Replace path with regex labels: - \"traefik.http.middlewares.test-replacepathregex.replacepathregex.regex=^/foo/(.*)\" - \"traefik.http.middlewares.test-replacepathregex.replacepathregex.replacement=/bar/$1\" File (TOML) # Redirect with domain replacement [http.middlewares] [http.middlewares.test-replacepathregex.replacePathRegex] regex = \"^/foo/(.*)\" replacement = \"/bar/$1\" File (YAML) # Redirect with domain replacement http: middlewares: test-replacepathregex: replacePathRegex: regex: \"^/foo/(.*)\" replacement: \"/bar/$1\"","title":"Configuration Examples"},{"location":"middlewares/replacepathregex/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/replacepathregex/#general","text":"The ReplacePathRegex middleware will: replace the matching path by the specified one. store the original path in a X-Replaced-Path header.","title":"General"},{"location":"middlewares/replacepathregex/#regex","text":"The regex option is the regular expression to match and capture the path from the request URL. Warning Care should be taken when defining replacement expand variables: $1x is equivalent to ${1x} , not ${1}x (see Regexp.Expand ), so use ${1} syntax. Tip Regular expressions and replacements can be tested using online tools such as Go Playground or the Regex101 .","title":"regex"},{"location":"middlewares/replacepathregex/#replacement","text":"The replacement option defines how to modify the path to have the new target path.","title":"replacement"},{"location":"middlewares/retry/","text":"Retry \u00b6 Retrying until it Succeeds The Retry middleware is in charge of reissuing a request a given number of times to a backend server if that server does not reply. To be clear, as soon as the server answers, the middleware stops retrying, regardless of the response status. Configuration Examples \u00b6 Docker # Retry to send request 4 times labels: - \"traefik.http.middlewares.test-retry.retry.attempts=4\" Kubernetes # Retry to send request 4 times apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-retry spec: retry: attempts: 4 Marathon \"labels\": { \"traefik.http.middlewares.test-retry.retry.attempts\": \"4\" } Rancher # Retry to send request 4 times labels: - \"traefik.http.middlewares.test-retry.retry.attempts=4\" File (TOML) # Retry to send request 4 times [http.middlewares] [http.middlewares.test-retry.retry] attempts = 4 File (YAML) # Retry to send request 4 times http: middlewares: test-retry: retry: attempts: 4 Configuration Options \u00b6 attempts \u00b6 mandatory The attempts option defines how many times the request should be retried.","title":"Retry"},{"location":"middlewares/retry/#retry","text":"Retrying until it Succeeds The Retry middleware is in charge of reissuing a request a given number of times to a backend server if that server does not reply. To be clear, as soon as the server answers, the middleware stops retrying, regardless of the response status.","title":"Retry"},{"location":"middlewares/retry/#configuration-examples","text":"Docker # Retry to send request 4 times labels: - \"traefik.http.middlewares.test-retry.retry.attempts=4\" Kubernetes # Retry to send request 4 times apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-retry spec: retry: attempts: 4 Marathon \"labels\": { \"traefik.http.middlewares.test-retry.retry.attempts\": \"4\" } Rancher # Retry to send request 4 times labels: - \"traefik.http.middlewares.test-retry.retry.attempts=4\" File (TOML) # Retry to send request 4 times [http.middlewares] [http.middlewares.test-retry.retry] attempts = 4 File (YAML) # Retry to send request 4 times http: middlewares: test-retry: retry: attempts: 4","title":"Configuration Examples"},{"location":"middlewares/retry/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/retry/#attempts","text":"mandatory The attempts option defines how many times the request should be retried.","title":"attempts"},{"location":"middlewares/stripprefix/","text":"StripPrefix \u00b6 Removing Prefixes From the Path Before Forwarding the Request Remove the specified prefixes from the URL path. Configuration Examples \u00b6 Docker # Strip prefix /foobar and /fiibar labels: - \"traefik.http.middlewares.test-stripprefix.stripprefix.prefixes=/foobar,/fiibar\" Kubernetes # Strip prefix /foobar and /fiibar apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-stripprefix spec: stripPrefix: prefixes: - /foobar - /fiibar Marathon \"labels\": { \"traefik.http.middlewares.test-stripprefix.stripprefix.prefixes\": \"/foobar,/fiibar\" } Rancher # Strip prefix /foobar and /fiibar labels: - \"traefik.http.middlewares.test-stripprefix.stripprefix.prefixes=/foobar,/fiibar\" File (TOML) # Strip prefix /foobar and /fiibar [http.middlewares] [http.middlewares.test-stripprefix.stripPrefix] prefixes = [\"/foobar\", \"/fiibar\"] File (YAML) # Strip prefix /foobar and /fiibar http: middlewares: test-stripprefix: stripPrefix: prefixes: - \"/foobar\" - \"/fiibar\" Configuration Options \u00b6 General \u00b6 The StripPrefix middleware will: strip the matching path prefix. store the matching path prefix in a X-Forwarded-Prefix header. Tip Use a StripPrefix middleware if your backend listens on the root path ( / ) but should be routeable on a specific prefix. prefixes \u00b6 The prefixes option defines the prefixes to strip from the request URL. For instance, /products would match /products but also /products/shoes and /products/shirts . Since the path is stripped prior to forwarding, your backend is expected to listen on / . If your backend is serving assets (e.g., images or Javascript files), chances are it must return properly constructed relative URLs. Continuing on the example, the backend should return /products/shoes/image.png (and not /images.png which Traefik would likely not be able to associate with the same backend). The X-Forwarded-Prefix header can be queried to build such URLs dynamically. forceSlash \u00b6 Optional, Default=true Docker labels: - \"traefik.http.middlewares.example.stripprefix.prefixes=/foobar\" - \"traefik.http.middlewares.example.stripprefix.forceslash=false\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: example spec: stripPrefix: prefixes: - \"/foobar\" forceSlash: false Marathon \"labels\": { \"traefik.http.middlewares.example.stripprefix.prefixes\": \"/foobar\", \"traefik.http.middlewares.example.stripprefix.forceslash\": \"false\" } Rancher labels: - \"traefik.http.middlewares.example.stripprefix.prefixes=/foobar\" - \"traefik.http.middlewares.example.stripprefix.forceSlash=false\" File (TOML) [http.middlewares] [http.middlewares.example.stripPrefix] prefixes = [\"/foobar\"] forceSlash = false File (YAML) http: middlewares: example: stripPrefix: prefixes: - \"/foobar\" forceSlash: false The forceSlash option makes sure that the resulting stripped path is not the empty string, by replacing it with / when necessary. This option was added to keep the initial (non-intuitive) behavior of this middleware, in order to avoid introducing a breaking change. It's recommended to explicitly set forceSlash to false . Behavior examples forceSlash=true Path Prefix to strip Result / / / /foo /foo / /foo/ /foo / /foo/ /foo/ / /bar /foo /bar /foo/bar /foo /bar forceSlash=false Path Prefix to strip Result / / empty /foo /foo empty /foo/ /foo / /foo/ /foo/ empty /bar /foo /bar /foo/bar /foo /bar","title":"StripPrefix"},{"location":"middlewares/stripprefix/#stripprefix","text":"Removing Prefixes From the Path Before Forwarding the Request Remove the specified prefixes from the URL path.","title":"StripPrefix"},{"location":"middlewares/stripprefix/#configuration-examples","text":"Docker # Strip prefix /foobar and /fiibar labels: - \"traefik.http.middlewares.test-stripprefix.stripprefix.prefixes=/foobar,/fiibar\" Kubernetes # Strip prefix /foobar and /fiibar apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-stripprefix spec: stripPrefix: prefixes: - /foobar - /fiibar Marathon \"labels\": { \"traefik.http.middlewares.test-stripprefix.stripprefix.prefixes\": \"/foobar,/fiibar\" } Rancher # Strip prefix /foobar and /fiibar labels: - \"traefik.http.middlewares.test-stripprefix.stripprefix.prefixes=/foobar,/fiibar\" File (TOML) # Strip prefix /foobar and /fiibar [http.middlewares] [http.middlewares.test-stripprefix.stripPrefix] prefixes = [\"/foobar\", \"/fiibar\"] File (YAML) # Strip prefix /foobar and /fiibar http: middlewares: test-stripprefix: stripPrefix: prefixes: - \"/foobar\" - \"/fiibar\"","title":"Configuration Examples"},{"location":"middlewares/stripprefix/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/stripprefix/#general","text":"The StripPrefix middleware will: strip the matching path prefix. store the matching path prefix in a X-Forwarded-Prefix header. Tip Use a StripPrefix middleware if your backend listens on the root path ( / ) but should be routeable on a specific prefix.","title":"General"},{"location":"middlewares/stripprefix/#prefixes","text":"The prefixes option defines the prefixes to strip from the request URL. For instance, /products would match /products but also /products/shoes and /products/shirts . Since the path is stripped prior to forwarding, your backend is expected to listen on / . If your backend is serving assets (e.g., images or Javascript files), chances are it must return properly constructed relative URLs. Continuing on the example, the backend should return /products/shoes/image.png (and not /images.png which Traefik would likely not be able to associate with the same backend). The X-Forwarded-Prefix header can be queried to build such URLs dynamically.","title":"prefixes"},{"location":"middlewares/stripprefix/#forceslash","text":"Optional, Default=true Docker labels: - \"traefik.http.middlewares.example.stripprefix.prefixes=/foobar\" - \"traefik.http.middlewares.example.stripprefix.forceslash=false\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: example spec: stripPrefix: prefixes: - \"/foobar\" forceSlash: false Marathon \"labels\": { \"traefik.http.middlewares.example.stripprefix.prefixes\": \"/foobar\", \"traefik.http.middlewares.example.stripprefix.forceslash\": \"false\" } Rancher labels: - \"traefik.http.middlewares.example.stripprefix.prefixes=/foobar\" - \"traefik.http.middlewares.example.stripprefix.forceSlash=false\" File (TOML) [http.middlewares] [http.middlewares.example.stripPrefix] prefixes = [\"/foobar\"] forceSlash = false File (YAML) http: middlewares: example: stripPrefix: prefixes: - \"/foobar\" forceSlash: false The forceSlash option makes sure that the resulting stripped path is not the empty string, by replacing it with / when necessary. This option was added to keep the initial (non-intuitive) behavior of this middleware, in order to avoid introducing a breaking change. It's recommended to explicitly set forceSlash to false . Behavior examples forceSlash=true Path Prefix to strip Result / / / /foo /foo / /foo/ /foo / /foo/ /foo/ / /bar /foo /bar /foo/bar /foo /bar forceSlash=false Path Prefix to strip Result / / empty /foo /foo empty /foo/ /foo / /foo/ /foo/ empty /bar /foo /bar /foo/bar /foo /bar","title":"forceSlash"},{"location":"middlewares/stripprefixregex/","text":"StripPrefixRegex \u00b6 Removing Prefixes From the Path Before Forwarding the Request (Using a Regex) Remove the matching prefixes from the URL path. Configuration Examples \u00b6 Docker labels: - \"traefik.http.middlewares.test-stripprefixregex.stripprefixregex.regex=/foo/[a-z0-9]+/[0-9]+/\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-stripprefixregex spec: stripPrefixRegex: regex: - \"/foo/[a-z0-9]+/[0-9]+/\" Marathon \"labels\": { \"traefik.http.middlewares.test-stripprefixregex.stripprefixregex.regex\": \"/foo/[a-z0-9]+/[0-9]+/\" } Rancher labels: - \"traefik.http.middlewares.test-stripprefixregex.stripprefixregex.regex=/foo/[a-z0-9]+/[0-9]+/\" File (TOML) [http.middlewares] [http.middlewares.test-stripprefixregex.stripPrefixRegex] regex = [\"/foo/[a-z0-9]+/[0-9]+/\"] File (YAML) http: middlewares: test-stripprefixregex: stripPrefixRegex: regex: - \"/foo/[a-z0-9]+/[0-9]+/\" Configuration Options \u00b6 General \u00b6 The StripPrefixRegex middleware will: strip the matching path prefix. store the matching path prefix in a X-Forwarded-Prefix header. Tip Use a stripPrefixRegex middleware if your backend listens on the root path ( / ) but should be routeable on a specific prefix. regex \u00b6 The regex option is the regular expression to match the path prefix from the request URL. Tip Regular expressions can be tested using online tools such as Go Playground or the Regex101 . For instance, /products would match /products but also /products/shoes and /products/shirts . Since the path is stripped prior to forwarding, your backend is expected to listen on / . If your backend is serving assets (e.g., images or Javascript files), chances are it must return properly constructed relative URLs. Continuing on the example, the backend should return /products/shoes/image.png (and not /images.png which Traefik would likely not be able to associate with the same backend). The X-Forwarded-Prefix header can be queried to build such URLs dynamically.","title":"StripPrefixRegex"},{"location":"middlewares/stripprefixregex/#stripprefixregex","text":"Removing Prefixes From the Path Before Forwarding the Request (Using a Regex) Remove the matching prefixes from the URL path.","title":"StripPrefixRegex"},{"location":"middlewares/stripprefixregex/#configuration-examples","text":"Docker labels: - \"traefik.http.middlewares.test-stripprefixregex.stripprefixregex.regex=/foo/[a-z0-9]+/[0-9]+/\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: test-stripprefixregex spec: stripPrefixRegex: regex: - \"/foo/[a-z0-9]+/[0-9]+/\" Marathon \"labels\": { \"traefik.http.middlewares.test-stripprefixregex.stripprefixregex.regex\": \"/foo/[a-z0-9]+/[0-9]+/\" } Rancher labels: - \"traefik.http.middlewares.test-stripprefixregex.stripprefixregex.regex=/foo/[a-z0-9]+/[0-9]+/\" File (TOML) [http.middlewares] [http.middlewares.test-stripprefixregex.stripPrefixRegex] regex = [\"/foo/[a-z0-9]+/[0-9]+/\"] File (YAML) http: middlewares: test-stripprefixregex: stripPrefixRegex: regex: - \"/foo/[a-z0-9]+/[0-9]+/\"","title":"Configuration Examples"},{"location":"middlewares/stripprefixregex/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/stripprefixregex/#general","text":"The StripPrefixRegex middleware will: strip the matching path prefix. store the matching path prefix in a X-Forwarded-Prefix header. Tip Use a stripPrefixRegex middleware if your backend listens on the root path ( / ) but should be routeable on a specific prefix.","title":"General"},{"location":"middlewares/stripprefixregex/#regex","text":"The regex option is the regular expression to match the path prefix from the request URL. Tip Regular expressions can be tested using online tools such as Go Playground or the Regex101 . For instance, /products would match /products but also /products/shoes and /products/shirts . Since the path is stripped prior to forwarding, your backend is expected to listen on / . If your backend is serving assets (e.g., images or Javascript files), chances are it must return properly constructed relative URLs. Continuing on the example, the backend should return /products/shoes/image.png (and not /images.png which Traefik would likely not be able to associate with the same backend). The X-Forwarded-Prefix header can be queried to build such URLs dynamically.","title":"regex"},{"location":"migration/v1-to-v2/","text":"Migration Guide: From v1 to v2 \u00b6 How to Migrate from Traefik v1 to Traefik v2. The version 2 of Traefik introduces a number of breaking changes, which require one to update their configuration when they migrate from v1 to v2. The goal of this page is to recapitulate all of these changes, and in particular to give examples, feature by feature, of how the configuration looked like in v1, and how it now looks like in v2. Migration Helper We created a tool to help during the migration: traefik-migration-tool This tool allows to: convert Ingress to Traefik IngressRoute resources. convert acme.json file from v1 to v2 format. migrate the static configuration contained in the file traefik.toml to a Traefik v2 file. Frontends and Backends Are Dead... ... Long Live Routers, Middlewares, and Services \u00b6 During the transition from v1 to v2, a number of internal pieces and components of Traefik were rewritten and reorganized. As such, the combination of core notions such as frontends and backends has been replaced with the combination of routers , services , and middlewares . Typically, a router replaces a frontend, and a service assumes the role of a backend, with each router referring to a service. However, even though a backend was in charge of applying any desired modification on the fly to the incoming request, the router defers that responsibility to another component. Instead, a dedicated middleware is now defined for each kind of such modification. Then any router can refer to an instance of the wanted middleware. One frontend with basic auth and one backend, become one router, one service, and one basic auth middleware. v1 Docker labels: - \"traefik.frontend.rule=Host:test.localhost;PathPrefix:/test\" - \"traefik.frontend.auth.basic.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" K8s Ingress apiVersion: extensions/v1beta1 kind: Ingress metadata: name: traefik namespace: kube-system annotations: kubernetes.io/ingress.class: traefik traefik.ingress.kubernetes.io/rule-type: PathPrefix spec: rules: - host: test.locahost http: paths: - path: /test backend: serviceName: server0 servicePort: 80 - path: /test backend: serviceName: server1 servicePort: 80 File (TOML) [frontends] [frontends.frontend1] entryPoints = [\"http\"] backend = \"backend1\" [frontends.frontend1.routes] [frontends.frontend1.routes.route0] rule = \"Host:test.localhost\" [frontends.frontend1.routes.route0] rule = \"PathPrefix:/test\" [frontends.frontend1.auth] [frontends.frontend1.auth.basic] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] [backends] [backends.backend1] [backends.backend1.servers.server0] url = \"http://10.10.10.1:80\" [backends.backend1.servers.server1] url = \"http://10.10.10.2:80\" [backends.backend1.loadBalancer] method = \"wrr\" v2 Docker labels: - \"traefik.http.routers.router0.rule=Host(`bar.com`) && PathPrefix(`/test`)\" - \"traefik.http.routers.router0.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" K8s IngressRoute # The definitions below require the definitions for the Middleware and IngressRoute kinds. # https://docs.traefik.io/v2.0/providers/kubernetes-crd/#traefik-ingressroute-definition apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: basicauth namespace: foo spec: basicAuth: users: - test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ - test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutebar spec: entryPoints: - http routes: - match: Host(`test.localhost`) && PathPrefix(`/test`) kind: Rule services: - name: server0 port: 80 - name: server1 port: 80 middlewares: - name: basicauth namespace: foo File (TOML) [http.routers] [http.routers.router0] rule = \"Host(`test.localhost`) && PathPrefix(`/test`)\" middlewares = [\"auth\"] service = \"my-service\" [http.services] [[http.services.my-service.loadBalancer.servers]] url = \"http://10.10.10.1:80\" [[http.services.my-service.loadBalancer.servers]] url = \"http://10.10.10.2:80\" [http.middlewares] [http.middlewares.auth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] File (YAML) http: routers: router0: rule: \"Host(`test.localhost`) && PathPrefix(`/test`)\" service: my-service middlewares: - auth services: my-service: loadBalancer: servers: - url: http://10.10.10.1:80 - url: http://10.10.10.2:80 middlewares: auth: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" TLS Configuration Is Now Dynamic, per Router. \u00b6 TLS parameters used to be specified in the static configuration, as an entryPoint field. With Traefik v2, a new dynamic TLS section at the root contains all the desired TLS configurations. Then, a router's TLS field can refer to one of the TLS configurations defined at the root, hence defining the TLS configuration for that router. TLS on web-secure entryPoint becomes TLS option on Router-1 v1 File (TOML) # static configuration [entryPoints] [entryPoints.web-secure] address = \":443\" [entryPoints.web-secure.tls] minVersion = \"VersionTLS12\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", ] [[entryPoints.web-secure.tls.certificates]] certFile = \"path/to/my.cert\" keyFile = \"path/to/my.key\" CLI --entryPoints='Name:web-secure Address::443 TLS:path/to/my.cert,path/to/my.key TLS.MinVersion:VersionTLS12 TLS.CipherSuites:TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256' v2 File (TOML) # dynamic configuration [http.routers] [http.routers.Router-1] rule = \"Host(`bar.com`)\" service = \"service-id\" # will terminate the TLS request [http.routers.Router-1.tls] options = \"myTLSOptions\" [[tls.certificates]] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" [tls.options] [tls.options.default] minVersion = \"VersionTLS12\" [tls.options.myTLSOptions] minVersion = \"VersionTLS13\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", ] File (YAML) http: routers: Router-1: rule: \"Host(`bar.com`)\" service: service-id # will terminate the TLS request tls: options: myTLSOptions tls: certificates: - certFile: /path/to/domain.cert keyFile: /path/to/domain.key options: myTLSOptions: minVersion: VersionTLS13 cipherSuites: - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 K8s IngressRoute # The definitions below require the definitions for the TLSOption and IngressRoute kinds. # https://docs.traefik.io/v2.0/providers/kubernetes-crd/#traefik-ingressroute-definition apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: mytlsoption namespace: default spec: minVersion: VersionTLS13 cipherSuites: - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutebar spec: entryPoints: - web routes: - match: Host(`bar.com`) kind: Rule services: - name: whoami port: 80 tls: options: name: mytlsoption namespace: default Docker labels: # myTLSOptions must be defined by another provider, in this instance in the File Provider. # see the cross provider section - \"traefik.http.routers.router0.tls.options=myTLSOptions@file\" HTTP to HTTPS Redirection Is Now Configured on Routers \u00b6 Previously on Traefik v1, the redirection was applied on an entry point or on a frontend. With Traefik v2 it is applied on a Router . To apply a redirection, one of the redirect middlewares, RedirectRegex or RedirectScheme , has to be configured and added to the router middlewares list. HTTP to HTTPS redirection v1 File (TOML) # static configuration defaultEntryPoints = [\"http\", \"https\"] [entryPoints] [entryPoints.http] address = \":80\" [entryPoints.http.redirect] entryPoint = \"https\" [entryPoints.https] address = \":443\" [entryPoints.https.tls] [[entryPoints.https.tls.certificates]] certFile = \"examples/traefik.crt\" keyFile = \"examples/traefik.key\" CLI --entrypoints=Name:web Address::80 Redirect.EntryPoint:web-secure --entryPoints='Name:web-secure Address::443 TLS:path/to/my.cert,path/to/my.key' v2 Docker labels: - traefik.http.routers.web.rule=Host(`foo.com`) - traefik.http.routers.web.entrypoints=web - traefik.http.routers.web.middlewares=redirect@file - traefik.http.routers.web-secured.rule=Host(`foo.com`) - traefik.http.routers.web-secured.entrypoints=web-secure - traefik.http.routers.web-secured.tls=true K8s IngressRoute apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: http-redirect-ingressRoute spec: entryPoints: - web routes: - match: Host(`foo.com`) kind: Rule services: - name: whoami port: 80 middlewares: - name: redirect --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: https-ingressRoute spec: entryPoints: - web-secure routes: - match: Host(`foo`) kind: Rule services: - name: whoami port: 80 tls: {} --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: redirect spec: redirectScheme: scheme: https File (TOML) ## static configuration # traefik.toml [entryPoints.web] address = \":80\" [entryPoints.web-secure] address = \":443\" ##---------------------## ## dynamic configuration # dynamic-conf.toml [http.routers] [http.routers.router0] rule = \"Host(`foo.com`)\" service = \"my-service\" entrypoints = [\"web\"] middlewares = [\"redirect\"] [http.routers.router1] rule = \"Host(`foo.com`)\" service = \"my-service\" entrypoints = [\"web-secure\"] [http.routers.router1.tls] [http.services] [[http.services.my-service.loadBalancer.servers]] url = \"http://10.10.10.1:80\" [[http.services.my-service.loadBalancer.servers]] url = \"http://10.10.10.2:80\" [http.middlewares] [http.middlewares.redirect.redirectScheme] scheme = \"https\" [[tls.certificates]] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" File (YAML) ## static configuration # traefik.yml entryPoints: web: address: \":80\" web-secure: address: \":443\" ##---------------------## ## dynamic configuration # dynamic-conf.yml http: routers: router0: rule: \"Host(`foo.com`)\" entryPoints: - web middlewares: - redirect service: my-service router1: rule: \"Host(`foo.com`)\" entryPoints: - web-secure service: my-service tls: {} services: my-service: loadBalancer: servers: - url: http://10.10.10.1:80 - url: http://10.10.10.2:80 middlewares: redirect: redirectScheme: scheme: https tls: certificates: - certFile: /app/certs/server/server.pem keyFile: /app/certs/server/server.pem Strip and Rewrite Path Prefixes \u00b6 With the new core notions of v2 (introduced earlier in the section \"Frontends and Backends Are Dead... Long Live Routers, Middlewares, and Services\" ), transforming the URL path prefix of incoming requests is configured with middlewares , after the routing step with router rule PathPrefix . Use Case: Incoming requests to http://company.org/admin are forwarded to the webapplication \"admin\", with the path /admin stripped, e.g. to http://<IP>:<port>/ . In this case, you must: First, configure a router named admin with a rule matching at least the path prefix with the PathPrefix keyword, Then, define a middleware of type stripprefix , which remove the prefix /admin , associated to the router admin . Strip Path Prefix When Forwarding to Backend v1 Docker labels: - \"traefik.frontend.rule=Host:company.org;PathPrefixStrip:/admin\" Kubernetes Ingress apiVersion: networking.k8s.io/v1beta1 kind: Ingress metadata: name: traefik annotations: kubernetes.io/ingress.class: traefik traefik.ingress.kubernetes.io/rule-type: PathPrefixStrip spec: rules: - host: company.org http: paths: - path: /admin backend: serviceName: admin-svc servicePort: admin File (TOML) [frontends.admin] [frontends.admin.routes.admin_1] rule = \"Host:company.org;PathPrefixStrip:/admin\" v2 Docker labels: - \"traefik.http.routers.admin.rule=Host(`company.org`) && PathPrefix(`/admin`)\" - \"traefik.http.routers.admin.middlewares=admin-stripprefix\" - \"traefik.http.middlewares.admin-stripprefix.stripprefix.prefixes=/admin\" Kubernetes IngressRoute --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: http-redirect-ingressRoute namespace: admin-web spec: entryPoints: - web routes: - match: Host(`company.org`) && PathPrefix(`/admin`) kind: Rule services: - name: admin-svc port: admin middlewares: - name: admin-stripprefix --- kind: Middleware metadata: name: admin-stripprefix spec: stripPrefix: prefixes: - /admin File (TOML) ## Dynamic configuration # dynamic-conf.toml [http.routers.router1] rule = \"Host(`company.org`) && PathPrefix(`/admin`)\" service = \"admin-svc\" entrypoints = [\"web\"] middlewares = [\"admin-stripprefix\"] [http.middlewares] [http.middlewares.admin-stripprefix.stripPrefix] prefixes = [\"/admin\"] # ... File (YAML) ## Dynamic Configuration # dynamic-conf.yml # As YAML Configuration File http: routers: admin: service: admin-svc middlewares: - \"admin-stripprefix\" rule: \"Host(`company.org`) && PathPrefix(`/admin`)\" middlewares: admin-stripprefix: stripPrefix: prefixes: - \"/admin\" # ... What About Other Path Transformations? Instead of removing the path prefix with the stripprefix middleware , you can also: Add a path prefix with the addprefix middleware Replace the complete path of the request with the replacepath middleware ReplaceRewrite path using Regexp with the replacepathregex middleware And a lot more on the middlewares page ACME (LetsEncrypt) \u00b6 ACME is now a certificate resolver (under a certificatesResolvers section) but remains in the static configuration. ACME from provider to a specific Certificate Resolver v1 File (TOML) # static configuration defaultEntryPoints = [\"web-secure\",\"web\"] [entryPoints.web] address = \":80\" [entryPoints.web.redirect] entryPoint = \"webs\" [entryPoints.web-secure] address = \":443\" [entryPoints.https.tls] [acme] email = \"your-email-here@my-awesome-app.org\" storage = \"acme.json\" entryPoint = \"web-secure\" onHostRule = true [acme.httpChallenge] entryPoint = \"web\" CLI --defaultentrypoints=web-secure,web --entryPoints=Name:web Address::80 Redirect.EntryPoint:web-secure --entryPoints=Name:web-secure Address::443 TLS --acme.email=your-email-here@my-awesome-app.org --acme.storage=acme.json --acme.entryPoint=web-secure --acme.onHostRule=true --acme.httpchallenge.entrypoint=http v2 File (TOML) # static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web-secure] address = \":443\" [certificatesResolvers.sample.acme] email = \"your-email@your-domain.org\" storage = \"acme.json\" [certificatesResolvers.sample.acme.httpChallenge] # used during the challenge entryPoint = \"web\" File (YAML) entryPoints: web: address: \":80\" web-secure: address: \":443\" certificatesResolvers: sample: acme: email: your-email@your-domain.org storage: acme.json httpChallenge: # used during the challenge entryPoint: web CLI --entryPoints.web.address=:80 --entryPoints.websecure.address=:443 --certificatesResolvers.sample.acme.email=your-email@your-domain.org --certificatesResolvers.sample.acme.storage=acme.json --certificatesResolvers.sample.acme.httpChallenge.entryPoint=web Traefik Logs \u00b6 In the v2, all the log configuration remains in the static part but are unified under a log section. There is no more log configuration at the root level. Simple log configuration v1 File (TOML) # static configuration logLevel = \"DEBUG\" [traefikLog] filePath = \"/path/to/traefik.log\" format = \"json\" CLI --logLevel=DEBUG --traefikLog.filePath=/path/to/traefik.log --traefikLog.format=json v2 File (TOML) # static configuration [log] level = \"DEBUG\" filePath = \"/path/to/log-file.log\" format = \"json\" File (YAML) # static configuration log: level: DEBUG filePath: /path/to/log-file.log format: json CLI --log.level=DEBUG --log.filePath=/path/to/traefik.log --log.format=json Tracing \u00b6 Traefik v2 retains OpenTracing support. The backend root option from the v1 is gone, you just have to set your tracing configuration . Simple Jaeger tracing configuration v1 File (TOML) # static configuration [tracing] backend = \"jaeger\" servicename = \"tracing\" [tracing.jaeger] samplingParam = 1.0 samplingServerURL = \"http://12.0.0.1:5778/sampling\" samplingType = \"const\" localAgentHostPort = \"12.0.0.1:6831\" CLI --tracing.backend=jaeger --tracing.servicename=tracing --tracing.jaeger.localagenthostport=12.0.0.1:6831 --tracing.jaeger.samplingparam=1.0 --tracing.jaeger.samplingserverurl=http://12.0.0.1:5778/sampling --tracing.jaeger.samplingtype=const v2 File (TOML) # static configuration [tracing] servicename = \"tracing\" [tracing.jaeger] samplingParam = 1.0 samplingServerURL = \"http://12.0.0.1:5778/sampling\" samplingType = \"const\" localAgentHostPort = \"12.0.0.1:6831\" File (YAML) # static configuration tracing: servicename: tracing jaeger: samplingParam: 1 samplingServerURL: 'http://12.0.0.1:5778/sampling' samplingType: const localAgentHostPort: '12.0.0.1:6831' CLI --tracing.servicename=tracing --tracing.jaeger.localagenthostport=12.0.0.1:6831 --tracing.jaeger.samplingparam=1.0 --tracing.jaeger.samplingserverurl=http://12.0.0.1:5778/sampling --tracing.jaeger.samplingtype=const Metrics \u00b6 The v2 retains metrics tools and allows metrics to be configured for the entrypoints and/or services. For a basic configuration, the metrics configuration remains the same. Simple Prometheus metrics configuration v1 File (TOML) # static configuration [metrics.prometheus] buckets = [0.1,0.3,1.2,5.0] entryPoint = \"traefik\" CLI --metrics.prometheus.buckets=[0.1,0.3,1.2,5.0] --metrics.prometheus.entrypoint=traefik v2 File (TOML) # static configuration [metrics.prometheus] buckets = [0.1,0.3,1.2,5.0] entryPoint = \"metrics\" File (YAML) # static configuration metrics: prometheus: buckets: - 0.1 - 0.3 - 1.2 - 5 entryPoint: metrics CLI --metrics.prometheus.buckets=[0.1,0.3,1.2,5.0] --metrics.prometheus.entrypoint=metrics No More Root Level Key/Values \u00b6 To avoid any source of confusion, there are no more configuration at the root level. Each root item has been moved to a related section or removed. From root to dedicated section v1 File (TOML) # static configuration checkNewVersion = false sendAnonymousUsage = true logLevel = \"DEBUG\" insecureSkipVerify = true rootCAs = [ \"/mycert.cert\" ] maxIdleConnsPerHost = 200 providersThrottleDuration = \"2s\" AllowMinWeightZero = true debug = true defaultEntryPoints = [\"web\", \"web-secure\"] keepTrailingSlash = false CLI --checknewversion=false --sendanonymoususage=true --loglevel=DEBUG --insecureskipverify=true --rootcas=/mycert.cert --maxidleconnsperhost=200 --providersthrottleduration=2s --allowminweightzero=true --debug=true --defaultentrypoints=web,web-secure --keeptrailingslash=true v2 File (TOML) # static configuration [global] checkNewVersion = true sendAnonymousUsage = true [log] level = \"DEBUG\" [serversTransport] insecureSkipVerify = true rootCAs = [ \"/mycert.cert\" ] maxIdleConnsPerHost = 42 [providers] providersThrottleDuration = 42 File (YAML) # static configuration global: checkNewVersion: true sendAnonymousUsage: true log: level: DEBUG serversTransport: insecureSkipVerify: true rootCAs: - /mycert.cert maxIdleConnsPerHost: 42 providers: providersThrottleDuration: 42 CLI --global.checknewversion=true --global.sendanonymoususage=true --log.level=DEBUG --serverstransport.insecureskipverify=true --serverstransport.rootcas=/mycert.cert --serverstransport.maxidleconnsperhost=42 --providers.providersthrottleduration=42 Dashboard \u00b6 You need to activate the API to access the dashboard . As the dashboard access is now secured by default you can either: define a specific router with the api@internal service and one authentication middleware like the following example or use the insecure option of the API Dashboard with k8s and dedicated router As api@internal is not a Kubernetes service, you have to use the file provider or the insecure API option. Activate and access the dashboard v1 File (TOML) ## static configuration # traefik.toml [entryPoints.web-secure] address = \":443\" [entryPoints.web-secure.tls] [entryPoints.web-secure.auth] [entryPoints.web-secure.auth.basic] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" ] [api] entryPoint = \"web-secure\" CLI --entryPoints='Name:web-secure Address::443 TLS Auth.Basic.Users:test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/' --api v2 Docker # dynamic configuration labels: - \"traefik.http.routers.api.rule=Host(`traefik.docker.localhost`)\" - \"traefik.http.routers.api.entrypoints=web-secured\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=myAuth\" - \"traefik.http.routers.api.tls\" - \"traefik.http.middlewares.myAuth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/\" File (TOML) ## static configuration # traefik.toml [entryPoints.web-secure] address = \":443\" [api] [providers.file] directory = \"/path/to/dynamic/config\" ##---------------------## ## dynamic configuration # /path/to/dynamic/config/dynamic-conf.toml [http.routers.api] rule = \"Host(`traefik.docker.localhost`)\" entrypoints = [\"web-secure\"] service = \"api@internal\" middlewares = [\"myAuth\"] [http.routers.api.tls] [http.middlewares.myAuth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" ] File (YAML) ## static configuration # traefik.yaml entryPoints: web-secure: address: ':443' api: {} providers: file: directory: /path/to/dynamic/config ##---------------------## ## dynamic configuration # /path/to/dynamic/config/dynamic-conf.yaml http: routers: api: rule: Host(`traefik.docker.localhost`) entrypoints: - web-secure service: api@internal middlewares: - myAuth tls: {} middlewares: myAuth: basicAuth: users: - 'test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/' Providers \u00b6 Supported providers , for now: Azure Service Fabric BoltDB Consul Consul Catalog Docker DynamoDB ECS Etcd Eureka File Kubernetes Ingress (without annotations) Kubernetes IngressRoute Marathon Mesos Rancher Rest Zookeeper Some Tips You Should Know \u00b6 Different sources of static configuration (file, CLI flags, ...) cannot be mixed . Now, configuration elements can be referenced between different providers by using the provider namespace notation: @<provider> . For instance, a router named myrouter in a File Provider can refer to a service named myservice defined in Docker Provider with the following notation: myservice@docker . Middlewares are applied in the same order as their declaration in router. If you have any questions feel free to join our community forum .","title":"Traefik v1 to v2"},{"location":"migration/v1-to-v2/#migration-guide-from-v1-to-v2","text":"How to Migrate from Traefik v1 to Traefik v2. The version 2 of Traefik introduces a number of breaking changes, which require one to update their configuration when they migrate from v1 to v2. The goal of this page is to recapitulate all of these changes, and in particular to give examples, feature by feature, of how the configuration looked like in v1, and how it now looks like in v2. Migration Helper We created a tool to help during the migration: traefik-migration-tool This tool allows to: convert Ingress to Traefik IngressRoute resources. convert acme.json file from v1 to v2 format. migrate the static configuration contained in the file traefik.toml to a Traefik v2 file.","title":"Migration Guide: From v1 to v2"},{"location":"migration/v1-to-v2/#frontends-and-backends-are-dead-long-live-routers-middlewares-and-services","text":"During the transition from v1 to v2, a number of internal pieces and components of Traefik were rewritten and reorganized. As such, the combination of core notions such as frontends and backends has been replaced with the combination of routers , services , and middlewares . Typically, a router replaces a frontend, and a service assumes the role of a backend, with each router referring to a service. However, even though a backend was in charge of applying any desired modification on the fly to the incoming request, the router defers that responsibility to another component. Instead, a dedicated middleware is now defined for each kind of such modification. Then any router can refer to an instance of the wanted middleware. One frontend with basic auth and one backend, become one router, one service, and one basic auth middleware. v1 Docker labels: - \"traefik.frontend.rule=Host:test.localhost;PathPrefix:/test\" - \"traefik.frontend.auth.basic.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" K8s Ingress apiVersion: extensions/v1beta1 kind: Ingress metadata: name: traefik namespace: kube-system annotations: kubernetes.io/ingress.class: traefik traefik.ingress.kubernetes.io/rule-type: PathPrefix spec: rules: - host: test.locahost http: paths: - path: /test backend: serviceName: server0 servicePort: 80 - path: /test backend: serviceName: server1 servicePort: 80 File (TOML) [frontends] [frontends.frontend1] entryPoints = [\"http\"] backend = \"backend1\" [frontends.frontend1.routes] [frontends.frontend1.routes.route0] rule = \"Host:test.localhost\" [frontends.frontend1.routes.route0] rule = \"PathPrefix:/test\" [frontends.frontend1.auth] [frontends.frontend1.auth.basic] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] [backends] [backends.backend1] [backends.backend1.servers.server0] url = \"http://10.10.10.1:80\" [backends.backend1.servers.server1] url = \"http://10.10.10.2:80\" [backends.backend1.loadBalancer] method = \"wrr\" v2 Docker labels: - \"traefik.http.routers.router0.rule=Host(`bar.com`) && PathPrefix(`/test`)\" - \"traefik.http.routers.router0.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" K8s IngressRoute # The definitions below require the definitions for the Middleware and IngressRoute kinds. # https://docs.traefik.io/v2.0/providers/kubernetes-crd/#traefik-ingressroute-definition apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: basicauth namespace: foo spec: basicAuth: users: - test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ - test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutebar spec: entryPoints: - http routes: - match: Host(`test.localhost`) && PathPrefix(`/test`) kind: Rule services: - name: server0 port: 80 - name: server1 port: 80 middlewares: - name: basicauth namespace: foo File (TOML) [http.routers] [http.routers.router0] rule = \"Host(`test.localhost`) && PathPrefix(`/test`)\" middlewares = [\"auth\"] service = \"my-service\" [http.services] [[http.services.my-service.loadBalancer.servers]] url = \"http://10.10.10.1:80\" [[http.services.my-service.loadBalancer.servers]] url = \"http://10.10.10.2:80\" [http.middlewares] [http.middlewares.auth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] File (YAML) http: routers: router0: rule: \"Host(`test.localhost`) && PathPrefix(`/test`)\" service: my-service middlewares: - auth services: my-service: loadBalancer: servers: - url: http://10.10.10.1:80 - url: http://10.10.10.2:80 middlewares: auth: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"","title":"Frontends and Backends Are Dead... ... Long Live Routers, Middlewares, and Services"},{"location":"migration/v1-to-v2/#tls-configuration-is-now-dynamic-per-router","text":"TLS parameters used to be specified in the static configuration, as an entryPoint field. With Traefik v2, a new dynamic TLS section at the root contains all the desired TLS configurations. Then, a router's TLS field can refer to one of the TLS configurations defined at the root, hence defining the TLS configuration for that router. TLS on web-secure entryPoint becomes TLS option on Router-1 v1 File (TOML) # static configuration [entryPoints] [entryPoints.web-secure] address = \":443\" [entryPoints.web-secure.tls] minVersion = \"VersionTLS12\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", ] [[entryPoints.web-secure.tls.certificates]] certFile = \"path/to/my.cert\" keyFile = \"path/to/my.key\" CLI --entryPoints='Name:web-secure Address::443 TLS:path/to/my.cert,path/to/my.key TLS.MinVersion:VersionTLS12 TLS.CipherSuites:TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256' v2 File (TOML) # dynamic configuration [http.routers] [http.routers.Router-1] rule = \"Host(`bar.com`)\" service = \"service-id\" # will terminate the TLS request [http.routers.Router-1.tls] options = \"myTLSOptions\" [[tls.certificates]] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" [tls.options] [tls.options.default] minVersion = \"VersionTLS12\" [tls.options.myTLSOptions] minVersion = \"VersionTLS13\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", ] File (YAML) http: routers: Router-1: rule: \"Host(`bar.com`)\" service: service-id # will terminate the TLS request tls: options: myTLSOptions tls: certificates: - certFile: /path/to/domain.cert keyFile: /path/to/domain.key options: myTLSOptions: minVersion: VersionTLS13 cipherSuites: - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 K8s IngressRoute # The definitions below require the definitions for the TLSOption and IngressRoute kinds. # https://docs.traefik.io/v2.0/providers/kubernetes-crd/#traefik-ingressroute-definition apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: mytlsoption namespace: default spec: minVersion: VersionTLS13 cipherSuites: - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutebar spec: entryPoints: - web routes: - match: Host(`bar.com`) kind: Rule services: - name: whoami port: 80 tls: options: name: mytlsoption namespace: default Docker labels: # myTLSOptions must be defined by another provider, in this instance in the File Provider. # see the cross provider section - \"traefik.http.routers.router0.tls.options=myTLSOptions@file\"","title":"TLS Configuration Is Now Dynamic, per Router."},{"location":"migration/v1-to-v2/#http-to-https-redirection-is-now-configured-on-routers","text":"Previously on Traefik v1, the redirection was applied on an entry point or on a frontend. With Traefik v2 it is applied on a Router . To apply a redirection, one of the redirect middlewares, RedirectRegex or RedirectScheme , has to be configured and added to the router middlewares list. HTTP to HTTPS redirection v1 File (TOML) # static configuration defaultEntryPoints = [\"http\", \"https\"] [entryPoints] [entryPoints.http] address = \":80\" [entryPoints.http.redirect] entryPoint = \"https\" [entryPoints.https] address = \":443\" [entryPoints.https.tls] [[entryPoints.https.tls.certificates]] certFile = \"examples/traefik.crt\" keyFile = \"examples/traefik.key\" CLI --entrypoints=Name:web Address::80 Redirect.EntryPoint:web-secure --entryPoints='Name:web-secure Address::443 TLS:path/to/my.cert,path/to/my.key' v2 Docker labels: - traefik.http.routers.web.rule=Host(`foo.com`) - traefik.http.routers.web.entrypoints=web - traefik.http.routers.web.middlewares=redirect@file - traefik.http.routers.web-secured.rule=Host(`foo.com`) - traefik.http.routers.web-secured.entrypoints=web-secure - traefik.http.routers.web-secured.tls=true K8s IngressRoute apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: http-redirect-ingressRoute spec: entryPoints: - web routes: - match: Host(`foo.com`) kind: Rule services: - name: whoami port: 80 middlewares: - name: redirect --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: https-ingressRoute spec: entryPoints: - web-secure routes: - match: Host(`foo`) kind: Rule services: - name: whoami port: 80 tls: {} --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: redirect spec: redirectScheme: scheme: https File (TOML) ## static configuration # traefik.toml [entryPoints.web] address = \":80\" [entryPoints.web-secure] address = \":443\" ##---------------------## ## dynamic configuration # dynamic-conf.toml [http.routers] [http.routers.router0] rule = \"Host(`foo.com`)\" service = \"my-service\" entrypoints = [\"web\"] middlewares = [\"redirect\"] [http.routers.router1] rule = \"Host(`foo.com`)\" service = \"my-service\" entrypoints = [\"web-secure\"] [http.routers.router1.tls] [http.services] [[http.services.my-service.loadBalancer.servers]] url = \"http://10.10.10.1:80\" [[http.services.my-service.loadBalancer.servers]] url = \"http://10.10.10.2:80\" [http.middlewares] [http.middlewares.redirect.redirectScheme] scheme = \"https\" [[tls.certificates]] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" File (YAML) ## static configuration # traefik.yml entryPoints: web: address: \":80\" web-secure: address: \":443\" ##---------------------## ## dynamic configuration # dynamic-conf.yml http: routers: router0: rule: \"Host(`foo.com`)\" entryPoints: - web middlewares: - redirect service: my-service router1: rule: \"Host(`foo.com`)\" entryPoints: - web-secure service: my-service tls: {} services: my-service: loadBalancer: servers: - url: http://10.10.10.1:80 - url: http://10.10.10.2:80 middlewares: redirect: redirectScheme: scheme: https tls: certificates: - certFile: /app/certs/server/server.pem keyFile: /app/certs/server/server.pem","title":"HTTP to HTTPS Redirection Is Now Configured on Routers"},{"location":"migration/v1-to-v2/#strip-and-rewrite-path-prefixes","text":"With the new core notions of v2 (introduced earlier in the section \"Frontends and Backends Are Dead... Long Live Routers, Middlewares, and Services\" ), transforming the URL path prefix of incoming requests is configured with middlewares , after the routing step with router rule PathPrefix . Use Case: Incoming requests to http://company.org/admin are forwarded to the webapplication \"admin\", with the path /admin stripped, e.g. to http://<IP>:<port>/ . In this case, you must: First, configure a router named admin with a rule matching at least the path prefix with the PathPrefix keyword, Then, define a middleware of type stripprefix , which remove the prefix /admin , associated to the router admin . Strip Path Prefix When Forwarding to Backend v1 Docker labels: - \"traefik.frontend.rule=Host:company.org;PathPrefixStrip:/admin\" Kubernetes Ingress apiVersion: networking.k8s.io/v1beta1 kind: Ingress metadata: name: traefik annotations: kubernetes.io/ingress.class: traefik traefik.ingress.kubernetes.io/rule-type: PathPrefixStrip spec: rules: - host: company.org http: paths: - path: /admin backend: serviceName: admin-svc servicePort: admin File (TOML) [frontends.admin] [frontends.admin.routes.admin_1] rule = \"Host:company.org;PathPrefixStrip:/admin\" v2 Docker labels: - \"traefik.http.routers.admin.rule=Host(`company.org`) && PathPrefix(`/admin`)\" - \"traefik.http.routers.admin.middlewares=admin-stripprefix\" - \"traefik.http.middlewares.admin-stripprefix.stripprefix.prefixes=/admin\" Kubernetes IngressRoute --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: http-redirect-ingressRoute namespace: admin-web spec: entryPoints: - web routes: - match: Host(`company.org`) && PathPrefix(`/admin`) kind: Rule services: - name: admin-svc port: admin middlewares: - name: admin-stripprefix --- kind: Middleware metadata: name: admin-stripprefix spec: stripPrefix: prefixes: - /admin File (TOML) ## Dynamic configuration # dynamic-conf.toml [http.routers.router1] rule = \"Host(`company.org`) && PathPrefix(`/admin`)\" service = \"admin-svc\" entrypoints = [\"web\"] middlewares = [\"admin-stripprefix\"] [http.middlewares] [http.middlewares.admin-stripprefix.stripPrefix] prefixes = [\"/admin\"] # ... File (YAML) ## Dynamic Configuration # dynamic-conf.yml # As YAML Configuration File http: routers: admin: service: admin-svc middlewares: - \"admin-stripprefix\" rule: \"Host(`company.org`) && PathPrefix(`/admin`)\" middlewares: admin-stripprefix: stripPrefix: prefixes: - \"/admin\" # ... What About Other Path Transformations? Instead of removing the path prefix with the stripprefix middleware , you can also: Add a path prefix with the addprefix middleware Replace the complete path of the request with the replacepath middleware ReplaceRewrite path using Regexp with the replacepathregex middleware And a lot more on the middlewares page","title":"Strip and Rewrite Path Prefixes"},{"location":"migration/v1-to-v2/#acme-letsencrypt","text":"ACME is now a certificate resolver (under a certificatesResolvers section) but remains in the static configuration. ACME from provider to a specific Certificate Resolver v1 File (TOML) # static configuration defaultEntryPoints = [\"web-secure\",\"web\"] [entryPoints.web] address = \":80\" [entryPoints.web.redirect] entryPoint = \"webs\" [entryPoints.web-secure] address = \":443\" [entryPoints.https.tls] [acme] email = \"your-email-here@my-awesome-app.org\" storage = \"acme.json\" entryPoint = \"web-secure\" onHostRule = true [acme.httpChallenge] entryPoint = \"web\" CLI --defaultentrypoints=web-secure,web --entryPoints=Name:web Address::80 Redirect.EntryPoint:web-secure --entryPoints=Name:web-secure Address::443 TLS --acme.email=your-email-here@my-awesome-app.org --acme.storage=acme.json --acme.entryPoint=web-secure --acme.onHostRule=true --acme.httpchallenge.entrypoint=http v2 File (TOML) # static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web-secure] address = \":443\" [certificatesResolvers.sample.acme] email = \"your-email@your-domain.org\" storage = \"acme.json\" [certificatesResolvers.sample.acme.httpChallenge] # used during the challenge entryPoint = \"web\" File (YAML) entryPoints: web: address: \":80\" web-secure: address: \":443\" certificatesResolvers: sample: acme: email: your-email@your-domain.org storage: acme.json httpChallenge: # used during the challenge entryPoint: web CLI --entryPoints.web.address=:80 --entryPoints.websecure.address=:443 --certificatesResolvers.sample.acme.email=your-email@your-domain.org --certificatesResolvers.sample.acme.storage=acme.json --certificatesResolvers.sample.acme.httpChallenge.entryPoint=web","title":"ACME (LetsEncrypt)"},{"location":"migration/v1-to-v2/#traefik-logs","text":"In the v2, all the log configuration remains in the static part but are unified under a log section. There is no more log configuration at the root level. Simple log configuration v1 File (TOML) # static configuration logLevel = \"DEBUG\" [traefikLog] filePath = \"/path/to/traefik.log\" format = \"json\" CLI --logLevel=DEBUG --traefikLog.filePath=/path/to/traefik.log --traefikLog.format=json v2 File (TOML) # static configuration [log] level = \"DEBUG\" filePath = \"/path/to/log-file.log\" format = \"json\" File (YAML) # static configuration log: level: DEBUG filePath: /path/to/log-file.log format: json CLI --log.level=DEBUG --log.filePath=/path/to/traefik.log --log.format=json","title":"Traefik Logs"},{"location":"migration/v1-to-v2/#tracing","text":"Traefik v2 retains OpenTracing support. The backend root option from the v1 is gone, you just have to set your tracing configuration . Simple Jaeger tracing configuration v1 File (TOML) # static configuration [tracing] backend = \"jaeger\" servicename = \"tracing\" [tracing.jaeger] samplingParam = 1.0 samplingServerURL = \"http://12.0.0.1:5778/sampling\" samplingType = \"const\" localAgentHostPort = \"12.0.0.1:6831\" CLI --tracing.backend=jaeger --tracing.servicename=tracing --tracing.jaeger.localagenthostport=12.0.0.1:6831 --tracing.jaeger.samplingparam=1.0 --tracing.jaeger.samplingserverurl=http://12.0.0.1:5778/sampling --tracing.jaeger.samplingtype=const v2 File (TOML) # static configuration [tracing] servicename = \"tracing\" [tracing.jaeger] samplingParam = 1.0 samplingServerURL = \"http://12.0.0.1:5778/sampling\" samplingType = \"const\" localAgentHostPort = \"12.0.0.1:6831\" File (YAML) # static configuration tracing: servicename: tracing jaeger: samplingParam: 1 samplingServerURL: 'http://12.0.0.1:5778/sampling' samplingType: const localAgentHostPort: '12.0.0.1:6831' CLI --tracing.servicename=tracing --tracing.jaeger.localagenthostport=12.0.0.1:6831 --tracing.jaeger.samplingparam=1.0 --tracing.jaeger.samplingserverurl=http://12.0.0.1:5778/sampling --tracing.jaeger.samplingtype=const","title":"Tracing"},{"location":"migration/v1-to-v2/#metrics","text":"The v2 retains metrics tools and allows metrics to be configured for the entrypoints and/or services. For a basic configuration, the metrics configuration remains the same. Simple Prometheus metrics configuration v1 File (TOML) # static configuration [metrics.prometheus] buckets = [0.1,0.3,1.2,5.0] entryPoint = \"traefik\" CLI --metrics.prometheus.buckets=[0.1,0.3,1.2,5.0] --metrics.prometheus.entrypoint=traefik v2 File (TOML) # static configuration [metrics.prometheus] buckets = [0.1,0.3,1.2,5.0] entryPoint = \"metrics\" File (YAML) # static configuration metrics: prometheus: buckets: - 0.1 - 0.3 - 1.2 - 5 entryPoint: metrics CLI --metrics.prometheus.buckets=[0.1,0.3,1.2,5.0] --metrics.prometheus.entrypoint=metrics","title":"Metrics"},{"location":"migration/v1-to-v2/#no-more-root-level-keyvalues","text":"To avoid any source of confusion, there are no more configuration at the root level. Each root item has been moved to a related section or removed. From root to dedicated section v1 File (TOML) # static configuration checkNewVersion = false sendAnonymousUsage = true logLevel = \"DEBUG\" insecureSkipVerify = true rootCAs = [ \"/mycert.cert\" ] maxIdleConnsPerHost = 200 providersThrottleDuration = \"2s\" AllowMinWeightZero = true debug = true defaultEntryPoints = [\"web\", \"web-secure\"] keepTrailingSlash = false CLI --checknewversion=false --sendanonymoususage=true --loglevel=DEBUG --insecureskipverify=true --rootcas=/mycert.cert --maxidleconnsperhost=200 --providersthrottleduration=2s --allowminweightzero=true --debug=true --defaultentrypoints=web,web-secure --keeptrailingslash=true v2 File (TOML) # static configuration [global] checkNewVersion = true sendAnonymousUsage = true [log] level = \"DEBUG\" [serversTransport] insecureSkipVerify = true rootCAs = [ \"/mycert.cert\" ] maxIdleConnsPerHost = 42 [providers] providersThrottleDuration = 42 File (YAML) # static configuration global: checkNewVersion: true sendAnonymousUsage: true log: level: DEBUG serversTransport: insecureSkipVerify: true rootCAs: - /mycert.cert maxIdleConnsPerHost: 42 providers: providersThrottleDuration: 42 CLI --global.checknewversion=true --global.sendanonymoususage=true --log.level=DEBUG --serverstransport.insecureskipverify=true --serverstransport.rootcas=/mycert.cert --serverstransport.maxidleconnsperhost=42 --providers.providersthrottleduration=42","title":"No More Root Level Key/Values"},{"location":"migration/v1-to-v2/#dashboard","text":"You need to activate the API to access the dashboard . As the dashboard access is now secured by default you can either: define a specific router with the api@internal service and one authentication middleware like the following example or use the insecure option of the API Dashboard with k8s and dedicated router As api@internal is not a Kubernetes service, you have to use the file provider or the insecure API option. Activate and access the dashboard v1 File (TOML) ## static configuration # traefik.toml [entryPoints.web-secure] address = \":443\" [entryPoints.web-secure.tls] [entryPoints.web-secure.auth] [entryPoints.web-secure.auth.basic] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" ] [api] entryPoint = \"web-secure\" CLI --entryPoints='Name:web-secure Address::443 TLS Auth.Basic.Users:test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/' --api v2 Docker # dynamic configuration labels: - \"traefik.http.routers.api.rule=Host(`traefik.docker.localhost`)\" - \"traefik.http.routers.api.entrypoints=web-secured\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=myAuth\" - \"traefik.http.routers.api.tls\" - \"traefik.http.middlewares.myAuth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/\" File (TOML) ## static configuration # traefik.toml [entryPoints.web-secure] address = \":443\" [api] [providers.file] directory = \"/path/to/dynamic/config\" ##---------------------## ## dynamic configuration # /path/to/dynamic/config/dynamic-conf.toml [http.routers.api] rule = \"Host(`traefik.docker.localhost`)\" entrypoints = [\"web-secure\"] service = \"api@internal\" middlewares = [\"myAuth\"] [http.routers.api.tls] [http.middlewares.myAuth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" ] File (YAML) ## static configuration # traefik.yaml entryPoints: web-secure: address: ':443' api: {} providers: file: directory: /path/to/dynamic/config ##---------------------## ## dynamic configuration # /path/to/dynamic/config/dynamic-conf.yaml http: routers: api: rule: Host(`traefik.docker.localhost`) entrypoints: - web-secure service: api@internal middlewares: - myAuth tls: {} middlewares: myAuth: basicAuth: users: - 'test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/'","title":"Dashboard"},{"location":"migration/v1-to-v2/#providers","text":"Supported providers , for now: Azure Service Fabric BoltDB Consul Consul Catalog Docker DynamoDB ECS Etcd Eureka File Kubernetes Ingress (without annotations) Kubernetes IngressRoute Marathon Mesos Rancher Rest Zookeeper","title":"Providers"},{"location":"migration/v1-to-v2/#some-tips-you-should-know","text":"Different sources of static configuration (file, CLI flags, ...) cannot be mixed . Now, configuration elements can be referenced between different providers by using the provider namespace notation: @<provider> . For instance, a router named myrouter in a File Provider can refer to a service named myservice defined in Docker Provider with the following notation: myservice@docker . Middlewares are applied in the same order as their declaration in router. If you have any questions feel free to join our community forum .","title":"Some Tips You Should Know"},{"location":"observability/access-logs/","text":"Access Logs \u00b6 Who Calls Whom? By default, logs are written to stdout, in text format. Configuration \u00b6 To enable the access logs: File (TOML) [accessLog] File (YAML) accessLog: {} CLI --accesslog=true filePath \u00b6 By default access logs are written to the standard output. To write the logs into a log file, use the filePath option. format \u00b6 By default, logs are written using the Common Log Format (CLF). To write logs in JSON, use json in the format option. If the given format is unsupported, the default (CLF) is used instead. Common Log Format <remote_IP_address> - <client_user_name_if_available> [<timestamp>] \"<request_method> <request_path> <request_protocol>\" <origin_server_HTTP_status> <origin_server_content_size> \"<request_referrer>\" \"<request_user_agent>\" <number_of_requests_received_since_Traefik_started> \"<Traefik_frontend_name>\" \"<Traefik_backend_URL>\" <request_duration_in_ms>ms bufferingSize \u00b6 To write the logs in an asynchronous fashion, specify a bufferingSize option. This option represents the number of log lines Traefik will keep in memory before writing them to the selected output. In some cases, this option can greatly help performances. File (TOML) # Configuring a buffer of 100 lines [accessLog] filePath = \"/path/to/access.log\" bufferingSize = 100 File (YAML) # Configuring a buffer of 100 lines accessLog: filePath: \"/path/to/access.log\" bufferingSize: 100 CLI # Configuring a buffer of 100 lines --accesslog=true --accesslog.filepath=/path/to/access.log --accesslog.bufferingsize=100 Filtering \u00b6 To filter logs, you can specify a set of filters which are logically \"OR-connected\". Thus, specifying multiple filters will keep more access logs than specifying only one. The available filters are: statusCodes , to limit the access logs to requests with a status codes in the specified range retryAttempts , to keep the access logs when at least one retry has happened minDuration , to keep access logs when requests take longer than the specified duration File (TOML) # Configuring Multiple Filters [accessLog] filePath = \"/path/to/access.log\" format = \"json\" [accessLog.filters] statusCodes = [\"200\", \"300-302\"] retryAttempts = true minDuration = \"10ms\" File (YAML) # Configuring Multiple Filters accessLog: filePath: \"/path/to/access.log\" format: json filters: statusCodes: - \"200\" - \"300-302\" retryAttempts: true minDuration: \"10ms\" CLI # Configuring Multiple Filters --accesslog=true --accesslog.filepath=/path/to/access.log --accesslog.format=json --accesslog.filters.statuscodes=200,300-302 --accesslog.filters.retryattempts --accesslog.filters.minduration=10ms Limiting the Fields \u00b6 You can decide to limit the logged fields/headers to a given list with the fields.names and fields.header options Each field can be set to: keep to keep the value drop to drop the value redact to replace the value with \"redacted\" The defaultMode for fields.header is drop . File (TOML) # Limiting the Logs to Specific Fields [accessLog] filePath = \"/path/to/access.log\" format = \"json\" [accessLog.fields] defaultMode = \"keep\" [accessLog.fields.names] \"ClientUsername\" = \"drop\" [accessLog.fields.headers] defaultMode = \"keep\" [accessLog.fields.headers.names] \"User-Agent\" = \"redact\" \"Authorization\" = \"drop\" \"Content-Type\" = \"keep\" File (YAML) # Limiting the Logs to Specific Fields accessLog: filePath: \"/path/to/access.log\" format: json fields: defaultMode: keep names: ClientUsername: drop headers: defaultMode: keep names: User-Agent: redact Authorization: drop Content-Type: keep CLI # Limiting the Logs to Specific Fields --accesslog=true --accesslog.filepath=/path/to/access.log --accesslog.format=json --accesslog.fields.defaultmode=keep --accesslog.fields.names.ClientUsername=drop --accesslog.fields.headers.defaultmode=keep --accesslog.fields.headers.names.User-Agent=redact --accesslog.fields.headers.names.Authorization=drop --accesslog.fields.headers.names.Content-Type=keep Available Fields Field Description StartUTC The time at which request processing started. StartLocal The local time at which request processing started. Duration The total time taken (in nanoseconds) by processing the response, including the origin server's time but not the log writing time. FrontendName The name of the Traefik frontend. BackendName The name of the Traefik backend. BackendURL The URL of the Traefik backend. BackendAddr The IP:port of the Traefik backend (extracted from BackendURL ) ClientAddr The remote address in its original form (usually IP:port). ClientHost The remote IP address from which the client request was received. ClientPort The remote TCP port from which the client request was received. ClientUsername The username provided in the URL, if present. RequestAddr The HTTP Host header (usually IP:port). This is treated as not a header by the Go API. RequestHost The HTTP Host server name (not including port). RequestPort The TCP port from the HTTP Host. RequestMethod The HTTP method. RequestPath The HTTP request URI, not including the scheme, host or port. RequestProtocol The version of HTTP requested. RequestLine RequestMethod + RequestPath + RequestProtocol RequestContentSize The number of bytes in the request entity (a.k.a. body) sent by the client. OriginDuration The time taken by the origin server ('upstream') to return its response. OriginContentSize The content length specified by the origin server, or 0 if unspecified. OriginStatus The HTTP status code returned by the origin server. If the request was handled by this Traefik instance (e.g. with a redirect), then this value will be absent. OriginStatusLine OriginStatus + Status code explanation DownstreamStatus The HTTP status code returned to the client. DownstreamStatusLine DownstreamStatus + Status code explanation DownstreamContentSize The number of bytes in the response entity returned to the client. This is in addition to the \"Content-Length\" header, which may be present in the origin response. RequestCount The number of requests received since the Traefik instance started. GzipRatio The response body compression ratio achieved. Overhead The processing time overhead caused by Traefik. RetryAttempts The amount of attempts the request was retried. Log Rotation \u00b6 Traefik will close and reopen its log files, assuming they're configured, on receipt of a USR1 signal. This allows the logs to be rotated and processed by an external program, such as logrotate . Warning This does not work on Windows due to the lack of USR signals.","title":"Access Logs"},{"location":"observability/access-logs/#access-logs","text":"Who Calls Whom? By default, logs are written to stdout, in text format.","title":"Access Logs"},{"location":"observability/access-logs/#configuration","text":"To enable the access logs: File (TOML) [accessLog] File (YAML) accessLog: {} CLI --accesslog=true","title":"Configuration"},{"location":"observability/access-logs/#filepath","text":"By default access logs are written to the standard output. To write the logs into a log file, use the filePath option.","title":"filePath"},{"location":"observability/access-logs/#format","text":"By default, logs are written using the Common Log Format (CLF). To write logs in JSON, use json in the format option. If the given format is unsupported, the default (CLF) is used instead. Common Log Format <remote_IP_address> - <client_user_name_if_available> [<timestamp>] \"<request_method> <request_path> <request_protocol>\" <origin_server_HTTP_status> <origin_server_content_size> \"<request_referrer>\" \"<request_user_agent>\" <number_of_requests_received_since_Traefik_started> \"<Traefik_frontend_name>\" \"<Traefik_backend_URL>\" <request_duration_in_ms>ms","title":"format"},{"location":"observability/access-logs/#bufferingsize","text":"To write the logs in an asynchronous fashion, specify a bufferingSize option. This option represents the number of log lines Traefik will keep in memory before writing them to the selected output. In some cases, this option can greatly help performances. File (TOML) # Configuring a buffer of 100 lines [accessLog] filePath = \"/path/to/access.log\" bufferingSize = 100 File (YAML) # Configuring a buffer of 100 lines accessLog: filePath: \"/path/to/access.log\" bufferingSize: 100 CLI # Configuring a buffer of 100 lines --accesslog=true --accesslog.filepath=/path/to/access.log --accesslog.bufferingsize=100","title":"bufferingSize"},{"location":"observability/access-logs/#filtering","text":"To filter logs, you can specify a set of filters which are logically \"OR-connected\". Thus, specifying multiple filters will keep more access logs than specifying only one. The available filters are: statusCodes , to limit the access logs to requests with a status codes in the specified range retryAttempts , to keep the access logs when at least one retry has happened minDuration , to keep access logs when requests take longer than the specified duration File (TOML) # Configuring Multiple Filters [accessLog] filePath = \"/path/to/access.log\" format = \"json\" [accessLog.filters] statusCodes = [\"200\", \"300-302\"] retryAttempts = true minDuration = \"10ms\" File (YAML) # Configuring Multiple Filters accessLog: filePath: \"/path/to/access.log\" format: json filters: statusCodes: - \"200\" - \"300-302\" retryAttempts: true minDuration: \"10ms\" CLI # Configuring Multiple Filters --accesslog=true --accesslog.filepath=/path/to/access.log --accesslog.format=json --accesslog.filters.statuscodes=200,300-302 --accesslog.filters.retryattempts --accesslog.filters.minduration=10ms","title":"Filtering"},{"location":"observability/access-logs/#limiting-the-fields","text":"You can decide to limit the logged fields/headers to a given list with the fields.names and fields.header options Each field can be set to: keep to keep the value drop to drop the value redact to replace the value with \"redacted\" The defaultMode for fields.header is drop . File (TOML) # Limiting the Logs to Specific Fields [accessLog] filePath = \"/path/to/access.log\" format = \"json\" [accessLog.fields] defaultMode = \"keep\" [accessLog.fields.names] \"ClientUsername\" = \"drop\" [accessLog.fields.headers] defaultMode = \"keep\" [accessLog.fields.headers.names] \"User-Agent\" = \"redact\" \"Authorization\" = \"drop\" \"Content-Type\" = \"keep\" File (YAML) # Limiting the Logs to Specific Fields accessLog: filePath: \"/path/to/access.log\" format: json fields: defaultMode: keep names: ClientUsername: drop headers: defaultMode: keep names: User-Agent: redact Authorization: drop Content-Type: keep CLI # Limiting the Logs to Specific Fields --accesslog=true --accesslog.filepath=/path/to/access.log --accesslog.format=json --accesslog.fields.defaultmode=keep --accesslog.fields.names.ClientUsername=drop --accesslog.fields.headers.defaultmode=keep --accesslog.fields.headers.names.User-Agent=redact --accesslog.fields.headers.names.Authorization=drop --accesslog.fields.headers.names.Content-Type=keep Available Fields Field Description StartUTC The time at which request processing started. StartLocal The local time at which request processing started. Duration The total time taken (in nanoseconds) by processing the response, including the origin server's time but not the log writing time. FrontendName The name of the Traefik frontend. BackendName The name of the Traefik backend. BackendURL The URL of the Traefik backend. BackendAddr The IP:port of the Traefik backend (extracted from BackendURL ) ClientAddr The remote address in its original form (usually IP:port). ClientHost The remote IP address from which the client request was received. ClientPort The remote TCP port from which the client request was received. ClientUsername The username provided in the URL, if present. RequestAddr The HTTP Host header (usually IP:port). This is treated as not a header by the Go API. RequestHost The HTTP Host server name (not including port). RequestPort The TCP port from the HTTP Host. RequestMethod The HTTP method. RequestPath The HTTP request URI, not including the scheme, host or port. RequestProtocol The version of HTTP requested. RequestLine RequestMethod + RequestPath + RequestProtocol RequestContentSize The number of bytes in the request entity (a.k.a. body) sent by the client. OriginDuration The time taken by the origin server ('upstream') to return its response. OriginContentSize The content length specified by the origin server, or 0 if unspecified. OriginStatus The HTTP status code returned by the origin server. If the request was handled by this Traefik instance (e.g. with a redirect), then this value will be absent. OriginStatusLine OriginStatus + Status code explanation DownstreamStatus The HTTP status code returned to the client. DownstreamStatusLine DownstreamStatus + Status code explanation DownstreamContentSize The number of bytes in the response entity returned to the client. This is in addition to the \"Content-Length\" header, which may be present in the origin response. RequestCount The number of requests received since the Traefik instance started. GzipRatio The response body compression ratio achieved. Overhead The processing time overhead caused by Traefik. RetryAttempts The amount of attempts the request was retried.","title":"Limiting the Fields"},{"location":"observability/access-logs/#log-rotation","text":"Traefik will close and reopen its log files, assuming they're configured, on receipt of a USR1 signal. This allows the logs to be rotated and processed by an external program, such as logrotate . Warning This does not work on Windows due to the lack of USR signals.","title":"Log Rotation"},{"location":"observability/logs/","text":"Logs \u00b6 Reading What's Happening By default, logs are written to stdout, in text format. Configuration \u00b6 General \u00b6 Traefik logs concern everything that happens to Traefik itself (startup, configuration, events, shutdown, and so on). filePath \u00b6 By default, the logs are written to the standard output. You can configure a file path instead using the filePath option. File (TOML) # Writing Logs to a File [log] filePath = \"/path/to/traefik.log\" File (YAML) # Writing Logs to a File log: filePath: \"/path/to/traefik.log\" CLI # Writing Logs to a File --log.filePath=/path/to/traefik.log format \u00b6 By default, the logs use a text format ( common ), but you can also ask for the json format in the format option. File (TOML) # Writing Logs to a File, in JSON [log] filePath = \"/path/to/log-file.log\" format = \"json\" File (YAML) # Writing Logs to a File, in JSON log: filePath: \"/path/to/log-file.log\" format: json CLI # Writing Logs to a File, in JSON --log.filePath=/path/to/traefik.log --log.format=json level \u00b6 By default, the level is set to ERROR . Alternative logging levels are DEBUG , PANIC , FATAL , ERROR , WARN , and INFO . File (TOML) [log] level = \"DEBUG\" File (YAML) log: level: DEBUG CLI --log.level=DEBUG Log Rotation \u00b6 Traefik will close and reopen its log files, assuming they're configured, on receipt of a USR1 signal. This allows the logs to be rotated and processed by an external program, such as logrotate . Warning This does not work on Windows due to the lack of USR signals.","title":"Logs"},{"location":"observability/logs/#logs","text":"Reading What's Happening By default, logs are written to stdout, in text format.","title":"Logs"},{"location":"observability/logs/#configuration","text":"","title":"Configuration"},{"location":"observability/logs/#general","text":"Traefik logs concern everything that happens to Traefik itself (startup, configuration, events, shutdown, and so on).","title":"General"},{"location":"observability/logs/#filepath","text":"By default, the logs are written to the standard output. You can configure a file path instead using the filePath option. File (TOML) # Writing Logs to a File [log] filePath = \"/path/to/traefik.log\" File (YAML) # Writing Logs to a File log: filePath: \"/path/to/traefik.log\" CLI # Writing Logs to a File --log.filePath=/path/to/traefik.log","title":"filePath"},{"location":"observability/logs/#format","text":"By default, the logs use a text format ( common ), but you can also ask for the json format in the format option. File (TOML) # Writing Logs to a File, in JSON [log] filePath = \"/path/to/log-file.log\" format = \"json\" File (YAML) # Writing Logs to a File, in JSON log: filePath: \"/path/to/log-file.log\" format: json CLI # Writing Logs to a File, in JSON --log.filePath=/path/to/traefik.log --log.format=json","title":"format"},{"location":"observability/logs/#level","text":"By default, the level is set to ERROR . Alternative logging levels are DEBUG , PANIC , FATAL , ERROR , WARN , and INFO . File (TOML) [log] level = \"DEBUG\" File (YAML) log: level: DEBUG CLI --log.level=DEBUG","title":"level"},{"location":"observability/logs/#log-rotation","text":"Traefik will close and reopen its log files, assuming they're configured, on receipt of a USR1 signal. This allows the logs to be rotated and processed by an external program, such as logrotate . Warning This does not work on Windows due to the lack of USR signals.","title":"Log Rotation"},{"location":"observability/metrics/datadog/","text":"Datadog \u00b6 To enable the Datadog: File (TOML) [metrics] [metrics.datadog] File (YAML) metrics: datadog: {} CLI --metrics.datadog=true address \u00b6 Required, Default=\"127.0.0.1:8125\" Address instructs exporter to send metrics to datadog-agent at this address. File (TOML) [metrics] [metrics.datadog] address = \"127.0.0.1:8125\" File (YAML) metrics: datadog: address: 127.0.0.1:8125 CLI --metrics.datadog.address=127.0.0.1:8125 addEntryPointsLabels \u00b6 Optional, Default=true Enable metrics on entry points. File (TOML) [metrics] [metrics.datadog] addEntryPointsLabels = true File (YAML) metrics: datadog: addEntryPointsLabels: true CLI --metrics.datadog.addEntryPointsLabels=true addServicesLabels \u00b6 Optional, Default=true Enable metrics on services. File (TOML) [metrics] [metrics.datadog] addServicesLabels = true File (YAML) metrics: datadog: addServicesLabels: true CLI --metrics.datadog.addServicesLabels=true pushInterval \u00b6 Optional, Default=10s The interval used by the exporter to push metrics to datadog-agent. File (TOML) [metrics] [metrics.datadog] pushInterval = 10s File (YAML) metrics: datadog: pushInterval: 10s CLI --metrics.datadog.pushInterval=10s","title":"Datadog"},{"location":"observability/metrics/datadog/#datadog","text":"To enable the Datadog: File (TOML) [metrics] [metrics.datadog] File (YAML) metrics: datadog: {} CLI --metrics.datadog=true","title":"Datadog"},{"location":"observability/metrics/datadog/#address","text":"Required, Default=\"127.0.0.1:8125\" Address instructs exporter to send metrics to datadog-agent at this address. File (TOML) [metrics] [metrics.datadog] address = \"127.0.0.1:8125\" File (YAML) metrics: datadog: address: 127.0.0.1:8125 CLI --metrics.datadog.address=127.0.0.1:8125","title":"address"},{"location":"observability/metrics/datadog/#addentrypointslabels","text":"Optional, Default=true Enable metrics on entry points. File (TOML) [metrics] [metrics.datadog] addEntryPointsLabels = true File (YAML) metrics: datadog: addEntryPointsLabels: true CLI --metrics.datadog.addEntryPointsLabels=true","title":"addEntryPointsLabels"},{"location":"observability/metrics/datadog/#addserviceslabels","text":"Optional, Default=true Enable metrics on services. File (TOML) [metrics] [metrics.datadog] addServicesLabels = true File (YAML) metrics: datadog: addServicesLabels: true CLI --metrics.datadog.addServicesLabels=true","title":"addServicesLabels"},{"location":"observability/metrics/datadog/#pushinterval","text":"Optional, Default=10s The interval used by the exporter to push metrics to datadog-agent. File (TOML) [metrics] [metrics.datadog] pushInterval = 10s File (YAML) metrics: datadog: pushInterval: 10s CLI --metrics.datadog.pushInterval=10s","title":"pushInterval"},{"location":"observability/metrics/influxdb/","text":"InfluxDB \u00b6 To enable the InfluxDB: File (TOML) [metrics] [metrics.influxDB] File (YAML) metrics: influxDB: {} CLI --metrics.influxdb=true address \u00b6 Required, Default=\"localhost:8089\" Address instructs exporter to send metrics to influxdb at this address. File (TOML) [metrics] [metrics.influxDB] address = \"localhost:8089\" File (YAML) metrics: influxDB: address: localhost:8089 CLI --metrics.influxdb.address=localhost:8089 protocol \u00b6 Required, Default=\"udp\" InfluxDB's address protocol (udp or http). File (TOML) [metrics] [metrics.influxDB] protocol = \"udp\" File (YAML) metrics: influxDB: protocol: udp CLI --metrics.influxdb.protocol=udp database \u00b6 Optional, Default=\"\" InfluxDB database used when protocol is http. File (TOML) [metrics] [metrics.influxDB] database = \"db\" File (YAML) metrics: influxDB: database: \"db\" CLI --metrics.influxdb.database=db retentionPolicy \u00b6 Optional, Default=\"\" InfluxDB retention policy used when protocol is http. File (TOML) [metrics] [metrics.influxDB] retentionPolicy = \"two_hours\" File (YAML) metrics: influxDB: retentionPolicy: \"two_hours\" CLI --metrics.influxdb.retentionPolicy=two_hours username \u00b6 Optional, Default=\"\" InfluxDB username (only with http). File (TOML) [metrics] [metrics.influxDB] username = \"john\" File (YAML) metrics: influxDB: username: \"john\" CLI --metrics.influxdb.username=john password \u00b6 Optional, Default=\"\" InfluxDB password (only with http). File (TOML) [metrics] [metrics.influxDB] password = \"secret\" File (YAML) metrics: influxDB: password: \"secret\" CLI --metrics.influxdb.password=secret addEntryPointsLabels \u00b6 Optional, Default=true Enable metrics on entry points. File (TOML) [metrics] [metrics.influxDB] addEntryPointsLabels = true File (YAML) metrics: influxDB: addEntryPointsLabels: true CLI --metrics.influxdb.addEntryPointsLabels=true addServicesLabels \u00b6 Optional, Default=true Enable metrics on services. File (TOML) [metrics] [metrics.influxDB] addServicesLabels = true File (YAML) metrics: influxDB: addServicesLabels: true CLI --metrics.influxdb.addServicesLabels=true pushInterval \u00b6 Optional, Default=10s The interval used by the exporter to push metrics to influxdb. File (TOML) [metrics] [metrics.influxDB] pushInterval = 10s File (YAML) metrics: influxDB: pushInterval: 10s CLI --metrics.influxdb.pushInterval=10s","title":"InfluxDB"},{"location":"observability/metrics/influxdb/#influxdb","text":"To enable the InfluxDB: File (TOML) [metrics] [metrics.influxDB] File (YAML) metrics: influxDB: {} CLI --metrics.influxdb=true","title":"InfluxDB"},{"location":"observability/metrics/influxdb/#address","text":"Required, Default=\"localhost:8089\" Address instructs exporter to send metrics to influxdb at this address. File (TOML) [metrics] [metrics.influxDB] address = \"localhost:8089\" File (YAML) metrics: influxDB: address: localhost:8089 CLI --metrics.influxdb.address=localhost:8089","title":"address"},{"location":"observability/metrics/influxdb/#protocol","text":"Required, Default=\"udp\" InfluxDB's address protocol (udp or http). File (TOML) [metrics] [metrics.influxDB] protocol = \"udp\" File (YAML) metrics: influxDB: protocol: udp CLI --metrics.influxdb.protocol=udp","title":"protocol"},{"location":"observability/metrics/influxdb/#database","text":"Optional, Default=\"\" InfluxDB database used when protocol is http. File (TOML) [metrics] [metrics.influxDB] database = \"db\" File (YAML) metrics: influxDB: database: \"db\" CLI --metrics.influxdb.database=db","title":"database"},{"location":"observability/metrics/influxdb/#retentionpolicy","text":"Optional, Default=\"\" InfluxDB retention policy used when protocol is http. File (TOML) [metrics] [metrics.influxDB] retentionPolicy = \"two_hours\" File (YAML) metrics: influxDB: retentionPolicy: \"two_hours\" CLI --metrics.influxdb.retentionPolicy=two_hours","title":"retentionPolicy"},{"location":"observability/metrics/influxdb/#username","text":"Optional, Default=\"\" InfluxDB username (only with http). File (TOML) [metrics] [metrics.influxDB] username = \"john\" File (YAML) metrics: influxDB: username: \"john\" CLI --metrics.influxdb.username=john","title":"username"},{"location":"observability/metrics/influxdb/#password","text":"Optional, Default=\"\" InfluxDB password (only with http). File (TOML) [metrics] [metrics.influxDB] password = \"secret\" File (YAML) metrics: influxDB: password: \"secret\" CLI --metrics.influxdb.password=secret","title":"password"},{"location":"observability/metrics/influxdb/#addentrypointslabels","text":"Optional, Default=true Enable metrics on entry points. File (TOML) [metrics] [metrics.influxDB] addEntryPointsLabels = true File (YAML) metrics: influxDB: addEntryPointsLabels: true CLI --metrics.influxdb.addEntryPointsLabels=true","title":"addEntryPointsLabels"},{"location":"observability/metrics/influxdb/#addserviceslabels","text":"Optional, Default=true Enable metrics on services. File (TOML) [metrics] [metrics.influxDB] addServicesLabels = true File (YAML) metrics: influxDB: addServicesLabels: true CLI --metrics.influxdb.addServicesLabels=true","title":"addServicesLabels"},{"location":"observability/metrics/influxdb/#pushinterval","text":"Optional, Default=10s The interval used by the exporter to push metrics to influxdb. File (TOML) [metrics] [metrics.influxDB] pushInterval = 10s File (YAML) metrics: influxDB: pushInterval: 10s CLI --metrics.influxdb.pushInterval=10s","title":"pushInterval"},{"location":"observability/metrics/overview/","text":"Metrics \u00b6 Metrics system Traefik supports 4 metrics backends: Datadog InfluxDB Prometheus StatsD Configuration \u00b6 To enable metrics: File (TOML) [metrics] File (YAML) metrics: {} CLI --metrics=true","title":"Overview"},{"location":"observability/metrics/overview/#metrics","text":"Metrics system Traefik supports 4 metrics backends: Datadog InfluxDB Prometheus StatsD","title":"Metrics"},{"location":"observability/metrics/overview/#configuration","text":"To enable metrics: File (TOML) [metrics] File (YAML) metrics: {} CLI --metrics=true","title":"Configuration"},{"location":"observability/metrics/prometheus/","text":"Prometheus \u00b6 To enable the Prometheus: File (TOML) [metrics] [metrics.prometheus] File (YAML) metrics: prometheus: {} CLI --metrics.prometheus=true buckets \u00b6 Optional, Default=\"0.100000, 0.300000, 1.200000, 5.000000\" Buckets for latency metrics. File (TOML) [metrics] [metrics.prometheus] buckets = [0.1,0.3,1.2,5.0] File (YAML) metrics: prometheus: buckets: - 0.1 - 0.3 - 1.2 - 5.0 CLI --metrics.prometheus.buckets=0.100000, 0.300000, 1.200000, 5.000000 addEntryPointsLabels \u00b6 Optional, Default=true Enable metrics on entry points. File (TOML) [metrics] [metrics.prometheus] addEntryPointsLabels = true File (YAML) metrics: prometheus: addEntryPointsLabels: true CLI --metrics.prometheus.addEntryPointsLabels=true addServicesLabels \u00b6 Optional, Default=true Enable metrics on services. File (TOML) [metrics] [metrics.prometheus] addServicesLabels = true File (YAML) metrics: prometheus: addServicesLabels: true CLI --metrics.prometheus.addServicesLabels=true entryPoint \u00b6 Optional, Default=traefik Entry point used to expose metrics. File (TOML) [entryPoints] [entryPoints.metrics] address = \":8082\" [metrics] [metrics.prometheus] entryPoint = \"metrics\" File (YAML) entryPoints: metrics: address: \":8082\" metrics: prometheus: entryPoint: metrics CLI --entryPoints.metrics.address=:8082 --metrics.prometheus.entryPoint=metrics","title":"Prometheus"},{"location":"observability/metrics/prometheus/#prometheus","text":"To enable the Prometheus: File (TOML) [metrics] [metrics.prometheus] File (YAML) metrics: prometheus: {} CLI --metrics.prometheus=true","title":"Prometheus"},{"location":"observability/metrics/prometheus/#buckets","text":"Optional, Default=\"0.100000, 0.300000, 1.200000, 5.000000\" Buckets for latency metrics. File (TOML) [metrics] [metrics.prometheus] buckets = [0.1,0.3,1.2,5.0] File (YAML) metrics: prometheus: buckets: - 0.1 - 0.3 - 1.2 - 5.0 CLI --metrics.prometheus.buckets=0.100000, 0.300000, 1.200000, 5.000000","title":"buckets"},{"location":"observability/metrics/prometheus/#addentrypointslabels","text":"Optional, Default=true Enable metrics on entry points. File (TOML) [metrics] [metrics.prometheus] addEntryPointsLabels = true File (YAML) metrics: prometheus: addEntryPointsLabels: true CLI --metrics.prometheus.addEntryPointsLabels=true","title":"addEntryPointsLabels"},{"location":"observability/metrics/prometheus/#addserviceslabels","text":"Optional, Default=true Enable metrics on services. File (TOML) [metrics] [metrics.prometheus] addServicesLabels = true File (YAML) metrics: prometheus: addServicesLabels: true CLI --metrics.prometheus.addServicesLabels=true","title":"addServicesLabels"},{"location":"observability/metrics/prometheus/#entrypoint","text":"Optional, Default=traefik Entry point used to expose metrics. File (TOML) [entryPoints] [entryPoints.metrics] address = \":8082\" [metrics] [metrics.prometheus] entryPoint = \"metrics\" File (YAML) entryPoints: metrics: address: \":8082\" metrics: prometheus: entryPoint: metrics CLI --entryPoints.metrics.address=:8082 --metrics.prometheus.entryPoint=metrics","title":"entryPoint"},{"location":"observability/metrics/statsd/","text":"StatsD \u00b6 To enable the Statsd: File (TOML) [metrics] [metrics.statsD] File (YAML) metrics: statsD: {} CLI --metrics.statsd=true address \u00b6 Required, Default=\"localhost:8125\" Address instructs exporter to send metrics to statsd at this address. File (TOML) [metrics] [metrics.statsD] address = \"localhost:8125\" File (YAML) metrics: statsD: address: localhost:8125 CLI --metrics.statsd.address=localhost:8125 addEntryPointsLabels \u00b6 Optional, Default=true Enable metrics on entry points. File (TOML) [metrics] [metrics.statsD] addEntryPointsLabels = true File (YAML) metrics: statsD: addEntryPointsLabels: true CLI --metrics.statsd.addEntryPointsLabels=true addServicesLabels \u00b6 Optional, Default=true Enable metrics on services. File (TOML) [metrics] [metrics.statsD] addServicesLabels = true File (YAML) metrics: statsD: addServicesLabels: true CLI --metrics.statsd.addServicesLabels=true pushInterval \u00b6 Optional, Default=10s The interval used by the exporter to push metrics to statsD. File (TOML) [metrics] [metrics.statsD] pushInterval = 10s File (YAML) metrics: statsD: pushInterval: 10s CLI --metrics.statsd.pushInterval=10s","title":"StatsD"},{"location":"observability/metrics/statsd/#statsd","text":"To enable the Statsd: File (TOML) [metrics] [metrics.statsD] File (YAML) metrics: statsD: {} CLI --metrics.statsd=true","title":"StatsD"},{"location":"observability/metrics/statsd/#address","text":"Required, Default=\"localhost:8125\" Address instructs exporter to send metrics to statsd at this address. File (TOML) [metrics] [metrics.statsD] address = \"localhost:8125\" File (YAML) metrics: statsD: address: localhost:8125 CLI --metrics.statsd.address=localhost:8125","title":"address"},{"location":"observability/metrics/statsd/#addentrypointslabels","text":"Optional, Default=true Enable metrics on entry points. File (TOML) [metrics] [metrics.statsD] addEntryPointsLabels = true File (YAML) metrics: statsD: addEntryPointsLabels: true CLI --metrics.statsd.addEntryPointsLabels=true","title":"addEntryPointsLabels"},{"location":"observability/metrics/statsd/#addserviceslabels","text":"Optional, Default=true Enable metrics on services. File (TOML) [metrics] [metrics.statsD] addServicesLabels = true File (YAML) metrics: statsD: addServicesLabels: true CLI --metrics.statsd.addServicesLabels=true","title":"addServicesLabels"},{"location":"observability/metrics/statsd/#pushinterval","text":"Optional, Default=10s The interval used by the exporter to push metrics to statsD. File (TOML) [metrics] [metrics.statsD] pushInterval = 10s File (YAML) metrics: statsD: pushInterval: 10s CLI --metrics.statsd.pushInterval=10s","title":"pushInterval"},{"location":"observability/tracing/datadog/","text":"Datadog \u00b6 To enable the Datadog: File (TOML) [tracing] [tracing.datadog] File (YAML) tracing: datadog: {} CLI --tracing.datadog=true localAgentHostPort \u00b6 Required, Default=\"127.0.0.1:8126\" Local Agent Host Port instructs reporter to send spans to datadog-tracing-agent at this address. File (TOML) [tracing] [tracing.datadog] localAgentHostPort = \"127.0.0.1:8126\" File (YAML) tracing: datadog: localAgentHostPort: 127.0.0.1:8126 CLI --tracing.datadog.localAgentHostPort=127.0.0.1:8126 debug \u00b6 Optional, Default=false Enable Datadog debug. File (TOML) [tracing] [tracing.datadog] debug = true File (YAML) tracing: datadog: debug: true CLI --tracing.datadog.debug=true globalTag \u00b6 Optional, Default=empty Apply shared tag in a form of Key:Value to all the traces. File (TOML) [tracing] [tracing.datadog] globalTag = \"sample\" File (YAML) tracing: datadog: globalTag: sample CLI --tracing.datadog.globalTag=sample prioritySampling \u00b6 Optional, Default=false Enable priority sampling. When using distributed tracing, this option must be enabled in order to get all the parts of a distributed trace sampled. File (TOML) [tracing] [tracing.datadog] prioritySampling = true File (YAML) tracing: datadog: prioritySampling: true CLI --tracing.datadog.prioritySampling=true","title":"Datadog"},{"location":"observability/tracing/datadog/#datadog","text":"To enable the Datadog: File (TOML) [tracing] [tracing.datadog] File (YAML) tracing: datadog: {} CLI --tracing.datadog=true","title":"Datadog"},{"location":"observability/tracing/datadog/#localagenthostport","text":"Required, Default=\"127.0.0.1:8126\" Local Agent Host Port instructs reporter to send spans to datadog-tracing-agent at this address. File (TOML) [tracing] [tracing.datadog] localAgentHostPort = \"127.0.0.1:8126\" File (YAML) tracing: datadog: localAgentHostPort: 127.0.0.1:8126 CLI --tracing.datadog.localAgentHostPort=127.0.0.1:8126","title":"localAgentHostPort"},{"location":"observability/tracing/datadog/#debug","text":"Optional, Default=false Enable Datadog debug. File (TOML) [tracing] [tracing.datadog] debug = true File (YAML) tracing: datadog: debug: true CLI --tracing.datadog.debug=true","title":"debug"},{"location":"observability/tracing/datadog/#globaltag","text":"Optional, Default=empty Apply shared tag in a form of Key:Value to all the traces. File (TOML) [tracing] [tracing.datadog] globalTag = \"sample\" File (YAML) tracing: datadog: globalTag: sample CLI --tracing.datadog.globalTag=sample","title":"globalTag"},{"location":"observability/tracing/datadog/#prioritysampling","text":"Optional, Default=false Enable priority sampling. When using distributed tracing, this option must be enabled in order to get all the parts of a distributed trace sampled. File (TOML) [tracing] [tracing.datadog] prioritySampling = true File (YAML) tracing: datadog: prioritySampling: true CLI --tracing.datadog.prioritySampling=true","title":"prioritySampling"},{"location":"observability/tracing/haystack/","text":"Haystack \u00b6 To enable the Haystack: File (TOML) [tracing] [tracing.haystack] File (YAML) tracing: haystack: {} CLI --tracing.haystack=true localAgentHost \u00b6 Require, Default=\"127.0.0.1\" Local Agent Host instructs reporter to send spans to haystack-agent at this address. File (TOML) [tracing] [tracing.haystack] localAgentHost = \"127.0.0.1\" File (YAML) tracing: haystack: localAgentHost: 127.0.0.1 CLI --tracing.haystack.localAgentHost=127.0.0.1 localAgentPort \u00b6 Require, Default=42699 Local Agent port instructs reporter to send spans to the haystack-agent at this port. File (TOML) [tracing] [tracing.haystack] localAgentPort = 42699 File (YAML) tracing: haystack: localAgentPort: 42699 CLI --tracing.haystack.localAgentPort=42699 globalTag \u00b6 Optional, Default=empty Apply shared tag in a form of Key:Value to all the traces. File (TOML) [tracing] [tracing.haystack] globalTag = \"sample:test\" File (YAML) tracing: haystack: globalTag: sample:test CLI --tracing.haystack.globalTag=sample:test traceIDHeaderName \u00b6 Optional, Default=empty Specifies the header name that will be used to store the trace ID. File (TOML) [tracing] [tracing.haystack] traceIDHeaderName = \"sample\" File (YAML) tracing: haystack: traceIDHeaderName: sample CLI --tracing.haystack.traceIDHeaderName=sample parentIDHeaderName \u00b6 Optional, Default=empty Specifies the header name that will be used to store the span ID. File (TOML) [tracing] [tracing.haystack] parentIDHeaderName = \"sample\" File (YAML) tracing: haystack: parentIDHeaderName: \"sample\" CLI --tracing.haystack.parentIDHeaderName=sample spanIDHeaderName \u00b6 Optional, Default=empty Apply shared tag in a form of Key:Value to all the traces. File (TOML) [tracing] [tracing.haystack] spanIDHeaderName = \"sample:test\" File (YAML) tracing: haystack: spanIDHeaderName: \"sample:test\" CLI --tracing.haystack.spanIDHeaderName=sample:test baggagePrefixHeaderName \u00b6 Optional, Default=empty Specifies the header name prefix that will be used to store baggage items in a map. File (TOML) [tracing] [tracing.haystack] baggagePrefixHeaderName = \"sample\" File (YAML) tracing: haystack: baggagePrefixHeaderName: \"sample\" CLI --tracing.haystack.baggagePrefixHeaderName=sample","title":"Haystack"},{"location":"observability/tracing/haystack/#haystack","text":"To enable the Haystack: File (TOML) [tracing] [tracing.haystack] File (YAML) tracing: haystack: {} CLI --tracing.haystack=true","title":"Haystack"},{"location":"observability/tracing/haystack/#localagenthost","text":"Require, Default=\"127.0.0.1\" Local Agent Host instructs reporter to send spans to haystack-agent at this address. File (TOML) [tracing] [tracing.haystack] localAgentHost = \"127.0.0.1\" File (YAML) tracing: haystack: localAgentHost: 127.0.0.1 CLI --tracing.haystack.localAgentHost=127.0.0.1","title":"localAgentHost"},{"location":"observability/tracing/haystack/#localagentport","text":"Require, Default=42699 Local Agent port instructs reporter to send spans to the haystack-agent at this port. File (TOML) [tracing] [tracing.haystack] localAgentPort = 42699 File (YAML) tracing: haystack: localAgentPort: 42699 CLI --tracing.haystack.localAgentPort=42699","title":"localAgentPort"},{"location":"observability/tracing/haystack/#globaltag","text":"Optional, Default=empty Apply shared tag in a form of Key:Value to all the traces. File (TOML) [tracing] [tracing.haystack] globalTag = \"sample:test\" File (YAML) tracing: haystack: globalTag: sample:test CLI --tracing.haystack.globalTag=sample:test","title":"globalTag"},{"location":"observability/tracing/haystack/#traceidheadername","text":"Optional, Default=empty Specifies the header name that will be used to store the trace ID. File (TOML) [tracing] [tracing.haystack] traceIDHeaderName = \"sample\" File (YAML) tracing: haystack: traceIDHeaderName: sample CLI --tracing.haystack.traceIDHeaderName=sample","title":"traceIDHeaderName"},{"location":"observability/tracing/haystack/#parentidheadername","text":"Optional, Default=empty Specifies the header name that will be used to store the span ID. File (TOML) [tracing] [tracing.haystack] parentIDHeaderName = \"sample\" File (YAML) tracing: haystack: parentIDHeaderName: \"sample\" CLI --tracing.haystack.parentIDHeaderName=sample","title":"parentIDHeaderName"},{"location":"observability/tracing/haystack/#spanidheadername","text":"Optional, Default=empty Apply shared tag in a form of Key:Value to all the traces. File (TOML) [tracing] [tracing.haystack] spanIDHeaderName = \"sample:test\" File (YAML) tracing: haystack: spanIDHeaderName: \"sample:test\" CLI --tracing.haystack.spanIDHeaderName=sample:test","title":"spanIDHeaderName"},{"location":"observability/tracing/haystack/#baggageprefixheadername","text":"Optional, Default=empty Specifies the header name prefix that will be used to store baggage items in a map. File (TOML) [tracing] [tracing.haystack] baggagePrefixHeaderName = \"sample\" File (YAML) tracing: haystack: baggagePrefixHeaderName: \"sample\" CLI --tracing.haystack.baggagePrefixHeaderName=sample","title":"baggagePrefixHeaderName"},{"location":"observability/tracing/instana/","text":"Instana \u00b6 To enable the Instana: File (TOML) [tracing] [tracing.instana] File (YAML) tracing: instana: {} CLI --tracing.instana=true localAgentHost \u00b6 Require, Default=\"127.0.0.1\" Local Agent Host instructs reporter to send spans to instana-agent at this address. File (TOML) [tracing] [tracing.instana] localAgentHost = \"127.0.0.1\" File (YAML) tracing: instana: localAgentHost: 127.0.0.1 CLI --tracing.instana.localAgentHost=127.0.0.1 localAgentPort \u00b6 Require, Default=42699 Local Agent port instructs reporter to send spans to the instana-agent at this port. File (TOML) [tracing] [tracing.instana] localAgentPort = 42699 File (YAML) tracing: instana: localAgentPort: 42699 CLI --tracing.instana.localAgentPort=42699 logLevel \u00b6 Require, Default=\"info\" Set Instana tracer log level. Valid values for logLevel field are: error warn debug info File (TOML) [tracing] [tracing.instana] logLevel = \"info\" File (YAML) tracing: instana: logLevel: info CLI --tracing.instana.logLevel=info","title":"Instana"},{"location":"observability/tracing/instana/#instana","text":"To enable the Instana: File (TOML) [tracing] [tracing.instana] File (YAML) tracing: instana: {} CLI --tracing.instana=true","title":"Instana"},{"location":"observability/tracing/instana/#localagenthost","text":"Require, Default=\"127.0.0.1\" Local Agent Host instructs reporter to send spans to instana-agent at this address. File (TOML) [tracing] [tracing.instana] localAgentHost = \"127.0.0.1\" File (YAML) tracing: instana: localAgentHost: 127.0.0.1 CLI --tracing.instana.localAgentHost=127.0.0.1","title":"localAgentHost"},{"location":"observability/tracing/instana/#localagentport","text":"Require, Default=42699 Local Agent port instructs reporter to send spans to the instana-agent at this port. File (TOML) [tracing] [tracing.instana] localAgentPort = 42699 File (YAML) tracing: instana: localAgentPort: 42699 CLI --tracing.instana.localAgentPort=42699","title":"localAgentPort"},{"location":"observability/tracing/instana/#loglevel","text":"Require, Default=\"info\" Set Instana tracer log level. Valid values for logLevel field are: error warn debug info File (TOML) [tracing] [tracing.instana] logLevel = \"info\" File (YAML) tracing: instana: logLevel: info CLI --tracing.instana.logLevel=info","title":"logLevel"},{"location":"observability/tracing/jaeger/","text":"Jaeger \u00b6 To enable the Jaeger: File (TOML) [tracing] [tracing.jaeger] File (YAML) tracing: jaeger: {} CLI --tracing.jaeger=true Warning Traefik is able to send data over the compact thrift protocol to the Jaeger agent or a Jaeger collector . samplingServerURL \u00b6 Required, Default=\"http://localhost:5778/sampling\" Sampling Server URL is the address of jaeger-agent's HTTP sampling server. File (TOML) [tracing] [tracing.jaeger] samplingServerURL = \"http://localhost:5778/sampling\" File (YAML) tracing: jaeger: samplingServerURL: http://localhost:5778/sampling CLI --tracing.jaeger.samplingServerURL=http://localhost:5778/sampling samplingType \u00b6 Required, Default=\"const\" Sampling Type specifies the type of the sampler: const , probabilistic , rateLimiting . File (TOML) [tracing] [tracing.jaeger] samplingType = \"const\" File (YAML) tracing: jaeger: samplingType: const CLI --tracing.jaeger.samplingType=const samplingParam \u00b6 Required, Default=1.0 Sampling Param is a value passed to the sampler. Valid values for Param field are: for const sampler, 0 or 1 for always false/true respectively for probabilistic sampler, a probability between 0 and 1 for rateLimiting sampler, the number of spans per second File (TOML) [tracing] [tracing.jaeger] samplingParam = 1.0 File (YAML) tracing: jaeger: samplingParam: 1.0 CLI --tracing.jaeger.samplingParam=1.0 localAgentHostPort \u00b6 Required, Default=\"127.0.0.1:6831\" Local Agent Host Port instructs reporter to send spans to jaeger-agent at this address. File (TOML) [tracing] [tracing.jaeger] localAgentHostPort = \"127.0.0.1:6831\" File (YAML) tracing: jaeger: localAgentHostPort: 127.0.0.1:6831 CLI --tracing.jaeger.localAgentHostPort=127.0.0.1:6831 gen128Bit \u00b6 Optional, Default=false Generate 128-bit trace IDs, compatible with OpenCensus. File (TOML) [tracing] [tracing.jaeger] gen128Bit = true File (YAML) tracing: jaeger: gen128Bit: true CLI --tracing.jaeger.gen128Bit propagation \u00b6 Required, Default=\"jaeger\" Set the propagation header type. This can be either: jaeger , jaeger's default trace header. b3 , compatible with OpenZipkin File (TOML) [tracing] [tracing.jaeger] propagation = \"jaeger\" File (YAML) tracing: jaeger: propagation: jaeger CLI --tracing.jaeger.propagation=jaeger traceContextHeaderName \u00b6 Required, Default=\"uber-trace-id\" Trace Context Header Name is the http header name used to propagate tracing context. This must be in lower-case to avoid mismatches when decoding incoming headers. File (TOML) [tracing] [tracing.jaeger] traceContextHeaderName = \"uber-trace-id\" File (YAML) tracing: jaeger: traceContextHeaderName: uber-trace-id CLI --tracing.jaeger.traceContextHeaderName=uber-trace-id collector \u00b6 endpoint \u00b6 Optional, Default=\"\" Collector Endpoint instructs reporter to send spans to jaeger-collector at this URL. File (TOML) [tracing] [tracing.jaeger.collector] endpoint = \"http://127.0.0.1:14268/api/traces?format=jaeger.thrift\" File (YAML) tracing: jaeger: collector: endpoint: http://127.0.0.1:14268/api/traces?format=jaeger.thrift CLI --tracing.jaeger.collector.endpoint=http://127.0.0.1:14268/api/traces?format=jaeger.thrift user \u00b6 Optional, Default=\"\" User instructs reporter to include a user for basic http authentication when sending spans to jaeger-collector. File (TOML) [tracing] [tracing.jaeger.collector] user = \"my-user\" File (YAML) tracing: jaeger: collector: user: my-user CLI --tracing.jaeger.collector.user=my-user password \u00b6 Optional, Default=\"\" Password instructs reporter to include a password for basic http authentication when sending spans to jaeger-collector. File (TOML) [tracing] [tracing.jaeger.collector] password = \"my-password\" File (YAML) tracing: jaeger: collector: password: my-password CLI --tracing.jaeger.collector.password=my-password","title":"Jaeger"},{"location":"observability/tracing/jaeger/#jaeger","text":"To enable the Jaeger: File (TOML) [tracing] [tracing.jaeger] File (YAML) tracing: jaeger: {} CLI --tracing.jaeger=true Warning Traefik is able to send data over the compact thrift protocol to the Jaeger agent or a Jaeger collector .","title":"Jaeger"},{"location":"observability/tracing/jaeger/#samplingserverurl","text":"Required, Default=\"http://localhost:5778/sampling\" Sampling Server URL is the address of jaeger-agent's HTTP sampling server. File (TOML) [tracing] [tracing.jaeger] samplingServerURL = \"http://localhost:5778/sampling\" File (YAML) tracing: jaeger: samplingServerURL: http://localhost:5778/sampling CLI --tracing.jaeger.samplingServerURL=http://localhost:5778/sampling","title":"samplingServerURL"},{"location":"observability/tracing/jaeger/#samplingtype","text":"Required, Default=\"const\" Sampling Type specifies the type of the sampler: const , probabilistic , rateLimiting . File (TOML) [tracing] [tracing.jaeger] samplingType = \"const\" File (YAML) tracing: jaeger: samplingType: const CLI --tracing.jaeger.samplingType=const","title":"samplingType"},{"location":"observability/tracing/jaeger/#samplingparam","text":"Required, Default=1.0 Sampling Param is a value passed to the sampler. Valid values for Param field are: for const sampler, 0 or 1 for always false/true respectively for probabilistic sampler, a probability between 0 and 1 for rateLimiting sampler, the number of spans per second File (TOML) [tracing] [tracing.jaeger] samplingParam = 1.0 File (YAML) tracing: jaeger: samplingParam: 1.0 CLI --tracing.jaeger.samplingParam=1.0","title":"samplingParam"},{"location":"observability/tracing/jaeger/#localagenthostport","text":"Required, Default=\"127.0.0.1:6831\" Local Agent Host Port instructs reporter to send spans to jaeger-agent at this address. File (TOML) [tracing] [tracing.jaeger] localAgentHostPort = \"127.0.0.1:6831\" File (YAML) tracing: jaeger: localAgentHostPort: 127.0.0.1:6831 CLI --tracing.jaeger.localAgentHostPort=127.0.0.1:6831","title":"localAgentHostPort"},{"location":"observability/tracing/jaeger/#gen128bit","text":"Optional, Default=false Generate 128-bit trace IDs, compatible with OpenCensus. File (TOML) [tracing] [tracing.jaeger] gen128Bit = true File (YAML) tracing: jaeger: gen128Bit: true CLI --tracing.jaeger.gen128Bit","title":"gen128Bit"},{"location":"observability/tracing/jaeger/#propagation","text":"Required, Default=\"jaeger\" Set the propagation header type. This can be either: jaeger , jaeger's default trace header. b3 , compatible with OpenZipkin File (TOML) [tracing] [tracing.jaeger] propagation = \"jaeger\" File (YAML) tracing: jaeger: propagation: jaeger CLI --tracing.jaeger.propagation=jaeger","title":"propagation"},{"location":"observability/tracing/jaeger/#tracecontextheadername","text":"Required, Default=\"uber-trace-id\" Trace Context Header Name is the http header name used to propagate tracing context. This must be in lower-case to avoid mismatches when decoding incoming headers. File (TOML) [tracing] [tracing.jaeger] traceContextHeaderName = \"uber-trace-id\" File (YAML) tracing: jaeger: traceContextHeaderName: uber-trace-id CLI --tracing.jaeger.traceContextHeaderName=uber-trace-id","title":"traceContextHeaderName"},{"location":"observability/tracing/jaeger/#collector","text":"","title":"collector"},{"location":"observability/tracing/jaeger/#endpoint","text":"Optional, Default=\"\" Collector Endpoint instructs reporter to send spans to jaeger-collector at this URL. File (TOML) [tracing] [tracing.jaeger.collector] endpoint = \"http://127.0.0.1:14268/api/traces?format=jaeger.thrift\" File (YAML) tracing: jaeger: collector: endpoint: http://127.0.0.1:14268/api/traces?format=jaeger.thrift CLI --tracing.jaeger.collector.endpoint=http://127.0.0.1:14268/api/traces?format=jaeger.thrift","title":"endpoint"},{"location":"observability/tracing/jaeger/#user","text":"Optional, Default=\"\" User instructs reporter to include a user for basic http authentication when sending spans to jaeger-collector. File (TOML) [tracing] [tracing.jaeger.collector] user = \"my-user\" File (YAML) tracing: jaeger: collector: user: my-user CLI --tracing.jaeger.collector.user=my-user","title":"user"},{"location":"observability/tracing/jaeger/#password","text":"Optional, Default=\"\" Password instructs reporter to include a password for basic http authentication when sending spans to jaeger-collector. File (TOML) [tracing] [tracing.jaeger.collector] password = \"my-password\" File (YAML) tracing: jaeger: collector: password: my-password CLI --tracing.jaeger.collector.password=my-password","title":"password"},{"location":"observability/tracing/overview/","text":"Tracing \u00b6 Visualize the Requests Flow The tracing system allows developers to visualize call flows in their infrastructure. Traefik uses OpenTracing, an open standard designed for distributed tracing. Traefik supports five tracing backends: Jaeger Zipkin Datadog Instana Haystack Configuration \u00b6 By default, Traefik uses Jaeger as tracing backend. To enable the tracing: File (TOML) [tracing] File (YAML) tracing: {} CLI --tracing=true Common Options \u00b6 serviceName \u00b6 Required, Default=\"traefik\" Service name used in selected backend. File (TOML) [tracing] serviceName = \"traefik\" File (YAML) tracing: serviceName: traefik CLI --tracing.serviceName=traefik spanNameLimit \u00b6 Required, Default=0 Span name limit allows for name truncation in case of very long names. This can prevent certain tracing providers to drop traces that exceed their length limits. 0 means no truncation will occur. File (TOML) [tracing] spanNameLimit = 150 File (YAML) tracing: spanNameLimit: 150 CLI --tracing.spanNameLimit=150","title":"Overview"},{"location":"observability/tracing/overview/#tracing","text":"Visualize the Requests Flow The tracing system allows developers to visualize call flows in their infrastructure. Traefik uses OpenTracing, an open standard designed for distributed tracing. Traefik supports five tracing backends: Jaeger Zipkin Datadog Instana Haystack","title":"Tracing"},{"location":"observability/tracing/overview/#configuration","text":"By default, Traefik uses Jaeger as tracing backend. To enable the tracing: File (TOML) [tracing] File (YAML) tracing: {} CLI --tracing=true","title":"Configuration"},{"location":"observability/tracing/overview/#common-options","text":"","title":"Common Options"},{"location":"observability/tracing/overview/#servicename","text":"Required, Default=\"traefik\" Service name used in selected backend. File (TOML) [tracing] serviceName = \"traefik\" File (YAML) tracing: serviceName: traefik CLI --tracing.serviceName=traefik","title":"serviceName"},{"location":"observability/tracing/overview/#spannamelimit","text":"Required, Default=0 Span name limit allows for name truncation in case of very long names. This can prevent certain tracing providers to drop traces that exceed their length limits. 0 means no truncation will occur. File (TOML) [tracing] spanNameLimit = 150 File (YAML) tracing: spanNameLimit: 150 CLI --tracing.spanNameLimit=150","title":"spanNameLimit"},{"location":"observability/tracing/zipkin/","text":"Zipkin \u00b6 To enable the Zipkin: File (TOML) [tracing] [tracing.zipkin] File (YAML) tracing: zipkin: {} CLI --tracing.zipkin=true httpEndpoint \u00b6 Required, Default=\"http://localhost:9411/api/v2/spans\" Zipkin HTTP endpoint used to send data. File (TOML) [tracing] [tracing.zipkin] httpEndpoint = \"http://localhost:9411/api/v2/spans\" File (YAML) tracing: zipkin: httpEndpoint: http://localhost:9411/api/v2/spans CLI --tracing.zipkin.httpEndpoint=http://localhost:9411/api/v2/spans sameSpan \u00b6 Optional, Default=false Use Zipkin SameSpan RPC style traces. File (TOML) [tracing] [tracing.zipkin] sameSpan = true File (YAML) tracing: zipkin: sameSpan: true CLI --tracing.zipkin.sameSpan=true id128Bit \u00b6 Optional, Default=true Use Zipkin 128 bit trace IDs. File (TOML) [tracing] [tracing.zipkin] id128Bit = false File (YAML) tracing: zipkin: id128Bit: false CLI --tracing.zipkin.id128Bit=false sampleRate \u00b6 Required, Default=1.0 The rate between 0.0 and 1.0 of requests to trace. File (TOML) [tracing] [tracing.zipkin] sampleRate = 0.2 File (YAML) tracing: zipkin: sampleRate: 0.2 CLI --tracing.zipkin.sampleRate=0.2","title":"Zipkin"},{"location":"observability/tracing/zipkin/#zipkin","text":"To enable the Zipkin: File (TOML) [tracing] [tracing.zipkin] File (YAML) tracing: zipkin: {} CLI --tracing.zipkin=true","title":"Zipkin"},{"location":"observability/tracing/zipkin/#httpendpoint","text":"Required, Default=\"http://localhost:9411/api/v2/spans\" Zipkin HTTP endpoint used to send data. File (TOML) [tracing] [tracing.zipkin] httpEndpoint = \"http://localhost:9411/api/v2/spans\" File (YAML) tracing: zipkin: httpEndpoint: http://localhost:9411/api/v2/spans CLI --tracing.zipkin.httpEndpoint=http://localhost:9411/api/v2/spans","title":"httpEndpoint"},{"location":"observability/tracing/zipkin/#samespan","text":"Optional, Default=false Use Zipkin SameSpan RPC style traces. File (TOML) [tracing] [tracing.zipkin] sameSpan = true File (YAML) tracing: zipkin: sameSpan: true CLI --tracing.zipkin.sameSpan=true","title":"sameSpan"},{"location":"observability/tracing/zipkin/#id128bit","text":"Optional, Default=true Use Zipkin 128 bit trace IDs. File (TOML) [tracing] [tracing.zipkin] id128Bit = false File (YAML) tracing: zipkin: id128Bit: false CLI --tracing.zipkin.id128Bit=false","title":"id128Bit"},{"location":"observability/tracing/zipkin/#samplerate","text":"Required, Default=1.0 The rate between 0.0 and 1.0 of requests to trace. File (TOML) [tracing] [tracing.zipkin] sampleRate = 0.2 File (YAML) tracing: zipkin: sampleRate: 0.2 CLI --tracing.zipkin.sampleRate=0.2","title":"sampleRate"},{"location":"operations/api/","text":"API \u00b6 Traefik exposes a number of information through an API handler, such as the configuration of all routers, services, middlewares, etc. As with all features of Traefik, this handler can be enabled with the static configuration . Security \u00b6 Enabling the API in production is not recommended, because it will expose all configuration elements, including sensitive data. In production, it should be at least secured by authentication and authorizations. A good sane default (non exhaustive) set of recommendations would be to apply the following protection mechanisms: At the transport level: NOT publicly exposing the API's port, keeping it restricted to internal networks (as in the principle of least privilege , applied to networks). Configuration \u00b6 If you enable the API, a new special service named api@internal is created and can then be referenced in a router. To enable the API handler, use the following option on the static configuration : File (TOML) # Static Configuration [api] File (YAML) # Static Configuration api: {} CLI --api=true And then define a routing configuration on Traefik itself with the dynamic configuration : Docker # Dynamic Configuration labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" Docker (Swarm) # Dynamic Configuration deploy: labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" # Dummy service for Swarm port detection. The port can be any valid integer value. - \"traefik.http.services.dummy-svc.loadbalancer.server.port=9999\" Marathon \"labels\": { \"traefik.http.routers.api.rule\": \"Host(`traefik.domain.com`)\", \"traefik.http.routers.api.service\": \"api@internal\", \"traefik.http.routers.api.middlewares\": \"auth\", \"traefik.http.middlewares.auth.basicauth.users\": \"test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" } Rancher # Dynamic Configuration labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" File (TOML) # Dynamic Configuration [http.routers.my-api] rule = \"Host(`traefik.domain.com`)\" service = \"api@internal\" middlewares = [\"auth\"] [http.middlewares.auth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] File (YAML) # Dynamic Configuration http: routers: api: rule: Host(`traefik.domain.com`) service: api@internal middlewares: - auth middlewares: auth: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" The router's rule must catch requests for the URI path /api Using an \"Host\" rule is recommended, by catching all the incoming traffic on this host domain to the API. However, you can also use \"path prefix\" rule or any combination or rules. Host Rule # Matches http://traefik.domain.com, http://traefik.domain.com/api # or http://traefik.domain.com/hello rule = \"Host(`traefik.domain.com`)\" Path Prefix Rule # Matches http://api.traefik.domain.com/api or http://domain.com/api # but does not match http://api.traefik.domain.com/hello rule = \"PathPrefix(`/api`)\" Combination of Rules # Matches http://traefik.domain.com/api or http://traefik.domain.com/dashboard # but does not match http://traefik.domain.com/hello rule = \"Host(`traefik.domain.com`) && (PathPrefix(`/api`) || PathPrefix(`/dashboard`))\" insecure \u00b6 Enable the API in insecure mode, which means that the API will be available directly on the entryPoint named traefik . Info If the entryPoint named traefik is not configured, it will be automatically created on port 8080. File (TOML) [api] insecure = true File (YAML) api: insecure: true CLI --api.insecure=true dashboard \u00b6 Optional, Default=true Enable the dashboard. More about the dashboard features here . File (TOML) [api] dashboard = true File (YAML) api: dashboard: true CLI --api.dashboard=true With Dashboard enabled, the router rule must catch requests for both /api and /dashboard Please check the Dashboard documentation to learn more about this and to get examples. debug \u00b6 Optional, Default=false Enable additional endpoints for debugging and profiling, served under /debug/ . File (TOML) [api] debug = true File (YAML) api: debug: true CLI --api.debug=true Endpoints \u00b6 All the following endpoints must be accessed with a GET HTTP request. Path Description /api/http/routers Lists all the HTTP routers information. /api/http/routers/{name} Returns the information of the HTTP router specified by name . /api/http/services Lists all the HTTP services information. /api/http/services/{name} Returns the information of the HTTP service specified by name . /api/http/middlewares Lists all the HTTP middlewares information. /api/http/middlewares/{name} Returns the information of the HTTP middleware specified by name . /api/tcp/routers Lists all the TCP routers information. /api/tcp/routers/{name} Returns the information of the TCP router specified by name . /api/tcp/services Lists all the TCP services information. /api/tcp/services/{name} Returns the information of the TCP service specified by name . /api/entrypoints Lists all the entry points information. /api/entrypoints/{name} Returns the information of the entry point specified by name . /api/overview Returns statistic information about http and tcp as well as enabled features and providers. /api/version Returns information about Traefik version. /debug/vars See the expvar Go documentation. /debug/pprof/ See the pprof Index Go documentation. /debug/pprof/cmdline See the pprof Cmdline Go documentation. /debug/pprof/profile See the pprof Profile Go documentation. /debug/pprof/symbol See the pprof Symbol Go documentation. /debug/pprof/trace See the pprof Trace Go documentation.","title":"API"},{"location":"operations/api/#api","text":"Traefik exposes a number of information through an API handler, such as the configuration of all routers, services, middlewares, etc. As with all features of Traefik, this handler can be enabled with the static configuration .","title":"API"},{"location":"operations/api/#security","text":"Enabling the API in production is not recommended, because it will expose all configuration elements, including sensitive data. In production, it should be at least secured by authentication and authorizations. A good sane default (non exhaustive) set of recommendations would be to apply the following protection mechanisms: At the transport level: NOT publicly exposing the API's port, keeping it restricted to internal networks (as in the principle of least privilege , applied to networks).","title":"Security"},{"location":"operations/api/#configuration","text":"If you enable the API, a new special service named api@internal is created and can then be referenced in a router. To enable the API handler, use the following option on the static configuration : File (TOML) # Static Configuration [api] File (YAML) # Static Configuration api: {} CLI --api=true And then define a routing configuration on Traefik itself with the dynamic configuration : Docker # Dynamic Configuration labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" Docker (Swarm) # Dynamic Configuration deploy: labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" # Dummy service for Swarm port detection. The port can be any valid integer value. - \"traefik.http.services.dummy-svc.loadbalancer.server.port=9999\" Marathon \"labels\": { \"traefik.http.routers.api.rule\": \"Host(`traefik.domain.com`)\", \"traefik.http.routers.api.service\": \"api@internal\", \"traefik.http.routers.api.middlewares\": \"auth\", \"traefik.http.middlewares.auth.basicauth.users\": \"test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" } Rancher # Dynamic Configuration labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" File (TOML) # Dynamic Configuration [http.routers.my-api] rule = \"Host(`traefik.domain.com`)\" service = \"api@internal\" middlewares = [\"auth\"] [http.middlewares.auth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] File (YAML) # Dynamic Configuration http: routers: api: rule: Host(`traefik.domain.com`) service: api@internal middlewares: - auth middlewares: auth: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" The router's rule must catch requests for the URI path /api Using an \"Host\" rule is recommended, by catching all the incoming traffic on this host domain to the API. However, you can also use \"path prefix\" rule or any combination or rules. Host Rule # Matches http://traefik.domain.com, http://traefik.domain.com/api # or http://traefik.domain.com/hello rule = \"Host(`traefik.domain.com`)\" Path Prefix Rule # Matches http://api.traefik.domain.com/api or http://domain.com/api # but does not match http://api.traefik.domain.com/hello rule = \"PathPrefix(`/api`)\" Combination of Rules # Matches http://traefik.domain.com/api or http://traefik.domain.com/dashboard # but does not match http://traefik.domain.com/hello rule = \"Host(`traefik.domain.com`) && (PathPrefix(`/api`) || PathPrefix(`/dashboard`))\"","title":"Configuration"},{"location":"operations/api/#insecure","text":"Enable the API in insecure mode, which means that the API will be available directly on the entryPoint named traefik . Info If the entryPoint named traefik is not configured, it will be automatically created on port 8080. File (TOML) [api] insecure = true File (YAML) api: insecure: true CLI --api.insecure=true","title":"insecure"},{"location":"operations/api/#dashboard","text":"Optional, Default=true Enable the dashboard. More about the dashboard features here . File (TOML) [api] dashboard = true File (YAML) api: dashboard: true CLI --api.dashboard=true With Dashboard enabled, the router rule must catch requests for both /api and /dashboard Please check the Dashboard documentation to learn more about this and to get examples.","title":"dashboard"},{"location":"operations/api/#debug","text":"Optional, Default=false Enable additional endpoints for debugging and profiling, served under /debug/ . File (TOML) [api] debug = true File (YAML) api: debug: true CLI --api.debug=true","title":"debug"},{"location":"operations/api/#endpoints","text":"All the following endpoints must be accessed with a GET HTTP request. Path Description /api/http/routers Lists all the HTTP routers information. /api/http/routers/{name} Returns the information of the HTTP router specified by name . /api/http/services Lists all the HTTP services information. /api/http/services/{name} Returns the information of the HTTP service specified by name . /api/http/middlewares Lists all the HTTP middlewares information. /api/http/middlewares/{name} Returns the information of the HTTP middleware specified by name . /api/tcp/routers Lists all the TCP routers information. /api/tcp/routers/{name} Returns the information of the TCP router specified by name . /api/tcp/services Lists all the TCP services information. /api/tcp/services/{name} Returns the information of the TCP service specified by name . /api/entrypoints Lists all the entry points information. /api/entrypoints/{name} Returns the information of the entry point specified by name . /api/overview Returns statistic information about http and tcp as well as enabled features and providers. /api/version Returns information about Traefik version. /debug/vars See the expvar Go documentation. /debug/pprof/ See the pprof Index Go documentation. /debug/pprof/cmdline See the pprof Cmdline Go documentation. /debug/pprof/profile See the pprof Profile Go documentation. /debug/pprof/symbol See the pprof Symbol Go documentation. /debug/pprof/trace See the pprof Trace Go documentation.","title":"Endpoints"},{"location":"operations/cli/","text":"CLI \u00b6 The Traefik Command Line General \u00b6 traefik [command] [flags] [arguments] Use traefik [command] --help for help on any command. Commands: healthcheck Calls Traefik /ping to check the health of Traefik (the API must be enabled). version Shows the current Traefik version. Flag's usage: # set flag_argument to flag(s) traefik [--flag=flag_argument] [-f [flag_argument]] # set true/false to boolean flag(s) traefik [--flag[=true|false| ]] [-f [true|false| ]] All flags are documented in the (static configuration) CLI reference . Flags are case insensitive. healthcheck \u00b6 Calls Traefik /ping to check the health of Traefik. Its exit status is 0 if Traefik is healthy and 1 otherwise. This can be used with Docker HEALTHCHECK instruction or any other health check orchestration mechanism. Info The ping endpoint must be enabled to allow the healthcheck command to call /ping . Usage: traefik healthcheck [command] [flags] [arguments] Example: $ traefik healthcheck OK: http://:8082/ping version \u00b6 Shows the current Traefik version. Usage: traefik version","title":"CLI"},{"location":"operations/cli/#cli","text":"The Traefik Command Line","title":"CLI"},{"location":"operations/cli/#general","text":"traefik [command] [flags] [arguments] Use traefik [command] --help for help on any command. Commands: healthcheck Calls Traefik /ping to check the health of Traefik (the API must be enabled). version Shows the current Traefik version. Flag's usage: # set flag_argument to flag(s) traefik [--flag=flag_argument] [-f [flag_argument]] # set true/false to boolean flag(s) traefik [--flag[=true|false| ]] [-f [true|false| ]] All flags are documented in the (static configuration) CLI reference . Flags are case insensitive.","title":"General"},{"location":"operations/cli/#healthcheck","text":"Calls Traefik /ping to check the health of Traefik. Its exit status is 0 if Traefik is healthy and 1 otherwise. This can be used with Docker HEALTHCHECK instruction or any other health check orchestration mechanism. Info The ping endpoint must be enabled to allow the healthcheck command to call /ping . Usage: traefik healthcheck [command] [flags] [arguments] Example: $ traefik healthcheck OK: http://:8082/ping","title":"healthcheck"},{"location":"operations/cli/#version","text":"Shows the current Traefik version. Usage: traefik version","title":"version"},{"location":"operations/dashboard/","text":"The Dashboard \u00b6 See What's Going On The dashboard is the central place that shows you the current active routes handled by Traefik. The dashboard in action The dashboard is available at the same location as the API but on the path /dashboard/ by default. The trailing slash / in /dashboard/ is mandatory There are 2 ways to configure and access the dashboard: Secure mode (Recommended) Insecure mode There is also a redirect of the path / to the path /dashboard/ , but one should not rely on that property as it is bound to change, and it might make for confusing routing rules anyway. Secure Mode \u00b6 This is the recommended method. Start by enabling the dashboard by using the following option from Traefik's API on the static configuration : File (TOML) [api] # Dashboard # # Optional # Default: true # dashboard = true File (YAML) api: # Dashboard # # Optional # Default: true # dashboard: true CLI # Dashboard # # Optional # Default: true # --api.dashboard=true Then define a routing configuration on Traefik itself, with a router attached to the service api@internal in the dynamic configuration , to allow defining: One or more security features through middlewares like authentication ( basicAuth , digestAuth , forwardAuth ) or whitelisting . A router rule for accessing the dashboard, through Traefik itself (sometimes referred as \"Traefik-ception\"). Dashboard Dynamic Configuration Examples Docker # Dynamic Configuration labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" Docker (Swarm) # Dynamic Configuration deploy: labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" # Dummy service for Swarm port detection. The port can be any valid integer value. - \"traefik.http.services.dummy-svc.loadbalancer.server.port=9999\" Marathon \"labels\": { \"traefik.http.routers.api.rule\": \"Host(`traefik.domain.com`)\", \"traefik.http.routers.api.service\": \"api@internal\", \"traefik.http.routers.api.middlewares\": \"auth\", \"traefik.http.middlewares.auth.basicauth.users\": \"test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" } Rancher # Dynamic Configuration labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" File (TOML) # Dynamic Configuration [http.routers.my-api] rule = \"Host(`traefik.domain.com`)\" service = \"api@internal\" middlewares = [\"auth\"] [http.middlewares.auth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] File (YAML) # Dynamic Configuration http: routers: api: rule: Host(`traefik.domain.com`) service: api@internal middlewares: - auth middlewares: auth: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\" Dashboard Router Rule \u00b6 As underlined in the documentation for the api.dashboard option , the router rule defined for Traefik must match the path prefixes /api and /dashboard . We recommend to use a \"Host Based rule\" as Host(`traefik.domain.com`) to match everything on the host domain, or to make sure that the defined rule captures both prefixes: Host Rule # The dashboard can be accessed on http://traefik.domain.com/dashboard/ rule = \"Host(`traefik.domain.com`)\" Path Prefix Rule # The dashboard can be accessed on http://domain.com/dashboard/ or http://traefik.domain.com/dashboard/ rule = \"PathPrefix(`/api`) || PathPrefix(`/dashboard`)\" Combination of Rules # The dashboard can be accessed on http://traefik.domain.com/dashboard/ rule = \"Host(`traefik.domain.com`) && (PathPrefix(`/api`) || PathPrefix(`/dashboard`))\" Insecure Mode \u00b6 This mode is not recommended because it does not allow the use of security features. To enable the \"insecure mode\", use the following options from Traefik's API : File (TOML) [api] dashboard = true insecure = true File (YAML) api: dashboard: true insecure: true CLI --api.dashboard=true --api.insecure=true You can now access the dashboard on the port 8080 of the Traefik instance, at the following URL: http://<Traefik IP>:8080/dashboard/ (trailing slash is mandatory).","title":"Dashboard"},{"location":"operations/dashboard/#the-dashboard","text":"See What's Going On The dashboard is the central place that shows you the current active routes handled by Traefik. The dashboard in action The dashboard is available at the same location as the API but on the path /dashboard/ by default. The trailing slash / in /dashboard/ is mandatory There are 2 ways to configure and access the dashboard: Secure mode (Recommended) Insecure mode There is also a redirect of the path / to the path /dashboard/ , but one should not rely on that property as it is bound to change, and it might make for confusing routing rules anyway.","title":"The Dashboard"},{"location":"operations/dashboard/#secure-mode","text":"This is the recommended method. Start by enabling the dashboard by using the following option from Traefik's API on the static configuration : File (TOML) [api] # Dashboard # # Optional # Default: true # dashboard = true File (YAML) api: # Dashboard # # Optional # Default: true # dashboard: true CLI # Dashboard # # Optional # Default: true # --api.dashboard=true Then define a routing configuration on Traefik itself, with a router attached to the service api@internal in the dynamic configuration , to allow defining: One or more security features through middlewares like authentication ( basicAuth , digestAuth , forwardAuth ) or whitelisting . A router rule for accessing the dashboard, through Traefik itself (sometimes referred as \"Traefik-ception\"). Dashboard Dynamic Configuration Examples Docker # Dynamic Configuration labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" Docker (Swarm) # Dynamic Configuration deploy: labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" # Dummy service for Swarm port detection. The port can be any valid integer value. - \"traefik.http.services.dummy-svc.loadbalancer.server.port=9999\" Marathon \"labels\": { \"traefik.http.routers.api.rule\": \"Host(`traefik.domain.com`)\", \"traefik.http.routers.api.service\": \"api@internal\", \"traefik.http.routers.api.middlewares\": \"auth\", \"traefik.http.middlewares.auth.basicauth.users\": \"test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" } Rancher # Dynamic Configuration labels: - \"traefik.http.routers.api.rule=Host(`traefik.domain.com`)\" - \"traefik.http.routers.api.service=api@internal\" - \"traefik.http.routers.api.middlewares=auth\" - \"traefik.http.middlewares.auth.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/,test2:$$apr1$$d9hr9HBB$$4HxwgUir3HP4EsggP/QNo0\" File (TOML) # Dynamic Configuration [http.routers.my-api] rule = \"Host(`traefik.domain.com`)\" service = \"api@internal\" middlewares = [\"auth\"] [http.middlewares.auth.basicAuth] users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", ] File (YAML) # Dynamic Configuration http: routers: api: rule: Host(`traefik.domain.com`) service: api@internal middlewares: - auth middlewares: auth: basicAuth: users: - \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\" - \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"","title":"Secure Mode"},{"location":"operations/dashboard/#dashboard-router-rule","text":"As underlined in the documentation for the api.dashboard option , the router rule defined for Traefik must match the path prefixes /api and /dashboard . We recommend to use a \"Host Based rule\" as Host(`traefik.domain.com`) to match everything on the host domain, or to make sure that the defined rule captures both prefixes: Host Rule # The dashboard can be accessed on http://traefik.domain.com/dashboard/ rule = \"Host(`traefik.domain.com`)\" Path Prefix Rule # The dashboard can be accessed on http://domain.com/dashboard/ or http://traefik.domain.com/dashboard/ rule = \"PathPrefix(`/api`) || PathPrefix(`/dashboard`)\" Combination of Rules # The dashboard can be accessed on http://traefik.domain.com/dashboard/ rule = \"Host(`traefik.domain.com`) && (PathPrefix(`/api`) || PathPrefix(`/dashboard`))\"","title":"Dashboard Router Rule"},{"location":"operations/dashboard/#insecure-mode","text":"This mode is not recommended because it does not allow the use of security features. To enable the \"insecure mode\", use the following options from Traefik's API : File (TOML) [api] dashboard = true insecure = true File (YAML) api: dashboard: true insecure: true CLI --api.dashboard=true --api.insecure=true You can now access the dashboard on the port 8080 of the Traefik instance, at the following URL: http://<Traefik IP>:8080/dashboard/ (trailing slash is mandatory).","title":"Insecure Mode"},{"location":"operations/ping/","text":"Ping \u00b6 Checking the Health of Your Traefik Instances Configuration Examples \u00b6 To enable the API handler: File (TOML) [ping] File (YAML) ping: {} CLI --ping=true Configuration Options \u00b6 The /ping health-check URL is enabled with the command-line --ping or config file option [ping] . You can customize the entryPoint where the /ping is active with the entryPoint option (default value: traefik ) Path Method Description /ping GET , HEAD A simple endpoint to check for Traefik process liveness. Return a code 200 with the content: OK Note The cli comes with a healthcheck command which can be used for calling this endpoint. entryPoint \u00b6 Enabling /ping on a dedicated EntryPoint. File (TOML) [entryPoints] [entryPoints.ping] address = \":8082\" [ping] entryPoint = \"ping\" File (YAML) entryPoints: ping: address: \":8082\" ping: entryPoint: \"ping\" CLI --entryPoints.ping.address=:8082 --ping.entryPoint=ping","title":"Ping"},{"location":"operations/ping/#ping","text":"Checking the Health of Your Traefik Instances","title":"Ping"},{"location":"operations/ping/#configuration-examples","text":"To enable the API handler: File (TOML) [ping] File (YAML) ping: {} CLI --ping=true","title":"Configuration Examples"},{"location":"operations/ping/#configuration-options","text":"The /ping health-check URL is enabled with the command-line --ping or config file option [ping] . You can customize the entryPoint where the /ping is active with the entryPoint option (default value: traefik ) Path Method Description /ping GET , HEAD A simple endpoint to check for Traefik process liveness. Return a code 200 with the content: OK Note The cli comes with a healthcheck command which can be used for calling this endpoint.","title":"Configuration Options"},{"location":"operations/ping/#entrypoint","text":"Enabling /ping on a dedicated EntryPoint. File (TOML) [entryPoints] [entryPoints.ping] address = \":8082\" [ping] entryPoint = \"ping\" File (YAML) entryPoints: ping: address: \":8082\" ping: entryPoint: \"ping\" CLI --entryPoints.ping.address=:8082 --ping.entryPoint=ping","title":"entryPoint"},{"location":"providers/docker/","text":"Traefik & Docker \u00b6 A Story of Labels & Containers Attach labels to your containers and let Traefik do the rest! Traefik works with both Docker (standalone) Engine and Docker Swarm Mode . The Quick Start Uses Docker If you haven't already, maybe you'd like to go through the quick start that uses the docker provider! Configuration Examples \u00b6 Configuring Docker & Deploying / Exposing Services Enabling the docker provider File (TOML) [providers.docker] File (YAML) providers: docker: {} CLI --providers.docker=true Attaching labels to containers (in your docker compose file) version: \"3\" services: my-container: # ... labels: - traefik.http.routers.my-container.rule=Host(`mydomain.com`) Configuring Docker Swarm & Deploying / Exposing Services Enabling the docker provider (Swarm Mode) File (TOML) [providers.docker] # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint = \"tcp://127.0.0.1:2377\" swarmMode = true File (YAML) providers: docker: # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint: \"tcp://127.0.0.1:2375\" swarmMode: true CLI --providers.docker.endpoint=tcp://127.0.0.1:2375 --providers.docker.swarmMode=true Attach labels to services (not to containers) while in Swarm mode (in your docker compose file) version: \"3\" services: my-container: deploy: labels: - traefik.http.routers.my-container.rule=Host(`mydomain.com`) - traefik.http.services.my-container-service.loadbalancer.server.port=8080 Routing Configuration \u00b6 When using Docker as a provider , Trafik uses container labels to retrieve its routing configuration. See the list of labels in the dedicated routing section. Routing Configuration with Labels \u00b6 By default, Traefik watches for container level labels on a standalone Docker Engine. When using Docker Compose, labels are specified by the directive labels from the \"services\" objects . Not Only Docker Please note that any tool like Nomad, Terraform, Ansible, etc. that is able to define a Docker container with labels can work with Traefik & the Docker provider. Port Detection \u00b6 Traefik retrieves the private IP and port of containers from the Docker API. Ports detection works as follows: If a container exposes only one port, then Traefik uses this port for private communication. If a container exposes multiple ports, or does not expose any port, then you must manually specify which port Traefik should use for communication by using the label traefik.http.services.<service_name>.loadbalancer.server.port (Read more on this label in the dedicated section in routing ). Docker API Access \u00b6 Traefik requires access to the docker socket to get its dynamic configuration. You can specify which Docker API Endpoint to use with the directive endpoint . Security Note Accessing the Docker API without any restriction is a security concern: If Traefik is attacked, then the attacker might get access to the underlying host. As explained in the Docker documentation: ( Docker Daemon Attack Surface page ): Quote [...] only trusted users should be allowed to control your Docker daemon [...] Solutions Expose the Docker socket over TCP, instead of the default Unix socket file. It allows different implementation levels of the AAA (Authentication, Authorization, Accounting) concepts , depending on your security assessment: Authentication with Client Certificates as described in \"Protect the Docker daemon socket.\" Authorize and filter requests to restrict possible actions with the TecnativaDocker Socket Proxy . Authorization with the Docker Authorization Plugin Mechanism Accounting at networking level, by exposing the socket only inside a Docker private network, only available for Traefik. Accounting at container level, by exposing the socket on a another container than Traefik's. With Swarm mode, it allows scheduling of Traefik on worker nodes, with only the \"socket exposer\" container on the manager nodes. Accounting at kernel level, by enforcing kernel calls with mechanisms like SELinux , to only allows an identified set of actions for Traefik's process (or the \"socket exposer\" process). More Resources and Examples \"Paranoid about mounting /var/run/docker.sock?\" Traefik and Docker: A Discussion with Docker Captain, Bret Fisher KubeCon EU 2018 Keynote, Running with Scissors, from Liz Rice Don't expose the Docker socket (not even to a container) A thread on Stack Overflow about sharing the /var/run/docker.sock file To DinD or not to DinD Traefik issue GH-4174 about security with Docker socket Inspecting Docker Activity with Socat Letting Traefik run on Worker Nodes Docker Socket Proxy from Tecnativa Docker Swarm Mode \u00b6 To enable Docker Swarm (instead of standalone Docker) as a configuration provider, set the swarmMode directive to true . Routing Configuration with Labels \u00b6 While in Swarm Mode, Traefik uses labels found on services, not on individual containers. Therefore, if you use a compose file with Swarm Mode, labels should be defined in the deploy part of your service. This behavior is only enabled for docker-compose version 3+ ( Compose file reference ). Port Detection \u00b6 Docker Swarm does not provide any port detection information to Traefik. Therefore you must specify the port to use for communication by using the label traefik.http.services.<service_name>.loadbalancer.server.port (Check the reference for this label in the routing section for Docker ). Docker API Access \u00b6 Docker Swarm Mode follows the same rules as Docker API Access . As the Swarm API is only exposed on the manager nodes , you should schedule Traefik on the Swarm manager nodes by default, by deploying Traefik with a constraint on the node's \"role\": With Docker CLI docker service create \\ --constraint=node.role==manager \\ #... \\ With Docker Compose version: '3' services: traefik: # ... deploy: placement: constraints: - node.role == manager Scheduling Traefik on Worker Nodes Following the guidelines given in the previous section \"Docker API Access\" , if you expose the Docker API through TCP, then Traefik can be scheduled on any node if the TCP socket is reachable. Please consider the security implications by reading the Security Note . A good example can be found on Bret Fisher's repository . Provider Configuration \u00b6 endpoint \u00b6 Required, Default=\"unix:///var/run/docker.sock\" File (TOML) [providers.docker] endpoint = \"unix:///var/run/docker.sock\" File (YAML) providers: docker: endpoint: \"unix:///var/run/docker.sock\" CLI --providers.docker.endpoint=unix:///var/run/docker.sock See the sections Docker API Access and Docker Swarm API Access for more information. Using the docker.sock The docker-compose file shares the docker sock with the Traefik container version: '3' services: traefik: image: traefik:v2.0 # The official v2.0 Traefik docker image ports: - \"80:80\" volumes: - /var/run/docker.sock:/var/run/docker.sock We specify the docker.sock in traefik's configuration file. File (TOML) [providers.docker] endpoint = \"unix:///var/run/docker.sock\" # ... File (YAML) providers: docker: endpoint: \"unix:///var/run/docker.sock\" # ... CLI --providers.docker.endpoint=unix:///var/run/docker.sock # ... useBindPortIP \u00b6 Optional, Default=false File (TOML) [providers.docker] useBindPortIP = true # ... File (YAML) providers: docker: useBindPortIP: true # ... CLI --providers.docker.useBindPortIP=true # ... Traefik routes requests to the IP/Port of the matching container. When setting useBindPortIP=true , you tell Traefik to use the IP/Port attached to the container's binding instead of its inner network IP/Port. When used in conjunction with the traefik.http.services.<name>.loadbalancer.server.port label (that tells Traefik to route requests to a specific port), Traefik tries to find a binding on port traefik.http.services.<name>.loadbalancer.server.port . If it can't find such a binding, Traefik falls back on the internal network IP of the container, but still uses the traefik.http.services.<name>.loadbalancer.server.port that is set in the label. Examples of usebindportip in different situations. port label Container's binding Routes to - - IntIP:IntPort - ExtPort:IntPort IntIP:IntPort - ExtIp:ExtPort:IntPort ExtIp:ExtPort LblPort - IntIp:LblPort LblPort ExtIp:ExtPort:LblPort ExtIp:ExtPort LblPort ExtIp:ExtPort:OtherPort IntIp:LblPort LblPort ExtIp1:ExtPort1:IntPort1 & ExtIp2:LblPort:IntPort2 ExtIp2:LblPort In the above table: ExtIp stands for \"external IP found in the binding\" IntIp stands for \"internal network container's IP\", ExtPort stands for \"external Port found in the binding\" IntPort stands for \"internal network container's port.\" exposedByDefault \u00b6 Optional, Default=true File (TOML) [providers.docker] exposedByDefault = false # ... File (YAML) providers: docker: exposedByDefault: false # ... CLI --providers.docker.exposedByDefault=false # ... Expose containers by default through Traefik. If set to false, containers that don't have a traefik.enable=true label will be ignored from the resulting routing configuration. See also Restrict the Scope of Service Discovery . network \u00b6 Optional, Default=empty File (TOML) [providers.docker] network = \"test\" # ... File (YAML) providers: docker: network: test # ... CLI --providers.docker.network=test # ... Defines a default docker network to use for connections to all containers. This option can be overridden on a container basis with the traefik.docker.network label. defaultRule \u00b6 Optional, Default= Host(`{{ normalize .Name }}`) File (TOML) [providers.docker] defaultRule = \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... File (YAML) providers: docker: defaultRule: \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... CLI --providers.docker.defaultRule=Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`) # ... For a given container if no routing rule was defined by a label, it is defined by this defaultRule instead. It must be a valid Go template , augmented with the sprig template functions . The container service name can be accessed as the Name identifier, and the template has access to all the labels defined on this container. swarmMode \u00b6 Optional, Default=false File (TOML) [providers.docker] swarmMode = true # ... File (YAML) providers: docker: swarmMode: true # ... CLI --providers.docker.swarmMode=true # ... Activates the Swarm Mode (instead of standalone Docker). swarmModeRefreshSeconds \u00b6 Optional, Default=15 File (TOML) [providers.docker] swarmModeRefreshSeconds = \"30s\" # ... File (YAML) providers: docker: swarmModeRefreshSeconds: \"30s\" # ... CLI --providers.docker.swarmModeRefreshSeconds=30s # ... Defines the polling interval (in seconds) in Swarm Mode. constraints \u00b6 Optional, Default=\"\" File (TOML) [providers.docker] constraints = \"Label(`a.label.name`,`foo`)\" # ... File (YAML) providers: docker: constraints: \"Label(`a.label.name`,`foo`)\" # ... CLI --providers.docker.constraints=Label(`a.label.name`,`foo`) # ... Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. That is to say, if none of the container's labels match the expression, no route for the container is created. If the expression is empty, all detected containers are included. The expression syntax is based on the Label(\"key\", \"value\") , and LabelRegex(\"key\", \"value\") functions, as well as the usual boolean logic, as shown in examples below. Constraints Expression Examples # Includes only containers having a label with key `a.label.name` and value `foo` constraints = \"Label(`a.label.name`, `foo`)\" # Excludes containers having any label with key `a.label.name` and value `foo` constraints = \"!Label(`a.label.name`, `value`)\" # With logical AND. constraints = \"Label(`a.label.name`, `valueA`) && Label(`another.label.name`, `valueB`)\" # With logical OR. constraints = \"Label(`a.label.name`, `valueA`) || Label(`another.label.name`, `valueB`)\" # With logical AND and OR, with precedence set by parentheses. constraints = \"Label(`a.label.name`, `valueA`) && (Label(`another.label.name`, `valueB`) || Label(`yet.another.label.name`, `valueC`))\" # Includes only containers having a label with key `a.label.name` and a value matching the `a.+` regular expression. constraints = \"LabelRegex(`a.label.name`, `a.+`)\" See also Restrict the Scope of Service Discovery . tls \u00b6 Optional tls.ca \u00b6 Certificate Authority used for the secured connection to Docker. File (TOML) [providers.docker.tls] ca = \"path/to/ca.crt\" File (YAML) providers: docker: tls: ca: path/to/ca.crt CLI --providers.docker.tls.ca=path/to/ca.crt tls.caOptional \u00b6 Policy followed for the secured connection with TLS Client Authentication to Docker. Requires tls.ca to be defined. true : VerifyClientCertIfGiven false : RequireAndVerifyClientCert if tls.ca is undefined NoClientCert File (TOML) [providers.docker.tls] caOptional = true File (YAML) providers: docker: tls: caOptional: true CLI --providers.docker.tls.caOptional=true tls.cert \u00b6 Public certificate used for the secured connection to Docker. File (TOML) [providers.docker.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) providers: docker: tls: cert: path/to/foo.cert key: path/to/foo.key CLI --providers.docker.tls.cert=path/to/foo.cert --providers.docker.tls.key=path/to/foo.key tls.key \u00b6 Private certificate used for the secured connection to Docker. File (TOML) [providers.docker.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) providers: docker: tls: cert: path/to/foo.cert key: path/to/foo.key CLI --providers.docker.tls.cert=path/to/foo.cert --providers.docker.tls.key=path/to/foo.key tls.insecureSkipVerify \u00b6 If insecureSkipVerify is true , TLS for the connection to Docker accepts any certificate presented by the server and any host name in that certificate. File (TOML) [providers.docker.tls] insecureSkipVerify = true File (YAML) providers: docker: tls: insecureSkipVerify: true CLI --providers.docker.tls.insecureSkipVerify=true","title":"Docker"},{"location":"providers/docker/#traefik-docker","text":"A Story of Labels & Containers Attach labels to your containers and let Traefik do the rest! Traefik works with both Docker (standalone) Engine and Docker Swarm Mode . The Quick Start Uses Docker If you haven't already, maybe you'd like to go through the quick start that uses the docker provider!","title":"Traefik &amp; Docker"},{"location":"providers/docker/#configuration-examples","text":"Configuring Docker & Deploying / Exposing Services Enabling the docker provider File (TOML) [providers.docker] File (YAML) providers: docker: {} CLI --providers.docker=true Attaching labels to containers (in your docker compose file) version: \"3\" services: my-container: # ... labels: - traefik.http.routers.my-container.rule=Host(`mydomain.com`) Configuring Docker Swarm & Deploying / Exposing Services Enabling the docker provider (Swarm Mode) File (TOML) [providers.docker] # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint = \"tcp://127.0.0.1:2377\" swarmMode = true File (YAML) providers: docker: # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint: \"tcp://127.0.0.1:2375\" swarmMode: true CLI --providers.docker.endpoint=tcp://127.0.0.1:2375 --providers.docker.swarmMode=true Attach labels to services (not to containers) while in Swarm mode (in your docker compose file) version: \"3\" services: my-container: deploy: labels: - traefik.http.routers.my-container.rule=Host(`mydomain.com`) - traefik.http.services.my-container-service.loadbalancer.server.port=8080","title":"Configuration Examples"},{"location":"providers/docker/#routing-configuration","text":"When using Docker as a provider , Trafik uses container labels to retrieve its routing configuration. See the list of labels in the dedicated routing section.","title":"Routing Configuration"},{"location":"providers/docker/#routing-configuration-with-labels","text":"By default, Traefik watches for container level labels on a standalone Docker Engine. When using Docker Compose, labels are specified by the directive labels from the \"services\" objects . Not Only Docker Please note that any tool like Nomad, Terraform, Ansible, etc. that is able to define a Docker container with labels can work with Traefik & the Docker provider.","title":"Routing Configuration with Labels"},{"location":"providers/docker/#port-detection","text":"Traefik retrieves the private IP and port of containers from the Docker API. Ports detection works as follows: If a container exposes only one port, then Traefik uses this port for private communication. If a container exposes multiple ports, or does not expose any port, then you must manually specify which port Traefik should use for communication by using the label traefik.http.services.<service_name>.loadbalancer.server.port (Read more on this label in the dedicated section in routing ).","title":"Port Detection"},{"location":"providers/docker/#docker-api-access","text":"Traefik requires access to the docker socket to get its dynamic configuration. You can specify which Docker API Endpoint to use with the directive endpoint . Security Note Accessing the Docker API without any restriction is a security concern: If Traefik is attacked, then the attacker might get access to the underlying host. As explained in the Docker documentation: ( Docker Daemon Attack Surface page ): Quote [...] only trusted users should be allowed to control your Docker daemon [...] Solutions Expose the Docker socket over TCP, instead of the default Unix socket file. It allows different implementation levels of the AAA (Authentication, Authorization, Accounting) concepts , depending on your security assessment: Authentication with Client Certificates as described in \"Protect the Docker daemon socket.\" Authorize and filter requests to restrict possible actions with the TecnativaDocker Socket Proxy . Authorization with the Docker Authorization Plugin Mechanism Accounting at networking level, by exposing the socket only inside a Docker private network, only available for Traefik. Accounting at container level, by exposing the socket on a another container than Traefik's. With Swarm mode, it allows scheduling of Traefik on worker nodes, with only the \"socket exposer\" container on the manager nodes. Accounting at kernel level, by enforcing kernel calls with mechanisms like SELinux , to only allows an identified set of actions for Traefik's process (or the \"socket exposer\" process). More Resources and Examples \"Paranoid about mounting /var/run/docker.sock?\" Traefik and Docker: A Discussion with Docker Captain, Bret Fisher KubeCon EU 2018 Keynote, Running with Scissors, from Liz Rice Don't expose the Docker socket (not even to a container) A thread on Stack Overflow about sharing the /var/run/docker.sock file To DinD or not to DinD Traefik issue GH-4174 about security with Docker socket Inspecting Docker Activity with Socat Letting Traefik run on Worker Nodes Docker Socket Proxy from Tecnativa","title":"Docker API Access"},{"location":"providers/docker/#docker-swarm-mode","text":"To enable Docker Swarm (instead of standalone Docker) as a configuration provider, set the swarmMode directive to true .","title":"Docker Swarm Mode"},{"location":"providers/docker/#routing-configuration-with-labels_1","text":"While in Swarm Mode, Traefik uses labels found on services, not on individual containers. Therefore, if you use a compose file with Swarm Mode, labels should be defined in the deploy part of your service. This behavior is only enabled for docker-compose version 3+ ( Compose file reference ).","title":"Routing Configuration with Labels"},{"location":"providers/docker/#port-detection_1","text":"Docker Swarm does not provide any port detection information to Traefik. Therefore you must specify the port to use for communication by using the label traefik.http.services.<service_name>.loadbalancer.server.port (Check the reference for this label in the routing section for Docker ).","title":"Port Detection"},{"location":"providers/docker/#docker-api-access_1","text":"Docker Swarm Mode follows the same rules as Docker API Access . As the Swarm API is only exposed on the manager nodes , you should schedule Traefik on the Swarm manager nodes by default, by deploying Traefik with a constraint on the node's \"role\": With Docker CLI docker service create \\ --constraint=node.role==manager \\ #... \\ With Docker Compose version: '3' services: traefik: # ... deploy: placement: constraints: - node.role == manager Scheduling Traefik on Worker Nodes Following the guidelines given in the previous section \"Docker API Access\" , if you expose the Docker API through TCP, then Traefik can be scheduled on any node if the TCP socket is reachable. Please consider the security implications by reading the Security Note . A good example can be found on Bret Fisher's repository .","title":"Docker API Access"},{"location":"providers/docker/#provider-configuration","text":"","title":"Provider Configuration"},{"location":"providers/docker/#endpoint","text":"Required, Default=\"unix:///var/run/docker.sock\" File (TOML) [providers.docker] endpoint = \"unix:///var/run/docker.sock\" File (YAML) providers: docker: endpoint: \"unix:///var/run/docker.sock\" CLI --providers.docker.endpoint=unix:///var/run/docker.sock See the sections Docker API Access and Docker Swarm API Access for more information. Using the docker.sock The docker-compose file shares the docker sock with the Traefik container version: '3' services: traefik: image: traefik:v2.0 # The official v2.0 Traefik docker image ports: - \"80:80\" volumes: - /var/run/docker.sock:/var/run/docker.sock We specify the docker.sock in traefik's configuration file. File (TOML) [providers.docker] endpoint = \"unix:///var/run/docker.sock\" # ... File (YAML) providers: docker: endpoint: \"unix:///var/run/docker.sock\" # ... CLI --providers.docker.endpoint=unix:///var/run/docker.sock # ...","title":"endpoint"},{"location":"providers/docker/#usebindportip","text":"Optional, Default=false File (TOML) [providers.docker] useBindPortIP = true # ... File (YAML) providers: docker: useBindPortIP: true # ... CLI --providers.docker.useBindPortIP=true # ... Traefik routes requests to the IP/Port of the matching container. When setting useBindPortIP=true , you tell Traefik to use the IP/Port attached to the container's binding instead of its inner network IP/Port. When used in conjunction with the traefik.http.services.<name>.loadbalancer.server.port label (that tells Traefik to route requests to a specific port), Traefik tries to find a binding on port traefik.http.services.<name>.loadbalancer.server.port . If it can't find such a binding, Traefik falls back on the internal network IP of the container, but still uses the traefik.http.services.<name>.loadbalancer.server.port that is set in the label. Examples of usebindportip in different situations. port label Container's binding Routes to - - IntIP:IntPort - ExtPort:IntPort IntIP:IntPort - ExtIp:ExtPort:IntPort ExtIp:ExtPort LblPort - IntIp:LblPort LblPort ExtIp:ExtPort:LblPort ExtIp:ExtPort LblPort ExtIp:ExtPort:OtherPort IntIp:LblPort LblPort ExtIp1:ExtPort1:IntPort1 & ExtIp2:LblPort:IntPort2 ExtIp2:LblPort In the above table: ExtIp stands for \"external IP found in the binding\" IntIp stands for \"internal network container's IP\", ExtPort stands for \"external Port found in the binding\" IntPort stands for \"internal network container's port.\"","title":"useBindPortIP"},{"location":"providers/docker/#exposedbydefault","text":"Optional, Default=true File (TOML) [providers.docker] exposedByDefault = false # ... File (YAML) providers: docker: exposedByDefault: false # ... CLI --providers.docker.exposedByDefault=false # ... Expose containers by default through Traefik. If set to false, containers that don't have a traefik.enable=true label will be ignored from the resulting routing configuration. See also Restrict the Scope of Service Discovery .","title":"exposedByDefault"},{"location":"providers/docker/#network","text":"Optional, Default=empty File (TOML) [providers.docker] network = \"test\" # ... File (YAML) providers: docker: network: test # ... CLI --providers.docker.network=test # ... Defines a default docker network to use for connections to all containers. This option can be overridden on a container basis with the traefik.docker.network label.","title":"network"},{"location":"providers/docker/#defaultrule","text":"Optional, Default= Host(`{{ normalize .Name }}`) File (TOML) [providers.docker] defaultRule = \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... File (YAML) providers: docker: defaultRule: \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... CLI --providers.docker.defaultRule=Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`) # ... For a given container if no routing rule was defined by a label, it is defined by this defaultRule instead. It must be a valid Go template , augmented with the sprig template functions . The container service name can be accessed as the Name identifier, and the template has access to all the labels defined on this container.","title":"defaultRule"},{"location":"providers/docker/#swarmmode","text":"Optional, Default=false File (TOML) [providers.docker] swarmMode = true # ... File (YAML) providers: docker: swarmMode: true # ... CLI --providers.docker.swarmMode=true # ... Activates the Swarm Mode (instead of standalone Docker).","title":"swarmMode"},{"location":"providers/docker/#swarmmoderefreshseconds","text":"Optional, Default=15 File (TOML) [providers.docker] swarmModeRefreshSeconds = \"30s\" # ... File (YAML) providers: docker: swarmModeRefreshSeconds: \"30s\" # ... CLI --providers.docker.swarmModeRefreshSeconds=30s # ... Defines the polling interval (in seconds) in Swarm Mode.","title":"swarmModeRefreshSeconds"},{"location":"providers/docker/#constraints","text":"Optional, Default=\"\" File (TOML) [providers.docker] constraints = \"Label(`a.label.name`,`foo`)\" # ... File (YAML) providers: docker: constraints: \"Label(`a.label.name`,`foo`)\" # ... CLI --providers.docker.constraints=Label(`a.label.name`,`foo`) # ... Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. That is to say, if none of the container's labels match the expression, no route for the container is created. If the expression is empty, all detected containers are included. The expression syntax is based on the Label(\"key\", \"value\") , and LabelRegex(\"key\", \"value\") functions, as well as the usual boolean logic, as shown in examples below. Constraints Expression Examples # Includes only containers having a label with key `a.label.name` and value `foo` constraints = \"Label(`a.label.name`, `foo`)\" # Excludes containers having any label with key `a.label.name` and value `foo` constraints = \"!Label(`a.label.name`, `value`)\" # With logical AND. constraints = \"Label(`a.label.name`, `valueA`) && Label(`another.label.name`, `valueB`)\" # With logical OR. constraints = \"Label(`a.label.name`, `valueA`) || Label(`another.label.name`, `valueB`)\" # With logical AND and OR, with precedence set by parentheses. constraints = \"Label(`a.label.name`, `valueA`) && (Label(`another.label.name`, `valueB`) || Label(`yet.another.label.name`, `valueC`))\" # Includes only containers having a label with key `a.label.name` and a value matching the `a.+` regular expression. constraints = \"LabelRegex(`a.label.name`, `a.+`)\" See also Restrict the Scope of Service Discovery .","title":"constraints"},{"location":"providers/docker/#tls","text":"Optional","title":"tls"},{"location":"providers/docker/#tlsca","text":"Certificate Authority used for the secured connection to Docker. File (TOML) [providers.docker.tls] ca = \"path/to/ca.crt\" File (YAML) providers: docker: tls: ca: path/to/ca.crt CLI --providers.docker.tls.ca=path/to/ca.crt","title":"tls.ca"},{"location":"providers/docker/#tlscaoptional","text":"Policy followed for the secured connection with TLS Client Authentication to Docker. Requires tls.ca to be defined. true : VerifyClientCertIfGiven false : RequireAndVerifyClientCert if tls.ca is undefined NoClientCert File (TOML) [providers.docker.tls] caOptional = true File (YAML) providers: docker: tls: caOptional: true CLI --providers.docker.tls.caOptional=true","title":"tls.caOptional"},{"location":"providers/docker/#tlscert","text":"Public certificate used for the secured connection to Docker. File (TOML) [providers.docker.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) providers: docker: tls: cert: path/to/foo.cert key: path/to/foo.key CLI --providers.docker.tls.cert=path/to/foo.cert --providers.docker.tls.key=path/to/foo.key","title":"tls.cert"},{"location":"providers/docker/#tlskey","text":"Private certificate used for the secured connection to Docker. File (TOML) [providers.docker.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) providers: docker: tls: cert: path/to/foo.cert key: path/to/foo.key CLI --providers.docker.tls.cert=path/to/foo.cert --providers.docker.tls.key=path/to/foo.key","title":"tls.key"},{"location":"providers/docker/#tlsinsecureskipverify","text":"If insecureSkipVerify is true , TLS for the connection to Docker accepts any certificate presented by the server and any host name in that certificate. File (TOML) [providers.docker.tls] insecureSkipVerify = true File (YAML) providers: docker: tls: insecureSkipVerify: true CLI --providers.docker.tls.insecureSkipVerify=true","title":"tls.insecureSkipVerify"},{"location":"providers/file/","text":"Traefik & File \u00b6 Good Old Configuration File The file provider lets you define the dynamic configuration in a TOML or YAML file. You can write one of these mutually exclusive configuration elements: In a dedicated file In several dedicated files Info The file provider is the default format used throughout the documentation to show samples of the configuration for many features. Tip The file provider can be a good location for common elements you'd like to re-use from other providers; e.g. declaring whitelist middlewares, basic authentication, ... Configuration Examples \u00b6 Declaring Routers, Middlewares & Services Enabling the file provider: File (TOML) [providers.file] directory = \"/path/to/dynamic/conf\" File (YAML) providers: file: directory: \"/path/to/dynamic/conf\" CLI --providers.file.directory=/path/to/dynamic/conf Declaring Routers, Middlewares & Services: TOML [http] # Add the router [http.routers] [http.routers.router0] entryPoints = [\"web\"] middlewares = [\"my-basic-auth\"] service = \"service-foo\" rule = \"Path(`/foo`)\" # Add the middleware [http.middlewares] [http.middlewares.my-basic-auth.basicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"] usersFile = \"etc/traefik/.htpasswd\" # Add the service [http.services] [http.services.service-foo] [http.services.service-foo.loadBalancer] [[http.services.service-foo.loadBalancer.servers]] url = \"http://foo/\" [[http.services.service-foo.loadBalancer.servers]] url = \"http://bar/\" YAML http: # Add the router routers: router0: entryPoints: - web middlewares: - my-basic-auth service: service-foo rule: Path(`/foo`) # Add the middleware middlewares: my-basic-auth: basicAuth: users: - test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ - test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 usersFile: etc/traefik/.htpasswd # Add the service services: service-foo: loadBalancer: servers: - url: http://foo/ - url: http://bar/ passHostHeader: false Provider Configuration \u00b6 If you're in a hurry, maybe you'd rather go through the dynamic configuration references and the static configuration . Limitations With the file provider, Traefik listens for file system notifications to update the dynamic configuration. If you use a mounted/bound file system in your orchestrator (like docker or kubernetes), the way the files are linked may be a source of errors. If the link between the file systems is broken, when a source file/directory is changed/renamed, nothing will be reported to the linked file/directory, so the file system notifications will be neither triggered nor caught. For example, in docker, if the host file is renamed, the link to the mounted file will be broken and the container's file will not be updated. To avoid this kind of issue, a good practice is to: set the Traefik directory configuration with the parent directory mount/bind the parent directory As it is very difficult to listen to all file system notifications, Traefik use fsnotify . If using a directory with a mounted directory does not fix your issue, please check your file system compatibility with fsnotify. filename \u00b6 Defines the path of the configuration file. File (TOML) [providers] [providers.file] filename = \"dynamic_conf.toml\" File (YAML) providers: file: filename: dynamic_conf.yml CLI --providers.file.filename=dynamic_conf.toml directory \u00b6 Defines the directory that contains the configuration files. File (TOML) [providers] [providers.file] directory = \"/path/to/config\" File (YAML) providers: file: directory: /path/to/config CLI --providers.file.directory=/path/to/config watch \u00b6 Set the watch option to true to allow Traefik to automatically watch for file changes. It works with both the filename and the directory options. File (TOML) [providers] [providers.file] directory = \"/path/to/dynamic/conf\" watch = true File (YAML) providers: file: directory: /path/to/dynamic/conf watch: true CLI --providers.file.directory=/my/path/to/dynamic/conf --providers.file.watch=true Go Templating \u00b6 Warning Go Templating only works along with dedicated dynamic configuration files. Templating does not work in the Traefik main static configuration file. Traefik allows using Go templating. Thus, it's possible to define easily lot of routers, services and TLS certificates as described in the file template-rules.toml : Configuring Using Templating TOML # template-rules.toml [http] [http.routers] {{ range $i, $e := until 100 }} [http.routers.router{{ $e }}] # ... {{ end }} [http.services] {{ range $i, $e := until 100 }} [http.services.service{{ $e }}] # ... {{ end }} [tcp] [tcp.routers] {{ range $i, $e := until 100 }} [tcp.routers.router{{ $e }}] # ... {{ end }} [tcp.services] {{ range $i, $e := until 100 }} [http.services.service{{ $e }}] # ... {{ end }} {{ range $i, $e := until 10 }} [[tls.certificates]] certFile = \"/etc/traefik/cert-{{ $e }}.pem\" keyFile = \"/etc/traefik/cert-{{ $e }}.key\" store = [\"my-store-foo-{{ $e }}\", \"my-store-bar-{{ $e }}\"] {{ end }} [tls.config] {{ range $i, $e := until 10 }} [tls.config.TLS{{ $e }}] # ... {{ end }} YAML http: {{range $i, $e := until 100 }} routers: router{{ $e }: # ... {{end}} {{range $i, $e := until 100 }} services: application{{ $e }}: # ... {{end}} tcp: {{range $i, $e := until 100 }} routers: router{{ $e }: # ... {{end}} {{range $i, $e := until 100 }} services: service{{ $e }}: # ... {{end}} {{ range $i, $e := until 10 }} tls: certificates: - certFile: \"/etc/traefik/cert-{{ $e }}.pem\" keyFile: \"/etc/traefik/cert-{{ $e }}.key\" store: - \"my-store-foo-{{ $e }}\" - \"my-store-bar-{{ $e }}\" {{end}}","title":"File"},{"location":"providers/file/#traefik-file","text":"Good Old Configuration File The file provider lets you define the dynamic configuration in a TOML or YAML file. You can write one of these mutually exclusive configuration elements: In a dedicated file In several dedicated files Info The file provider is the default format used throughout the documentation to show samples of the configuration for many features. Tip The file provider can be a good location for common elements you'd like to re-use from other providers; e.g. declaring whitelist middlewares, basic authentication, ...","title":"Traefik &amp; File"},{"location":"providers/file/#configuration-examples","text":"Declaring Routers, Middlewares & Services Enabling the file provider: File (TOML) [providers.file] directory = \"/path/to/dynamic/conf\" File (YAML) providers: file: directory: \"/path/to/dynamic/conf\" CLI --providers.file.directory=/path/to/dynamic/conf Declaring Routers, Middlewares & Services: TOML [http] # Add the router [http.routers] [http.routers.router0] entryPoints = [\"web\"] middlewares = [\"my-basic-auth\"] service = \"service-foo\" rule = \"Path(`/foo`)\" # Add the middleware [http.middlewares] [http.middlewares.my-basic-auth.basicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"] usersFile = \"etc/traefik/.htpasswd\" # Add the service [http.services] [http.services.service-foo] [http.services.service-foo.loadBalancer] [[http.services.service-foo.loadBalancer.servers]] url = \"http://foo/\" [[http.services.service-foo.loadBalancer.servers]] url = \"http://bar/\" YAML http: # Add the router routers: router0: entryPoints: - web middlewares: - my-basic-auth service: service-foo rule: Path(`/foo`) # Add the middleware middlewares: my-basic-auth: basicAuth: users: - test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ - test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 usersFile: etc/traefik/.htpasswd # Add the service services: service-foo: loadBalancer: servers: - url: http://foo/ - url: http://bar/ passHostHeader: false","title":"Configuration Examples"},{"location":"providers/file/#provider-configuration","text":"If you're in a hurry, maybe you'd rather go through the dynamic configuration references and the static configuration . Limitations With the file provider, Traefik listens for file system notifications to update the dynamic configuration. If you use a mounted/bound file system in your orchestrator (like docker or kubernetes), the way the files are linked may be a source of errors. If the link between the file systems is broken, when a source file/directory is changed/renamed, nothing will be reported to the linked file/directory, so the file system notifications will be neither triggered nor caught. For example, in docker, if the host file is renamed, the link to the mounted file will be broken and the container's file will not be updated. To avoid this kind of issue, a good practice is to: set the Traefik directory configuration with the parent directory mount/bind the parent directory As it is very difficult to listen to all file system notifications, Traefik use fsnotify . If using a directory with a mounted directory does not fix your issue, please check your file system compatibility with fsnotify.","title":"Provider Configuration"},{"location":"providers/file/#filename","text":"Defines the path of the configuration file. File (TOML) [providers] [providers.file] filename = \"dynamic_conf.toml\" File (YAML) providers: file: filename: dynamic_conf.yml CLI --providers.file.filename=dynamic_conf.toml","title":"filename"},{"location":"providers/file/#directory","text":"Defines the directory that contains the configuration files. File (TOML) [providers] [providers.file] directory = \"/path/to/config\" File (YAML) providers: file: directory: /path/to/config CLI --providers.file.directory=/path/to/config","title":"directory"},{"location":"providers/file/#watch","text":"Set the watch option to true to allow Traefik to automatically watch for file changes. It works with both the filename and the directory options. File (TOML) [providers] [providers.file] directory = \"/path/to/dynamic/conf\" watch = true File (YAML) providers: file: directory: /path/to/dynamic/conf watch: true CLI --providers.file.directory=/my/path/to/dynamic/conf --providers.file.watch=true","title":"watch"},{"location":"providers/file/#go-templating","text":"Warning Go Templating only works along with dedicated dynamic configuration files. Templating does not work in the Traefik main static configuration file. Traefik allows using Go templating. Thus, it's possible to define easily lot of routers, services and TLS certificates as described in the file template-rules.toml : Configuring Using Templating TOML # template-rules.toml [http] [http.routers] {{ range $i, $e := until 100 }} [http.routers.router{{ $e }}] # ... {{ end }} [http.services] {{ range $i, $e := until 100 }} [http.services.service{{ $e }}] # ... {{ end }} [tcp] [tcp.routers] {{ range $i, $e := until 100 }} [tcp.routers.router{{ $e }}] # ... {{ end }} [tcp.services] {{ range $i, $e := until 100 }} [http.services.service{{ $e }}] # ... {{ end }} {{ range $i, $e := until 10 }} [[tls.certificates]] certFile = \"/etc/traefik/cert-{{ $e }}.pem\" keyFile = \"/etc/traefik/cert-{{ $e }}.key\" store = [\"my-store-foo-{{ $e }}\", \"my-store-bar-{{ $e }}\"] {{ end }} [tls.config] {{ range $i, $e := until 10 }} [tls.config.TLS{{ $e }}] # ... {{ end }} YAML http: {{range $i, $e := until 100 }} routers: router{{ $e }: # ... {{end}} {{range $i, $e := until 100 }} services: application{{ $e }}: # ... {{end}} tcp: {{range $i, $e := until 100 }} routers: router{{ $e }: # ... {{end}} {{range $i, $e := until 100 }} services: service{{ $e }}: # ... {{end}} {{ range $i, $e := until 10 }} tls: certificates: - certFile: \"/etc/traefik/cert-{{ $e }}.pem\" keyFile: \"/etc/traefik/cert-{{ $e }}.key\" store: - \"my-store-foo-{{ $e }}\" - \"my-store-bar-{{ $e }}\" {{end}}","title":"Go Templating"},{"location":"providers/kubernetes-crd/","text":"Traefik & Kubernetes \u00b6 The Kubernetes Ingress Controller, The Custom Resource Way. Traefik used to support Kubernetes only through the Kubernetes Ingress provider , which is a Kubernetes Ingress controller in the strict sense of the term. However, as the community expressed the need to benefit from Traefik features without resorting to (lots of) annotations, we ended up writing a Custom Resource Definition (alias CRD in the following) for an IngressRoute type, defined below, in order to provide a better way to configure access to a Kubernetes cluster. Resource Configuration \u00b6 See the dedicated section in routing . LetsEncrypt Support with the Custom Resource Definition Provider \u00b6 By design, Traefik is a stateless application, meaning that it only derives its configuration from the environment it runs in, without additional configuration. For this reason, users can run multiple instances of Traefik at the same time to achieve HA, as is a common pattern in the kubernetes ecosystem. When using a single instance of Traefik with LetsEncrypt, no issues should be encountered, however this could be a single point of failure. Unfortunately, it is not possible to run multiple instances of Traefik 2.0 with LetsEncrypt enabled, because there is no way to ensure that the correct instance of Traefik will receive the challenge request, and subsequent responses. Previous versions of Traefik used a KV store to attempt to achieve this, but due to sub-optimal performance was dropped as a feature in 2.0. If you require LetsEncrypt with HA in a kubernetes environment, we recommend using TraefikEE where distributed LetsEncrypt is a supported feature. If you are wanting to continue to run Traefik Community Edition, LetsEncrypt HA can be achieved by using a Certificate Controller such as Cert-Manager . When using Cert-Manager to manage certificates, it will create secrets in your namespaces that can be referenced as TLS secrets in your ingress objects . When using the Traefik Kubernetes CRD Provider, unfortunately Cert-Manager cannot interface directly with the CRDs yet , but this is being worked on by our team. A workaround it to enable the Kubernetes Ingress provider to allow Cert-Manager to create ingress objects to complete the challenges. Please note that this still requires manual intervention to create the certificates through Cert-Manager, but once created, Cert-Manager will keep the certificate renewed. Provider Configuration \u00b6 endpoint \u00b6 Optional, Default=empty File (TOML) [providers.kubernetesCRD] endpoint = \"http://localhost:8080\" # ... File (YAML) providers: kubernetesCRD: endpoint = \"http://localhost:8080\" # ... CLI --providers.kubernetescrd.endpoint=http://localhost:8080 The Kubernetes server endpoint as URL. When deployed into Kubernetes, Traefik will read the environment variables KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT or KUBECONFIG to construct the endpoint. The access token will be looked up in /var/run/secrets/kubernetes.io/serviceaccount/token and the SSL CA certificate in /var/run/secrets/kubernetes.io/serviceaccount/ca.crt . Both are provided mounted automatically when deployed inside Kubernetes. The endpoint may be specified to override the environment variable values inside a cluster. When the environment variables are not found, Traefik will try to connect to the Kubernetes API server with an external-cluster client. In this case, the endpoint is required. Specifically, it may be set to the URL used by kubectl proxy to connect to a Kubernetes cluster using the granted authentication and authorization of the associated kubeconfig. token \u00b6 Optional, Default=empty File (TOML) [providers.kubernetesCRD] token = \"mytoken\" # ... File (YAML) providers: kubernetesCRD: token = \"mytoken\" # ... CLI --providers.kubernetescrd.token=mytoken Bearer token used for the Kubernetes client configuration. certAuthFilePath \u00b6 Optional, Default=empty File (TOML) [providers.kubernetesCRD] certAuthFilePath = \"/my/ca.crt\" # ... File (YAML) providers: kubernetesCRD: certAuthFilePath: \"/my/ca.crt\" # ... CLI --providers.kubernetescrd.certauthfilepath=/my/ca.crt Path to the certificate authority file. Used for the Kubernetes client configuration. namespaces \u00b6 Optional, Default: all namespaces (empty array) File (TOML) [providers.kubernetesCRD] namespaces = [\"default\", \"production\"] # ... File (YAML) providers: kubernetesCRD: namespaces: - \"default\" - \"production\" # ... CLI --providers.kubernetescrd.namespaces=default,production Array of namespaces to watch. labelselector \u00b6 Optional,Default: empty (process all Ingresses) File (TOML) [providers.kubernetesCRD] labelselector = \"A and not B\" # ... File (YAML) providers: kubernetesCRD: labelselector: \"A and not B\" # ... CLI --providers.kubernetescrd.labelselector=\"A and not B\" By default, Traefik processes all Ingress objects in the configured namespaces. A label selector can be defined to filter on specific Ingress objects only. See label-selectors for details. ingressClass \u00b6 Optional, Default: empty File (TOML) [providers.kubernetesCRD] ingressClass = \"traefik-internal\" # ... File (YAML) providers: kubernetesCRD: ingressClass: \"traefik-internal\" # ... CLI --providers.kubernetescrd.ingressclass=traefik-internal Value of kubernetes.io/ingress.class annotation that identifies Ingress objects to be processed. If the parameter is non-empty, only Ingresses containing an annotation with the same value are processed. Otherwise, Ingresses missing the annotation, having an empty value, or the value traefik are processed. throttleDuration \u00b6 Optional, Default: 0 (no throttling) File (TOML) [providers.kubernetesCRD] throttleDuration = \"10s\" # ... File (YAML) providers: kubernetesCRD: throttleDuration: \"10s\" # ... CLI --providers.kubernetescrd.throttleDuration=10s Further \u00b6 Also see the full example with Let's Encrypt.","title":"Kubernetes IngressRoute"},{"location":"providers/kubernetes-crd/#traefik-kubernetes","text":"The Kubernetes Ingress Controller, The Custom Resource Way. Traefik used to support Kubernetes only through the Kubernetes Ingress provider , which is a Kubernetes Ingress controller in the strict sense of the term. However, as the community expressed the need to benefit from Traefik features without resorting to (lots of) annotations, we ended up writing a Custom Resource Definition (alias CRD in the following) for an IngressRoute type, defined below, in order to provide a better way to configure access to a Kubernetes cluster.","title":"Traefik &amp; Kubernetes"},{"location":"providers/kubernetes-crd/#resource-configuration","text":"See the dedicated section in routing .","title":"Resource Configuration"},{"location":"providers/kubernetes-crd/#letsencrypt-support-with-the-custom-resource-definition-provider","text":"By design, Traefik is a stateless application, meaning that it only derives its configuration from the environment it runs in, without additional configuration. For this reason, users can run multiple instances of Traefik at the same time to achieve HA, as is a common pattern in the kubernetes ecosystem. When using a single instance of Traefik with LetsEncrypt, no issues should be encountered, however this could be a single point of failure. Unfortunately, it is not possible to run multiple instances of Traefik 2.0 with LetsEncrypt enabled, because there is no way to ensure that the correct instance of Traefik will receive the challenge request, and subsequent responses. Previous versions of Traefik used a KV store to attempt to achieve this, but due to sub-optimal performance was dropped as a feature in 2.0. If you require LetsEncrypt with HA in a kubernetes environment, we recommend using TraefikEE where distributed LetsEncrypt is a supported feature. If you are wanting to continue to run Traefik Community Edition, LetsEncrypt HA can be achieved by using a Certificate Controller such as Cert-Manager . When using Cert-Manager to manage certificates, it will create secrets in your namespaces that can be referenced as TLS secrets in your ingress objects . When using the Traefik Kubernetes CRD Provider, unfortunately Cert-Manager cannot interface directly with the CRDs yet , but this is being worked on by our team. A workaround it to enable the Kubernetes Ingress provider to allow Cert-Manager to create ingress objects to complete the challenges. Please note that this still requires manual intervention to create the certificates through Cert-Manager, but once created, Cert-Manager will keep the certificate renewed.","title":"LetsEncrypt Support with the Custom Resource Definition Provider"},{"location":"providers/kubernetes-crd/#provider-configuration","text":"","title":"Provider Configuration"},{"location":"providers/kubernetes-crd/#endpoint","text":"Optional, Default=empty File (TOML) [providers.kubernetesCRD] endpoint = \"http://localhost:8080\" # ... File (YAML) providers: kubernetesCRD: endpoint = \"http://localhost:8080\" # ... CLI --providers.kubernetescrd.endpoint=http://localhost:8080 The Kubernetes server endpoint as URL. When deployed into Kubernetes, Traefik will read the environment variables KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT or KUBECONFIG to construct the endpoint. The access token will be looked up in /var/run/secrets/kubernetes.io/serviceaccount/token and the SSL CA certificate in /var/run/secrets/kubernetes.io/serviceaccount/ca.crt . Both are provided mounted automatically when deployed inside Kubernetes. The endpoint may be specified to override the environment variable values inside a cluster. When the environment variables are not found, Traefik will try to connect to the Kubernetes API server with an external-cluster client. In this case, the endpoint is required. Specifically, it may be set to the URL used by kubectl proxy to connect to a Kubernetes cluster using the granted authentication and authorization of the associated kubeconfig.","title":"endpoint"},{"location":"providers/kubernetes-crd/#token","text":"Optional, Default=empty File (TOML) [providers.kubernetesCRD] token = \"mytoken\" # ... File (YAML) providers: kubernetesCRD: token = \"mytoken\" # ... CLI --providers.kubernetescrd.token=mytoken Bearer token used for the Kubernetes client configuration.","title":"token"},{"location":"providers/kubernetes-crd/#certauthfilepath","text":"Optional, Default=empty File (TOML) [providers.kubernetesCRD] certAuthFilePath = \"/my/ca.crt\" # ... File (YAML) providers: kubernetesCRD: certAuthFilePath: \"/my/ca.crt\" # ... CLI --providers.kubernetescrd.certauthfilepath=/my/ca.crt Path to the certificate authority file. Used for the Kubernetes client configuration.","title":"certAuthFilePath"},{"location":"providers/kubernetes-crd/#namespaces","text":"Optional, Default: all namespaces (empty array) File (TOML) [providers.kubernetesCRD] namespaces = [\"default\", \"production\"] # ... File (YAML) providers: kubernetesCRD: namespaces: - \"default\" - \"production\" # ... CLI --providers.kubernetescrd.namespaces=default,production Array of namespaces to watch.","title":"namespaces"},{"location":"providers/kubernetes-crd/#labelselector","text":"Optional,Default: empty (process all Ingresses) File (TOML) [providers.kubernetesCRD] labelselector = \"A and not B\" # ... File (YAML) providers: kubernetesCRD: labelselector: \"A and not B\" # ... CLI --providers.kubernetescrd.labelselector=\"A and not B\" By default, Traefik processes all Ingress objects in the configured namespaces. A label selector can be defined to filter on specific Ingress objects only. See label-selectors for details.","title":"labelselector"},{"location":"providers/kubernetes-crd/#ingressclass","text":"Optional, Default: empty File (TOML) [providers.kubernetesCRD] ingressClass = \"traefik-internal\" # ... File (YAML) providers: kubernetesCRD: ingressClass: \"traefik-internal\" # ... CLI --providers.kubernetescrd.ingressclass=traefik-internal Value of kubernetes.io/ingress.class annotation that identifies Ingress objects to be processed. If the parameter is non-empty, only Ingresses containing an annotation with the same value are processed. Otherwise, Ingresses missing the annotation, having an empty value, or the value traefik are processed.","title":"ingressClass"},{"location":"providers/kubernetes-crd/#throttleduration","text":"Optional, Default: 0 (no throttling) File (TOML) [providers.kubernetesCRD] throttleDuration = \"10s\" # ... File (YAML) providers: kubernetesCRD: throttleDuration: \"10s\" # ... CLI --providers.kubernetescrd.throttleDuration=10s","title":"throttleDuration"},{"location":"providers/kubernetes-crd/#further","text":"Also see the full example with Let's Encrypt.","title":"Further"},{"location":"providers/kubernetes-ingress/","text":"Traefik & Kubernetes \u00b6 The Kubernetes Ingress Controller. The Traefik Kubernetes Ingress provider is a Kubernetes Ingress controller; that is to say, it manages access to a cluster services by supporting the Ingress specification. Enabling and using the provider \u00b6 As usual, the provider is enabled through the static configuration: File (TOML) [providers.kubernetesIngress] File (YAML) providers: kubernetesIngress: {} CLI --providers.kubernetesingress=true The provider then watches for incoming ingresses events, such as the example below, and derives the corresponding dynamic configuration from it, which in turn will create the resulting routers, services, handlers, etc. File (YAML) kind: Ingress apiVersion: extensions/v1beta1 metadata: name: \"foo\" namespace: production spec: rules: - host: foo.com http: paths: - path: /bar backend: serviceName: service1 servicePort: 80 - path: /foo backend: serviceName: service1 servicePort: 80 LetsEncrypt Support with the Ingress Provider \u00b6 By design, Traefik is a stateless application, meaning that it only derives its configuration from the environment it runs in, without additional configuration. For this reason, users can run multiple instances of Traefik at the same time to achieve HA, as is a common pattern in the kubernetes ecosystem. When using a single instance of Traefik with LetsEncrypt, no issues should be encountered, however this could be a single point of failure. Unfortunately, it is not possible to run multiple instances of Traefik 2.0 with LetsEncrypt enabled, because there is no way to ensure that the correct instance of Traefik will receive the challenge request, and subsequent responses. Previous versions of Traefik used a KV store to attempt to achieve this, but due to sub-optimal performance was dropped as a feature in 2.0. If you require LetsEncrypt with HA in a kubernetes environment, we recommend using TraefikEE where distributed LetsEncrypt is a supported feature. If you are wanting to continue to run Traefik Community Edition, LetsEncrypt HA can be achieved by using a Certificate Controller such as Cert-Manager . When using Cert-Manager to manage certificates, it will create secrets in your namespaces that can be referenced as TLS secrets in your ingress objects . Provider Configuration \u00b6 endpoint \u00b6 Optional, Default=empty File (TOML) [providers.kubernetesIngress] endpoint = \"http://localhost:8080\" # ... File (YAML) providers: kubernetesIngress: endpoint = \"http://localhost:8080\" # ... CLI --providers.kubernetesingress.endpoint=http://localhost:8080 The Kubernetes server endpoint as URL, which is only used when the behavior based on environment variables described below does not apply. When deployed into Kubernetes, Traefik reads the environment variables KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT or KUBECONFIG to construct the endpoint. The access token is looked up in /var/run/secrets/kubernetes.io/serviceaccount/token and the SSL CA certificate in /var/run/secrets/kubernetes.io/serviceaccount/ca.crt . They are both provided automatically as mounts in the pod where Traefik is deployed. When the environment variables are not found, Traefik tries to connect to the Kubernetes API server with an external-cluster client. In which case, the endpoint is required. Specifically, it may be set to the URL used by kubectl proxy to connect to a Kubernetes cluster using the granted authentication and authorization of the associated kubeconfig. token \u00b6 Optional, Default=empty File (TOML) [providers.kubernetesIngress] token = \"mytoken\" # ... File (YAML) providers: kubernetesIngress: token = \"mytoken\" # ... CLI --providers.kubernetesingress.token=mytoken Bearer token used for the Kubernetes client configuration. certAuthFilePath \u00b6 Optional, Default=empty File (TOML) [providers.kubernetesIngress] certAuthFilePath = \"/my/ca.crt\" # ... File (YAML) providers: kubernetesIngress: certAuthFilePath: \"/my/ca.crt\" # ... CLI --providers.kubernetesingress.certauthfilepath=/my/ca.crt Path to the certificate authority file. Used for the Kubernetes client configuration. disablePassHostHeaders \u00b6 Optional, Default=false File (TOML) [providers.kubernetesIngress] disablePassHostHeaders = true # ... File (YAML) providers: kubernetesIngress: disablePassHostHeaders: true # ... CLI --providers.kubernetesingress.disablepasshostheaders=true Whether to disable PassHost Headers. namespaces \u00b6 Optional, Default: all namespaces (empty array) File (TOML) [providers.kubernetesIngress] namespaces = [\"default\", \"production\"] # ... File (YAML) providers: kubernetesIngress: namespaces: - \"default\" - \"production\" # ... CLI --providers.kubernetesingress.namespaces=default,production Array of namespaces to watch. labelSelector \u00b6 Optional,Default: empty (process all Ingresses) File (TOML) [providers.kubernetesIngress] labelSelector = \"A and not B\" # ... File (YAML) providers: kubernetesIngress: labelselector: \"A and not B\" # ... CLI --providers.kubernetesingress.labelselector=\"A and not B\" By default, Traefik processes all Ingress objects in the configured namespaces. A label selector can be defined to filter on specific Ingress objects only. See label-selectors for details. ingressClass \u00b6 Optional, Default: empty File (TOML) [providers.kubernetesIngress] ingressClass = \"traefik-internal\" # ... File (YAML) providers: kubernetesIngress: ingressClass: \"traefik-internal\" # ... CLI --providers.kubernetesingress.ingressclass=traefik-internal Value of kubernetes.io/ingress.class annotation that identifies Ingress objects to be processed. If the parameter is non-empty, only Ingresses containing an annotation with the same value are processed. Otherwise, Ingresses missing the annotation, having an empty value, or with the value traefik are processed. ingressEndpoint \u00b6 hostname \u00b6 Optional, Default: empty File (TOML) [providers.kubernetesIngress.ingressEndpoint] hostname = \"foo.com\" # ... File (YAML) providers: kubernetesIngress: ingressEndpoint: hostname: \"foo.com\" # ... CLI --providers.kubernetesingress.ingressendpoint.hostname=foo.com Hostname used for Kubernetes Ingress endpoints. ip \u00b6 Optional, Default: empty File (TOML) [providers.kubernetesIngress.ingressEndpoint] ip = \"1.2.3.4\" # ... File (YAML) providers: kubernetesIngress: ingressEndpoint: ip: \"1.2.3.4\" # ... CLI --providers.kubernetesingress.ingressendpoint.ip=1.2.3.4 IP used for Kubernetes Ingress endpoints. publishedService \u00b6 Optional, Default: empty File (TOML) [providers.kubernetesIngress.ingressEndpoint] publishedService = \"foo-service\" # ... File (YAML) providers: kubernetesIngress: ingressEndpoint: publishedService: \"foo-service\" # ... CLI --providers.kubernetesingress.ingressendpoint.publishedservice=foo-service Published Kubernetes Service to copy status from. throttleDuration \u00b6 Optional, Default: 0 (no throttling) File (TOML) [providers.kubernetesIngress] throttleDuration = \"10s\" # ... File (YAML) providers: kubernetesIngress: throttleDuration: \"10s\" # ... CLI --providers.kubernetesingress.throttleDuration=10s Further \u00b6 If one wants to know more about the various aspects of the Ingress spec that Traefik supports, many examples of Ingresses definitions are located in the tests data of the Traefik repository.","title":"Kubernetes Ingress"},{"location":"providers/kubernetes-ingress/#traefik-kubernetes","text":"The Kubernetes Ingress Controller. The Traefik Kubernetes Ingress provider is a Kubernetes Ingress controller; that is to say, it manages access to a cluster services by supporting the Ingress specification.","title":"Traefik &amp; Kubernetes"},{"location":"providers/kubernetes-ingress/#enabling-and-using-the-provider","text":"As usual, the provider is enabled through the static configuration: File (TOML) [providers.kubernetesIngress] File (YAML) providers: kubernetesIngress: {} CLI --providers.kubernetesingress=true The provider then watches for incoming ingresses events, such as the example below, and derives the corresponding dynamic configuration from it, which in turn will create the resulting routers, services, handlers, etc. File (YAML) kind: Ingress apiVersion: extensions/v1beta1 metadata: name: \"foo\" namespace: production spec: rules: - host: foo.com http: paths: - path: /bar backend: serviceName: service1 servicePort: 80 - path: /foo backend: serviceName: service1 servicePort: 80","title":"Enabling and using the provider"},{"location":"providers/kubernetes-ingress/#letsencrypt-support-with-the-ingress-provider","text":"By design, Traefik is a stateless application, meaning that it only derives its configuration from the environment it runs in, without additional configuration. For this reason, users can run multiple instances of Traefik at the same time to achieve HA, as is a common pattern in the kubernetes ecosystem. When using a single instance of Traefik with LetsEncrypt, no issues should be encountered, however this could be a single point of failure. Unfortunately, it is not possible to run multiple instances of Traefik 2.0 with LetsEncrypt enabled, because there is no way to ensure that the correct instance of Traefik will receive the challenge request, and subsequent responses. Previous versions of Traefik used a KV store to attempt to achieve this, but due to sub-optimal performance was dropped as a feature in 2.0. If you require LetsEncrypt with HA in a kubernetes environment, we recommend using TraefikEE where distributed LetsEncrypt is a supported feature. If you are wanting to continue to run Traefik Community Edition, LetsEncrypt HA can be achieved by using a Certificate Controller such as Cert-Manager . When using Cert-Manager to manage certificates, it will create secrets in your namespaces that can be referenced as TLS secrets in your ingress objects .","title":"LetsEncrypt Support with the Ingress Provider"},{"location":"providers/kubernetes-ingress/#provider-configuration","text":"","title":"Provider Configuration"},{"location":"providers/kubernetes-ingress/#endpoint","text":"Optional, Default=empty File (TOML) [providers.kubernetesIngress] endpoint = \"http://localhost:8080\" # ... File (YAML) providers: kubernetesIngress: endpoint = \"http://localhost:8080\" # ... CLI --providers.kubernetesingress.endpoint=http://localhost:8080 The Kubernetes server endpoint as URL, which is only used when the behavior based on environment variables described below does not apply. When deployed into Kubernetes, Traefik reads the environment variables KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT or KUBECONFIG to construct the endpoint. The access token is looked up in /var/run/secrets/kubernetes.io/serviceaccount/token and the SSL CA certificate in /var/run/secrets/kubernetes.io/serviceaccount/ca.crt . They are both provided automatically as mounts in the pod where Traefik is deployed. When the environment variables are not found, Traefik tries to connect to the Kubernetes API server with an external-cluster client. In which case, the endpoint is required. Specifically, it may be set to the URL used by kubectl proxy to connect to a Kubernetes cluster using the granted authentication and authorization of the associated kubeconfig.","title":"endpoint"},{"location":"providers/kubernetes-ingress/#token","text":"Optional, Default=empty File (TOML) [providers.kubernetesIngress] token = \"mytoken\" # ... File (YAML) providers: kubernetesIngress: token = \"mytoken\" # ... CLI --providers.kubernetesingress.token=mytoken Bearer token used for the Kubernetes client configuration.","title":"token"},{"location":"providers/kubernetes-ingress/#certauthfilepath","text":"Optional, Default=empty File (TOML) [providers.kubernetesIngress] certAuthFilePath = \"/my/ca.crt\" # ... File (YAML) providers: kubernetesIngress: certAuthFilePath: \"/my/ca.crt\" # ... CLI --providers.kubernetesingress.certauthfilepath=/my/ca.crt Path to the certificate authority file. Used for the Kubernetes client configuration.","title":"certAuthFilePath"},{"location":"providers/kubernetes-ingress/#disablepasshostheaders","text":"Optional, Default=false File (TOML) [providers.kubernetesIngress] disablePassHostHeaders = true # ... File (YAML) providers: kubernetesIngress: disablePassHostHeaders: true # ... CLI --providers.kubernetesingress.disablepasshostheaders=true Whether to disable PassHost Headers.","title":"disablePassHostHeaders"},{"location":"providers/kubernetes-ingress/#namespaces","text":"Optional, Default: all namespaces (empty array) File (TOML) [providers.kubernetesIngress] namespaces = [\"default\", \"production\"] # ... File (YAML) providers: kubernetesIngress: namespaces: - \"default\" - \"production\" # ... CLI --providers.kubernetesingress.namespaces=default,production Array of namespaces to watch.","title":"namespaces"},{"location":"providers/kubernetes-ingress/#labelselector","text":"Optional,Default: empty (process all Ingresses) File (TOML) [providers.kubernetesIngress] labelSelector = \"A and not B\" # ... File (YAML) providers: kubernetesIngress: labelselector: \"A and not B\" # ... CLI --providers.kubernetesingress.labelselector=\"A and not B\" By default, Traefik processes all Ingress objects in the configured namespaces. A label selector can be defined to filter on specific Ingress objects only. See label-selectors for details.","title":"labelSelector"},{"location":"providers/kubernetes-ingress/#ingressclass","text":"Optional, Default: empty File (TOML) [providers.kubernetesIngress] ingressClass = \"traefik-internal\" # ... File (YAML) providers: kubernetesIngress: ingressClass: \"traefik-internal\" # ... CLI --providers.kubernetesingress.ingressclass=traefik-internal Value of kubernetes.io/ingress.class annotation that identifies Ingress objects to be processed. If the parameter is non-empty, only Ingresses containing an annotation with the same value are processed. Otherwise, Ingresses missing the annotation, having an empty value, or with the value traefik are processed.","title":"ingressClass"},{"location":"providers/kubernetes-ingress/#ingressendpoint","text":"","title":"ingressEndpoint"},{"location":"providers/kubernetes-ingress/#hostname","text":"Optional, Default: empty File (TOML) [providers.kubernetesIngress.ingressEndpoint] hostname = \"foo.com\" # ... File (YAML) providers: kubernetesIngress: ingressEndpoint: hostname: \"foo.com\" # ... CLI --providers.kubernetesingress.ingressendpoint.hostname=foo.com Hostname used for Kubernetes Ingress endpoints.","title":"hostname"},{"location":"providers/kubernetes-ingress/#ip","text":"Optional, Default: empty File (TOML) [providers.kubernetesIngress.ingressEndpoint] ip = \"1.2.3.4\" # ... File (YAML) providers: kubernetesIngress: ingressEndpoint: ip: \"1.2.3.4\" # ... CLI --providers.kubernetesingress.ingressendpoint.ip=1.2.3.4 IP used for Kubernetes Ingress endpoints.","title":"ip"},{"location":"providers/kubernetes-ingress/#publishedservice","text":"Optional, Default: empty File (TOML) [providers.kubernetesIngress.ingressEndpoint] publishedService = \"foo-service\" # ... File (YAML) providers: kubernetesIngress: ingressEndpoint: publishedService: \"foo-service\" # ... CLI --providers.kubernetesingress.ingressendpoint.publishedservice=foo-service Published Kubernetes Service to copy status from.","title":"publishedService"},{"location":"providers/kubernetes-ingress/#throttleduration","text":"Optional, Default: 0 (no throttling) File (TOML) [providers.kubernetesIngress] throttleDuration = \"10s\" # ... File (YAML) providers: kubernetesIngress: throttleDuration: \"10s\" # ... CLI --providers.kubernetesingress.throttleDuration=10s","title":"throttleDuration"},{"location":"providers/kubernetes-ingress/#further","text":"If one wants to know more about the various aspects of the Ingress spec that Traefik supports, many examples of Ingresses definitions are located in the tests data of the Traefik repository.","title":"Further"},{"location":"providers/marathon/","text":"Traefik & Marathon \u00b6 Traefik can be configured to use Marathon as a provider. See also Marathon user guide . Configuration Examples \u00b6 Configuring Marathon & Deploying / Exposing Applications Enabling the marathon provider File (TOML) [providers.marathon] File (YAML) providers: marathon: {} CLI --providers.marathon=true Attaching labels to marathon applications { \"id\": \"/whoami\", \"container\": { \"type\": \"DOCKER\", \"docker\": { \"image\": \"containous/whoami\", \"network\": \"BRIDGE\", \"portMappings\": [ { \"containerPort\": 80, \"hostPort\": 0, \"protocol\": \"tcp\" } ] } }, \"labels\": { \"traefik.http.Routers.app.Rule\": \"PathPrefix(`/app`)\" } } Routing Configuration \u00b6 See the dedicated section in routing . Provider Configuration \u00b6 basic \u00b6 Optional File (TOML) [providers.marathon.basic] httpBasicAuthUser = \"foo\" httpBasicPassword = \"bar\" File (YAML) providers: marathon: basic: httpBasicAuthUser: foo httpBasicPassword: bar CLI --providers.marathon.basic.httpbasicauthuser=foo --providers.marathon.basic.httpbasicpassword=bar Enables Marathon basic authentication. dcosToken \u00b6 Optional File (TOML) [providers.marathon] dcosToken = \"xxxxxx\" # ... File (YAML) providers: marathon: dcosToken: \"xxxxxx\" # ... CLI --providers.marathon.dcosToken=xxxxxx DCOSToken for DCOS environment. If set, it overrides the Authorization header. defaultRule \u00b6 Optional, Default= Host(`{{ normalize .Name }}`) File (TOML) [providers.marathon] defaultRule = \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... File (YAML) providers: marathon: defaultRule: \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... CLI --providers.marathon.defaultRule=Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`) # ... For a given application if no routing rule was defined by a label, it is defined by this defaultRule instead. It must be a valid Go template , augmented with the sprig template functions . The app ID can be accessed as the Name identifier, and the template has access to all the labels defined on this Marathon application. dialerTimeout \u00b6 Optional, Default=5s File (TOML) [providers.marathon] dialerTimeout = \"10s\" # ... File (YAML) providers: marathon: dialerTimeout: \"10s\" # ... CLI --providers.marathon.dialerTimeout=10s Overrides DialerTimeout. Amount of time the Marathon provider should wait before timing out, when trying to open a TCP connection to a Marathon master. Can be provided in a format supported by time.ParseDuration , or directly as a number of seconds. endpoint \u00b6 Optional, Default=http://127.0.0.1:8080 File (TOML) [providers.marathon] endpoint = \"http://10.241.1.71:8080,10.241.1.72:8080,10.241.1.73:8080\" # ... File (YAML) providers: marathon: endpoint: \"http://10.241.1.71:8080,10.241.1.72:8080,10.241.1.73:8080\" # ... CLI --providers.marathon.endpoint=http://10.241.1.71:8080,10.241.1.72:8080,10.241.1.73:8080 Marathon server endpoint. You can optionally specify multiple endpoints: exposedByDefault \u00b6 Optional, Default=true File (TOML) [providers.marathon] exposedByDefault = false # ... File (YAML) providers: marathon: exposedByDefault: false # ... CLI --providers.marathon.exposedByDefault=false # ... Exposes Marathon applications by default through Traefik. If set to false, applications that don't have a traefik.enable=true label will be ignored from the resulting routing configuration. See also Restrict the Scope of Service Discovery . constraints \u00b6 Optional, Default=\"\" File (TOML) [providers.marathon] constraints = \"Label(`a.label.name`,`foo`)\" # ... File (YAML) providers: marathon: constraints: \"Label(`a.label.name`,`foo`)\" # ... CLI --providers.marathon.constraints=Label(`a.label.name`,`foo`) # ... Constraints is an expression that Traefik matches against the application's labels to determine whether to create any route for that application. That is to say, if none of the application's labels match the expression, no route for the application is created. In addition, the expression also matched against the application's constraints, such as described in Marathon constraints . If the expression is empty, all detected applications are included. The expression syntax is based on the Label(\"key\", \"value\") , and LabelRegex(\"key\", \"value\") , as well as the usual boolean logic. In addition, to match against marathon constraints, the function MarathonConstraint(\"field:operator:value\") can be used, where the field, operator, and value parts are joined together in a single string with the : separator. Constraints Expression Examples # Includes only applications having a label with key `a.label.name` and value `foo` constraints = \"Label(`a.label.name`, `foo`)\" # Excludes applications having any label with key `a.label.name` and value `foo` constraints = \"!Label(`a.label.name`, `value`)\" # With logical AND. constraints = \"Label(`a.label.name`, `valueA`) && Label(`another.label.name`, `valueB`)\" # With logical OR. constraints = \"Label(`a.label.name`, `valueA`) || Label(`another.label.name`, `valueB`)\" # With logical AND and OR, with precedence set by parentheses. constraints = \"Label(`a.label.name`, `valueA`) && (Label(`another.label.name`, `valueB`) || Label(`yet.another.label.name`, `valueC`))\" # Includes only applications having a label with key `a.label.name` and a value matching the `a.+` regular expression. constraints = \"LabelRegex(`a.label.name`, `a.+`)\" # Includes only applications having a Marathon constraint with field `A`, operator `B`, and value `C`. constraints = \"MarathonConstraint(`A:B:C`)\" # Uses both Marathon constraint and application label with logical operator. constraints = \"MarathonConstraint(`A:B:C`) && Label(`a.label.name`, `value`)\" See also Restrict the Scope of Service Discovery . forceTaskHostname \u00b6 Optional, Default=false File (TOML) [providers.marathon] forceTaskHostname = true # ... File (YAML) providers: marathon: forceTaskHostname: true # ... CLI --providers.marathon.forceTaskHostname=true # ... By default, a task's IP address (as returned by the Marathon API) is used as backend server if an IP-per-task configuration can be found; otherwise, the name of the host running the task is used. The latter behavior can be enforced by enabling this switch. keepAlive \u00b6 Optional, Default=10s File (TOML) [providers.marathon] keepAlive = \"30s\" # ... File (YAML) providers: marathon: keepAlive: \"30s\" # ... CLI --providers.marathon.keepAlive=30s # ... Set the TCP Keep Alive interval for the Marathon HTTP Client. Can be provided in a format supported by time.ParseDuration , or directly as a number of seconds. respectReadinessChecks \u00b6 Optional, Default=false File (TOML) [providers.marathon] respectReadinessChecks = true # ... File (YAML) providers: marathon: respectReadinessChecks: true # ... CLI --providers.marathon.respectReadinessChecks=true # ... Applications may define readiness checks which are probed by Marathon during deployments periodically, and these check results are exposed via the API. Enabling respectReadinessChecks causes Traefik to filter out tasks whose readiness checks have not succeeded. Note that the checks are only valid at deployment times. See the Marathon guide for details. responseHeaderTimeout \u00b6 Optional, Default=60s File (TOML) [providers.marathon] responseHeaderTimeout = \"66s\" # ... File (YAML) providers: marathon: responseHeaderTimeout: \"66s\" # ... CLI --providers.marathon.responseHeaderTimeout=66s # ... Overrides ResponseHeaderTimeout. Amount of time the Marathon provider should wait before timing out, when waiting for the first response header from a Marathon master. Can be provided in a format supported by time.ParseDuration , or directly as a number of seconds. tls \u00b6 Optional tls.ca \u00b6 Certificate Authority used for the secured connection to Marathon. File (TOML) [providers.marathon.tls] ca = \"path/to/ca.crt\" File (YAML) providers: marathon: tls: ca: path/to/ca.crt CLI --providers.marathon.tls.ca=path/to/ca.crt tls.caOptional \u00b6 Policy followed for the secured connection to Marathon with TLS Client Authentication. Requires tls.ca to be defined. true : VerifyClientCertIfGiven false : RequireAndVerifyClientCert if tls.ca is undefined NoClientCert File (TOML) [providers.marathon.tls] caOptional = true File (YAML) providers: marathon: tls: caOptional: true CLI --providers.marathon.tls.caOptional=true tls.cert \u00b6 Public certificate used for the secured connection to Marathon. File (TOML) [providers.marathon.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) providers: marathon: tls: cert: path/to/foo.cert key: path/to/foo.key CLI --providers.marathon.tls.cert=path/to/foo.cert --providers.marathon.tls.key=path/to/foo.key tls.key \u00b6 Private certificate used for the secured connection to Marathon. File (TOML) [providers.marathon.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) providers: marathon: tls: cert: path/to/foo.cert key: path/to/foo.key CLI --providers.marathon.tls.cert=path/to/foo.cert --providers.marathon.tls.key=path/to/foo.key tls.insecureSkipVerify \u00b6 If insecureSkipVerify is true , TLS for the connection to Marathon accepts any certificate presented by the server and any host name in that certificate. File (TOML) [providers.marathon.tls] insecureSkipVerify = true File (YAML) providers: marathon: tls: insecureSkipVerify: true CLI --providers.marathon.tls.insecureSkipVerify=true tlsHandshakeTimeout \u00b6 Optional, Default=5s File (TOML) [providers.marathon] responseHeaderTimeout = \"10s\" # ... File (YAML) providers: marathon: responseHeaderTimeout: \"10s\" # ... CLI --providers.marathon.responseHeaderTimeout=10s # ... Overrides TLSHandshakeTimeout. Amount of time the Marathon provider should wait before timing out, when waiting for the TLS handshake to complete. Can be provided in a format supported by time.ParseDuration , or directly as a number of seconds. trace \u00b6 Optional, Default=false File (TOML) [providers.marathon] trace = true # ... File (YAML) providers: marathon: trace: true # ... CLI --providers.marathon.trace=true # ... Displays additional provider logs (if available). watch \u00b6 Optional, Default=true File (TOML) [providers.marathon] watch = false # ... File (YAML) providers: marathon: watch: false # ... CLI --providers.marathon.watch=false # ... Enables watching for Marathon changes.","title":"Marathon"},{"location":"providers/marathon/#traefik-marathon","text":"Traefik can be configured to use Marathon as a provider. See also Marathon user guide .","title":"Traefik &amp; Marathon"},{"location":"providers/marathon/#configuration-examples","text":"Configuring Marathon & Deploying / Exposing Applications Enabling the marathon provider File (TOML) [providers.marathon] File (YAML) providers: marathon: {} CLI --providers.marathon=true Attaching labels to marathon applications { \"id\": \"/whoami\", \"container\": { \"type\": \"DOCKER\", \"docker\": { \"image\": \"containous/whoami\", \"network\": \"BRIDGE\", \"portMappings\": [ { \"containerPort\": 80, \"hostPort\": 0, \"protocol\": \"tcp\" } ] } }, \"labels\": { \"traefik.http.Routers.app.Rule\": \"PathPrefix(`/app`)\" } }","title":"Configuration Examples"},{"location":"providers/marathon/#routing-configuration","text":"See the dedicated section in routing .","title":"Routing Configuration"},{"location":"providers/marathon/#provider-configuration","text":"","title":"Provider Configuration"},{"location":"providers/marathon/#basic","text":"Optional File (TOML) [providers.marathon.basic] httpBasicAuthUser = \"foo\" httpBasicPassword = \"bar\" File (YAML) providers: marathon: basic: httpBasicAuthUser: foo httpBasicPassword: bar CLI --providers.marathon.basic.httpbasicauthuser=foo --providers.marathon.basic.httpbasicpassword=bar Enables Marathon basic authentication.","title":"basic"},{"location":"providers/marathon/#dcostoken","text":"Optional File (TOML) [providers.marathon] dcosToken = \"xxxxxx\" # ... File (YAML) providers: marathon: dcosToken: \"xxxxxx\" # ... CLI --providers.marathon.dcosToken=xxxxxx DCOSToken for DCOS environment. If set, it overrides the Authorization header.","title":"dcosToken"},{"location":"providers/marathon/#defaultrule","text":"Optional, Default= Host(`{{ normalize .Name }}`) File (TOML) [providers.marathon] defaultRule = \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... File (YAML) providers: marathon: defaultRule: \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... CLI --providers.marathon.defaultRule=Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`) # ... For a given application if no routing rule was defined by a label, it is defined by this defaultRule instead. It must be a valid Go template , augmented with the sprig template functions . The app ID can be accessed as the Name identifier, and the template has access to all the labels defined on this Marathon application.","title":"defaultRule"},{"location":"providers/marathon/#dialertimeout","text":"Optional, Default=5s File (TOML) [providers.marathon] dialerTimeout = \"10s\" # ... File (YAML) providers: marathon: dialerTimeout: \"10s\" # ... CLI --providers.marathon.dialerTimeout=10s Overrides DialerTimeout. Amount of time the Marathon provider should wait before timing out, when trying to open a TCP connection to a Marathon master. Can be provided in a format supported by time.ParseDuration , or directly as a number of seconds.","title":"dialerTimeout"},{"location":"providers/marathon/#endpoint","text":"Optional, Default=http://127.0.0.1:8080 File (TOML) [providers.marathon] endpoint = \"http://10.241.1.71:8080,10.241.1.72:8080,10.241.1.73:8080\" # ... File (YAML) providers: marathon: endpoint: \"http://10.241.1.71:8080,10.241.1.72:8080,10.241.1.73:8080\" # ... CLI --providers.marathon.endpoint=http://10.241.1.71:8080,10.241.1.72:8080,10.241.1.73:8080 Marathon server endpoint. You can optionally specify multiple endpoints:","title":"endpoint"},{"location":"providers/marathon/#exposedbydefault","text":"Optional, Default=true File (TOML) [providers.marathon] exposedByDefault = false # ... File (YAML) providers: marathon: exposedByDefault: false # ... CLI --providers.marathon.exposedByDefault=false # ... Exposes Marathon applications by default through Traefik. If set to false, applications that don't have a traefik.enable=true label will be ignored from the resulting routing configuration. See also Restrict the Scope of Service Discovery .","title":"exposedByDefault"},{"location":"providers/marathon/#constraints","text":"Optional, Default=\"\" File (TOML) [providers.marathon] constraints = \"Label(`a.label.name`,`foo`)\" # ... File (YAML) providers: marathon: constraints: \"Label(`a.label.name`,`foo`)\" # ... CLI --providers.marathon.constraints=Label(`a.label.name`,`foo`) # ... Constraints is an expression that Traefik matches against the application's labels to determine whether to create any route for that application. That is to say, if none of the application's labels match the expression, no route for the application is created. In addition, the expression also matched against the application's constraints, such as described in Marathon constraints . If the expression is empty, all detected applications are included. The expression syntax is based on the Label(\"key\", \"value\") , and LabelRegex(\"key\", \"value\") , as well as the usual boolean logic. In addition, to match against marathon constraints, the function MarathonConstraint(\"field:operator:value\") can be used, where the field, operator, and value parts are joined together in a single string with the : separator. Constraints Expression Examples # Includes only applications having a label with key `a.label.name` and value `foo` constraints = \"Label(`a.label.name`, `foo`)\" # Excludes applications having any label with key `a.label.name` and value `foo` constraints = \"!Label(`a.label.name`, `value`)\" # With logical AND. constraints = \"Label(`a.label.name`, `valueA`) && Label(`another.label.name`, `valueB`)\" # With logical OR. constraints = \"Label(`a.label.name`, `valueA`) || Label(`another.label.name`, `valueB`)\" # With logical AND and OR, with precedence set by parentheses. constraints = \"Label(`a.label.name`, `valueA`) && (Label(`another.label.name`, `valueB`) || Label(`yet.another.label.name`, `valueC`))\" # Includes only applications having a label with key `a.label.name` and a value matching the `a.+` regular expression. constraints = \"LabelRegex(`a.label.name`, `a.+`)\" # Includes only applications having a Marathon constraint with field `A`, operator `B`, and value `C`. constraints = \"MarathonConstraint(`A:B:C`)\" # Uses both Marathon constraint and application label with logical operator. constraints = \"MarathonConstraint(`A:B:C`) && Label(`a.label.name`, `value`)\" See also Restrict the Scope of Service Discovery .","title":"constraints"},{"location":"providers/marathon/#forcetaskhostname","text":"Optional, Default=false File (TOML) [providers.marathon] forceTaskHostname = true # ... File (YAML) providers: marathon: forceTaskHostname: true # ... CLI --providers.marathon.forceTaskHostname=true # ... By default, a task's IP address (as returned by the Marathon API) is used as backend server if an IP-per-task configuration can be found; otherwise, the name of the host running the task is used. The latter behavior can be enforced by enabling this switch.","title":"forceTaskHostname"},{"location":"providers/marathon/#keepalive","text":"Optional, Default=10s File (TOML) [providers.marathon] keepAlive = \"30s\" # ... File (YAML) providers: marathon: keepAlive: \"30s\" # ... CLI --providers.marathon.keepAlive=30s # ... Set the TCP Keep Alive interval for the Marathon HTTP Client. Can be provided in a format supported by time.ParseDuration , or directly as a number of seconds.","title":"keepAlive"},{"location":"providers/marathon/#respectreadinesschecks","text":"Optional, Default=false File (TOML) [providers.marathon] respectReadinessChecks = true # ... File (YAML) providers: marathon: respectReadinessChecks: true # ... CLI --providers.marathon.respectReadinessChecks=true # ... Applications may define readiness checks which are probed by Marathon during deployments periodically, and these check results are exposed via the API. Enabling respectReadinessChecks causes Traefik to filter out tasks whose readiness checks have not succeeded. Note that the checks are only valid at deployment times. See the Marathon guide for details.","title":"respectReadinessChecks"},{"location":"providers/marathon/#responseheadertimeout","text":"Optional, Default=60s File (TOML) [providers.marathon] responseHeaderTimeout = \"66s\" # ... File (YAML) providers: marathon: responseHeaderTimeout: \"66s\" # ... CLI --providers.marathon.responseHeaderTimeout=66s # ... Overrides ResponseHeaderTimeout. Amount of time the Marathon provider should wait before timing out, when waiting for the first response header from a Marathon master. Can be provided in a format supported by time.ParseDuration , or directly as a number of seconds.","title":"responseHeaderTimeout"},{"location":"providers/marathon/#tls","text":"Optional","title":"tls"},{"location":"providers/marathon/#tlsca","text":"Certificate Authority used for the secured connection to Marathon. File (TOML) [providers.marathon.tls] ca = \"path/to/ca.crt\" File (YAML) providers: marathon: tls: ca: path/to/ca.crt CLI --providers.marathon.tls.ca=path/to/ca.crt","title":"tls.ca"},{"location":"providers/marathon/#tlscaoptional","text":"Policy followed for the secured connection to Marathon with TLS Client Authentication. Requires tls.ca to be defined. true : VerifyClientCertIfGiven false : RequireAndVerifyClientCert if tls.ca is undefined NoClientCert File (TOML) [providers.marathon.tls] caOptional = true File (YAML) providers: marathon: tls: caOptional: true CLI --providers.marathon.tls.caOptional=true","title":"tls.caOptional"},{"location":"providers/marathon/#tlscert","text":"Public certificate used for the secured connection to Marathon. File (TOML) [providers.marathon.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) providers: marathon: tls: cert: path/to/foo.cert key: path/to/foo.key CLI --providers.marathon.tls.cert=path/to/foo.cert --providers.marathon.tls.key=path/to/foo.key","title":"tls.cert"},{"location":"providers/marathon/#tlskey","text":"Private certificate used for the secured connection to Marathon. File (TOML) [providers.marathon.tls] cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" File (YAML) providers: marathon: tls: cert: path/to/foo.cert key: path/to/foo.key CLI --providers.marathon.tls.cert=path/to/foo.cert --providers.marathon.tls.key=path/to/foo.key","title":"tls.key"},{"location":"providers/marathon/#tlsinsecureskipverify","text":"If insecureSkipVerify is true , TLS for the connection to Marathon accepts any certificate presented by the server and any host name in that certificate. File (TOML) [providers.marathon.tls] insecureSkipVerify = true File (YAML) providers: marathon: tls: insecureSkipVerify: true CLI --providers.marathon.tls.insecureSkipVerify=true","title":"tls.insecureSkipVerify"},{"location":"providers/marathon/#tlshandshaketimeout","text":"Optional, Default=5s File (TOML) [providers.marathon] responseHeaderTimeout = \"10s\" # ... File (YAML) providers: marathon: responseHeaderTimeout: \"10s\" # ... CLI --providers.marathon.responseHeaderTimeout=10s # ... Overrides TLSHandshakeTimeout. Amount of time the Marathon provider should wait before timing out, when waiting for the TLS handshake to complete. Can be provided in a format supported by time.ParseDuration , or directly as a number of seconds.","title":"tlsHandshakeTimeout"},{"location":"providers/marathon/#trace","text":"Optional, Default=false File (TOML) [providers.marathon] trace = true # ... File (YAML) providers: marathon: trace: true # ... CLI --providers.marathon.trace=true # ... Displays additional provider logs (if available).","title":"trace"},{"location":"providers/marathon/#watch","text":"Optional, Default=true File (TOML) [providers.marathon] watch = false # ... File (YAML) providers: marathon: watch: false # ... CLI --providers.marathon.watch=false # ... Enables watching for Marathon changes.","title":"watch"},{"location":"providers/overview/","text":"Overview \u00b6 Traefik's Many Friends Configuration discovery in Traefik is achieved through Providers . The providers are existing infrastructure components, whether orchestrators, container engines, cloud providers, or key-value stores. The idea is that Traefik will query the providers' API in order to find relevant information about routing, and each time Traefik detects a change, it dynamically updates the routes. Deploy and forget is Traefik's credo. Orchestrators \u00b6 Even if each provider is different, we can categorize them in four groups: Label based (each deployed container has a set of labels attached to it) Key-Value based (each deployed container updates a key-value store with relevant information) Annotation based (a separate object, with annotations, defines the characteristics of the container) File based (the good old configuration file) Supported Providers \u00b6 Below is the list of the currently supported providers in Traefik. Provider Type Configuration Type Docker Orchestrator Label Kubernetes Orchestrator Custom Resource Marathon Orchestrator Label Rancher Orchestrator Label File Manual TOML/YAML format More Providers The current version of Traefik doesn't support (yet) every provider. See the previous version (v1.7) for more providers. Configuration reload frequency \u00b6 In some cases, some providers might undergo a sudden burst of changes, which would generate a lot of configuration change events. If Traefik took them all into account, that would trigger a lot more configuration reloads than what is necessary, or even useful. In order to mitigate that, the providers.providersThrottleDuration option can be set. It is the duration that Traefik waits for, after a configuration reload, before taking into account any new configuration refresh event. If any event arrives during that duration, only the most recent one is taken into account, and all the previous others are dropped. This option cannot be set per provider, but the throttling algorithm applies independently to each of them. It defaults to 2 seconds. File (TOML) [providers] providers.providersThrottleDuration = 10s File (YAML) providers: providersThrottleDuration: 10s CLI --providers.providersThrottleDuration=10s Restrict the Scope of Service Discovery \u00b6 By default Traefik will create routes for all detected containers. If you want to limit the scope of Traefik's service discovery, i.e. disallow route creation for some containers, you can do so in two different ways: either with the generic configuration option exposedByDefault , or with a finer granularity mechanism based on constraints. exposedByDefault and traefik.enable \u00b6 List of providers that support that feature: Docker Rancher Marathon Constraints \u00b6 List of providers that support constraints: Docker Rancher Marathon Kubernetes CRD Kubernetes Ingress","title":"Overview"},{"location":"providers/overview/#overview","text":"Traefik's Many Friends Configuration discovery in Traefik is achieved through Providers . The providers are existing infrastructure components, whether orchestrators, container engines, cloud providers, or key-value stores. The idea is that Traefik will query the providers' API in order to find relevant information about routing, and each time Traefik detects a change, it dynamically updates the routes. Deploy and forget is Traefik's credo.","title":"Overview"},{"location":"providers/overview/#orchestrators","text":"Even if each provider is different, we can categorize them in four groups: Label based (each deployed container has a set of labels attached to it) Key-Value based (each deployed container updates a key-value store with relevant information) Annotation based (a separate object, with annotations, defines the characteristics of the container) File based (the good old configuration file)","title":"Orchestrators"},{"location":"providers/overview/#supported-providers","text":"Below is the list of the currently supported providers in Traefik. Provider Type Configuration Type Docker Orchestrator Label Kubernetes Orchestrator Custom Resource Marathon Orchestrator Label Rancher Orchestrator Label File Manual TOML/YAML format More Providers The current version of Traefik doesn't support (yet) every provider. See the previous version (v1.7) for more providers.","title":"Supported Providers"},{"location":"providers/overview/#configuration-reload-frequency","text":"In some cases, some providers might undergo a sudden burst of changes, which would generate a lot of configuration change events. If Traefik took them all into account, that would trigger a lot more configuration reloads than what is necessary, or even useful. In order to mitigate that, the providers.providersThrottleDuration option can be set. It is the duration that Traefik waits for, after a configuration reload, before taking into account any new configuration refresh event. If any event arrives during that duration, only the most recent one is taken into account, and all the previous others are dropped. This option cannot be set per provider, but the throttling algorithm applies independently to each of them. It defaults to 2 seconds. File (TOML) [providers] providers.providersThrottleDuration = 10s File (YAML) providers: providersThrottleDuration: 10s CLI --providers.providersThrottleDuration=10s","title":"Configuration reload frequency"},{"location":"providers/overview/#restrict-the-scope-of-service-discovery","text":"By default Traefik will create routes for all detected containers. If you want to limit the scope of Traefik's service discovery, i.e. disallow route creation for some containers, you can do so in two different ways: either with the generic configuration option exposedByDefault , or with a finer granularity mechanism based on constraints.","title":"Restrict the Scope of Service Discovery"},{"location":"providers/overview/#exposedbydefault-and-traefikenable","text":"List of providers that support that feature: Docker Rancher Marathon","title":"exposedByDefault and traefik.enable"},{"location":"providers/overview/#constraints","text":"List of providers that support constraints: Docker Rancher Marathon Kubernetes CRD Kubernetes Ingress","title":"Constraints"},{"location":"providers/rancher/","text":"Traefik & Rancher \u00b6 A Story of Labels, Services & Containers Attach labels to your services and let Traefik do the rest! This provider is specific to Rancher 1.x. Rancher 2.x requires Kubernetes and does not have a metadata endpoint of its own for Traefik to query. As such, Rancher 2.x users should utilize the Kubernetes provider directly. Configuration Examples \u00b6 Configuring Rancher & Deploying / Exposing Services Enabling the rancher provider File (TOML) [providers.rancher] File (YAML) providers: rancher: {} CLI --providers.rancher=true Attaching labels to services labels: - traefik.http.services.my-service.rule=Host(`mydomain.com`) Routing Configuration \u00b6 See the dedicated section in routing . Provider Configuration \u00b6 Browse the Reference If you're in a hurry, maybe you'd rather go through the configuration reference: File (TOML) # Enable Rancher Provider. [providers.rancher] # Expose Rancher services by default in Traefik. exposedByDefault = true # Enable watch Rancher changes. watch = true # Filter services with unhealthy states and inactive states. enableServiceHealthFilter = true # Defines the polling interval (in seconds). refreshSeconds = 15 # Poll the Rancher metadata service for changes every `rancher.refreshSeconds`, which is less accurate intervalPoll = false # Prefix used for accessing the Rancher metadata service prefix = \"/latest\" File (YAML) # Enable Rancher Provider. providers: rancher: # Expose Rancher services by default in Traefik. exposedByDefault: true # Enable watch Rancher changes. watch: true # Filter services with unhealthy states and inactive states. enableServiceHealthFilter: true # Defines the polling interval (in seconds). refreshSeconds: 15 # Poll the Rancher metadata service for changes every `rancher.refreshSeconds`, which is less accurate intervalPoll: false # Prefix used for accessing the Rancher metadata service prefix: /latest CLI # Enable Rancher Provider. --providers.rancher=true # Expose Rancher services by default in Traefik. --providers.rancher.exposedByDefault=true # Enable watch Rancher changes. --providers.rancher.watch=true # Filter services with unhealthy states and inactive states. --providers.rancher.enableServiceHealthFilter=true # Defines the polling interval (in seconds). --providers.rancher.refreshSeconds=15 # Poll the Rancher metadata service for changes every `rancher.refreshSeconds`, which is less accurate --providers.rancher.intervalPoll=false # Prefix used for accessing the Rancher metadata service --providers.rancher.prefix=/latest exposedByDefault \u00b6 Optional, Default=true File (TOML) [providers.rancher] exposedByDefault = false # ... File (YAML) providers: rancher: exposedByDefault: false # ... CLI --providers.rancher.exposedByDefault=false # ... Expose Rancher services by default in Traefik. If set to false, services that don't have a traefik.enable=true label will be ignored from the resulting routing configuration. See also Restrict the Scope of Service Discovery . defaultRule \u00b6 Optional, Default= Host(`{{ normalize .Name }}`) File (TOML) [providers.rancher] defaultRule = \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... File (YAML) providers: rancher: defaultRule: \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... CLI --providers.rancher.defaultRule=Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`) # ... The default host rule for all services. For a given container if no routing rule was defined by a label, it is defined by this defaultRule instead. It must be a valid Go template , augmented with the sprig template functions . The service name can be accessed as the Name identifier, and the template has access to all the labels defined on this container. This option can be overridden on a container basis with the traefik.http.routers.Router1.rule label. enableServiceHealthFilter \u00b6 Optional, Default=true File (TOML) [providers.rancher] enableServiceHealthFilter = false # ... File (YAML) providers: rancher: enableServiceHealthFilter: false # ... CLI --providers.rancher.enableServiceHealthFilter=false # ... Filter services with unhealthy states and inactive states. refreshSeconds \u00b6 Optional, Default=15 File (TOML) [providers.rancher] refreshSeconds = 30 # ... File (YAML) providers: rancher: refreshSeconds: 30 # ... CLI --providers.rancher.refreshSeconds=30 # ... Defines the polling interval (in seconds). intervalPoll \u00b6 Optional, Default=false File (TOML) [providers.rancher] intervalPoll = true # ... File (YAML) providers: rancher: intervalPoll: true # ... CLI --providers.rancher.intervalPoll=true # ... Poll the Rancher metadata service for changes every rancher.refreshSeconds , which is less accurate than the default long polling technique which will provide near instantaneous updates to Traefik. prefix \u00b6 Optional, Default=/latest File (TOML) [providers.rancher] prefix = \"/test\" # ... File (YAML) providers: rancher: prefix: \"/test\" # ... CLI --providers.rancher.prefix=/test # ... Prefix used for accessing the Rancher metadata service constraints \u00b6 Optional, Default=\"\" File (TOML) [providers.rancher] constraints = \"Label(`a.label.name`,`foo`)\" # ... File (YAML) providers: rancher: constraints: \"Label(`a.label.name`,`foo`)\" # ... CLI --providers.rancher.constraints=Label(`a.label.name`,`foo`) # ... Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. That is to say, if none of the container's labels match the expression, no route for the container is created. If the expression is empty, all detected containers are included. The expression syntax is based on the Label(\"key\", \"value\") , and LabelRegex(\"key\", \"value\") functions, as well as the usual boolean logic, as shown in examples below. Constraints Expression Examples # Includes only containers having a label with key `a.label.name` and value `foo` constraints = \"Label(`a.label.name`, `foo`)\" # Excludes containers having any label with key `a.label.name` and value `foo` constraints = \"!Label(`a.label.name`, `value`)\" # With logical AND. constraints = \"Label(`a.label.name`, `valueA`) && Label(`another.label.name`, `valueB`)\" # With logical OR. constraints = \"Label(`a.label.name`, `valueA`) || Label(`another.label.name`, `valueB`)\" # With logical AND and OR, with precedence set by parentheses. constraints = \"Label(`a.label.name`, `valueA`) && (Label(`another.label.name`, `valueB`) || Label(`yet.another.label.name`, `valueC`))\" # Includes only containers having a label with key `a.label.name` and a value matching the `a.+` regular expression. constraints = \"LabelRegex(`a.label.name`, `a.+`)\" See also Restrict the Scope of Service Discovery .","title":"Rancher"},{"location":"providers/rancher/#traefik-rancher","text":"A Story of Labels, Services & Containers Attach labels to your services and let Traefik do the rest! This provider is specific to Rancher 1.x. Rancher 2.x requires Kubernetes and does not have a metadata endpoint of its own for Traefik to query. As such, Rancher 2.x users should utilize the Kubernetes provider directly.","title":"Traefik &amp; Rancher"},{"location":"providers/rancher/#configuration-examples","text":"Configuring Rancher & Deploying / Exposing Services Enabling the rancher provider File (TOML) [providers.rancher] File (YAML) providers: rancher: {} CLI --providers.rancher=true Attaching labels to services labels: - traefik.http.services.my-service.rule=Host(`mydomain.com`)","title":"Configuration Examples"},{"location":"providers/rancher/#routing-configuration","text":"See the dedicated section in routing .","title":"Routing Configuration"},{"location":"providers/rancher/#provider-configuration","text":"Browse the Reference If you're in a hurry, maybe you'd rather go through the configuration reference: File (TOML) # Enable Rancher Provider. [providers.rancher] # Expose Rancher services by default in Traefik. exposedByDefault = true # Enable watch Rancher changes. watch = true # Filter services with unhealthy states and inactive states. enableServiceHealthFilter = true # Defines the polling interval (in seconds). refreshSeconds = 15 # Poll the Rancher metadata service for changes every `rancher.refreshSeconds`, which is less accurate intervalPoll = false # Prefix used for accessing the Rancher metadata service prefix = \"/latest\" File (YAML) # Enable Rancher Provider. providers: rancher: # Expose Rancher services by default in Traefik. exposedByDefault: true # Enable watch Rancher changes. watch: true # Filter services with unhealthy states and inactive states. enableServiceHealthFilter: true # Defines the polling interval (in seconds). refreshSeconds: 15 # Poll the Rancher metadata service for changes every `rancher.refreshSeconds`, which is less accurate intervalPoll: false # Prefix used for accessing the Rancher metadata service prefix: /latest CLI # Enable Rancher Provider. --providers.rancher=true # Expose Rancher services by default in Traefik. --providers.rancher.exposedByDefault=true # Enable watch Rancher changes. --providers.rancher.watch=true # Filter services with unhealthy states and inactive states. --providers.rancher.enableServiceHealthFilter=true # Defines the polling interval (in seconds). --providers.rancher.refreshSeconds=15 # Poll the Rancher metadata service for changes every `rancher.refreshSeconds`, which is less accurate --providers.rancher.intervalPoll=false # Prefix used for accessing the Rancher metadata service --providers.rancher.prefix=/latest","title":"Provider Configuration"},{"location":"providers/rancher/#exposedbydefault","text":"Optional, Default=true File (TOML) [providers.rancher] exposedByDefault = false # ... File (YAML) providers: rancher: exposedByDefault: false # ... CLI --providers.rancher.exposedByDefault=false # ... Expose Rancher services by default in Traefik. If set to false, services that don't have a traefik.enable=true label will be ignored from the resulting routing configuration. See also Restrict the Scope of Service Discovery .","title":"exposedByDefault"},{"location":"providers/rancher/#defaultrule","text":"Optional, Default= Host(`{{ normalize .Name }}`) File (TOML) [providers.rancher] defaultRule = \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... File (YAML) providers: rancher: defaultRule: \"Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`)\" # ... CLI --providers.rancher.defaultRule=Host(`{{ .Name }}.{{ index .Labels \\\"customLabel\\\"}}`) # ... The default host rule for all services. For a given container if no routing rule was defined by a label, it is defined by this defaultRule instead. It must be a valid Go template , augmented with the sprig template functions . The service name can be accessed as the Name identifier, and the template has access to all the labels defined on this container. This option can be overridden on a container basis with the traefik.http.routers.Router1.rule label.","title":"defaultRule"},{"location":"providers/rancher/#enableservicehealthfilter","text":"Optional, Default=true File (TOML) [providers.rancher] enableServiceHealthFilter = false # ... File (YAML) providers: rancher: enableServiceHealthFilter: false # ... CLI --providers.rancher.enableServiceHealthFilter=false # ... Filter services with unhealthy states and inactive states.","title":"enableServiceHealthFilter"},{"location":"providers/rancher/#refreshseconds","text":"Optional, Default=15 File (TOML) [providers.rancher] refreshSeconds = 30 # ... File (YAML) providers: rancher: refreshSeconds: 30 # ... CLI --providers.rancher.refreshSeconds=30 # ... Defines the polling interval (in seconds).","title":"refreshSeconds"},{"location":"providers/rancher/#intervalpoll","text":"Optional, Default=false File (TOML) [providers.rancher] intervalPoll = true # ... File (YAML) providers: rancher: intervalPoll: true # ... CLI --providers.rancher.intervalPoll=true # ... Poll the Rancher metadata service for changes every rancher.refreshSeconds , which is less accurate than the default long polling technique which will provide near instantaneous updates to Traefik.","title":"intervalPoll"},{"location":"providers/rancher/#prefix","text":"Optional, Default=/latest File (TOML) [providers.rancher] prefix = \"/test\" # ... File (YAML) providers: rancher: prefix: \"/test\" # ... CLI --providers.rancher.prefix=/test # ... Prefix used for accessing the Rancher metadata service","title":"prefix"},{"location":"providers/rancher/#constraints","text":"Optional, Default=\"\" File (TOML) [providers.rancher] constraints = \"Label(`a.label.name`,`foo`)\" # ... File (YAML) providers: rancher: constraints: \"Label(`a.label.name`,`foo`)\" # ... CLI --providers.rancher.constraints=Label(`a.label.name`,`foo`) # ... Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. That is to say, if none of the container's labels match the expression, no route for the container is created. If the expression is empty, all detected containers are included. The expression syntax is based on the Label(\"key\", \"value\") , and LabelRegex(\"key\", \"value\") functions, as well as the usual boolean logic, as shown in examples below. Constraints Expression Examples # Includes only containers having a label with key `a.label.name` and value `foo` constraints = \"Label(`a.label.name`, `foo`)\" # Excludes containers having any label with key `a.label.name` and value `foo` constraints = \"!Label(`a.label.name`, `value`)\" # With logical AND. constraints = \"Label(`a.label.name`, `valueA`) && Label(`another.label.name`, `valueB`)\" # With logical OR. constraints = \"Label(`a.label.name`, `valueA`) || Label(`another.label.name`, `valueB`)\" # With logical AND and OR, with precedence set by parentheses. constraints = \"Label(`a.label.name`, `valueA`) && (Label(`another.label.name`, `valueB`) || Label(`yet.another.label.name`, `valueC`))\" # Includes only containers having a label with key `a.label.name` and a value matching the `a.+` regular expression. constraints = \"LabelRegex(`a.label.name`, `a.+`)\" See also Restrict the Scope of Service Discovery .","title":"constraints"},{"location":"reference/dynamic-configuration/docker/","text":"Docker Configuration Reference \u00b6 Dynamic configuration with Docker Labels The labels are case insensitive. labels: - \"traefik.enable=true\" - \"traefik.docker.network=foobar\" - \"traefik.docker.lbswarm=true\" - \"traefik.http.middlewares.middleware00.addprefix.prefix=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.headerfield=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.realm=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.removeheader=true\" - \"traefik.http.middlewares.middleware01.basicauth.users=foobar, foobar\" - \"traefik.http.middlewares.middleware01.basicauth.usersfile=foobar\" - \"traefik.http.middlewares.middleware02.buffering.maxrequestbodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.maxresponsebodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.memrequestbodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.memresponsebodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.retryexpression=foobar\" - \"traefik.http.middlewares.middleware03.chain.middlewares=foobar, foobar\" - \"traefik.http.middlewares.middleware04.circuitbreaker.expression=foobar\" - \"traefik.http.middlewares.middleware05.compress=true\" - \"traefik.http.middlewares.middleware06.digestauth.headerfield=foobar\" - \"traefik.http.middlewares.middleware06.digestauth.realm=foobar\" - \"traefik.http.middlewares.middleware06.digestauth.removeheader=true\" - \"traefik.http.middlewares.middleware06.digestauth.users=foobar, foobar\" - \"traefik.http.middlewares.middleware06.digestauth.usersfile=foobar\" - \"traefik.http.middlewares.middleware07.errors.query=foobar\" - \"traefik.http.middlewares.middleware07.errors.service=foobar\" - \"traefik.http.middlewares.middleware07.errors.status=foobar, foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.address=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.authresponseheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.ca=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.caoptional=true\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.cert=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.insecureskipverify=true\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.key=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.trustforwardheader=true\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowcredentials=true\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowmethods=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolalloworigin=foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolexposeheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolmaxage=42\" - \"traefik.http.middlewares.middleware09.headers.addvaryheader=true\" - \"traefik.http.middlewares.middleware09.headers.allowedhosts=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.browserxssfilter=true\" - \"traefik.http.middlewares.middleware09.headers.contentsecuritypolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.contenttypenosniff=true\" - \"traefik.http.middlewares.middleware09.headers.custombrowserxssvalue=foobar\" - \"traefik.http.middlewares.middleware09.headers.customframeoptionsvalue=foobar\" - \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.featurepolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.forcestsheader=true\" - \"traefik.http.middlewares.middleware09.headers.framedeny=true\" - \"traefik.http.middlewares.middleware09.headers.hostsproxyheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.isdevelopment=true\" - \"traefik.http.middlewares.middleware09.headers.publickey=foobar\" - \"traefik.http.middlewares.middleware09.headers.referrerpolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslforcehost=true\" - \"traefik.http.middlewares.middleware09.headers.sslhost=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslredirect=true\" - \"traefik.http.middlewares.middleware09.headers.ssltemporaryredirect=true\" - \"traefik.http.middlewares.middleware09.headers.stsincludesubdomains=true\" - \"traefik.http.middlewares.middleware09.headers.stspreload=true\" - \"traefik.http.middlewares.middleware09.headers.stsseconds=42\" - \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware10.ipwhitelist.sourcerange=foobar, foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.amount=42\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requestheadername=foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requesthost=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.commonname=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.country=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.domaincomponent=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.locality=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.organization=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.province=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.serialnumber=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notafter=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notbefore=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.sans=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.commonname=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.country=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.domaincomponent=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.locality=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.organization=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.province=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.serialnumber=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.pem=true\" - \"traefik.http.middlewares.middleware13.ratelimit.average=42\" - \"traefik.http.middlewares.middleware13.ratelimit.burst=42\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requestheadername=foobar\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requesthost=true\" - \"traefik.http.middlewares.middleware14.redirectregex.permanent=true\" - \"traefik.http.middlewares.middleware14.redirectregex.regex=foobar\" - \"traefik.http.middlewares.middleware14.redirectregex.replacement=foobar\" - \"traefik.http.middlewares.middleware15.redirectscheme.permanent=true\" - \"traefik.http.middlewares.middleware15.redirectscheme.port=foobar\" - \"traefik.http.middlewares.middleware15.redirectscheme.scheme=foobar\" - \"traefik.http.middlewares.middleware16.replacepath.path=foobar\" - \"traefik.http.middlewares.middleware17.replacepathregex.regex=foobar\" - \"traefik.http.middlewares.middleware17.replacepathregex.replacement=foobar\" - \"traefik.http.middlewares.middleware18.retry.attempts=42\" - \"traefik.http.middlewares.middleware19.stripprefix.forceslash=true\" - \"traefik.http.middlewares.middleware19.stripprefix.prefixes=foobar, foobar\" - \"traefik.http.middlewares.middleware20.stripprefixregex.regex=foobar, foobar\" - \"traefik.http.routers.router0.entrypoints=foobar, foobar\" - \"traefik.http.routers.router0.middlewares=foobar, foobar\" - \"traefik.http.routers.router0.priority=42\" - \"traefik.http.routers.router0.rule=foobar\" - \"traefik.http.routers.router0.service=foobar\" - \"traefik.http.routers.router0.tls=true\" - \"traefik.http.routers.router0.tls.certresolver=foobar\" - \"traefik.http.routers.router0.tls.domains[0].main=foobar\" - \"traefik.http.routers.router0.tls.domains[0].sans=foobar, foobar\" - \"traefik.http.routers.router0.tls.domains[1].main=foobar\" - \"traefik.http.routers.router0.tls.domains[1].sans=foobar, foobar\" - \"traefik.http.routers.router0.tls.options=foobar\" - \"traefik.http.routers.router1.entrypoints=foobar, foobar\" - \"traefik.http.routers.router1.middlewares=foobar, foobar\" - \"traefik.http.routers.router1.priority=42\" - \"traefik.http.routers.router1.rule=foobar\" - \"traefik.http.routers.router1.service=foobar\" - \"traefik.http.routers.router1.tls=true\" - \"traefik.http.routers.router1.tls.certresolver=foobar\" - \"traefik.http.routers.router1.tls.domains[0].main=foobar\" - \"traefik.http.routers.router1.tls.domains[0].sans=foobar, foobar\" - \"traefik.http.routers.router1.tls.domains[1].main=foobar\" - \"traefik.http.routers.router1.tls.domains[1].sans=foobar, foobar\" - \"traefik.http.routers.router1.tls.options=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name0=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name1=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.hostname=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.interval=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.path=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.port=42\" - \"traefik.http.services.service01.loadbalancer.healthcheck.scheme=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.timeout=foobar\" - \"traefik.http.services.service01.loadbalancer.passhostheader=true\" - \"traefik.http.services.service01.loadbalancer.responseforwarding.flushinterval=foobar\" - \"traefik.http.services.service01.loadbalancer.sticky=true\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.httponly=true\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.name=foobar\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.secure=true\" - \"traefik.http.services.service01.loadbalancer.server.port=foobar\" - \"traefik.http.services.service01.loadbalancer.server.scheme=foobar\" - \"traefik.tcp.routers.tcprouter0.entrypoints=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.rule=foobar\" - \"traefik.tcp.routers.tcprouter0.service=foobar\" - \"traefik.tcp.routers.tcprouter0.tls=true\" - \"traefik.tcp.routers.tcprouter0.tls.certresolver=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[0].main=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[0].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[1].main=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[1].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.tls.options=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.passthrough=true\" - \"traefik.tcp.routers.tcprouter1.entrypoints=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.rule=foobar\" - \"traefik.tcp.routers.tcprouter1.service=foobar\" - \"traefik.tcp.routers.tcprouter1.tls=true\" - \"traefik.tcp.routers.tcprouter1.tls.certresolver=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[0].main=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[0].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[1].main=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[1].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.tls.options=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.passthrough=true\" - \"traefik.tcp.services.tcpservice01.loadbalancer.terminationdelay=42\" - \"traefik.tcp.services.tcpservice01.loadbalancer.server.port=foobar\"","title":"Docker"},{"location":"reference/dynamic-configuration/docker/#docker-configuration-reference","text":"Dynamic configuration with Docker Labels The labels are case insensitive. labels: - \"traefik.enable=true\" - \"traefik.docker.network=foobar\" - \"traefik.docker.lbswarm=true\" - \"traefik.http.middlewares.middleware00.addprefix.prefix=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.headerfield=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.realm=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.removeheader=true\" - \"traefik.http.middlewares.middleware01.basicauth.users=foobar, foobar\" - \"traefik.http.middlewares.middleware01.basicauth.usersfile=foobar\" - \"traefik.http.middlewares.middleware02.buffering.maxrequestbodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.maxresponsebodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.memrequestbodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.memresponsebodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.retryexpression=foobar\" - \"traefik.http.middlewares.middleware03.chain.middlewares=foobar, foobar\" - \"traefik.http.middlewares.middleware04.circuitbreaker.expression=foobar\" - \"traefik.http.middlewares.middleware05.compress=true\" - \"traefik.http.middlewares.middleware06.digestauth.headerfield=foobar\" - \"traefik.http.middlewares.middleware06.digestauth.realm=foobar\" - \"traefik.http.middlewares.middleware06.digestauth.removeheader=true\" - \"traefik.http.middlewares.middleware06.digestauth.users=foobar, foobar\" - \"traefik.http.middlewares.middleware06.digestauth.usersfile=foobar\" - \"traefik.http.middlewares.middleware07.errors.query=foobar\" - \"traefik.http.middlewares.middleware07.errors.service=foobar\" - \"traefik.http.middlewares.middleware07.errors.status=foobar, foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.address=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.authresponseheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.ca=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.caoptional=true\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.cert=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.insecureskipverify=true\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.key=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.trustforwardheader=true\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowcredentials=true\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowmethods=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolalloworigin=foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolexposeheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolmaxage=42\" - \"traefik.http.middlewares.middleware09.headers.addvaryheader=true\" - \"traefik.http.middlewares.middleware09.headers.allowedhosts=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.browserxssfilter=true\" - \"traefik.http.middlewares.middleware09.headers.contentsecuritypolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.contenttypenosniff=true\" - \"traefik.http.middlewares.middleware09.headers.custombrowserxssvalue=foobar\" - \"traefik.http.middlewares.middleware09.headers.customframeoptionsvalue=foobar\" - \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.featurepolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.forcestsheader=true\" - \"traefik.http.middlewares.middleware09.headers.framedeny=true\" - \"traefik.http.middlewares.middleware09.headers.hostsproxyheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.isdevelopment=true\" - \"traefik.http.middlewares.middleware09.headers.publickey=foobar\" - \"traefik.http.middlewares.middleware09.headers.referrerpolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslforcehost=true\" - \"traefik.http.middlewares.middleware09.headers.sslhost=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslredirect=true\" - \"traefik.http.middlewares.middleware09.headers.ssltemporaryredirect=true\" - \"traefik.http.middlewares.middleware09.headers.stsincludesubdomains=true\" - \"traefik.http.middlewares.middleware09.headers.stspreload=true\" - \"traefik.http.middlewares.middleware09.headers.stsseconds=42\" - \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware10.ipwhitelist.sourcerange=foobar, foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.amount=42\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requestheadername=foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requesthost=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.commonname=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.country=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.domaincomponent=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.locality=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.organization=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.province=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.serialnumber=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notafter=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notbefore=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.sans=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.commonname=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.country=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.domaincomponent=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.locality=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.organization=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.province=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.serialnumber=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.pem=true\" - \"traefik.http.middlewares.middleware13.ratelimit.average=42\" - \"traefik.http.middlewares.middleware13.ratelimit.burst=42\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requestheadername=foobar\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requesthost=true\" - \"traefik.http.middlewares.middleware14.redirectregex.permanent=true\" - \"traefik.http.middlewares.middleware14.redirectregex.regex=foobar\" - \"traefik.http.middlewares.middleware14.redirectregex.replacement=foobar\" - \"traefik.http.middlewares.middleware15.redirectscheme.permanent=true\" - \"traefik.http.middlewares.middleware15.redirectscheme.port=foobar\" - \"traefik.http.middlewares.middleware15.redirectscheme.scheme=foobar\" - \"traefik.http.middlewares.middleware16.replacepath.path=foobar\" - \"traefik.http.middlewares.middleware17.replacepathregex.regex=foobar\" - \"traefik.http.middlewares.middleware17.replacepathregex.replacement=foobar\" - \"traefik.http.middlewares.middleware18.retry.attempts=42\" - \"traefik.http.middlewares.middleware19.stripprefix.forceslash=true\" - \"traefik.http.middlewares.middleware19.stripprefix.prefixes=foobar, foobar\" - \"traefik.http.middlewares.middleware20.stripprefixregex.regex=foobar, foobar\" - \"traefik.http.routers.router0.entrypoints=foobar, foobar\" - \"traefik.http.routers.router0.middlewares=foobar, foobar\" - \"traefik.http.routers.router0.priority=42\" - \"traefik.http.routers.router0.rule=foobar\" - \"traefik.http.routers.router0.service=foobar\" - \"traefik.http.routers.router0.tls=true\" - \"traefik.http.routers.router0.tls.certresolver=foobar\" - \"traefik.http.routers.router0.tls.domains[0].main=foobar\" - \"traefik.http.routers.router0.tls.domains[0].sans=foobar, foobar\" - \"traefik.http.routers.router0.tls.domains[1].main=foobar\" - \"traefik.http.routers.router0.tls.domains[1].sans=foobar, foobar\" - \"traefik.http.routers.router0.tls.options=foobar\" - \"traefik.http.routers.router1.entrypoints=foobar, foobar\" - \"traefik.http.routers.router1.middlewares=foobar, foobar\" - \"traefik.http.routers.router1.priority=42\" - \"traefik.http.routers.router1.rule=foobar\" - \"traefik.http.routers.router1.service=foobar\" - \"traefik.http.routers.router1.tls=true\" - \"traefik.http.routers.router1.tls.certresolver=foobar\" - \"traefik.http.routers.router1.tls.domains[0].main=foobar\" - \"traefik.http.routers.router1.tls.domains[0].sans=foobar, foobar\" - \"traefik.http.routers.router1.tls.domains[1].main=foobar\" - \"traefik.http.routers.router1.tls.domains[1].sans=foobar, foobar\" - \"traefik.http.routers.router1.tls.options=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name0=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name1=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.hostname=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.interval=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.path=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.port=42\" - \"traefik.http.services.service01.loadbalancer.healthcheck.scheme=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.timeout=foobar\" - \"traefik.http.services.service01.loadbalancer.passhostheader=true\" - \"traefik.http.services.service01.loadbalancer.responseforwarding.flushinterval=foobar\" - \"traefik.http.services.service01.loadbalancer.sticky=true\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.httponly=true\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.name=foobar\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.secure=true\" - \"traefik.http.services.service01.loadbalancer.server.port=foobar\" - \"traefik.http.services.service01.loadbalancer.server.scheme=foobar\" - \"traefik.tcp.routers.tcprouter0.entrypoints=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.rule=foobar\" - \"traefik.tcp.routers.tcprouter0.service=foobar\" - \"traefik.tcp.routers.tcprouter0.tls=true\" - \"traefik.tcp.routers.tcprouter0.tls.certresolver=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[0].main=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[0].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[1].main=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[1].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.tls.options=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.passthrough=true\" - \"traefik.tcp.routers.tcprouter1.entrypoints=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.rule=foobar\" - \"traefik.tcp.routers.tcprouter1.service=foobar\" - \"traefik.tcp.routers.tcprouter1.tls=true\" - \"traefik.tcp.routers.tcprouter1.tls.certresolver=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[0].main=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[0].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[1].main=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[1].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.tls.options=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.passthrough=true\" - \"traefik.tcp.services.tcpservice01.loadbalancer.terminationdelay=42\" - \"traefik.tcp.services.tcpservice01.loadbalancer.server.port=foobar\"","title":"Docker Configuration Reference"},{"location":"reference/dynamic-configuration/file/","text":"File Configuration Reference \u00b6 Dynamic configuration with files TOML [http] [http.routers] [http.routers.Router0] entryPoints = [\"foobar\", \"foobar\"] middlewares = [\"foobar\", \"foobar\"] service = \"foobar\" rule = \"foobar\" priority = 42 [http.routers.Router0.tls] options = \"foobar\" certResolver = \"foobar\" [[http.routers.Router0.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [[http.routers.Router0.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [http.routers.Router1] entryPoints = [\"foobar\", \"foobar\"] middlewares = [\"foobar\", \"foobar\"] service = \"foobar\" rule = \"foobar\" priority = 42 [http.routers.Router1.tls] options = \"foobar\" certResolver = \"foobar\" [[http.routers.Router1.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [[http.routers.Router1.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [http.services] [http.services.Service01] [http.services.Service01.loadBalancer] passHostHeader = true [http.services.Service01.loadBalancer.sticky] [http.services.Service01.loadBalancer.sticky.cookie] name = \"foobar\" secure = true httpOnly = true [[http.services.Service01.loadBalancer.servers]] url = \"foobar\" [[http.services.Service01.loadBalancer.servers]] url = \"foobar\" [http.services.Service01.loadBalancer.healthCheck] scheme = \"foobar\" path = \"foobar\" port = 42 interval = \"foobar\" timeout = \"foobar\" hostname = \"foobar\" [http.services.Service01.loadBalancer.healthCheck.headers] name0 = \"foobar\" name1 = \"foobar\" [http.services.Service01.loadBalancer.responseForwarding] flushInterval = \"foobar\" [http.services.Service02] [http.services.Service02.mirroring] service = \"foobar\" [[http.services.Service02.mirroring.mirrors]] name = \"foobar\" percent = 42 [[http.services.Service02.mirroring.mirrors]] name = \"foobar\" percent = 42 [http.services.Service03] [http.services.Service03.weighted] [[http.services.Service03.weighted.services]] name = \"foobar\" weight = 42 [[http.services.Service03.weighted.services]] name = \"foobar\" weight = 42 [http.services.Service03.weighted.sticky] [http.services.Service03.weighted.sticky.cookie] name = \"foobar\" secure = true httpOnly = true [http.middlewares] [http.middlewares.Middleware00] [http.middlewares.Middleware00.addPrefix] prefix = \"foobar\" [http.middlewares.Middleware01] [http.middlewares.Middleware01.basicAuth] users = [\"foobar\", \"foobar\"] usersFile = \"foobar\" realm = \"foobar\" removeHeader = true headerField = \"foobar\" [http.middlewares.Middleware02] [http.middlewares.Middleware02.buffering] maxRequestBodyBytes = 42 memRequestBodyBytes = 42 maxResponseBodyBytes = 42 memResponseBodyBytes = 42 retryExpression = \"foobar\" [http.middlewares.Middleware03] [http.middlewares.Middleware03.chain] middlewares = [\"foobar\", \"foobar\"] [http.middlewares.Middleware04] [http.middlewares.Middleware04.circuitBreaker] expression = \"foobar\" [http.middlewares.Middleware05] [http.middlewares.Middleware05.compress] [http.middlewares.Middleware06] [http.middlewares.Middleware06.digestAuth] users = [\"foobar\", \"foobar\"] usersFile = \"foobar\" removeHeader = true realm = \"foobar\" headerField = \"foobar\" [http.middlewares.Middleware07] [http.middlewares.Middleware07.errors] status = [\"foobar\", \"foobar\"] service = \"foobar\" query = \"foobar\" [http.middlewares.Middleware08] [http.middlewares.Middleware08.forwardAuth] address = \"foobar\" trustForwardHeader = true authResponseHeaders = [\"foobar\", \"foobar\"] [http.middlewares.Middleware08.forwardAuth.tls] ca = \"foobar\" caOptional = true cert = \"foobar\" key = \"foobar\" insecureSkipVerify = true [http.middlewares.Middleware09] [http.middlewares.Middleware09.headers] accessControlAllowCredentials = true accessControlAllowHeaders = [\"foobar\", \"foobar\"] accessControlAllowMethods = [\"foobar\", \"foobar\"] accessControlAllowOrigin = \"foobar\" accessControlExposeHeaders = [\"foobar\", \"foobar\"] accessControlMaxAge = 42 addVaryHeader = true allowedHosts = [\"foobar\", \"foobar\"] hostsProxyHeaders = [\"foobar\", \"foobar\"] sslRedirect = true sslTemporaryRedirect = true sslHost = \"foobar\" sslForceHost = true stsSeconds = 42 stsIncludeSubdomains = true stsPreload = true forceSTSHeader = true frameDeny = true customFrameOptionsValue = \"foobar\" contentTypeNosniff = true browserXssFilter = true customBrowserXSSValue = \"foobar\" contentSecurityPolicy = \"foobar\" publicKey = \"foobar\" referrerPolicy = \"foobar\" featurePolicy = \"foobar\" isDevelopment = true [http.middlewares.Middleware09.headers.customRequestHeaders] name0 = \"foobar\" name1 = \"foobar\" [http.middlewares.Middleware09.headers.customResponseHeaders] name0 = \"foobar\" name1 = \"foobar\" [http.middlewares.Middleware09.headers.sslProxyHeaders] name0 = \"foobar\" name1 = \"foobar\" [http.middlewares.Middleware10] [http.middlewares.Middleware10.ipWhiteList] sourceRange = [\"foobar\", \"foobar\"] [http.middlewares.Middleware10.ipWhiteList.ipStrategy] depth = 42 excludedIPs = [\"foobar\", \"foobar\"] [http.middlewares.Middleware11] [http.middlewares.Middleware11.inFlightReq] amount = 42 [http.middlewares.Middleware11.inFlightReq.sourceCriterion] requestHeaderName = \"foobar\" requestHost = true [http.middlewares.Middleware11.inFlightReq.sourceCriterion.ipStrategy] depth = 42 excludedIPs = [\"foobar\", \"foobar\"] [http.middlewares.Middleware12] [http.middlewares.Middleware12.passTLSClientCert] pem = true [http.middlewares.Middleware12.passTLSClientCert.info] notAfter = true notBefore = true sans = true [http.middlewares.Middleware12.passTLSClientCert.info.subject] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.Middleware12.passTLSClientCert.info.issuer] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.Middleware13] [http.middlewares.Middleware13.rateLimit] average = 42 burst = 42 [http.middlewares.Middleware13.rateLimit.sourceCriterion] requestHeaderName = \"foobar\" requestHost = true [http.middlewares.Middleware13.rateLimit.sourceCriterion.ipStrategy] depth = 42 excludedIPs = [\"foobar\", \"foobar\"] [http.middlewares.Middleware14] [http.middlewares.Middleware14.redirectRegex] regex = \"foobar\" replacement = \"foobar\" permanent = true [http.middlewares.Middleware15] [http.middlewares.Middleware15.redirectScheme] scheme = \"foobar\" port = \"foobar\" permanent = true [http.middlewares.Middleware16] [http.middlewares.Middleware16.replacePath] path = \"foobar\" [http.middlewares.Middleware17] [http.middlewares.Middleware17.replacePathRegex] regex = \"foobar\" replacement = \"foobar\" [http.middlewares.Middleware18] [http.middlewares.Middleware18.retry] attempts = 42 [http.middlewares.Middleware19] [http.middlewares.Middleware19.stripPrefix] prefixes = [\"foobar\", \"foobar\"] forceSlash = true [http.middlewares.Middleware20] [http.middlewares.Middleware20.stripPrefixRegex] regex = [\"foobar\", \"foobar\"] [tcp] [tcp.routers] [tcp.routers.TCPRouter0] entryPoints = [\"foobar\", \"foobar\"] service = \"foobar\" rule = \"foobar\" [tcp.routers.TCPRouter0.tls] passthrough = true options = \"foobar\" certResolver = \"foobar\" [[tcp.routers.TCPRouter0.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [[tcp.routers.TCPRouter0.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [tcp.routers.TCPRouter1] entryPoints = [\"foobar\", \"foobar\"] service = \"foobar\" rule = \"foobar\" [tcp.routers.TCPRouter1.tls] passthrough = true options = \"foobar\" certResolver = \"foobar\" [[tcp.routers.TCPRouter1.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [[tcp.routers.TCPRouter1.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [tcp.services] [tcp.services.TCPService01] [tcp.services.TCPService01.loadBalancer] terminationDelay = 42 [[tcp.services.TCPService01.loadBalancer.servers]] address = \"foobar\" [[tcp.services.TCPService01.loadBalancer.servers]] address = \"foobar\" [tcp.services.TCPService02] [tcp.services.TCPService02.weighted] [[tcp.services.TCPService02.weighted.services]] name = \"foobar\" weight = 42 [[tcp.services.TCPService02.weighted.services]] name = \"foobar\" weight = 42 [tls] [[tls.certificates]] certFile = \"foobar\" keyFile = \"foobar\" stores = [\"foobar\", \"foobar\"] [[tls.certificates]] certFile = \"foobar\" keyFile = \"foobar\" stores = [\"foobar\", \"foobar\"] [tls.options] [tls.options.Options0] minVersion = \"foobar\" cipherSuites = [\"foobar\", \"foobar\"] sniStrict = true [tls.options.Options0.clientAuth] caFiles = [\"foobar\", \"foobar\"] clientAuthType = \"foobar\" [tls.options.Options1] minVersion = \"foobar\" cipherSuites = [\"foobar\", \"foobar\"] sniStrict = true [tls.options.Options1.clientAuth] caFiles = [\"foobar\", \"foobar\"] clientAuthType = \"foobar\" [tls.stores] [tls.stores.Store0] [tls.stores.Store0.defaultCertificate] certFile = \"foobar\" keyFile = \"foobar\" [tls.stores.Store1] [tls.stores.Store1.defaultCertificate] certFile = \"foobar\" keyFile = \"foobar\" YAML http: routers: Router0: entryPoints: - foobar - foobar middlewares: - foobar - foobar service: foobar rule: foobar priority: 42 tls: options: foobar certResolver: foobar domains: - main: foobar sans: - foobar - foobar - main: foobar sans: - foobar - foobar Router1: entryPoints: - foobar - foobar middlewares: - foobar - foobar service: foobar rule: foobar priority: 42 tls: options: foobar certResolver: foobar domains: - main: foobar sans: - foobar - foobar - main: foobar sans: - foobar - foobar services: Service01: loadBalancer: sticky: cookie: name: foobar secure: true httpOnly: true servers: - url: foobar - url: foobar healthCheck: scheme: foobar path: foobar port: 42 interval: foobar timeout: foobar hostname: foobar headers: name0: foobar name1: foobar passHostHeader: true responseForwarding: flushInterval: foobar Service02: mirroring: service: foobar mirrors: - name: foobar percent: 42 - name: foobar percent: 42 Service03: weighted: services: - name: foobar weight: 42 - name: foobar weight: 42 sticky: cookie: name: foobar secure: true httpOnly: true middlewares: Middleware00: addPrefix: prefix: foobar Middleware01: basicAuth: users: - foobar - foobar usersFile: foobar realm: foobar removeHeader: true headerField: foobar Middleware02: buffering: maxRequestBodyBytes: 42 memRequestBodyBytes: 42 maxResponseBodyBytes: 42 memResponseBodyBytes: 42 retryExpression: foobar Middleware03: chain: middlewares: - foobar - foobar Middleware04: circuitBreaker: expression: foobar Middleware05: compress: {} Middleware06: digestAuth: users: - foobar - foobar usersFile: foobar removeHeader: true realm: foobar headerField: foobar Middleware07: errors: status: - foobar - foobar service: foobar query: foobar Middleware08: forwardAuth: address: foobar tls: ca: foobar caOptional: true cert: foobar key: foobar insecureSkipVerify: true trustForwardHeader: true authResponseHeaders: - foobar - foobar Middleware09: headers: customRequestHeaders: name0: foobar name1: foobar customResponseHeaders: name0: foobar name1: foobar accessControlAllowCredentials: true accessControlAllowHeaders: - foobar - foobar accessControlAllowMethods: - foobar - foobar accessControlAllowOrigin: foobar accessControlExposeHeaders: - foobar - foobar accessControlMaxAge: 42 addVaryHeader: true allowedHosts: - foobar - foobar hostsProxyHeaders: - foobar - foobar sslRedirect: true sslTemporaryRedirect: true sslHost: foobar sslProxyHeaders: name0: foobar name1: foobar sslForceHost: true stsSeconds: 42 stsIncludeSubdomains: true stsPreload: true forceSTSHeader: true frameDeny: true customFrameOptionsValue: foobar contentTypeNosniff: true browserXssFilter: true customBrowserXSSValue: foobar contentSecurityPolicy: foobar publicKey: foobar referrerPolicy: foobar featurePolicy: foobar isDevelopment: true Middleware10: ipWhiteList: sourceRange: - foobar - foobar ipStrategy: depth: 42 excludedIPs: - foobar - foobar Middleware11: inFlightReq: amount: 42 sourceCriterion: ipstrategy: depth: 42 excludedIPs: - foobar - foobar requestHeaderName: foobar requestHost: true Middleware12: passTLSClientCert: pem: true info: notAfter: true notBefore: true sans: true subject: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true issuer: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true Middleware13: rateLimit: average: 42 burst: 42 sourceCriterion: ipstrategy: depth: 42 excludedIPs: - foobar - foobar requestHeaderName: foobar requestHost: true Middleware14: redirectRegex: regex: foobar replacement: foobar permanent: true Middleware15: redirectScheme: scheme: foobar port: foobar permanent: true Middleware16: replacePath: path: foobar Middleware17: replacePathRegex: regex: foobar replacement: foobar Middleware18: retry: attempts: 42 Middleware19: stripPrefix: prefixes: - foobar - foobar forceSlash: true Middleware20: stripPrefixRegex: regex: - foobar - foobar tcp: routers: TCPRouter0: entryPoints: - foobar - foobar service: foobar rule: foobar tls: passthrough: true options: foobar certResolver: foobar domains: - main: foobar sans: - foobar - foobar - main: foobar sans: - foobar - foobar TCPRouter1: entryPoints: - foobar - foobar service: foobar rule: foobar tls: passthrough: true options: foobar certResolver: foobar domains: - main: foobar sans: - foobar - foobar - main: foobar sans: - foobar - foobar services: TCPService01: loadBalancer: terminationDelay: 42 servers: - address: foobar - address: foobar TCPService02: weighted: services: - name: foobar weight: 42 - name: foobar weight: 42 tls: certificates: - certFile: foobar keyFile: foobar stores: - foobar - foobar - certFile: foobar keyFile: foobar stores: - foobar - foobar options: Options0: minVersion: foobar cipherSuites: - foobar - foobar clientAuth: caFiles: - foobar - foobar clientAuthType: foobar sniStrict: true Options1: minVersion: foobar cipherSuites: - foobar - foobar clientAuth: caFiles: - foobar - foobar clientAuthType: foobar sniStrict: true stores: Store0: defaultCertificate: certFile: foobar keyFile: foobar Store1: defaultCertificate: certFile: foobar keyFile: foobar","title":"File"},{"location":"reference/dynamic-configuration/file/#file-configuration-reference","text":"Dynamic configuration with files TOML [http] [http.routers] [http.routers.Router0] entryPoints = [\"foobar\", \"foobar\"] middlewares = [\"foobar\", \"foobar\"] service = \"foobar\" rule = \"foobar\" priority = 42 [http.routers.Router0.tls] options = \"foobar\" certResolver = \"foobar\" [[http.routers.Router0.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [[http.routers.Router0.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [http.routers.Router1] entryPoints = [\"foobar\", \"foobar\"] middlewares = [\"foobar\", \"foobar\"] service = \"foobar\" rule = \"foobar\" priority = 42 [http.routers.Router1.tls] options = \"foobar\" certResolver = \"foobar\" [[http.routers.Router1.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [[http.routers.Router1.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [http.services] [http.services.Service01] [http.services.Service01.loadBalancer] passHostHeader = true [http.services.Service01.loadBalancer.sticky] [http.services.Service01.loadBalancer.sticky.cookie] name = \"foobar\" secure = true httpOnly = true [[http.services.Service01.loadBalancer.servers]] url = \"foobar\" [[http.services.Service01.loadBalancer.servers]] url = \"foobar\" [http.services.Service01.loadBalancer.healthCheck] scheme = \"foobar\" path = \"foobar\" port = 42 interval = \"foobar\" timeout = \"foobar\" hostname = \"foobar\" [http.services.Service01.loadBalancer.healthCheck.headers] name0 = \"foobar\" name1 = \"foobar\" [http.services.Service01.loadBalancer.responseForwarding] flushInterval = \"foobar\" [http.services.Service02] [http.services.Service02.mirroring] service = \"foobar\" [[http.services.Service02.mirroring.mirrors]] name = \"foobar\" percent = 42 [[http.services.Service02.mirroring.mirrors]] name = \"foobar\" percent = 42 [http.services.Service03] [http.services.Service03.weighted] [[http.services.Service03.weighted.services]] name = \"foobar\" weight = 42 [[http.services.Service03.weighted.services]] name = \"foobar\" weight = 42 [http.services.Service03.weighted.sticky] [http.services.Service03.weighted.sticky.cookie] name = \"foobar\" secure = true httpOnly = true [http.middlewares] [http.middlewares.Middleware00] [http.middlewares.Middleware00.addPrefix] prefix = \"foobar\" [http.middlewares.Middleware01] [http.middlewares.Middleware01.basicAuth] users = [\"foobar\", \"foobar\"] usersFile = \"foobar\" realm = \"foobar\" removeHeader = true headerField = \"foobar\" [http.middlewares.Middleware02] [http.middlewares.Middleware02.buffering] maxRequestBodyBytes = 42 memRequestBodyBytes = 42 maxResponseBodyBytes = 42 memResponseBodyBytes = 42 retryExpression = \"foobar\" [http.middlewares.Middleware03] [http.middlewares.Middleware03.chain] middlewares = [\"foobar\", \"foobar\"] [http.middlewares.Middleware04] [http.middlewares.Middleware04.circuitBreaker] expression = \"foobar\" [http.middlewares.Middleware05] [http.middlewares.Middleware05.compress] [http.middlewares.Middleware06] [http.middlewares.Middleware06.digestAuth] users = [\"foobar\", \"foobar\"] usersFile = \"foobar\" removeHeader = true realm = \"foobar\" headerField = \"foobar\" [http.middlewares.Middleware07] [http.middlewares.Middleware07.errors] status = [\"foobar\", \"foobar\"] service = \"foobar\" query = \"foobar\" [http.middlewares.Middleware08] [http.middlewares.Middleware08.forwardAuth] address = \"foobar\" trustForwardHeader = true authResponseHeaders = [\"foobar\", \"foobar\"] [http.middlewares.Middleware08.forwardAuth.tls] ca = \"foobar\" caOptional = true cert = \"foobar\" key = \"foobar\" insecureSkipVerify = true [http.middlewares.Middleware09] [http.middlewares.Middleware09.headers] accessControlAllowCredentials = true accessControlAllowHeaders = [\"foobar\", \"foobar\"] accessControlAllowMethods = [\"foobar\", \"foobar\"] accessControlAllowOrigin = \"foobar\" accessControlExposeHeaders = [\"foobar\", \"foobar\"] accessControlMaxAge = 42 addVaryHeader = true allowedHosts = [\"foobar\", \"foobar\"] hostsProxyHeaders = [\"foobar\", \"foobar\"] sslRedirect = true sslTemporaryRedirect = true sslHost = \"foobar\" sslForceHost = true stsSeconds = 42 stsIncludeSubdomains = true stsPreload = true forceSTSHeader = true frameDeny = true customFrameOptionsValue = \"foobar\" contentTypeNosniff = true browserXssFilter = true customBrowserXSSValue = \"foobar\" contentSecurityPolicy = \"foobar\" publicKey = \"foobar\" referrerPolicy = \"foobar\" featurePolicy = \"foobar\" isDevelopment = true [http.middlewares.Middleware09.headers.customRequestHeaders] name0 = \"foobar\" name1 = \"foobar\" [http.middlewares.Middleware09.headers.customResponseHeaders] name0 = \"foobar\" name1 = \"foobar\" [http.middlewares.Middleware09.headers.sslProxyHeaders] name0 = \"foobar\" name1 = \"foobar\" [http.middlewares.Middleware10] [http.middlewares.Middleware10.ipWhiteList] sourceRange = [\"foobar\", \"foobar\"] [http.middlewares.Middleware10.ipWhiteList.ipStrategy] depth = 42 excludedIPs = [\"foobar\", \"foobar\"] [http.middlewares.Middleware11] [http.middlewares.Middleware11.inFlightReq] amount = 42 [http.middlewares.Middleware11.inFlightReq.sourceCriterion] requestHeaderName = \"foobar\" requestHost = true [http.middlewares.Middleware11.inFlightReq.sourceCriterion.ipStrategy] depth = 42 excludedIPs = [\"foobar\", \"foobar\"] [http.middlewares.Middleware12] [http.middlewares.Middleware12.passTLSClientCert] pem = true [http.middlewares.Middleware12.passTLSClientCert.info] notAfter = true notBefore = true sans = true [http.middlewares.Middleware12.passTLSClientCert.info.subject] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.Middleware12.passTLSClientCert.info.issuer] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.Middleware13] [http.middlewares.Middleware13.rateLimit] average = 42 burst = 42 [http.middlewares.Middleware13.rateLimit.sourceCriterion] requestHeaderName = \"foobar\" requestHost = true [http.middlewares.Middleware13.rateLimit.sourceCriterion.ipStrategy] depth = 42 excludedIPs = [\"foobar\", \"foobar\"] [http.middlewares.Middleware14] [http.middlewares.Middleware14.redirectRegex] regex = \"foobar\" replacement = \"foobar\" permanent = true [http.middlewares.Middleware15] [http.middlewares.Middleware15.redirectScheme] scheme = \"foobar\" port = \"foobar\" permanent = true [http.middlewares.Middleware16] [http.middlewares.Middleware16.replacePath] path = \"foobar\" [http.middlewares.Middleware17] [http.middlewares.Middleware17.replacePathRegex] regex = \"foobar\" replacement = \"foobar\" [http.middlewares.Middleware18] [http.middlewares.Middleware18.retry] attempts = 42 [http.middlewares.Middleware19] [http.middlewares.Middleware19.stripPrefix] prefixes = [\"foobar\", \"foobar\"] forceSlash = true [http.middlewares.Middleware20] [http.middlewares.Middleware20.stripPrefixRegex] regex = [\"foobar\", \"foobar\"] [tcp] [tcp.routers] [tcp.routers.TCPRouter0] entryPoints = [\"foobar\", \"foobar\"] service = \"foobar\" rule = \"foobar\" [tcp.routers.TCPRouter0.tls] passthrough = true options = \"foobar\" certResolver = \"foobar\" [[tcp.routers.TCPRouter0.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [[tcp.routers.TCPRouter0.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [tcp.routers.TCPRouter1] entryPoints = [\"foobar\", \"foobar\"] service = \"foobar\" rule = \"foobar\" [tcp.routers.TCPRouter1.tls] passthrough = true options = \"foobar\" certResolver = \"foobar\" [[tcp.routers.TCPRouter1.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [[tcp.routers.TCPRouter1.tls.domains]] main = \"foobar\" sans = [\"foobar\", \"foobar\"] [tcp.services] [tcp.services.TCPService01] [tcp.services.TCPService01.loadBalancer] terminationDelay = 42 [[tcp.services.TCPService01.loadBalancer.servers]] address = \"foobar\" [[tcp.services.TCPService01.loadBalancer.servers]] address = \"foobar\" [tcp.services.TCPService02] [tcp.services.TCPService02.weighted] [[tcp.services.TCPService02.weighted.services]] name = \"foobar\" weight = 42 [[tcp.services.TCPService02.weighted.services]] name = \"foobar\" weight = 42 [tls] [[tls.certificates]] certFile = \"foobar\" keyFile = \"foobar\" stores = [\"foobar\", \"foobar\"] [[tls.certificates]] certFile = \"foobar\" keyFile = \"foobar\" stores = [\"foobar\", \"foobar\"] [tls.options] [tls.options.Options0] minVersion = \"foobar\" cipherSuites = [\"foobar\", \"foobar\"] sniStrict = true [tls.options.Options0.clientAuth] caFiles = [\"foobar\", \"foobar\"] clientAuthType = \"foobar\" [tls.options.Options1] minVersion = \"foobar\" cipherSuites = [\"foobar\", \"foobar\"] sniStrict = true [tls.options.Options1.clientAuth] caFiles = [\"foobar\", \"foobar\"] clientAuthType = \"foobar\" [tls.stores] [tls.stores.Store0] [tls.stores.Store0.defaultCertificate] certFile = \"foobar\" keyFile = \"foobar\" [tls.stores.Store1] [tls.stores.Store1.defaultCertificate] certFile = \"foobar\" keyFile = \"foobar\" YAML http: routers: Router0: entryPoints: - foobar - foobar middlewares: - foobar - foobar service: foobar rule: foobar priority: 42 tls: options: foobar certResolver: foobar domains: - main: foobar sans: - foobar - foobar - main: foobar sans: - foobar - foobar Router1: entryPoints: - foobar - foobar middlewares: - foobar - foobar service: foobar rule: foobar priority: 42 tls: options: foobar certResolver: foobar domains: - main: foobar sans: - foobar - foobar - main: foobar sans: - foobar - foobar services: Service01: loadBalancer: sticky: cookie: name: foobar secure: true httpOnly: true servers: - url: foobar - url: foobar healthCheck: scheme: foobar path: foobar port: 42 interval: foobar timeout: foobar hostname: foobar headers: name0: foobar name1: foobar passHostHeader: true responseForwarding: flushInterval: foobar Service02: mirroring: service: foobar mirrors: - name: foobar percent: 42 - name: foobar percent: 42 Service03: weighted: services: - name: foobar weight: 42 - name: foobar weight: 42 sticky: cookie: name: foobar secure: true httpOnly: true middlewares: Middleware00: addPrefix: prefix: foobar Middleware01: basicAuth: users: - foobar - foobar usersFile: foobar realm: foobar removeHeader: true headerField: foobar Middleware02: buffering: maxRequestBodyBytes: 42 memRequestBodyBytes: 42 maxResponseBodyBytes: 42 memResponseBodyBytes: 42 retryExpression: foobar Middleware03: chain: middlewares: - foobar - foobar Middleware04: circuitBreaker: expression: foobar Middleware05: compress: {} Middleware06: digestAuth: users: - foobar - foobar usersFile: foobar removeHeader: true realm: foobar headerField: foobar Middleware07: errors: status: - foobar - foobar service: foobar query: foobar Middleware08: forwardAuth: address: foobar tls: ca: foobar caOptional: true cert: foobar key: foobar insecureSkipVerify: true trustForwardHeader: true authResponseHeaders: - foobar - foobar Middleware09: headers: customRequestHeaders: name0: foobar name1: foobar customResponseHeaders: name0: foobar name1: foobar accessControlAllowCredentials: true accessControlAllowHeaders: - foobar - foobar accessControlAllowMethods: - foobar - foobar accessControlAllowOrigin: foobar accessControlExposeHeaders: - foobar - foobar accessControlMaxAge: 42 addVaryHeader: true allowedHosts: - foobar - foobar hostsProxyHeaders: - foobar - foobar sslRedirect: true sslTemporaryRedirect: true sslHost: foobar sslProxyHeaders: name0: foobar name1: foobar sslForceHost: true stsSeconds: 42 stsIncludeSubdomains: true stsPreload: true forceSTSHeader: true frameDeny: true customFrameOptionsValue: foobar contentTypeNosniff: true browserXssFilter: true customBrowserXSSValue: foobar contentSecurityPolicy: foobar publicKey: foobar referrerPolicy: foobar featurePolicy: foobar isDevelopment: true Middleware10: ipWhiteList: sourceRange: - foobar - foobar ipStrategy: depth: 42 excludedIPs: - foobar - foobar Middleware11: inFlightReq: amount: 42 sourceCriterion: ipstrategy: depth: 42 excludedIPs: - foobar - foobar requestHeaderName: foobar requestHost: true Middleware12: passTLSClientCert: pem: true info: notAfter: true notBefore: true sans: true subject: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true issuer: country: true province: true locality: true organization: true commonName: true serialNumber: true domainComponent: true Middleware13: rateLimit: average: 42 burst: 42 sourceCriterion: ipstrategy: depth: 42 excludedIPs: - foobar - foobar requestHeaderName: foobar requestHost: true Middleware14: redirectRegex: regex: foobar replacement: foobar permanent: true Middleware15: redirectScheme: scheme: foobar port: foobar permanent: true Middleware16: replacePath: path: foobar Middleware17: replacePathRegex: regex: foobar replacement: foobar Middleware18: retry: attempts: 42 Middleware19: stripPrefix: prefixes: - foobar - foobar forceSlash: true Middleware20: stripPrefixRegex: regex: - foobar - foobar tcp: routers: TCPRouter0: entryPoints: - foobar - foobar service: foobar rule: foobar tls: passthrough: true options: foobar certResolver: foobar domains: - main: foobar sans: - foobar - foobar - main: foobar sans: - foobar - foobar TCPRouter1: entryPoints: - foobar - foobar service: foobar rule: foobar tls: passthrough: true options: foobar certResolver: foobar domains: - main: foobar sans: - foobar - foobar - main: foobar sans: - foobar - foobar services: TCPService01: loadBalancer: terminationDelay: 42 servers: - address: foobar - address: foobar TCPService02: weighted: services: - name: foobar weight: 42 - name: foobar weight: 42 tls: certificates: - certFile: foobar keyFile: foobar stores: - foobar - foobar - certFile: foobar keyFile: foobar stores: - foobar - foobar options: Options0: minVersion: foobar cipherSuites: - foobar - foobar clientAuth: caFiles: - foobar - foobar clientAuthType: foobar sniStrict: true Options1: minVersion: foobar cipherSuites: - foobar - foobar clientAuth: caFiles: - foobar - foobar clientAuthType: foobar sniStrict: true stores: Store0: defaultCertificate: certFile: foobar keyFile: foobar Store1: defaultCertificate: certFile: foobar keyFile: foobar","title":"File Configuration Reference"},{"location":"reference/dynamic-configuration/kubernetes-crd/","text":"Kubernetes Configuration Reference \u00b6 Dynamic configuration with Kubernetes Custom Resource apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: tlsoptions.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: TLSOption plural: tlsoptions singular: tlsoption scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutetcps.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRouteTCP plural: ingressroutetcps singular: ingressroutetcp scope: Namespaced --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroute spec: entryPoints: - web - web-secure routes: - match: Host(`foo.com`) && PathPrefix(`/bar`) kind: Rule priority: 12 # defining several services is possible and allowed, but for now the servers of # all the services (for a given route) get merged altogether under the same # load-balancing strategy. services: - name: s1 port: 80 healthCheck: path: /health host: baz.com intervalSeconds: 7 timeoutSeconds: 60 # strategy defines the load balancing strategy between the servers. It defaults # to Round Robin, and for now only Round Robin is supported anyway. strategy: RoundRobin - name: s2 port: 433 healthCheck: path: /health host: baz.com intervalSeconds: 7 timeoutSeconds: 60 - match: PathPrefix(`/misc`) services: - name: s3 port: 80 middlewares: - name: stripprefix - name: addprefix - match: PathPrefix(`/misc`) services: - name: s3 port: 8443 # scheme allow to override the scheme for the service. (ex: https or h2c) scheme: https # use an empty tls object for TLS with Let's Encrypt tls: secretName: supersecret options: name: myTLSOption namespace: default --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRouteTCP metadata: name: ingressroutetcp.crd namespace: default spec: entryPoints: - footcp routes: - match: HostSNI(`bar.com`) services: - name: whoamitcp port: 8080 tls: secretName: foosecret passthrough: false options: name: myTLSOption namespace: default","title":"Kubernetes CRD"},{"location":"reference/dynamic-configuration/kubernetes-crd/#kubernetes-configuration-reference","text":"Dynamic configuration with Kubernetes Custom Resource apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: tlsoptions.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: TLSOption plural: tlsoptions singular: tlsoption scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutetcps.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRouteTCP plural: ingressroutetcps singular: ingressroutetcp scope: Namespaced --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroute spec: entryPoints: - web - web-secure routes: - match: Host(`foo.com`) && PathPrefix(`/bar`) kind: Rule priority: 12 # defining several services is possible and allowed, but for now the servers of # all the services (for a given route) get merged altogether under the same # load-balancing strategy. services: - name: s1 port: 80 healthCheck: path: /health host: baz.com intervalSeconds: 7 timeoutSeconds: 60 # strategy defines the load balancing strategy between the servers. It defaults # to Round Robin, and for now only Round Robin is supported anyway. strategy: RoundRobin - name: s2 port: 433 healthCheck: path: /health host: baz.com intervalSeconds: 7 timeoutSeconds: 60 - match: PathPrefix(`/misc`) services: - name: s3 port: 80 middlewares: - name: stripprefix - name: addprefix - match: PathPrefix(`/misc`) services: - name: s3 port: 8443 # scheme allow to override the scheme for the service. (ex: https or h2c) scheme: https # use an empty tls object for TLS with Let's Encrypt tls: secretName: supersecret options: name: myTLSOption namespace: default --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRouteTCP metadata: name: ingressroutetcp.crd namespace: default spec: entryPoints: - footcp routes: - match: HostSNI(`bar.com`) services: - name: whoamitcp port: 8080 tls: secretName: foosecret passthrough: false options: name: myTLSOption namespace: default","title":"Kubernetes Configuration Reference"},{"location":"reference/dynamic-configuration/marathon/","text":"Marathon Configuration Reference \u00b6 Dynamic configuration with Marathon Labels \"labels\": { \"traefik.enable\": \"true\", \"traefik.marathon.ipaddressidx\": \"42\", \"traefik.http.middlewares.middleware00.addprefix.prefix\": \"foobar\", \"traefik.http.middlewares.middleware01.basicauth.headerfield\": \"foobar\", \"traefik.http.middlewares.middleware01.basicauth.realm\": \"foobar\", \"traefik.http.middlewares.middleware01.basicauth.removeheader\": \"true\", \"traefik.http.middlewares.middleware01.basicauth.users\": \"foobar, foobar\", \"traefik.http.middlewares.middleware01.basicauth.usersfile\": \"foobar\", \"traefik.http.middlewares.middleware02.buffering.maxrequestbodybytes\": \"42\", \"traefik.http.middlewares.middleware02.buffering.maxresponsebodybytes\": \"42\", \"traefik.http.middlewares.middleware02.buffering.memrequestbodybytes\": \"42\", \"traefik.http.middlewares.middleware02.buffering.memresponsebodybytes\": \"42\", \"traefik.http.middlewares.middleware02.buffering.retryexpression\": \"foobar\", \"traefik.http.middlewares.middleware03.chain.middlewares\": \"foobar, foobar\", \"traefik.http.middlewares.middleware04.circuitbreaker.expression\": \"foobar\", \"traefik.http.middlewares.middleware05.compress\": \"true\", \"traefik.http.middlewares.middleware06.digestauth.headerfield\": \"foobar\", \"traefik.http.middlewares.middleware06.digestauth.realm\": \"foobar\", \"traefik.http.middlewares.middleware06.digestauth.removeheader\": \"true\", \"traefik.http.middlewares.middleware06.digestauth.users\": \"foobar, foobar\", \"traefik.http.middlewares.middleware06.digestauth.usersfile\": \"foobar\", \"traefik.http.middlewares.middleware07.errors.query\": \"foobar\", \"traefik.http.middlewares.middleware07.errors.service\": \"foobar\", \"traefik.http.middlewares.middleware07.errors.status\": \"foobar, foobar\", \"traefik.http.middlewares.middleware08.forwardauth.address\": \"foobar\", \"traefik.http.middlewares.middleware08.forwardauth.authresponseheaders\": \"foobar, foobar\", \"traefik.http.middlewares.middleware08.forwardauth.tls.ca\": \"foobar\", \"traefik.http.middlewares.middleware08.forwardauth.tls.caoptional\": \"true\", \"traefik.http.middlewares.middleware08.forwardauth.tls.cert\": \"foobar\", \"traefik.http.middlewares.middleware08.forwardauth.tls.insecureskipverify\": \"true\", \"traefik.http.middlewares.middleware08.forwardauth.tls.key\": \"foobar\", \"traefik.http.middlewares.middleware08.forwardauth.trustforwardheader\": \"true\", \"traefik.http.middlewares.middleware09.headers.accesscontrolallowcredentials\": \"true\", \"traefik.http.middlewares.middleware09.headers.accesscontrolallowheaders\": \"foobar, foobar\", \"traefik.http.middlewares.middleware09.headers.accesscontrolallowmethods\": \"foobar, foobar\", \"traefik.http.middlewares.middleware09.headers.accesscontrolalloworigin\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.accesscontrolexposeheaders\": \"foobar, foobar\", \"traefik.http.middlewares.middleware09.headers.accesscontrolmaxage\": \"42\", \"traefik.http.middlewares.middleware09.headers.addvaryheader\": \"true\", \"traefik.http.middlewares.middleware09.headers.allowedhosts\": \"foobar, foobar\", \"traefik.http.middlewares.middleware09.headers.browserxssfilter\": \"true\", \"traefik.http.middlewares.middleware09.headers.contentsecuritypolicy\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.contenttypenosniff\": \"true\", \"traefik.http.middlewares.middleware09.headers.custombrowserxssvalue\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.customframeoptionsvalue\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name0\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name1\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name0\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name1\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.featurepolicy\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.forcestsheader\": \"true\", \"traefik.http.middlewares.middleware09.headers.framedeny\": \"true\", \"traefik.http.middlewares.middleware09.headers.hostsproxyheaders\": \"foobar, foobar\", \"traefik.http.middlewares.middleware09.headers.isdevelopment\": \"true\", \"traefik.http.middlewares.middleware09.headers.publickey\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.referrerpolicy\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.sslforcehost\": \"true\", \"traefik.http.middlewares.middleware09.headers.sslhost\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name0\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name1\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.sslredirect\": \"true\", \"traefik.http.middlewares.middleware09.headers.ssltemporaryredirect\": \"true\", \"traefik.http.middlewares.middleware09.headers.stsincludesubdomains\": \"true\", \"traefik.http.middlewares.middleware09.headers.stspreload\": \"true\", \"traefik.http.middlewares.middleware09.headers.stsseconds\": \"42\", \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.depth\": \"42\", \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.excludedips\": \"foobar, foobar\", \"traefik.http.middlewares.middleware10.ipwhitelist.sourcerange\": \"foobar, foobar\", \"traefik.http.middlewares.middleware11.inflightreq.amount\": \"42\", \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.depth\": \"42\", \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.excludedips\": \"foobar, foobar\", \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requestheadername\": \"foobar\", \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requesthost\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.commonname\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.country\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.domaincomponent\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.locality\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.organization\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.province\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.serialnumber\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notafter\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notbefore\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.sans\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.commonname\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.country\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.domaincomponent\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.locality\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.organization\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.province\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.serialnumber\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.pem\": \"true\", \"traefik.http.middlewares.middleware13.ratelimit.average\": \"42\", \"traefik.http.middlewares.middleware13.ratelimit.burst\": \"42\", \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.depth\": \"42\", \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.excludedips\": \"foobar, foobar\", \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requestheadername\": \"foobar\", \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requesthost\": \"true\", \"traefik.http.middlewares.middleware14.redirectregex.permanent\": \"true\", \"traefik.http.middlewares.middleware14.redirectregex.regex\": \"foobar\", \"traefik.http.middlewares.middleware14.redirectregex.replacement\": \"foobar\", \"traefik.http.middlewares.middleware15.redirectscheme.permanent\": \"true\", \"traefik.http.middlewares.middleware15.redirectscheme.port\": \"foobar\", \"traefik.http.middlewares.middleware15.redirectscheme.scheme\": \"foobar\", \"traefik.http.middlewares.middleware16.replacepath.path\": \"foobar\", \"traefik.http.middlewares.middleware17.replacepathregex.regex\": \"foobar\", \"traefik.http.middlewares.middleware17.replacepathregex.replacement\": \"foobar\", \"traefik.http.middlewares.middleware18.retry.attempts\": \"42\", \"traefik.http.middlewares.middleware19.stripprefix.forceslash\": \"true\", \"traefik.http.middlewares.middleware19.stripprefix.prefixes\": \"foobar, foobar\", \"traefik.http.middlewares.middleware20.stripprefixregex.regex\": \"foobar, foobar\", \"traefik.http.routers.router0.entrypoints\": \"foobar, foobar\", \"traefik.http.routers.router0.middlewares\": \"foobar, foobar\", \"traefik.http.routers.router0.priority\": \"42\", \"traefik.http.routers.router0.rule\": \"foobar\", \"traefik.http.routers.router0.service\": \"foobar\", \"traefik.http.routers.router0.tls.certresolver\": \"foobar\", \"traefik.http.routers.router0.tls.domains[0].main\": \"foobar\", \"traefik.http.routers.router0.tls.domains[0].sans\": \"foobar, foobar\", \"traefik.http.routers.router0.tls.domains[1].main\": \"foobar\", \"traefik.http.routers.router0.tls.domains[1].sans\": \"foobar, foobar\", \"traefik.http.routers.router0.tls.options\": \"foobar\", \"traefik.http.routers.router1.entrypoints\": \"foobar, foobar\", \"traefik.http.routers.router1.middlewares\": \"foobar, foobar\", \"traefik.http.routers.router1.priority\": \"42\", \"traefik.http.routers.router1.rule\": \"foobar\", \"traefik.http.routers.router1.service\": \"foobar\", \"traefik.http.routers.router1.tls.certresolver\": \"foobar\", \"traefik.http.routers.router1.tls.domains[0].main\": \"foobar\", \"traefik.http.routers.router1.tls.domains[0].sans\": \"foobar, foobar\", \"traefik.http.routers.router1.tls.domains[1].main\": \"foobar\", \"traefik.http.routers.router1.tls.domains[1].sans\": \"foobar, foobar\", \"traefik.http.routers.router1.tls.options\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name0\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name1\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.hostname\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.interval\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.path\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.port\": \"42\", \"traefik.http.services.service01.loadbalancer.healthcheck.scheme\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.timeout\": \"foobar\", \"traefik.http.services.service01.loadbalancer.passhostheader\": \"true\", \"traefik.http.services.service01.loadbalancer.responseforwarding.flushinterval\": \"foobar\", \"traefik.http.services.service01.loadbalancer.sticky.cookie.httponly\": \"true\", \"traefik.http.services.service01.loadbalancer.sticky.cookie.name\": \"foobar\", \"traefik.http.services.service01.loadbalancer.sticky.cookie.secure\": \"true\", \"traefik.http.services.service01.loadbalancer.server.port\": \"foobar\", \"traefik.http.services.service01.loadbalancer.server.scheme\": \"foobar\", \"traefik.tcp.routers.tcprouter0.entrypoints\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter0.rule\": \"foobar\", \"traefik.tcp.routers.tcprouter0.service\": \"foobar\", \"traefik.tcp.routers.tcprouter0.tls.certresolver\": \"foobar\", \"traefik.tcp.routers.tcprouter0.tls.domains[0].main\": \"foobar\", \"traefik.tcp.routers.tcprouter0.tls.domains[0].sans\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter0.tls.domains[1].main\": \"foobar\", \"traefik.tcp.routers.tcprouter0.tls.domains[1].sans\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter0.tls.options\": \"foobar\", \"traefik.tcp.routers.tcprouter0.tls.passthrough\": \"true\", \"traefik.tcp.routers.tcprouter1.entrypoints\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter1.rule\": \"foobar\", \"traefik.tcp.routers.tcprouter1.service\": \"foobar\", \"traefik.tcp.routers.tcprouter1.tls.certresolver\": \"foobar\", \"traefik.tcp.routers.tcprouter1.tls.domains[0].main\": \"foobar\", \"traefik.tcp.routers.tcprouter1.tls.domains[0].sans\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter1.tls.domains[1].main\": \"foobar\", \"traefik.tcp.routers.tcprouter1.tls.domains[1].sans\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter1.tls.options\": \"foobar\", \"traefik.tcp.routers.tcprouter1.tls.passthrough\": \"true\", \"traefik.tcp.services.tcpservice01.loadbalancer.terminationdelay\": \"42\", \"traefik.tcp.services.tcpservice01.loadbalancer.server.port\": \"foobar\", }","title":"Marathon"},{"location":"reference/dynamic-configuration/marathon/#marathon-configuration-reference","text":"Dynamic configuration with Marathon Labels \"labels\": { \"traefik.enable\": \"true\", \"traefik.marathon.ipaddressidx\": \"42\", \"traefik.http.middlewares.middleware00.addprefix.prefix\": \"foobar\", \"traefik.http.middlewares.middleware01.basicauth.headerfield\": \"foobar\", \"traefik.http.middlewares.middleware01.basicauth.realm\": \"foobar\", \"traefik.http.middlewares.middleware01.basicauth.removeheader\": \"true\", \"traefik.http.middlewares.middleware01.basicauth.users\": \"foobar, foobar\", \"traefik.http.middlewares.middleware01.basicauth.usersfile\": \"foobar\", \"traefik.http.middlewares.middleware02.buffering.maxrequestbodybytes\": \"42\", \"traefik.http.middlewares.middleware02.buffering.maxresponsebodybytes\": \"42\", \"traefik.http.middlewares.middleware02.buffering.memrequestbodybytes\": \"42\", \"traefik.http.middlewares.middleware02.buffering.memresponsebodybytes\": \"42\", \"traefik.http.middlewares.middleware02.buffering.retryexpression\": \"foobar\", \"traefik.http.middlewares.middleware03.chain.middlewares\": \"foobar, foobar\", \"traefik.http.middlewares.middleware04.circuitbreaker.expression\": \"foobar\", \"traefik.http.middlewares.middleware05.compress\": \"true\", \"traefik.http.middlewares.middleware06.digestauth.headerfield\": \"foobar\", \"traefik.http.middlewares.middleware06.digestauth.realm\": \"foobar\", \"traefik.http.middlewares.middleware06.digestauth.removeheader\": \"true\", \"traefik.http.middlewares.middleware06.digestauth.users\": \"foobar, foobar\", \"traefik.http.middlewares.middleware06.digestauth.usersfile\": \"foobar\", \"traefik.http.middlewares.middleware07.errors.query\": \"foobar\", \"traefik.http.middlewares.middleware07.errors.service\": \"foobar\", \"traefik.http.middlewares.middleware07.errors.status\": \"foobar, foobar\", \"traefik.http.middlewares.middleware08.forwardauth.address\": \"foobar\", \"traefik.http.middlewares.middleware08.forwardauth.authresponseheaders\": \"foobar, foobar\", \"traefik.http.middlewares.middleware08.forwardauth.tls.ca\": \"foobar\", \"traefik.http.middlewares.middleware08.forwardauth.tls.caoptional\": \"true\", \"traefik.http.middlewares.middleware08.forwardauth.tls.cert\": \"foobar\", \"traefik.http.middlewares.middleware08.forwardauth.tls.insecureskipverify\": \"true\", \"traefik.http.middlewares.middleware08.forwardauth.tls.key\": \"foobar\", \"traefik.http.middlewares.middleware08.forwardauth.trustforwardheader\": \"true\", \"traefik.http.middlewares.middleware09.headers.accesscontrolallowcredentials\": \"true\", \"traefik.http.middlewares.middleware09.headers.accesscontrolallowheaders\": \"foobar, foobar\", \"traefik.http.middlewares.middleware09.headers.accesscontrolallowmethods\": \"foobar, foobar\", \"traefik.http.middlewares.middleware09.headers.accesscontrolalloworigin\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.accesscontrolexposeheaders\": \"foobar, foobar\", \"traefik.http.middlewares.middleware09.headers.accesscontrolmaxage\": \"42\", \"traefik.http.middlewares.middleware09.headers.addvaryheader\": \"true\", \"traefik.http.middlewares.middleware09.headers.allowedhosts\": \"foobar, foobar\", \"traefik.http.middlewares.middleware09.headers.browserxssfilter\": \"true\", \"traefik.http.middlewares.middleware09.headers.contentsecuritypolicy\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.contenttypenosniff\": \"true\", \"traefik.http.middlewares.middleware09.headers.custombrowserxssvalue\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.customframeoptionsvalue\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name0\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name1\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name0\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name1\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.featurepolicy\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.forcestsheader\": \"true\", \"traefik.http.middlewares.middleware09.headers.framedeny\": \"true\", \"traefik.http.middlewares.middleware09.headers.hostsproxyheaders\": \"foobar, foobar\", \"traefik.http.middlewares.middleware09.headers.isdevelopment\": \"true\", \"traefik.http.middlewares.middleware09.headers.publickey\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.referrerpolicy\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.sslforcehost\": \"true\", \"traefik.http.middlewares.middleware09.headers.sslhost\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name0\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name1\": \"foobar\", \"traefik.http.middlewares.middleware09.headers.sslredirect\": \"true\", \"traefik.http.middlewares.middleware09.headers.ssltemporaryredirect\": \"true\", \"traefik.http.middlewares.middleware09.headers.stsincludesubdomains\": \"true\", \"traefik.http.middlewares.middleware09.headers.stspreload\": \"true\", \"traefik.http.middlewares.middleware09.headers.stsseconds\": \"42\", \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.depth\": \"42\", \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.excludedips\": \"foobar, foobar\", \"traefik.http.middlewares.middleware10.ipwhitelist.sourcerange\": \"foobar, foobar\", \"traefik.http.middlewares.middleware11.inflightreq.amount\": \"42\", \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.depth\": \"42\", \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.excludedips\": \"foobar, foobar\", \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requestheadername\": \"foobar\", \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requesthost\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.commonname\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.country\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.domaincomponent\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.locality\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.organization\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.province\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.serialnumber\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notafter\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notbefore\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.sans\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.commonname\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.country\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.domaincomponent\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.locality\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.organization\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.province\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.serialnumber\": \"true\", \"traefik.http.middlewares.middleware12.passtlsclientcert.pem\": \"true\", \"traefik.http.middlewares.middleware13.ratelimit.average\": \"42\", \"traefik.http.middlewares.middleware13.ratelimit.burst\": \"42\", \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.depth\": \"42\", \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.excludedips\": \"foobar, foobar\", \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requestheadername\": \"foobar\", \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requesthost\": \"true\", \"traefik.http.middlewares.middleware14.redirectregex.permanent\": \"true\", \"traefik.http.middlewares.middleware14.redirectregex.regex\": \"foobar\", \"traefik.http.middlewares.middleware14.redirectregex.replacement\": \"foobar\", \"traefik.http.middlewares.middleware15.redirectscheme.permanent\": \"true\", \"traefik.http.middlewares.middleware15.redirectscheme.port\": \"foobar\", \"traefik.http.middlewares.middleware15.redirectscheme.scheme\": \"foobar\", \"traefik.http.middlewares.middleware16.replacepath.path\": \"foobar\", \"traefik.http.middlewares.middleware17.replacepathregex.regex\": \"foobar\", \"traefik.http.middlewares.middleware17.replacepathregex.replacement\": \"foobar\", \"traefik.http.middlewares.middleware18.retry.attempts\": \"42\", \"traefik.http.middlewares.middleware19.stripprefix.forceslash\": \"true\", \"traefik.http.middlewares.middleware19.stripprefix.prefixes\": \"foobar, foobar\", \"traefik.http.middlewares.middleware20.stripprefixregex.regex\": \"foobar, foobar\", \"traefik.http.routers.router0.entrypoints\": \"foobar, foobar\", \"traefik.http.routers.router0.middlewares\": \"foobar, foobar\", \"traefik.http.routers.router0.priority\": \"42\", \"traefik.http.routers.router0.rule\": \"foobar\", \"traefik.http.routers.router0.service\": \"foobar\", \"traefik.http.routers.router0.tls.certresolver\": \"foobar\", \"traefik.http.routers.router0.tls.domains[0].main\": \"foobar\", \"traefik.http.routers.router0.tls.domains[0].sans\": \"foobar, foobar\", \"traefik.http.routers.router0.tls.domains[1].main\": \"foobar\", \"traefik.http.routers.router0.tls.domains[1].sans\": \"foobar, foobar\", \"traefik.http.routers.router0.tls.options\": \"foobar\", \"traefik.http.routers.router1.entrypoints\": \"foobar, foobar\", \"traefik.http.routers.router1.middlewares\": \"foobar, foobar\", \"traefik.http.routers.router1.priority\": \"42\", \"traefik.http.routers.router1.rule\": \"foobar\", \"traefik.http.routers.router1.service\": \"foobar\", \"traefik.http.routers.router1.tls.certresolver\": \"foobar\", \"traefik.http.routers.router1.tls.domains[0].main\": \"foobar\", \"traefik.http.routers.router1.tls.domains[0].sans\": \"foobar, foobar\", \"traefik.http.routers.router1.tls.domains[1].main\": \"foobar\", \"traefik.http.routers.router1.tls.domains[1].sans\": \"foobar, foobar\", \"traefik.http.routers.router1.tls.options\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name0\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name1\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.hostname\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.interval\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.path\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.port\": \"42\", \"traefik.http.services.service01.loadbalancer.healthcheck.scheme\": \"foobar\", \"traefik.http.services.service01.loadbalancer.healthcheck.timeout\": \"foobar\", \"traefik.http.services.service01.loadbalancer.passhostheader\": \"true\", \"traefik.http.services.service01.loadbalancer.responseforwarding.flushinterval\": \"foobar\", \"traefik.http.services.service01.loadbalancer.sticky.cookie.httponly\": \"true\", \"traefik.http.services.service01.loadbalancer.sticky.cookie.name\": \"foobar\", \"traefik.http.services.service01.loadbalancer.sticky.cookie.secure\": \"true\", \"traefik.http.services.service01.loadbalancer.server.port\": \"foobar\", \"traefik.http.services.service01.loadbalancer.server.scheme\": \"foobar\", \"traefik.tcp.routers.tcprouter0.entrypoints\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter0.rule\": \"foobar\", \"traefik.tcp.routers.tcprouter0.service\": \"foobar\", \"traefik.tcp.routers.tcprouter0.tls.certresolver\": \"foobar\", \"traefik.tcp.routers.tcprouter0.tls.domains[0].main\": \"foobar\", \"traefik.tcp.routers.tcprouter0.tls.domains[0].sans\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter0.tls.domains[1].main\": \"foobar\", \"traefik.tcp.routers.tcprouter0.tls.domains[1].sans\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter0.tls.options\": \"foobar\", \"traefik.tcp.routers.tcprouter0.tls.passthrough\": \"true\", \"traefik.tcp.routers.tcprouter1.entrypoints\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter1.rule\": \"foobar\", \"traefik.tcp.routers.tcprouter1.service\": \"foobar\", \"traefik.tcp.routers.tcprouter1.tls.certresolver\": \"foobar\", \"traefik.tcp.routers.tcprouter1.tls.domains[0].main\": \"foobar\", \"traefik.tcp.routers.tcprouter1.tls.domains[0].sans\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter1.tls.domains[1].main\": \"foobar\", \"traefik.tcp.routers.tcprouter1.tls.domains[1].sans\": \"foobar, foobar\", \"traefik.tcp.routers.tcprouter1.tls.options\": \"foobar\", \"traefik.tcp.routers.tcprouter1.tls.passthrough\": \"true\", \"traefik.tcp.services.tcpservice01.loadbalancer.terminationdelay\": \"42\", \"traefik.tcp.services.tcpservice01.loadbalancer.server.port\": \"foobar\", }","title":"Marathon Configuration Reference"},{"location":"reference/dynamic-configuration/rancher/","text":"Rancher Configuration Reference \u00b6 Dynamic configuration with Rancher Labels The labels are case insensitive. labels: - \"traefik.enable=true\" - \"traefik.http.middlewares.middleware00.addprefix.prefix=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.headerfield=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.realm=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.removeheader=true\" - \"traefik.http.middlewares.middleware01.basicauth.users=foobar, foobar\" - \"traefik.http.middlewares.middleware01.basicauth.usersfile=foobar\" - \"traefik.http.middlewares.middleware02.buffering.maxrequestbodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.maxresponsebodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.memrequestbodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.memresponsebodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.retryexpression=foobar\" - \"traefik.http.middlewares.middleware03.chain.middlewares=foobar, foobar\" - \"traefik.http.middlewares.middleware04.circuitbreaker.expression=foobar\" - \"traefik.http.middlewares.middleware05.compress=true\" - \"traefik.http.middlewares.middleware06.digestauth.headerfield=foobar\" - \"traefik.http.middlewares.middleware06.digestauth.realm=foobar\" - \"traefik.http.middlewares.middleware06.digestauth.removeheader=true\" - \"traefik.http.middlewares.middleware06.digestauth.users=foobar, foobar\" - \"traefik.http.middlewares.middleware06.digestauth.usersfile=foobar\" - \"traefik.http.middlewares.middleware07.errors.query=foobar\" - \"traefik.http.middlewares.middleware07.errors.service=foobar\" - \"traefik.http.middlewares.middleware07.errors.status=foobar, foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.address=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.authresponseheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.ca=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.caoptional=true\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.cert=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.insecureskipverify=true\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.key=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.trustforwardheader=true\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowcredentials=true\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowmethods=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolalloworigin=foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolexposeheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolmaxage=42\" - \"traefik.http.middlewares.middleware09.headers.addvaryheader=true\" - \"traefik.http.middlewares.middleware09.headers.allowedhosts=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.browserxssfilter=true\" - \"traefik.http.middlewares.middleware09.headers.contentsecuritypolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.contenttypenosniff=true\" - \"traefik.http.middlewares.middleware09.headers.custombrowserxssvalue=foobar\" - \"traefik.http.middlewares.middleware09.headers.customframeoptionsvalue=foobar\" - \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.featurepolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.forcestsheader=true\" - \"traefik.http.middlewares.middleware09.headers.framedeny=true\" - \"traefik.http.middlewares.middleware09.headers.hostsproxyheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.isdevelopment=true\" - \"traefik.http.middlewares.middleware09.headers.publickey=foobar\" - \"traefik.http.middlewares.middleware09.headers.referrerpolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslforcehost=true\" - \"traefik.http.middlewares.middleware09.headers.sslhost=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslredirect=true\" - \"traefik.http.middlewares.middleware09.headers.ssltemporaryredirect=true\" - \"traefik.http.middlewares.middleware09.headers.stsincludesubdomains=true\" - \"traefik.http.middlewares.middleware09.headers.stspreload=true\" - \"traefik.http.middlewares.middleware09.headers.stsseconds=42\" - \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware10.ipwhitelist.sourcerange=foobar, foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.amount=42\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requestheadername=foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requesthost=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.commonname=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.country=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.domaincomponent=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.locality=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.organization=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.province=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.serialnumber=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notafter=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notbefore=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.sans=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.commonname=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.country=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.domaincomponent=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.locality=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.organization=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.province=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.serialnumber=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.pem=true\" - \"traefik.http.middlewares.middleware13.ratelimit.average=42\" - \"traefik.http.middlewares.middleware13.ratelimit.burst=42\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requestheadername=foobar\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requesthost=true\" - \"traefik.http.middlewares.middleware14.redirectregex.permanent=true\" - \"traefik.http.middlewares.middleware14.redirectregex.regex=foobar\" - \"traefik.http.middlewares.middleware14.redirectregex.replacement=foobar\" - \"traefik.http.middlewares.middleware15.redirectscheme.permanent=true\" - \"traefik.http.middlewares.middleware15.redirectscheme.port=foobar\" - \"traefik.http.middlewares.middleware15.redirectscheme.scheme=foobar\" - \"traefik.http.middlewares.middleware16.replacepath.path=foobar\" - \"traefik.http.middlewares.middleware17.replacepathregex.regex=foobar\" - \"traefik.http.middlewares.middleware17.replacepathregex.replacement=foobar\" - \"traefik.http.middlewares.middleware18.retry.attempts=42\" - \"traefik.http.middlewares.middleware19.stripprefix.forceslash=true\" - \"traefik.http.middlewares.middleware19.stripprefix.prefixes=foobar, foobar\" - \"traefik.http.middlewares.middleware20.stripprefixregex.regex=foobar, foobar\" - \"traefik.http.routers.router0.entrypoints=foobar, foobar\" - \"traefik.http.routers.router0.middlewares=foobar, foobar\" - \"traefik.http.routers.router0.priority=42\" - \"traefik.http.routers.router0.rule=foobar\" - \"traefik.http.routers.router0.service=foobar\" - \"traefik.http.routers.router0.tls=true\" - \"traefik.http.routers.router0.tls.certresolver=foobar\" - \"traefik.http.routers.router0.tls.domains[0].main=foobar\" - \"traefik.http.routers.router0.tls.domains[0].sans=foobar, foobar\" - \"traefik.http.routers.router0.tls.domains[1].main=foobar\" - \"traefik.http.routers.router0.tls.domains[1].sans=foobar, foobar\" - \"traefik.http.routers.router0.tls.options=foobar\" - \"traefik.http.routers.router1.entrypoints=foobar, foobar\" - \"traefik.http.routers.router1.middlewares=foobar, foobar\" - \"traefik.http.routers.router1.priority=42\" - \"traefik.http.routers.router1.rule=foobar\" - \"traefik.http.routers.router1.service=foobar\" - \"traefik.http.routers.router1.tls=true\" - \"traefik.http.routers.router1.tls.certresolver=foobar\" - \"traefik.http.routers.router1.tls.domains[0].main=foobar\" - \"traefik.http.routers.router1.tls.domains[0].sans=foobar, foobar\" - \"traefik.http.routers.router1.tls.domains[1].main=foobar\" - \"traefik.http.routers.router1.tls.domains[1].sans=foobar, foobar\" - \"traefik.http.routers.router1.tls.options=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name0=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name1=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.hostname=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.interval=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.path=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.port=42\" - \"traefik.http.services.service01.loadbalancer.healthcheck.scheme=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.timeout=foobar\" - \"traefik.http.services.service01.loadbalancer.passhostheader=true\" - \"traefik.http.services.service01.loadbalancer.responseforwarding.flushinterval=foobar\" - \"traefik.http.services.service01.loadbalancer.sticky=true\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.httponly=true\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.name=foobar\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.secure=true\" - \"traefik.http.services.service01.loadbalancer.server.port=foobar\" - \"traefik.http.services.service01.loadbalancer.server.scheme=foobar\" - \"traefik.tcp.routers.tcprouter0.entrypoints=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.rule=foobar\" - \"traefik.tcp.routers.tcprouter0.service=foobar\" - \"traefik.tcp.routers.tcprouter0.tls=true\" - \"traefik.tcp.routers.tcprouter0.tls.certresolver=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[0].main=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[0].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[1].main=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[1].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.tls.options=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.passthrough=true\" - \"traefik.tcp.routers.tcprouter1.entrypoints=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.rule=foobar\" - \"traefik.tcp.routers.tcprouter1.service=foobar\" - \"traefik.tcp.routers.tcprouter1.tls=true\" - \"traefik.tcp.routers.tcprouter1.tls.certresolver=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[0].main=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[0].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[1].main=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[1].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.tls.options=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.passthrough=true\" - \"traefik.tcp.services.tcpservice01.loadbalancer.terminationdelay=42\" - \"traefik.tcp.services.tcpservice01.loadbalancer.server.port=foobar\"","title":"Rancher"},{"location":"reference/dynamic-configuration/rancher/#rancher-configuration-reference","text":"Dynamic configuration with Rancher Labels The labels are case insensitive. labels: - \"traefik.enable=true\" - \"traefik.http.middlewares.middleware00.addprefix.prefix=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.headerfield=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.realm=foobar\" - \"traefik.http.middlewares.middleware01.basicauth.removeheader=true\" - \"traefik.http.middlewares.middleware01.basicauth.users=foobar, foobar\" - \"traefik.http.middlewares.middleware01.basicauth.usersfile=foobar\" - \"traefik.http.middlewares.middleware02.buffering.maxrequestbodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.maxresponsebodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.memrequestbodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.memresponsebodybytes=42\" - \"traefik.http.middlewares.middleware02.buffering.retryexpression=foobar\" - \"traefik.http.middlewares.middleware03.chain.middlewares=foobar, foobar\" - \"traefik.http.middlewares.middleware04.circuitbreaker.expression=foobar\" - \"traefik.http.middlewares.middleware05.compress=true\" - \"traefik.http.middlewares.middleware06.digestauth.headerfield=foobar\" - \"traefik.http.middlewares.middleware06.digestauth.realm=foobar\" - \"traefik.http.middlewares.middleware06.digestauth.removeheader=true\" - \"traefik.http.middlewares.middleware06.digestauth.users=foobar, foobar\" - \"traefik.http.middlewares.middleware06.digestauth.usersfile=foobar\" - \"traefik.http.middlewares.middleware07.errors.query=foobar\" - \"traefik.http.middlewares.middleware07.errors.service=foobar\" - \"traefik.http.middlewares.middleware07.errors.status=foobar, foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.address=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.authresponseheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.ca=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.caoptional=true\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.cert=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.insecureskipverify=true\" - \"traefik.http.middlewares.middleware08.forwardauth.tls.key=foobar\" - \"traefik.http.middlewares.middleware08.forwardauth.trustforwardheader=true\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowcredentials=true\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolallowmethods=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolalloworigin=foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolexposeheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.accesscontrolmaxage=42\" - \"traefik.http.middlewares.middleware09.headers.addvaryheader=true\" - \"traefik.http.middlewares.middleware09.headers.allowedhosts=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.browserxssfilter=true\" - \"traefik.http.middlewares.middleware09.headers.contentsecuritypolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.contenttypenosniff=true\" - \"traefik.http.middlewares.middleware09.headers.custombrowserxssvalue=foobar\" - \"traefik.http.middlewares.middleware09.headers.customframeoptionsvalue=foobar\" - \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.customrequestheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.customresponseheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.featurepolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.forcestsheader=true\" - \"traefik.http.middlewares.middleware09.headers.framedeny=true\" - \"traefik.http.middlewares.middleware09.headers.hostsproxyheaders=foobar, foobar\" - \"traefik.http.middlewares.middleware09.headers.isdevelopment=true\" - \"traefik.http.middlewares.middleware09.headers.publickey=foobar\" - \"traefik.http.middlewares.middleware09.headers.referrerpolicy=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslforcehost=true\" - \"traefik.http.middlewares.middleware09.headers.sslhost=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name0=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslproxyheaders.name1=foobar\" - \"traefik.http.middlewares.middleware09.headers.sslredirect=true\" - \"traefik.http.middlewares.middleware09.headers.ssltemporaryredirect=true\" - \"traefik.http.middlewares.middleware09.headers.stsincludesubdomains=true\" - \"traefik.http.middlewares.middleware09.headers.stspreload=true\" - \"traefik.http.middlewares.middleware09.headers.stsseconds=42\" - \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware10.ipwhitelist.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware10.ipwhitelist.sourcerange=foobar, foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.amount=42\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requestheadername=foobar\" - \"traefik.http.middlewares.middleware11.inflightreq.sourcecriterion.requesthost=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.commonname=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.country=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.domaincomponent=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.locality=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.organization=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.province=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.issuer.serialnumber=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notafter=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.notbefore=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.sans=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.commonname=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.country=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.domaincomponent=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.locality=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.organization=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.province=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.info.subject.serialnumber=true\" - \"traefik.http.middlewares.middleware12.passtlsclientcert.pem=true\" - \"traefik.http.middlewares.middleware13.ratelimit.average=42\" - \"traefik.http.middlewares.middleware13.ratelimit.burst=42\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.depth=42\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.ipstrategy.excludedips=foobar, foobar\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requestheadername=foobar\" - \"traefik.http.middlewares.middleware13.ratelimit.sourcecriterion.requesthost=true\" - \"traefik.http.middlewares.middleware14.redirectregex.permanent=true\" - \"traefik.http.middlewares.middleware14.redirectregex.regex=foobar\" - \"traefik.http.middlewares.middleware14.redirectregex.replacement=foobar\" - \"traefik.http.middlewares.middleware15.redirectscheme.permanent=true\" - \"traefik.http.middlewares.middleware15.redirectscheme.port=foobar\" - \"traefik.http.middlewares.middleware15.redirectscheme.scheme=foobar\" - \"traefik.http.middlewares.middleware16.replacepath.path=foobar\" - \"traefik.http.middlewares.middleware17.replacepathregex.regex=foobar\" - \"traefik.http.middlewares.middleware17.replacepathregex.replacement=foobar\" - \"traefik.http.middlewares.middleware18.retry.attempts=42\" - \"traefik.http.middlewares.middleware19.stripprefix.forceslash=true\" - \"traefik.http.middlewares.middleware19.stripprefix.prefixes=foobar, foobar\" - \"traefik.http.middlewares.middleware20.stripprefixregex.regex=foobar, foobar\" - \"traefik.http.routers.router0.entrypoints=foobar, foobar\" - \"traefik.http.routers.router0.middlewares=foobar, foobar\" - \"traefik.http.routers.router0.priority=42\" - \"traefik.http.routers.router0.rule=foobar\" - \"traefik.http.routers.router0.service=foobar\" - \"traefik.http.routers.router0.tls=true\" - \"traefik.http.routers.router0.tls.certresolver=foobar\" - \"traefik.http.routers.router0.tls.domains[0].main=foobar\" - \"traefik.http.routers.router0.tls.domains[0].sans=foobar, foobar\" - \"traefik.http.routers.router0.tls.domains[1].main=foobar\" - \"traefik.http.routers.router0.tls.domains[1].sans=foobar, foobar\" - \"traefik.http.routers.router0.tls.options=foobar\" - \"traefik.http.routers.router1.entrypoints=foobar, foobar\" - \"traefik.http.routers.router1.middlewares=foobar, foobar\" - \"traefik.http.routers.router1.priority=42\" - \"traefik.http.routers.router1.rule=foobar\" - \"traefik.http.routers.router1.service=foobar\" - \"traefik.http.routers.router1.tls=true\" - \"traefik.http.routers.router1.tls.certresolver=foobar\" - \"traefik.http.routers.router1.tls.domains[0].main=foobar\" - \"traefik.http.routers.router1.tls.domains[0].sans=foobar, foobar\" - \"traefik.http.routers.router1.tls.domains[1].main=foobar\" - \"traefik.http.routers.router1.tls.domains[1].sans=foobar, foobar\" - \"traefik.http.routers.router1.tls.options=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name0=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.headers.name1=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.hostname=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.interval=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.path=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.port=42\" - \"traefik.http.services.service01.loadbalancer.healthcheck.scheme=foobar\" - \"traefik.http.services.service01.loadbalancer.healthcheck.timeout=foobar\" - \"traefik.http.services.service01.loadbalancer.passhostheader=true\" - \"traefik.http.services.service01.loadbalancer.responseforwarding.flushinterval=foobar\" - \"traefik.http.services.service01.loadbalancer.sticky=true\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.httponly=true\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.name=foobar\" - \"traefik.http.services.service01.loadbalancer.sticky.cookie.secure=true\" - \"traefik.http.services.service01.loadbalancer.server.port=foobar\" - \"traefik.http.services.service01.loadbalancer.server.scheme=foobar\" - \"traefik.tcp.routers.tcprouter0.entrypoints=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.rule=foobar\" - \"traefik.tcp.routers.tcprouter0.service=foobar\" - \"traefik.tcp.routers.tcprouter0.tls=true\" - \"traefik.tcp.routers.tcprouter0.tls.certresolver=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[0].main=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[0].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[1].main=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.domains[1].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter0.tls.options=foobar\" - \"traefik.tcp.routers.tcprouter0.tls.passthrough=true\" - \"traefik.tcp.routers.tcprouter1.entrypoints=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.rule=foobar\" - \"traefik.tcp.routers.tcprouter1.service=foobar\" - \"traefik.tcp.routers.tcprouter1.tls=true\" - \"traefik.tcp.routers.tcprouter1.tls.certresolver=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[0].main=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[0].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[1].main=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.domains[1].sans=foobar, foobar\" - \"traefik.tcp.routers.tcprouter1.tls.options=foobar\" - \"traefik.tcp.routers.tcprouter1.tls.passthrough=true\" - \"traefik.tcp.services.tcpservice01.loadbalancer.terminationdelay=42\" - \"traefik.tcp.services.tcpservice01.loadbalancer.server.port=foobar\"","title":"Rancher Configuration Reference"},{"location":"reference/static-configuration/cli-ref/","text":"--accesslog : Access log settings. (Default: false ) --accesslog.bufferingsize : Number of access log lines to process in a buffered way. (Default: 0 ) --accesslog.fields.defaultmode : Default mode for fields: keep | drop (Default: keep ) --accesslog.fields.headers.defaultmode : Default mode for fields: keep | drop | redact (Default: drop ) --accesslog.fields.headers.names.<name> : Override mode for headers --accesslog.fields.names.<name> : Override mode for fields --accesslog.filepath : Access log file path. Stdout is used when omitted or empty. --accesslog.filters.minduration : Keep access logs when request took longer than the specified duration. (Default: 0 ) --accesslog.filters.retryattempts : Keep access logs when at least one retry happened. (Default: false ) --accesslog.filters.statuscodes : Keep access logs with status codes in the specified range. --accesslog.format : Access log format: json | common (Default: common ) --api : Enable api/dashboard. (Default: false ) --api.dashboard : Activate dashboard. (Default: true ) --api.debug : Enable additional endpoints for debugging and profiling. (Default: false ) --api.insecure : Activate API directly on the entryPoint named traefik. (Default: false ) --certificatesresolvers.<name> : Certificates resolvers configuration. (Default: false ) --certificatesresolvers.<name>.acme.caserver : CA server to use. (Default: https://acme-v02.api.letsencrypt.org/directory ) --certificatesresolvers.<name>.acme.dnschallenge : Activate DNS-01 Challenge. (Default: false ) --certificatesresolvers.<name>.acme.dnschallenge.delaybeforecheck : Assume DNS propagates after a delay in seconds rather than finding and querying nameservers. (Default: 0 ) --certificatesresolvers.<name>.acme.dnschallenge.disablepropagationcheck : Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. [not recommended] (Default: false ) --certificatesresolvers.<name>.acme.dnschallenge.provider : Use a DNS-01 based challenge provider rather than HTTPS. --certificatesresolvers.<name>.acme.dnschallenge.resolvers : Use following DNS servers to resolve the FQDN authority. --certificatesresolvers.<name>.acme.email : Email address used for registration. --certificatesresolvers.<name>.acme.httpchallenge : Activate HTTP-01 Challenge. (Default: false ) --certificatesresolvers.<name>.acme.httpchallenge.entrypoint : HTTP challenge EntryPoint --certificatesresolvers.<name>.acme.keytype : KeyType used for generating certificate private key. Allow value 'EC256', 'EC384', 'RSA2048', 'RSA4096', 'RSA8192'. (Default: RSA4096 ) --certificatesresolvers.<name>.acme.storage : Storage to use. (Default: acme.json ) --certificatesresolvers.<name>.acme.tlschallenge : Activate TLS-ALPN-01 Challenge. (Default: true ) --entrypoints.<name> : Entry points definition. (Default: false ) --entrypoints.<name>.address : Entry point address. --entrypoints.<name>.forwardedheaders.insecure : Trust all forwarded headers. (Default: false ) --entrypoints.<name>.forwardedheaders.trustedips : Trust only forwarded headers from selected IPs. --entrypoints.<name>.proxyprotocol : Proxy-Protocol configuration. (Default: false ) --entrypoints.<name>.proxyprotocol.insecure : Trust all. (Default: false ) --entrypoints.<name>.proxyprotocol.trustedips : Trust only selected IPs. --entrypoints.<name>.transport.lifecycle.gracetimeout : Duration to give active requests a chance to finish before Traefik stops. (Default: 10 ) --entrypoints.<name>.transport.lifecycle.requestacceptgracetimeout : Duration to keep accepting requests before Traefik initiates the graceful shutdown procedure. (Default: 0 ) --entrypoints.<name>.transport.respondingtimeouts.idletimeout : IdleTimeout is the maximum amount duration an idle (keep-alive) connection will remain idle before closing itself. If zero, no timeout is set. (Default: 180 ) --entrypoints.<name>.transport.respondingtimeouts.readtimeout : ReadTimeout is the maximum duration for reading the entire request, including the body. If zero, no timeout is set. (Default: 0 ) --entrypoints.<name>.transport.respondingtimeouts.writetimeout : WriteTimeout is the maximum duration before timing out writes of the response. If zero, no timeout is set. (Default: 0 ) --global.checknewversion : Periodically check if a new version has been released. (Default: false ) --global.sendanonymoususage : Periodically send anonymous usage statistics. If the option is not specified, it will be enabled by default. (Default: false ) --hostresolver : Enable CNAME Flattening. (Default: false ) --hostresolver.cnameflattening : A flag to enable/disable CNAME flattening (Default: false ) --hostresolver.resolvconfig : resolv.conf used for DNS resolving (Default: /etc/resolv.conf ) --hostresolver.resolvdepth : The maximal depth of DNS recursive resolving (Default: 5 ) --log : Traefik log settings. (Default: false ) --log.filepath : Traefik log file path. Stdout is used when omitted or empty. --log.format : Traefik log format: json | common (Default: common ) --log.level : Log level set to traefik logs. (Default: ERROR ) --metrics.datadog : Datadog metrics exporter type. (Default: false ) --metrics.datadog.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.datadog.address : Datadog's address. (Default: localhost:8125 ) --metrics.datadog.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.datadog.pushinterval : Datadog push interval. (Default: 10 ) --metrics.influxdb : InfluxDB metrics exporter type. (Default: false ) --metrics.influxdb.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.influxdb.address : InfluxDB address. (Default: localhost:8089 ) --metrics.influxdb.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.influxdb.database : InfluxDB database used when protocol is http. --metrics.influxdb.password : InfluxDB password (only with http). --metrics.influxdb.protocol : InfluxDB address protocol (udp or http). (Default: udp ) --metrics.influxdb.pushinterval : InfluxDB push interval. (Default: 10 ) --metrics.influxdb.retentionpolicy : InfluxDB retention policy used when protocol is http. --metrics.influxdb.username : InfluxDB username (only with http). --metrics.prometheus : Prometheus metrics exporter type. (Default: false ) --metrics.prometheus.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.prometheus.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.prometheus.buckets : Buckets for latency metrics. (Default: 0.100000, 0.300000, 1.200000, 5.000000 ) --metrics.prometheus.entrypoint : EntryPoint (Default: traefik ) --metrics.statsd : StatsD metrics exporter type. (Default: false ) --metrics.statsd.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.statsd.address : StatsD address. (Default: localhost:8125 ) --metrics.statsd.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.statsd.pushinterval : StatsD push interval. (Default: 10 ) --ping : Enable ping. (Default: false ) --ping.entrypoint : EntryPoint (Default: traefik ) --providers.docker : Enable Docker backend with default settings. (Default: false ) --providers.docker.constraints : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. --providers.docker.defaultrule : Default rule. (Default: Host(`{{ normalize .Name }}`) ) --providers.docker.endpoint : Docker server endpoint. Can be a tcp or a unix socket endpoint. (Default: unix:///var/run/docker.sock ) --providers.docker.exposedbydefault : Expose containers by default. (Default: true ) --providers.docker.network : Default Docker network used. --providers.docker.swarmmode : Use Docker on Swarm Mode. (Default: false ) --providers.docker.swarmmoderefreshseconds : Polling interval for swarm mode. (Default: 15 ) --providers.docker.tls.ca : TLS CA --providers.docker.tls.caoptional : TLS CA.Optional (Default: false ) --providers.docker.tls.cert : TLS cert --providers.docker.tls.insecureskipverify : TLS insecure skip verify (Default: false ) --providers.docker.tls.key : TLS key --providers.docker.usebindportip : Use the ip address from the bound port, rather than from the inner network. (Default: false ) --providers.docker.watch : Watch provider. (Default: true ) --providers.file.debugloggeneratedtemplate : Enable debug logging of generated configuration template. (Default: false ) --providers.file.directory : Load dynamic configuration from one or more .toml or .yml files in a directory. --providers.file.filename : Load dynamic configuration from a file. --providers.file.watch : Watch provider. (Default: true ) --providers.kubernetescrd : Enable Kubernetes backend with default settings. (Default: false ) --providers.kubernetescrd.certauthfilepath : Kubernetes certificate authority file path (not needed for in-cluster client). --providers.kubernetescrd.disablepasshostheaders : Kubernetes disable PassHost Headers. (Default: false ) --providers.kubernetescrd.endpoint : Kubernetes server endpoint (required for external cluster client). --providers.kubernetescrd.ingressclass : Value of kubernetes.io/ingress.class annotation to watch for. --providers.kubernetescrd.labelselector : Kubernetes label selector to use. --providers.kubernetescrd.namespaces : Kubernetes namespaces. --providers.kubernetescrd.throttleduration : Ingress refresh throttle duration (Default: 0 ) --providers.kubernetescrd.token : Kubernetes bearer token (not needed for in-cluster client). --providers.kubernetesingress : Enable Kubernetes backend with default settings. (Default: false ) --providers.kubernetesingress.certauthfilepath : Kubernetes certificate authority file path (not needed for in-cluster client). --providers.kubernetesingress.disablepasshostheaders : Kubernetes disable PassHost Headers. (Default: false ) --providers.kubernetesingress.endpoint : Kubernetes server endpoint (required for external cluster client). --providers.kubernetesingress.ingressclass : Value of kubernetes.io/ingress.class annotation to watch for. --providers.kubernetesingress.ingressendpoint.hostname : Hostname used for Kubernetes Ingress endpoints. --providers.kubernetesingress.ingressendpoint.ip : IP used for Kubernetes Ingress endpoints. --providers.kubernetesingress.ingressendpoint.publishedservice : Published Kubernetes Service to copy status from. --providers.kubernetesingress.labelselector : Kubernetes Ingress label selector to use. --providers.kubernetesingress.namespaces : Kubernetes namespaces. --providers.kubernetesingress.throttleduration : Ingress refresh throttle duration (Default: 0 ) --providers.kubernetesingress.token : Kubernetes bearer token (not needed for in-cluster client). --providers.marathon : Enable Marathon backend with default settings. (Default: false ) --providers.marathon.basic.httpbasicauthuser : Basic authentication User. --providers.marathon.basic.httpbasicpassword : Basic authentication Password. --providers.marathon.constraints : Constraints is an expression that Traefik matches against the application's labels to determine whether to create any route for that application. --providers.marathon.dcostoken : DCOSToken for DCOS environment, This will override the Authorization header. --providers.marathon.defaultrule : Default rule. (Default: Host(`{{ normalize .Name }}`) ) --providers.marathon.dialertimeout : Set a dialer timeout for Marathon. (Default: 5 ) --providers.marathon.endpoint : Marathon server endpoint. You can also specify multiple endpoint for Marathon. (Default: http://127.0.0.1:8080 ) --providers.marathon.exposedbydefault : Expose Marathon apps by default. (Default: true ) --providers.marathon.forcetaskhostname : Force to use the task's hostname. (Default: false ) --providers.marathon.keepalive : Set a TCP Keep Alive time. (Default: 10 ) --providers.marathon.respectreadinesschecks : Filter out tasks with non-successful readiness checks during deployments. (Default: false ) --providers.marathon.responseheadertimeout : Set a response header timeout for Marathon. (Default: 60 ) --providers.marathon.tls.ca : TLS CA --providers.marathon.tls.caoptional : TLS CA.Optional (Default: false ) --providers.marathon.tls.cert : TLS cert --providers.marathon.tls.insecureskipverify : TLS insecure skip verify (Default: false ) --providers.marathon.tls.key : TLS key --providers.marathon.tlshandshaketimeout : Set a TLS handshake timeout for Marathon. (Default: 5 ) --providers.marathon.trace : Display additional provider logs. (Default: false ) --providers.marathon.watch : Watch provider. (Default: true ) --providers.providersthrottleduration : Backends throttle duration: minimum duration between 2 events from providers before applying a new configuration. It avoids unnecessary reloads if multiples events are sent in a short amount of time. (Default: 0 ) --providers.rancher : Enable Rancher backend with default settings. (Default: false ) --providers.rancher.constraints : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. --providers.rancher.defaultrule : Default rule. (Default: Host(`{{ normalize .Name }}`) ) --providers.rancher.enableservicehealthfilter : Filter services with unhealthy states and inactive states. (Default: true ) --providers.rancher.exposedbydefault : Expose containers by default. (Default: true ) --providers.rancher.intervalpoll : Poll the Rancher metadata service every 'rancher.refreshseconds' (less accurate). (Default: false ) --providers.rancher.prefix : Prefix used for accessing the Rancher metadata service. (Default: latest ) --providers.rancher.refreshseconds : Defines the polling interval in seconds. (Default: 15 ) --providers.rancher.watch : Watch provider. (Default: true ) --providers.rest : Enable Rest backend with default settings. (Default: false ) --providers.rest.insecure : Activate REST Provider directly on the entryPoint named traefik. (Default: false ) --serverstransport.forwardingtimeouts.dialtimeout : The amount of time to wait until a connection to a backend server can be established. If zero, no timeout exists. (Default: 30 ) --serverstransport.forwardingtimeouts.idleconntimeout : The maximum period for which an idle HTTP keep-alive connection will remain open before closing itself (Default: 90 ) --serverstransport.forwardingtimeouts.responseheadertimeout : The amount of time to wait for a server's response headers after fully writing the request (including its body, if any). If zero, no timeout exists. (Default: 0 ) --serverstransport.insecureskipverify : Disable SSL certificate verification. (Default: false ) --serverstransport.maxidleconnsperhost : If non-zero, controls the maximum idle (keep-alive) to keep per-host. If zero, DefaultMaxIdleConnsPerHost is used (Default: 0 ) --serverstransport.rootcas : Add cert file for self-signed certificate. --tracing : OpenTracing configuration. (Default: false ) --tracing.datadog : Settings for Datadog. (Default: false ) --tracing.datadog.bagageprefixheadername : Specifies the header name prefix that will be used to store baggage items in a map. --tracing.datadog.debug : Enable Datadog debug. (Default: false ) --tracing.datadog.globaltag : Key:Value tag to be set on all the spans. --tracing.datadog.localagenthostport : Set datadog-agent's host:port that the reporter will used. (Default: localhost:8126 ) --tracing.datadog.parentidheadername : Specifies the header name that will be used to store the parent ID. --tracing.datadog.prioritysampling : Enable priority sampling. When using distributed tracing, this option must be enabled in order to get all the parts of a distributed trace sampled. (Default: false ) --tracing.datadog.samplingpriorityheadername : Specifies the header name that will be used to store the sampling priority. --tracing.datadog.traceidheadername : Specifies the header name that will be used to store the trace ID. --tracing.haystack : Settings for Haystack. (Default: false ) --tracing.haystack.baggageprefixheadername : Specifies the header name prefix that will be used to store baggage items in a map. --tracing.haystack.globaltag : Key:Value tag to be set on all the spans. --tracing.haystack.localagenthost : Set haystack-agent's host that the reporter will used. (Default: LocalAgentHost ) --tracing.haystack.localagentport : Set haystack-agent's port that the reporter will used. (Default: 35000 ) --tracing.haystack.parentidheadername : Specifies the header name that will be used to store the parent ID. --tracing.haystack.spanidheadername : Specifies the header name that will be used to store the span ID. --tracing.haystack.traceidheadername : Specifies the header name that will be used to store the trace ID. --tracing.instana : Settings for Instana. (Default: false ) --tracing.instana.localagenthost : Set instana-agent's host that the reporter will used. --tracing.instana.localagentport : Set instana-agent's port that the reporter will used. (Default: 42699 ) --tracing.instana.loglevel : Set instana-agent's log level. ('error','warn','info','debug') (Default: info ) --tracing.jaeger : Settings for Jaeger. (Default: false ) --tracing.jaeger.collector.endpoint : Instructs reporter to send spans to jaeger-collector at this URL. --tracing.jaeger.collector.password : Password for basic http authentication when sending spans to jaeger-collector. --tracing.jaeger.collector.user : User for basic http authentication when sending spans to jaeger-collector. --tracing.jaeger.gen128bit : Generate 128 bit span IDs. (Default: false ) --tracing.jaeger.localagenthostport : Set jaeger-agent's host:port that the reporter will used. (Default: 127.0.0.1:6831 ) --tracing.jaeger.propagation : Which propagation format to use (jaeger/b3). (Default: jaeger ) --tracing.jaeger.samplingparam : Set the sampling parameter. (Default: 1.000000 ) --tracing.jaeger.samplingserverurl : Set the sampling server url. (Default: http://localhost:5778/sampling ) --tracing.jaeger.samplingtype : Set the sampling type. (Default: const ) --tracing.jaeger.tracecontextheadername : Set the header to use for the trace-id. (Default: uber-trace-id ) --tracing.servicename : Set the name for this service. (Default: traefik ) --tracing.spannamelimit : Set the maximum character limit for Span names (default 0 = no limit). (Default: 0 ) --tracing.zipkin : Settings for Zipkin. (Default: false ) --tracing.zipkin.httpendpoint : HTTP Endpoint to report traces to. (Default: http://localhost:9411/api/v2/spans ) --tracing.zipkin.id128bit : Use Zipkin 128 bit root span IDs. (Default: true ) --tracing.zipkin.samespan : Use Zipkin SameSpan RPC style traces. (Default: false ) --tracing.zipkin.samplerate : The rate between 0.0 and 1.0 of requests to trace. (Default: 1.000000 )","title":"Cli ref"},{"location":"reference/static-configuration/cli/","text":"Static Configuration: CLI \u00b6 --accesslog : Access log settings. (Default: false ) --accesslog.bufferingsize : Number of access log lines to process in a buffered way. (Default: 0 ) --accesslog.fields.defaultmode : Default mode for fields: keep | drop (Default: keep ) --accesslog.fields.headers.defaultmode : Default mode for fields: keep | drop | redact (Default: drop ) --accesslog.fields.headers.names.<name> : Override mode for headers --accesslog.fields.names.<name> : Override mode for fields --accesslog.filepath : Access log file path. Stdout is used when omitted or empty. --accesslog.filters.minduration : Keep access logs when request took longer than the specified duration. (Default: 0 ) --accesslog.filters.retryattempts : Keep access logs when at least one retry happened. (Default: false ) --accesslog.filters.statuscodes : Keep access logs with status codes in the specified range. --accesslog.format : Access log format: json | common (Default: common ) --api : Enable api/dashboard. (Default: false ) --api.dashboard : Activate dashboard. (Default: true ) --api.debug : Enable additional endpoints for debugging and profiling. (Default: false ) --api.insecure : Activate API directly on the entryPoint named traefik. (Default: false ) --certificatesresolvers.<name> : Certificates resolvers configuration. (Default: false ) --certificatesresolvers.<name>.acme.caserver : CA server to use. (Default: https://acme-v02.api.letsencrypt.org/directory ) --certificatesresolvers.<name>.acme.dnschallenge : Activate DNS-01 Challenge. (Default: false ) --certificatesresolvers.<name>.acme.dnschallenge.delaybeforecheck : Assume DNS propagates after a delay in seconds rather than finding and querying nameservers. (Default: 0 ) --certificatesresolvers.<name>.acme.dnschallenge.disablepropagationcheck : Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. [not recommended] (Default: false ) --certificatesresolvers.<name>.acme.dnschallenge.provider : Use a DNS-01 based challenge provider rather than HTTPS. --certificatesresolvers.<name>.acme.dnschallenge.resolvers : Use following DNS servers to resolve the FQDN authority. --certificatesresolvers.<name>.acme.email : Email address used for registration. --certificatesresolvers.<name>.acme.httpchallenge : Activate HTTP-01 Challenge. (Default: false ) --certificatesresolvers.<name>.acme.httpchallenge.entrypoint : HTTP challenge EntryPoint --certificatesresolvers.<name>.acme.keytype : KeyType used for generating certificate private key. Allow value 'EC256', 'EC384', 'RSA2048', 'RSA4096', 'RSA8192'. (Default: RSA4096 ) --certificatesresolvers.<name>.acme.storage : Storage to use. (Default: acme.json ) --certificatesresolvers.<name>.acme.tlschallenge : Activate TLS-ALPN-01 Challenge. (Default: true ) --entrypoints.<name> : Entry points definition. (Default: false ) --entrypoints.<name>.address : Entry point address. --entrypoints.<name>.forwardedheaders.insecure : Trust all forwarded headers. (Default: false ) --entrypoints.<name>.forwardedheaders.trustedips : Trust only forwarded headers from selected IPs. --entrypoints.<name>.proxyprotocol : Proxy-Protocol configuration. (Default: false ) --entrypoints.<name>.proxyprotocol.insecure : Trust all. (Default: false ) --entrypoints.<name>.proxyprotocol.trustedips : Trust only selected IPs. --entrypoints.<name>.transport.lifecycle.gracetimeout : Duration to give active requests a chance to finish before Traefik stops. (Default: 10 ) --entrypoints.<name>.transport.lifecycle.requestacceptgracetimeout : Duration to keep accepting requests before Traefik initiates the graceful shutdown procedure. (Default: 0 ) --entrypoints.<name>.transport.respondingtimeouts.idletimeout : IdleTimeout is the maximum amount duration an idle (keep-alive) connection will remain idle before closing itself. If zero, no timeout is set. (Default: 180 ) --entrypoints.<name>.transport.respondingtimeouts.readtimeout : ReadTimeout is the maximum duration for reading the entire request, including the body. If zero, no timeout is set. (Default: 0 ) --entrypoints.<name>.transport.respondingtimeouts.writetimeout : WriteTimeout is the maximum duration before timing out writes of the response. If zero, no timeout is set. (Default: 0 ) --global.checknewversion : Periodically check if a new version has been released. (Default: false ) --global.sendanonymoususage : Periodically send anonymous usage statistics. If the option is not specified, it will be enabled by default. (Default: false ) --hostresolver : Enable CNAME Flattening. (Default: false ) --hostresolver.cnameflattening : A flag to enable/disable CNAME flattening (Default: false ) --hostresolver.resolvconfig : resolv.conf used for DNS resolving (Default: /etc/resolv.conf ) --hostresolver.resolvdepth : The maximal depth of DNS recursive resolving (Default: 5 ) --log : Traefik log settings. (Default: false ) --log.filepath : Traefik log file path. Stdout is used when omitted or empty. --log.format : Traefik log format: json | common (Default: common ) --log.level : Log level set to traefik logs. (Default: ERROR ) --metrics.datadog : Datadog metrics exporter type. (Default: false ) --metrics.datadog.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.datadog.address : Datadog's address. (Default: localhost:8125 ) --metrics.datadog.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.datadog.pushinterval : Datadog push interval. (Default: 10 ) --metrics.influxdb : InfluxDB metrics exporter type. (Default: false ) --metrics.influxdb.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.influxdb.address : InfluxDB address. (Default: localhost:8089 ) --metrics.influxdb.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.influxdb.database : InfluxDB database used when protocol is http. --metrics.influxdb.password : InfluxDB password (only with http). --metrics.influxdb.protocol : InfluxDB address protocol (udp or http). (Default: udp ) --metrics.influxdb.pushinterval : InfluxDB push interval. (Default: 10 ) --metrics.influxdb.retentionpolicy : InfluxDB retention policy used when protocol is http. --metrics.influxdb.username : InfluxDB username (only with http). --metrics.prometheus : Prometheus metrics exporter type. (Default: false ) --metrics.prometheus.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.prometheus.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.prometheus.buckets : Buckets for latency metrics. (Default: 0.100000, 0.300000, 1.200000, 5.000000 ) --metrics.prometheus.entrypoint : EntryPoint (Default: traefik ) --metrics.statsd : StatsD metrics exporter type. (Default: false ) --metrics.statsd.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.statsd.address : StatsD address. (Default: localhost:8125 ) --metrics.statsd.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.statsd.pushinterval : StatsD push interval. (Default: 10 ) --ping : Enable ping. (Default: false ) --ping.entrypoint : EntryPoint (Default: traefik ) --providers.docker : Enable Docker backend with default settings. (Default: false ) --providers.docker.constraints : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. --providers.docker.defaultrule : Default rule. (Default: Host(`{{ normalize .Name }}`) ) --providers.docker.endpoint : Docker server endpoint. Can be a tcp or a unix socket endpoint. (Default: unix:///var/run/docker.sock ) --providers.docker.exposedbydefault : Expose containers by default. (Default: true ) --providers.docker.network : Default Docker network used. --providers.docker.swarmmode : Use Docker on Swarm Mode. (Default: false ) --providers.docker.swarmmoderefreshseconds : Polling interval for swarm mode. (Default: 15 ) --providers.docker.tls.ca : TLS CA --providers.docker.tls.caoptional : TLS CA.Optional (Default: false ) --providers.docker.tls.cert : TLS cert --providers.docker.tls.insecureskipverify : TLS insecure skip verify (Default: false ) --providers.docker.tls.key : TLS key --providers.docker.usebindportip : Use the ip address from the bound port, rather than from the inner network. (Default: false ) --providers.docker.watch : Watch provider. (Default: true ) --providers.file.debugloggeneratedtemplate : Enable debug logging of generated configuration template. (Default: false ) --providers.file.directory : Load dynamic configuration from one or more .toml or .yml files in a directory. --providers.file.filename : Load dynamic configuration from a file. --providers.file.watch : Watch provider. (Default: true ) --providers.kubernetescrd : Enable Kubernetes backend with default settings. (Default: false ) --providers.kubernetescrd.certauthfilepath : Kubernetes certificate authority file path (not needed for in-cluster client). --providers.kubernetescrd.disablepasshostheaders : Kubernetes disable PassHost Headers. (Default: false ) --providers.kubernetescrd.endpoint : Kubernetes server endpoint (required for external cluster client). --providers.kubernetescrd.ingressclass : Value of kubernetes.io/ingress.class annotation to watch for. --providers.kubernetescrd.labelselector : Kubernetes label selector to use. --providers.kubernetescrd.namespaces : Kubernetes namespaces. --providers.kubernetescrd.throttleduration : Ingress refresh throttle duration (Default: 0 ) --providers.kubernetescrd.token : Kubernetes bearer token (not needed for in-cluster client). --providers.kubernetesingress : Enable Kubernetes backend with default settings. (Default: false ) --providers.kubernetesingress.certauthfilepath : Kubernetes certificate authority file path (not needed for in-cluster client). --providers.kubernetesingress.disablepasshostheaders : Kubernetes disable PassHost Headers. (Default: false ) --providers.kubernetesingress.endpoint : Kubernetes server endpoint (required for external cluster client). --providers.kubernetesingress.ingressclass : Value of kubernetes.io/ingress.class annotation to watch for. --providers.kubernetesingress.ingressendpoint.hostname : Hostname used for Kubernetes Ingress endpoints. --providers.kubernetesingress.ingressendpoint.ip : IP used for Kubernetes Ingress endpoints. --providers.kubernetesingress.ingressendpoint.publishedservice : Published Kubernetes Service to copy status from. --providers.kubernetesingress.labelselector : Kubernetes Ingress label selector to use. --providers.kubernetesingress.namespaces : Kubernetes namespaces. --providers.kubernetesingress.throttleduration : Ingress refresh throttle duration (Default: 0 ) --providers.kubernetesingress.token : Kubernetes bearer token (not needed for in-cluster client). --providers.marathon : Enable Marathon backend with default settings. (Default: false ) --providers.marathon.basic.httpbasicauthuser : Basic authentication User. --providers.marathon.basic.httpbasicpassword : Basic authentication Password. --providers.marathon.constraints : Constraints is an expression that Traefik matches against the application's labels to determine whether to create any route for that application. --providers.marathon.dcostoken : DCOSToken for DCOS environment, This will override the Authorization header. --providers.marathon.defaultrule : Default rule. (Default: Host(`{{ normalize .Name }}`) ) --providers.marathon.dialertimeout : Set a dialer timeout for Marathon. (Default: 5 ) --providers.marathon.endpoint : Marathon server endpoint. You can also specify multiple endpoint for Marathon. (Default: http://127.0.0.1:8080 ) --providers.marathon.exposedbydefault : Expose Marathon apps by default. (Default: true ) --providers.marathon.forcetaskhostname : Force to use the task's hostname. (Default: false ) --providers.marathon.keepalive : Set a TCP Keep Alive time. (Default: 10 ) --providers.marathon.respectreadinesschecks : Filter out tasks with non-successful readiness checks during deployments. (Default: false ) --providers.marathon.responseheadertimeout : Set a response header timeout for Marathon. (Default: 60 ) --providers.marathon.tls.ca : TLS CA --providers.marathon.tls.caoptional : TLS CA.Optional (Default: false ) --providers.marathon.tls.cert : TLS cert --providers.marathon.tls.insecureskipverify : TLS insecure skip verify (Default: false ) --providers.marathon.tls.key : TLS key --providers.marathon.tlshandshaketimeout : Set a TLS handshake timeout for Marathon. (Default: 5 ) --providers.marathon.trace : Display additional provider logs. (Default: false ) --providers.marathon.watch : Watch provider. (Default: true ) --providers.providersthrottleduration : Backends throttle duration: minimum duration between 2 events from providers before applying a new configuration. It avoids unnecessary reloads if multiples events are sent in a short amount of time. (Default: 0 ) --providers.rancher : Enable Rancher backend with default settings. (Default: false ) --providers.rancher.constraints : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. --providers.rancher.defaultrule : Default rule. (Default: Host(`{{ normalize .Name }}`) ) --providers.rancher.enableservicehealthfilter : Filter services with unhealthy states and inactive states. (Default: true ) --providers.rancher.exposedbydefault : Expose containers by default. (Default: true ) --providers.rancher.intervalpoll : Poll the Rancher metadata service every 'rancher.refreshseconds' (less accurate). (Default: false ) --providers.rancher.prefix : Prefix used for accessing the Rancher metadata service. (Default: latest ) --providers.rancher.refreshseconds : Defines the polling interval in seconds. (Default: 15 ) --providers.rancher.watch : Watch provider. (Default: true ) --providers.rest : Enable Rest backend with default settings. (Default: false ) --providers.rest.insecure : Activate REST Provider directly on the entryPoint named traefik. (Default: false ) --serverstransport.forwardingtimeouts.dialtimeout : The amount of time to wait until a connection to a backend server can be established. If zero, no timeout exists. (Default: 30 ) --serverstransport.forwardingtimeouts.idleconntimeout : The maximum period for which an idle HTTP keep-alive connection will remain open before closing itself (Default: 90 ) --serverstransport.forwardingtimeouts.responseheadertimeout : The amount of time to wait for a server's response headers after fully writing the request (including its body, if any). If zero, no timeout exists. (Default: 0 ) --serverstransport.insecureskipverify : Disable SSL certificate verification. (Default: false ) --serverstransport.maxidleconnsperhost : If non-zero, controls the maximum idle (keep-alive) to keep per-host. If zero, DefaultMaxIdleConnsPerHost is used (Default: 0 ) --serverstransport.rootcas : Add cert file for self-signed certificate. --tracing : OpenTracing configuration. (Default: false ) --tracing.datadog : Settings for Datadog. (Default: false ) --tracing.datadog.bagageprefixheadername : Specifies the header name prefix that will be used to store baggage items in a map. --tracing.datadog.debug : Enable Datadog debug. (Default: false ) --tracing.datadog.globaltag : Key:Value tag to be set on all the spans. --tracing.datadog.localagenthostport : Set datadog-agent's host:port that the reporter will used. (Default: localhost:8126 ) --tracing.datadog.parentidheadername : Specifies the header name that will be used to store the parent ID. --tracing.datadog.prioritysampling : Enable priority sampling. When using distributed tracing, this option must be enabled in order to get all the parts of a distributed trace sampled. (Default: false ) --tracing.datadog.samplingpriorityheadername : Specifies the header name that will be used to store the sampling priority. --tracing.datadog.traceidheadername : Specifies the header name that will be used to store the trace ID. --tracing.haystack : Settings for Haystack. (Default: false ) --tracing.haystack.baggageprefixheadername : Specifies the header name prefix that will be used to store baggage items in a map. --tracing.haystack.globaltag : Key:Value tag to be set on all the spans. --tracing.haystack.localagenthost : Set haystack-agent's host that the reporter will used. (Default: LocalAgentHost ) --tracing.haystack.localagentport : Set haystack-agent's port that the reporter will used. (Default: 35000 ) --tracing.haystack.parentidheadername : Specifies the header name that will be used to store the parent ID. --tracing.haystack.spanidheadername : Specifies the header name that will be used to store the span ID. --tracing.haystack.traceidheadername : Specifies the header name that will be used to store the trace ID. --tracing.instana : Settings for Instana. (Default: false ) --tracing.instana.localagenthost : Set instana-agent's host that the reporter will used. --tracing.instana.localagentport : Set instana-agent's port that the reporter will used. (Default: 42699 ) --tracing.instana.loglevel : Set instana-agent's log level. ('error','warn','info','debug') (Default: info ) --tracing.jaeger : Settings for Jaeger. (Default: false ) --tracing.jaeger.collector.endpoint : Instructs reporter to send spans to jaeger-collector at this URL. --tracing.jaeger.collector.password : Password for basic http authentication when sending spans to jaeger-collector. --tracing.jaeger.collector.user : User for basic http authentication when sending spans to jaeger-collector. --tracing.jaeger.gen128bit : Generate 128 bit span IDs. (Default: false ) --tracing.jaeger.localagenthostport : Set jaeger-agent's host:port that the reporter will used. (Default: 127.0.0.1:6831 ) --tracing.jaeger.propagation : Which propagation format to use (jaeger/b3). (Default: jaeger ) --tracing.jaeger.samplingparam : Set the sampling parameter. (Default: 1.000000 ) --tracing.jaeger.samplingserverurl : Set the sampling server url. (Default: http://localhost:5778/sampling ) --tracing.jaeger.samplingtype : Set the sampling type. (Default: const ) --tracing.jaeger.tracecontextheadername : Set the header to use for the trace-id. (Default: uber-trace-id ) --tracing.servicename : Set the name for this service. (Default: traefik ) --tracing.spannamelimit : Set the maximum character limit for Span names (default 0 = no limit). (Default: 0 ) --tracing.zipkin : Settings for Zipkin. (Default: false ) --tracing.zipkin.httpendpoint : HTTP Endpoint to report traces to. (Default: http://localhost:9411/api/v2/spans ) --tracing.zipkin.id128bit : Use Zipkin 128 bit root span IDs. (Default: true ) --tracing.zipkin.samespan : Use Zipkin SameSpan RPC style traces. (Default: false ) --tracing.zipkin.samplerate : The rate between 0.0 and 1.0 of requests to trace. (Default: 1.000000 )","title":"CLI"},{"location":"reference/static-configuration/cli/#static-configuration-cli","text":"--accesslog : Access log settings. (Default: false ) --accesslog.bufferingsize : Number of access log lines to process in a buffered way. (Default: 0 ) --accesslog.fields.defaultmode : Default mode for fields: keep | drop (Default: keep ) --accesslog.fields.headers.defaultmode : Default mode for fields: keep | drop | redact (Default: drop ) --accesslog.fields.headers.names.<name> : Override mode for headers --accesslog.fields.names.<name> : Override mode for fields --accesslog.filepath : Access log file path. Stdout is used when omitted or empty. --accesslog.filters.minduration : Keep access logs when request took longer than the specified duration. (Default: 0 ) --accesslog.filters.retryattempts : Keep access logs when at least one retry happened. (Default: false ) --accesslog.filters.statuscodes : Keep access logs with status codes in the specified range. --accesslog.format : Access log format: json | common (Default: common ) --api : Enable api/dashboard. (Default: false ) --api.dashboard : Activate dashboard. (Default: true ) --api.debug : Enable additional endpoints for debugging and profiling. (Default: false ) --api.insecure : Activate API directly on the entryPoint named traefik. (Default: false ) --certificatesresolvers.<name> : Certificates resolvers configuration. (Default: false ) --certificatesresolvers.<name>.acme.caserver : CA server to use. (Default: https://acme-v02.api.letsencrypt.org/directory ) --certificatesresolvers.<name>.acme.dnschallenge : Activate DNS-01 Challenge. (Default: false ) --certificatesresolvers.<name>.acme.dnschallenge.delaybeforecheck : Assume DNS propagates after a delay in seconds rather than finding and querying nameservers. (Default: 0 ) --certificatesresolvers.<name>.acme.dnschallenge.disablepropagationcheck : Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. [not recommended] (Default: false ) --certificatesresolvers.<name>.acme.dnschallenge.provider : Use a DNS-01 based challenge provider rather than HTTPS. --certificatesresolvers.<name>.acme.dnschallenge.resolvers : Use following DNS servers to resolve the FQDN authority. --certificatesresolvers.<name>.acme.email : Email address used for registration. --certificatesresolvers.<name>.acme.httpchallenge : Activate HTTP-01 Challenge. (Default: false ) --certificatesresolvers.<name>.acme.httpchallenge.entrypoint : HTTP challenge EntryPoint --certificatesresolvers.<name>.acme.keytype : KeyType used for generating certificate private key. Allow value 'EC256', 'EC384', 'RSA2048', 'RSA4096', 'RSA8192'. (Default: RSA4096 ) --certificatesresolvers.<name>.acme.storage : Storage to use. (Default: acme.json ) --certificatesresolvers.<name>.acme.tlschallenge : Activate TLS-ALPN-01 Challenge. (Default: true ) --entrypoints.<name> : Entry points definition. (Default: false ) --entrypoints.<name>.address : Entry point address. --entrypoints.<name>.forwardedheaders.insecure : Trust all forwarded headers. (Default: false ) --entrypoints.<name>.forwardedheaders.trustedips : Trust only forwarded headers from selected IPs. --entrypoints.<name>.proxyprotocol : Proxy-Protocol configuration. (Default: false ) --entrypoints.<name>.proxyprotocol.insecure : Trust all. (Default: false ) --entrypoints.<name>.proxyprotocol.trustedips : Trust only selected IPs. --entrypoints.<name>.transport.lifecycle.gracetimeout : Duration to give active requests a chance to finish before Traefik stops. (Default: 10 ) --entrypoints.<name>.transport.lifecycle.requestacceptgracetimeout : Duration to keep accepting requests before Traefik initiates the graceful shutdown procedure. (Default: 0 ) --entrypoints.<name>.transport.respondingtimeouts.idletimeout : IdleTimeout is the maximum amount duration an idle (keep-alive) connection will remain idle before closing itself. If zero, no timeout is set. (Default: 180 ) --entrypoints.<name>.transport.respondingtimeouts.readtimeout : ReadTimeout is the maximum duration for reading the entire request, including the body. If zero, no timeout is set. (Default: 0 ) --entrypoints.<name>.transport.respondingtimeouts.writetimeout : WriteTimeout is the maximum duration before timing out writes of the response. If zero, no timeout is set. (Default: 0 ) --global.checknewversion : Periodically check if a new version has been released. (Default: false ) --global.sendanonymoususage : Periodically send anonymous usage statistics. If the option is not specified, it will be enabled by default. (Default: false ) --hostresolver : Enable CNAME Flattening. (Default: false ) --hostresolver.cnameflattening : A flag to enable/disable CNAME flattening (Default: false ) --hostresolver.resolvconfig : resolv.conf used for DNS resolving (Default: /etc/resolv.conf ) --hostresolver.resolvdepth : The maximal depth of DNS recursive resolving (Default: 5 ) --log : Traefik log settings. (Default: false ) --log.filepath : Traefik log file path. Stdout is used when omitted or empty. --log.format : Traefik log format: json | common (Default: common ) --log.level : Log level set to traefik logs. (Default: ERROR ) --metrics.datadog : Datadog metrics exporter type. (Default: false ) --metrics.datadog.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.datadog.address : Datadog's address. (Default: localhost:8125 ) --metrics.datadog.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.datadog.pushinterval : Datadog push interval. (Default: 10 ) --metrics.influxdb : InfluxDB metrics exporter type. (Default: false ) --metrics.influxdb.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.influxdb.address : InfluxDB address. (Default: localhost:8089 ) --metrics.influxdb.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.influxdb.database : InfluxDB database used when protocol is http. --metrics.influxdb.password : InfluxDB password (only with http). --metrics.influxdb.protocol : InfluxDB address protocol (udp or http). (Default: udp ) --metrics.influxdb.pushinterval : InfluxDB push interval. (Default: 10 ) --metrics.influxdb.retentionpolicy : InfluxDB retention policy used when protocol is http. --metrics.influxdb.username : InfluxDB username (only with http). --metrics.prometheus : Prometheus metrics exporter type. (Default: false ) --metrics.prometheus.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.prometheus.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.prometheus.buckets : Buckets for latency metrics. (Default: 0.100000, 0.300000, 1.200000, 5.000000 ) --metrics.prometheus.entrypoint : EntryPoint (Default: traefik ) --metrics.statsd : StatsD metrics exporter type. (Default: false ) --metrics.statsd.addentrypointslabels : Enable metrics on entry points. (Default: true ) --metrics.statsd.address : StatsD address. (Default: localhost:8125 ) --metrics.statsd.addserviceslabels : Enable metrics on services. (Default: true ) --metrics.statsd.pushinterval : StatsD push interval. (Default: 10 ) --ping : Enable ping. (Default: false ) --ping.entrypoint : EntryPoint (Default: traefik ) --providers.docker : Enable Docker backend with default settings. (Default: false ) --providers.docker.constraints : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. --providers.docker.defaultrule : Default rule. (Default: Host(`{{ normalize .Name }}`) ) --providers.docker.endpoint : Docker server endpoint. Can be a tcp or a unix socket endpoint. (Default: unix:///var/run/docker.sock ) --providers.docker.exposedbydefault : Expose containers by default. (Default: true ) --providers.docker.network : Default Docker network used. --providers.docker.swarmmode : Use Docker on Swarm Mode. (Default: false ) --providers.docker.swarmmoderefreshseconds : Polling interval for swarm mode. (Default: 15 ) --providers.docker.tls.ca : TLS CA --providers.docker.tls.caoptional : TLS CA.Optional (Default: false ) --providers.docker.tls.cert : TLS cert --providers.docker.tls.insecureskipverify : TLS insecure skip verify (Default: false ) --providers.docker.tls.key : TLS key --providers.docker.usebindportip : Use the ip address from the bound port, rather than from the inner network. (Default: false ) --providers.docker.watch : Watch provider. (Default: true ) --providers.file.debugloggeneratedtemplate : Enable debug logging of generated configuration template. (Default: false ) --providers.file.directory : Load dynamic configuration from one or more .toml or .yml files in a directory. --providers.file.filename : Load dynamic configuration from a file. --providers.file.watch : Watch provider. (Default: true ) --providers.kubernetescrd : Enable Kubernetes backend with default settings. (Default: false ) --providers.kubernetescrd.certauthfilepath : Kubernetes certificate authority file path (not needed for in-cluster client). --providers.kubernetescrd.disablepasshostheaders : Kubernetes disable PassHost Headers. (Default: false ) --providers.kubernetescrd.endpoint : Kubernetes server endpoint (required for external cluster client). --providers.kubernetescrd.ingressclass : Value of kubernetes.io/ingress.class annotation to watch for. --providers.kubernetescrd.labelselector : Kubernetes label selector to use. --providers.kubernetescrd.namespaces : Kubernetes namespaces. --providers.kubernetescrd.throttleduration : Ingress refresh throttle duration (Default: 0 ) --providers.kubernetescrd.token : Kubernetes bearer token (not needed for in-cluster client). --providers.kubernetesingress : Enable Kubernetes backend with default settings. (Default: false ) --providers.kubernetesingress.certauthfilepath : Kubernetes certificate authority file path (not needed for in-cluster client). --providers.kubernetesingress.disablepasshostheaders : Kubernetes disable PassHost Headers. (Default: false ) --providers.kubernetesingress.endpoint : Kubernetes server endpoint (required for external cluster client). --providers.kubernetesingress.ingressclass : Value of kubernetes.io/ingress.class annotation to watch for. --providers.kubernetesingress.ingressendpoint.hostname : Hostname used for Kubernetes Ingress endpoints. --providers.kubernetesingress.ingressendpoint.ip : IP used for Kubernetes Ingress endpoints. --providers.kubernetesingress.ingressendpoint.publishedservice : Published Kubernetes Service to copy status from. --providers.kubernetesingress.labelselector : Kubernetes Ingress label selector to use. --providers.kubernetesingress.namespaces : Kubernetes namespaces. --providers.kubernetesingress.throttleduration : Ingress refresh throttle duration (Default: 0 ) --providers.kubernetesingress.token : Kubernetes bearer token (not needed for in-cluster client). --providers.marathon : Enable Marathon backend with default settings. (Default: false ) --providers.marathon.basic.httpbasicauthuser : Basic authentication User. --providers.marathon.basic.httpbasicpassword : Basic authentication Password. --providers.marathon.constraints : Constraints is an expression that Traefik matches against the application's labels to determine whether to create any route for that application. --providers.marathon.dcostoken : DCOSToken for DCOS environment, This will override the Authorization header. --providers.marathon.defaultrule : Default rule. (Default: Host(`{{ normalize .Name }}`) ) --providers.marathon.dialertimeout : Set a dialer timeout for Marathon. (Default: 5 ) --providers.marathon.endpoint : Marathon server endpoint. You can also specify multiple endpoint for Marathon. (Default: http://127.0.0.1:8080 ) --providers.marathon.exposedbydefault : Expose Marathon apps by default. (Default: true ) --providers.marathon.forcetaskhostname : Force to use the task's hostname. (Default: false ) --providers.marathon.keepalive : Set a TCP Keep Alive time. (Default: 10 ) --providers.marathon.respectreadinesschecks : Filter out tasks with non-successful readiness checks during deployments. (Default: false ) --providers.marathon.responseheadertimeout : Set a response header timeout for Marathon. (Default: 60 ) --providers.marathon.tls.ca : TLS CA --providers.marathon.tls.caoptional : TLS CA.Optional (Default: false ) --providers.marathon.tls.cert : TLS cert --providers.marathon.tls.insecureskipverify : TLS insecure skip verify (Default: false ) --providers.marathon.tls.key : TLS key --providers.marathon.tlshandshaketimeout : Set a TLS handshake timeout for Marathon. (Default: 5 ) --providers.marathon.trace : Display additional provider logs. (Default: false ) --providers.marathon.watch : Watch provider. (Default: true ) --providers.providersthrottleduration : Backends throttle duration: minimum duration between 2 events from providers before applying a new configuration. It avoids unnecessary reloads if multiples events are sent in a short amount of time. (Default: 0 ) --providers.rancher : Enable Rancher backend with default settings. (Default: false ) --providers.rancher.constraints : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. --providers.rancher.defaultrule : Default rule. (Default: Host(`{{ normalize .Name }}`) ) --providers.rancher.enableservicehealthfilter : Filter services with unhealthy states and inactive states. (Default: true ) --providers.rancher.exposedbydefault : Expose containers by default. (Default: true ) --providers.rancher.intervalpoll : Poll the Rancher metadata service every 'rancher.refreshseconds' (less accurate). (Default: false ) --providers.rancher.prefix : Prefix used for accessing the Rancher metadata service. (Default: latest ) --providers.rancher.refreshseconds : Defines the polling interval in seconds. (Default: 15 ) --providers.rancher.watch : Watch provider. (Default: true ) --providers.rest : Enable Rest backend with default settings. (Default: false ) --providers.rest.insecure : Activate REST Provider directly on the entryPoint named traefik. (Default: false ) --serverstransport.forwardingtimeouts.dialtimeout : The amount of time to wait until a connection to a backend server can be established. If zero, no timeout exists. (Default: 30 ) --serverstransport.forwardingtimeouts.idleconntimeout : The maximum period for which an idle HTTP keep-alive connection will remain open before closing itself (Default: 90 ) --serverstransport.forwardingtimeouts.responseheadertimeout : The amount of time to wait for a server's response headers after fully writing the request (including its body, if any). If zero, no timeout exists. (Default: 0 ) --serverstransport.insecureskipverify : Disable SSL certificate verification. (Default: false ) --serverstransport.maxidleconnsperhost : If non-zero, controls the maximum idle (keep-alive) to keep per-host. If zero, DefaultMaxIdleConnsPerHost is used (Default: 0 ) --serverstransport.rootcas : Add cert file for self-signed certificate. --tracing : OpenTracing configuration. (Default: false ) --tracing.datadog : Settings for Datadog. (Default: false ) --tracing.datadog.bagageprefixheadername : Specifies the header name prefix that will be used to store baggage items in a map. --tracing.datadog.debug : Enable Datadog debug. (Default: false ) --tracing.datadog.globaltag : Key:Value tag to be set on all the spans. --tracing.datadog.localagenthostport : Set datadog-agent's host:port that the reporter will used. (Default: localhost:8126 ) --tracing.datadog.parentidheadername : Specifies the header name that will be used to store the parent ID. --tracing.datadog.prioritysampling : Enable priority sampling. When using distributed tracing, this option must be enabled in order to get all the parts of a distributed trace sampled. (Default: false ) --tracing.datadog.samplingpriorityheadername : Specifies the header name that will be used to store the sampling priority. --tracing.datadog.traceidheadername : Specifies the header name that will be used to store the trace ID. --tracing.haystack : Settings for Haystack. (Default: false ) --tracing.haystack.baggageprefixheadername : Specifies the header name prefix that will be used to store baggage items in a map. --tracing.haystack.globaltag : Key:Value tag to be set on all the spans. --tracing.haystack.localagenthost : Set haystack-agent's host that the reporter will used. (Default: LocalAgentHost ) --tracing.haystack.localagentport : Set haystack-agent's port that the reporter will used. (Default: 35000 ) --tracing.haystack.parentidheadername : Specifies the header name that will be used to store the parent ID. --tracing.haystack.spanidheadername : Specifies the header name that will be used to store the span ID. --tracing.haystack.traceidheadername : Specifies the header name that will be used to store the trace ID. --tracing.instana : Settings for Instana. (Default: false ) --tracing.instana.localagenthost : Set instana-agent's host that the reporter will used. --tracing.instana.localagentport : Set instana-agent's port that the reporter will used. (Default: 42699 ) --tracing.instana.loglevel : Set instana-agent's log level. ('error','warn','info','debug') (Default: info ) --tracing.jaeger : Settings for Jaeger. (Default: false ) --tracing.jaeger.collector.endpoint : Instructs reporter to send spans to jaeger-collector at this URL. --tracing.jaeger.collector.password : Password for basic http authentication when sending spans to jaeger-collector. --tracing.jaeger.collector.user : User for basic http authentication when sending spans to jaeger-collector. --tracing.jaeger.gen128bit : Generate 128 bit span IDs. (Default: false ) --tracing.jaeger.localagenthostport : Set jaeger-agent's host:port that the reporter will used. (Default: 127.0.0.1:6831 ) --tracing.jaeger.propagation : Which propagation format to use (jaeger/b3). (Default: jaeger ) --tracing.jaeger.samplingparam : Set the sampling parameter. (Default: 1.000000 ) --tracing.jaeger.samplingserverurl : Set the sampling server url. (Default: http://localhost:5778/sampling ) --tracing.jaeger.samplingtype : Set the sampling type. (Default: const ) --tracing.jaeger.tracecontextheadername : Set the header to use for the trace-id. (Default: uber-trace-id ) --tracing.servicename : Set the name for this service. (Default: traefik ) --tracing.spannamelimit : Set the maximum character limit for Span names (default 0 = no limit). (Default: 0 ) --tracing.zipkin : Settings for Zipkin. (Default: false ) --tracing.zipkin.httpendpoint : HTTP Endpoint to report traces to. (Default: http://localhost:9411/api/v2/spans ) --tracing.zipkin.id128bit : Use Zipkin 128 bit root span IDs. (Default: true ) --tracing.zipkin.samespan : Use Zipkin SameSpan RPC style traces. (Default: false ) --tracing.zipkin.samplerate : The rate between 0.0 and 1.0 of requests to trace. (Default: 1.000000 )","title":"Static Configuration: CLI"},{"location":"reference/static-configuration/env-ref/","text":"TRAEFIK_ACCESSLOG : Access log settings. (Default: false ) TRAEFIK_ACCESSLOG_BUFFERINGSIZE : Number of access log lines to process in a buffered way. (Default: 0 ) TRAEFIK_ACCESSLOG_FIELDS_DEFAULTMODE : Default mode for fields: keep | drop (Default: keep ) TRAEFIK_ACCESSLOG_FIELDS_HEADERS_DEFAULTMODE : Default mode for fields: keep | drop | redact (Default: drop ) TRAEFIK_ACCESSLOG_FIELDS_HEADERS_NAMES_<NAME> : Override mode for headers TRAEFIK_ACCESSLOG_FIELDS_NAMES_<NAME> : Override mode for fields TRAEFIK_ACCESSLOG_FILEPATH : Access log file path. Stdout is used when omitted or empty. TRAEFIK_ACCESSLOG_FILTERS_MINDURATION : Keep access logs when request took longer than the specified duration. (Default: 0 ) TRAEFIK_ACCESSLOG_FILTERS_RETRYATTEMPTS : Keep access logs when at least one retry happened. (Default: false ) TRAEFIK_ACCESSLOG_FILTERS_STATUSCODES : Keep access logs with status codes in the specified range. TRAEFIK_ACCESSLOG_FORMAT : Access log format: json | common (Default: common ) TRAEFIK_API : Enable api/dashboard. (Default: false ) TRAEFIK_API_DASHBOARD : Activate dashboard. (Default: true ) TRAEFIK_API_DEBUG : Enable additional endpoints for debugging and profiling. (Default: false ) TRAEFIK_API_INSECURE : Activate API directly on the entryPoint named traefik. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME> : Certificates resolvers configuration. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_CASERVER : CA server to use. (Default: https://acme-v02.api.letsencrypt.org/directory ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE : Activate DNS-01 Challenge. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_DELAYBEFORECHECK : Assume DNS propagates after a delay in seconds rather than finding and querying nameservers. (Default: 0 ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_DISABLEPROPAGATIONCHECK : Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. [not recommended] (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_PROVIDER : Use a DNS-01 based challenge provider rather than HTTPS. TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_RESOLVERS : Use following DNS servers to resolve the FQDN authority. TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_EMAIL : Email address used for registration. TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_HTTPCHALLENGE : Activate HTTP-01 Challenge. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_HTTPCHALLENGE_ENTRYPOINT : HTTP challenge EntryPoint TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_KEYTYPE : KeyType used for generating certificate private key. Allow value 'EC256', 'EC384', 'RSA2048', 'RSA4096', 'RSA8192'. (Default: RSA4096 ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_STORAGE : Storage to use. (Default: acme.json ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_TLSCHALLENGE : Activate TLS-ALPN-01 Challenge. (Default: true ) TRAEFIK_ENTRYPOINTS_<NAME> : Entry points definition. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_ADDRESS : Entry point address. TRAEFIK_ENTRYPOINTS_<NAME>_FORWARDEDHEADERS_INSECURE : Trust all forwarded headers. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_FORWARDEDHEADERS_TRUSTEDIPS : Trust only forwarded headers from selected IPs. TRAEFIK_ENTRYPOINTS_<NAME>_PROXYPROTOCOL : Proxy-Protocol configuration. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_PROXYPROTOCOL_INSECURE : Trust all. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_PROXYPROTOCOL_TRUSTEDIPS : Trust only selected IPs. TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_LIFECYCLE_GRACETIMEOUT : Duration to give active requests a chance to finish before Traefik stops. (Default: 10 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_LIFECYCLE_REQUESTACCEPTGRACETIMEOUT : Duration to keep accepting requests before Traefik initiates the graceful shutdown procedure. (Default: 0 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_IDLETIMEOUT : IdleTimeout is the maximum amount duration an idle (keep-alive) connection will remain idle before closing itself. If zero, no timeout is set. (Default: 180 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_READTIMEOUT : ReadTimeout is the maximum duration for reading the entire request, including the body. If zero, no timeout is set. (Default: 0 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_WRITETIMEOUT : WriteTimeout is the maximum duration before timing out writes of the response. If zero, no timeout is set. (Default: 0 ) TRAEFIK_GLOBAL_CHECKNEWVERSION : Periodically check if a new version has been released. (Default: false ) TRAEFIK_GLOBAL_SENDANONYMOUSUSAGE : Periodically send anonymous usage statistics. If the option is not specified, it will be enabled by default. (Default: false ) TRAEFIK_HOSTRESOLVER : Enable CNAME Flattening. (Default: false ) TRAEFIK_HOSTRESOLVER_CNAMEFLATTENING : A flag to enable/disable CNAME flattening (Default: false ) TRAEFIK_HOSTRESOLVER_RESOLVCONFIG : resolv.conf used for DNS resolving (Default: /etc/resolv.conf ) TRAEFIK_HOSTRESOLVER_RESOLVDEPTH : The maximal depth of DNS recursive resolving (Default: 5 ) TRAEFIK_LOG : Traefik log settings. (Default: false ) TRAEFIK_LOG_FILEPATH : Traefik log file path. Stdout is used when omitted or empty. TRAEFIK_LOG_FORMAT : Traefik log format: json | common (Default: common ) TRAEFIK_LOG_LEVEL : Log level set to traefik logs. (Default: ERROR ) TRAEFIK_METRICS_DATADOG : Datadog metrics exporter type. (Default: false ) TRAEFIK_METRICS_DATADOG_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_DATADOG_ADDRESS : Datadog's address. (Default: localhost:8125 ) TRAEFIK_METRICS_DATADOG_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_DATADOG_PUSHINTERVAL : Datadog push interval. (Default: 10 ) TRAEFIK_METRICS_INFLUXDB : InfluxDB metrics exporter type. (Default: false ) TRAEFIK_METRICS_INFLUXDB_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_INFLUXDB_ADDRESS : InfluxDB address. (Default: localhost:8089 ) TRAEFIK_METRICS_INFLUXDB_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_INFLUXDB_DATABASE : InfluxDB database used when protocol is http. TRAEFIK_METRICS_INFLUXDB_PASSWORD : InfluxDB password (only with http). TRAEFIK_METRICS_INFLUXDB_PROTOCOL : InfluxDB address protocol (udp or http). (Default: udp ) TRAEFIK_METRICS_INFLUXDB_PUSHINTERVAL : InfluxDB push interval. (Default: 10 ) TRAEFIK_METRICS_INFLUXDB_RETENTIONPOLICY : InfluxDB retention policy used when protocol is http. TRAEFIK_METRICS_INFLUXDB_USERNAME : InfluxDB username (only with http). TRAEFIK_METRICS_PROMETHEUS : Prometheus metrics exporter type. (Default: false ) TRAEFIK_METRICS_PROMETHEUS_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_PROMETHEUS_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_PROMETHEUS_BUCKETS : Buckets for latency metrics. (Default: 0.100000, 0.300000, 1.200000, 5.000000 ) TRAEFIK_METRICS_PROMETHEUS_ENTRYPOINT : EntryPoint (Default: traefik ) TRAEFIK_METRICS_STATSD : StatsD metrics exporter type. (Default: false ) TRAEFIK_METRICS_STATSD_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_STATSD_ADDRESS : StatsD address. (Default: localhost:8125 ) TRAEFIK_METRICS_STATSD_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_STATSD_PUSHINTERVAL : StatsD push interval. (Default: 10 ) TRAEFIK_PING : Enable ping. (Default: false ) TRAEFIK_PING_ENTRYPOINT : EntryPoint (Default: traefik ) TRAEFIK_PROVIDERS_DOCKER : Enable Docker backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_DOCKER_CONSTRAINTS : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. TRAEFIK_PROVIDERS_DOCKER_DEFAULTRULE : Default rule. (Default: Host(`{{ normalize .Name }}`) ) TRAEFIK_PROVIDERS_DOCKER_ENDPOINT : Docker server endpoint. Can be a tcp or a unix socket endpoint. (Default: unix:///var/run/docker.sock ) TRAEFIK_PROVIDERS_DOCKER_EXPOSEDBYDEFAULT : Expose containers by default. (Default: true ) TRAEFIK_PROVIDERS_DOCKER_NETWORK : Default Docker network used. TRAEFIK_PROVIDERS_DOCKER_SWARMMODE : Use Docker on Swarm Mode. (Default: false ) TRAEFIK_PROVIDERS_DOCKER_SWARMMODEREFRESHSECONDS : Polling interval for swarm mode. (Default: 15 ) TRAEFIK_PROVIDERS_DOCKER_TLS_CA : TLS CA TRAEFIK_PROVIDERS_DOCKER_TLS_CAOPTIONAL : TLS CA.Optional (Default: false ) TRAEFIK_PROVIDERS_DOCKER_TLS_CERT : TLS cert TRAEFIK_PROVIDERS_DOCKER_TLS_INSECURESKIPVERIFY : TLS insecure skip verify (Default: false ) TRAEFIK_PROVIDERS_DOCKER_TLS_KEY : TLS key TRAEFIK_PROVIDERS_DOCKER_USEBINDPORTIP : Use the ip address from the bound port, rather than from the inner network. (Default: false ) TRAEFIK_PROVIDERS_DOCKER_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_FILE_DEBUGLOGGENERATEDTEMPLATE : Enable debug logging of generated configuration template. (Default: false ) TRAEFIK_PROVIDERS_FILE_DIRECTORY : Load dynamic configuration from one or more .toml or .yml files in a directory. TRAEFIK_PROVIDERS_FILE_FILENAME : Load dynamic configuration from a file. TRAEFIK_PROVIDERS_FILE_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_KUBERNETESCRD : Enable Kubernetes backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESCRD_CERTAUTHFILEPATH : Kubernetes certificate authority file path (not needed for in-cluster client). TRAEFIK_PROVIDERS_KUBERNETESCRD_DISABLEPASSHOSTHEADERS : Kubernetes disable PassHost Headers. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESCRD_ENDPOINT : Kubernetes server endpoint (required for external cluster client). TRAEFIK_PROVIDERS_KUBERNETESCRD_INGRESSCLASS : Value of kubernetes.io/ingress.class annotation to watch for. TRAEFIK_PROVIDERS_KUBERNETESCRD_LABELSELECTOR : Kubernetes label selector to use. TRAEFIK_PROVIDERS_KUBERNETESCRD_NAMESPACES : Kubernetes namespaces. TRAEFIK_PROVIDERS_KUBERNETESCRD_THROTTLEDURATION : Ingress refresh throttle duration (Default: 0 ) TRAEFIK_PROVIDERS_KUBERNETESCRD_TOKEN : Kubernetes bearer token (not needed for in-cluster client). TRAEFIK_PROVIDERS_KUBERNETESINGRESS : Enable Kubernetes backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESINGRESS_CERTAUTHFILEPATH : Kubernetes certificate authority file path (not needed for in-cluster client). TRAEFIK_PROVIDERS_KUBERNETESINGRESS_DISABLEPASSHOSTHEADERS : Kubernetes disable PassHost Headers. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESINGRESS_ENDPOINT : Kubernetes server endpoint (required for external cluster client). TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSCLASS : Value of kubernetes.io/ingress.class annotation to watch for. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_HOSTNAME : Hostname used for Kubernetes Ingress endpoints. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_IP : IP used for Kubernetes Ingress endpoints. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_PUBLISHEDSERVICE : Published Kubernetes Service to copy status from. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_LABELSELECTOR : Kubernetes Ingress label selector to use. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_NAMESPACES : Kubernetes namespaces. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_THROTTLEDURATION : Ingress refresh throttle duration (Default: 0 ) TRAEFIK_PROVIDERS_KUBERNETESINGRESS_TOKEN : Kubernetes bearer token (not needed for in-cluster client). TRAEFIK_PROVIDERS_MARATHON : Enable Marathon backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_BASIC_HTTPBASICAUTHUSER : Basic authentication User. TRAEFIK_PROVIDERS_MARATHON_BASIC_HTTPBASICPASSWORD : Basic authentication Password. TRAEFIK_PROVIDERS_MARATHON_CONSTRAINTS : Constraints is an expression that Traefik matches against the application's labels to determine whether to create any route for that application. TRAEFIK_PROVIDERS_MARATHON_DCOSTOKEN : DCOSToken for DCOS environment, This will override the Authorization header. TRAEFIK_PROVIDERS_MARATHON_DEFAULTRULE : Default rule. (Default: Host(`{{ normalize .Name }}`) ) TRAEFIK_PROVIDERS_MARATHON_DIALERTIMEOUT : Set a dialer timeout for Marathon. (Default: 5 ) TRAEFIK_PROVIDERS_MARATHON_ENDPOINT : Marathon server endpoint. You can also specify multiple endpoint for Marathon. (Default: http://127.0.0.1:8080 ) TRAEFIK_PROVIDERS_MARATHON_EXPOSEDBYDEFAULT : Expose Marathon apps by default. (Default: true ) TRAEFIK_PROVIDERS_MARATHON_FORCETASKHOSTNAME : Force to use the task's hostname. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_KEEPALIVE : Set a TCP Keep Alive time. (Default: 10 ) TRAEFIK_PROVIDERS_MARATHON_RESPECTREADINESSCHECKS : Filter out tasks with non-successful readiness checks during deployments. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_RESPONSEHEADERTIMEOUT : Set a response header timeout for Marathon. (Default: 60 ) TRAEFIK_PROVIDERS_MARATHON_TLSHANDSHAKETIMEOUT : Set a TLS handshake timeout for Marathon. (Default: 5 ) TRAEFIK_PROVIDERS_MARATHON_TLS_CA : TLS CA TRAEFIK_PROVIDERS_MARATHON_TLS_CAOPTIONAL : TLS CA.Optional (Default: false ) TRAEFIK_PROVIDERS_MARATHON_TLS_CERT : TLS cert TRAEFIK_PROVIDERS_MARATHON_TLS_INSECURESKIPVERIFY : TLS insecure skip verify (Default: false ) TRAEFIK_PROVIDERS_MARATHON_TLS_KEY : TLS key TRAEFIK_PROVIDERS_MARATHON_TRACE : Display additional provider logs. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_PROVIDERSTHROTTLEDURATION : Backends throttle duration: minimum duration between 2 events from providers before applying a new configuration. It avoids unnecessary reloads if multiples events are sent in a short amount of time. (Default: 0 ) TRAEFIK_PROVIDERS_RANCHER : Enable Rancher backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_RANCHER_CONSTRAINTS : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. TRAEFIK_PROVIDERS_RANCHER_DEFAULTRULE : Default rule. (Default: Host(`{{ normalize .Name }}`) ) TRAEFIK_PROVIDERS_RANCHER_ENABLESERVICEHEALTHFILTER : Filter services with unhealthy states and inactive states. (Default: true ) TRAEFIK_PROVIDERS_RANCHER_EXPOSEDBYDEFAULT : Expose containers by default. (Default: true ) TRAEFIK_PROVIDERS_RANCHER_INTERVALPOLL : Poll the Rancher metadata service every 'rancher.refreshseconds' (less accurate). (Default: false ) TRAEFIK_PROVIDERS_RANCHER_PREFIX : Prefix used for accessing the Rancher metadata service. (Default: latest ) TRAEFIK_PROVIDERS_RANCHER_REFRESHSECONDS : Defines the polling interval in seconds. (Default: 15 ) TRAEFIK_PROVIDERS_RANCHER_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_REST : Enable Rest backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_REST_INSECURE : Activate REST Provider directly on the entryPoint named traefik. (Default: false ) TRAEFIK_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_DIALTIMEOUT : The amount of time to wait until a connection to a backend server can be established. If zero, no timeout exists. (Default: 30 ) TRAEFIK_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_IDLECONNTIMEOUT : The maximum period for which an idle HTTP keep-alive connection will remain open before closing itself (Default: 90 ) TRAEFIK_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_RESPONSEHEADERTIMEOUT : The amount of time to wait for a server's response headers after fully writing the request (including its body, if any). If zero, no timeout exists. (Default: 0 ) TRAEFIK_SERVERSTRANSPORT_INSECURESKIPVERIFY : Disable SSL certificate verification. (Default: false ) TRAEFIK_SERVERSTRANSPORT_MAXIDLECONNSPERHOST : If non-zero, controls the maximum idle (keep-alive) to keep per-host. If zero, DefaultMaxIdleConnsPerHost is used (Default: 0 ) TRAEFIK_SERVERSTRANSPORT_ROOTCAS : Add cert file for self-signed certificate. TRAEFIK_TRACING : OpenTracing configuration. (Default: false ) TRAEFIK_TRACING_DATADOG : Settings for Datadog. (Default: false ) TRAEFIK_TRACING_DATADOG_BAGAGEPREFIXHEADERNAME : Specifies the header name prefix that will be used to store baggage items in a map. TRAEFIK_TRACING_DATADOG_DEBUG : Enable Datadog debug. (Default: false ) TRAEFIK_TRACING_DATADOG_GLOBALTAG : Key:Value tag to be set on all the spans. TRAEFIK_TRACING_DATADOG_LOCALAGENTHOSTPORT : Set datadog-agent's host:port that the reporter will used. (Default: localhost:8126 ) TRAEFIK_TRACING_DATADOG_PARENTIDHEADERNAME : Specifies the header name that will be used to store the parent ID. TRAEFIK_TRACING_DATADOG_PRIORITYSAMPLING : Enable priority sampling. When using distributed tracing, this option must be enabled in order to get all the parts of a distributed trace sampled. (Default: false ) TRAEFIK_TRACING_DATADOG_SAMPLINGPRIORITYHEADERNAME : Specifies the header name that will be used to store the sampling priority. TRAEFIK_TRACING_DATADOG_TRACEIDHEADERNAME : Specifies the header name that will be used to store the trace ID. TRAEFIK_TRACING_HAYSTACK : Settings for Haystack. (Default: false ) TRAEFIK_TRACING_HAYSTACK_BAGGAGEPREFIXHEADERNAME : Specifies the header name prefix that will be used to store baggage items in a map. TRAEFIK_TRACING_HAYSTACK_GLOBALTAG : Key:Value tag to be set on all the spans. TRAEFIK_TRACING_HAYSTACK_LOCALAGENTHOST : Set haystack-agent's host that the reporter will used. (Default: LocalAgentHost ) TRAEFIK_TRACING_HAYSTACK_LOCALAGENTPORT : Set haystack-agent's port that the reporter will used. (Default: 35000 ) TRAEFIK_TRACING_HAYSTACK_PARENTIDHEADERNAME : Specifies the header name that will be used to store the parent ID. TRAEFIK_TRACING_HAYSTACK_SPANIDHEADERNAME : Specifies the header name that will be used to store the span ID. TRAEFIK_TRACING_HAYSTACK_TRACEIDHEADERNAME : Specifies the header name that will be used to store the trace ID. TRAEFIK_TRACING_INSTANA : Settings for Instana. (Default: false ) TRAEFIK_TRACING_INSTANA_LOCALAGENTHOST : Set instana-agent's host that the reporter will used. TRAEFIK_TRACING_INSTANA_LOCALAGENTPORT : Set instana-agent's port that the reporter will used. (Default: 42699 ) TRAEFIK_TRACING_INSTANA_LOGLEVEL : Set instana-agent's log level. ('error','warn','info','debug') (Default: info ) TRAEFIK_TRACING_JAEGER : Settings for Jaeger. (Default: false ) TRAEFIK_TRACING_JAEGER_COLLECTOR_ENDPOINT : Instructs reporter to send spans to jaeger-collector at this URL. TRAEFIK_TRACING_JAEGER_COLLECTOR_PASSWORD : Password for basic http authentication when sending spans to jaeger-collector. TRAEFIK_TRACING_JAEGER_COLLECTOR_USER : User for basic http authentication when sending spans to jaeger-collector. TRAEFIK_TRACING_JAEGER_GEN128BIT : Generate 128 bit span IDs. (Default: false ) TRAEFIK_TRACING_JAEGER_LOCALAGENTHOSTPORT : Set jaeger-agent's host:port that the reporter will used. (Default: 127.0.0.1:6831 ) TRAEFIK_TRACING_JAEGER_PROPAGATION : Which propagation format to use (jaeger/b3). (Default: jaeger ) TRAEFIK_TRACING_JAEGER_SAMPLINGPARAM : Set the sampling parameter. (Default: 1.000000 ) TRAEFIK_TRACING_JAEGER_SAMPLINGSERVERURL : Set the sampling server url. (Default: http://localhost:5778/sampling ) TRAEFIK_TRACING_JAEGER_SAMPLINGTYPE : Set the sampling type. (Default: const ) TRAEFIK_TRACING_JAEGER_TRACECONTEXTHEADERNAME : Set the header to use for the trace-id. (Default: uber-trace-id ) TRAEFIK_TRACING_SERVICENAME : Set the name for this service. (Default: traefik ) TRAEFIK_TRACING_SPANNAMELIMIT : Set the maximum character limit for Span names (default 0 = no limit). (Default: 0 ) TRAEFIK_TRACING_ZIPKIN : Settings for Zipkin. (Default: false ) TRAEFIK_TRACING_ZIPKIN_HTTPENDPOINT : HTTP Endpoint to report traces to. (Default: http://localhost:9411/api/v2/spans ) TRAEFIK_TRACING_ZIPKIN_ID128BIT : Use Zipkin 128 bit root span IDs. (Default: true ) TRAEFIK_TRACING_ZIPKIN_SAMESPAN : Use Zipkin SameSpan RPC style traces. (Default: false ) TRAEFIK_TRACING_ZIPKIN_SAMPLERATE : The rate between 0.0 and 1.0 of requests to trace. (Default: 1.000000 )","title":"Env ref"},{"location":"reference/static-configuration/env/","text":"Static Configuration: Environment variables \u00b6 TRAEFIK_ACCESSLOG : Access log settings. (Default: false ) TRAEFIK_ACCESSLOG_BUFFERINGSIZE : Number of access log lines to process in a buffered way. (Default: 0 ) TRAEFIK_ACCESSLOG_FIELDS_DEFAULTMODE : Default mode for fields: keep | drop (Default: keep ) TRAEFIK_ACCESSLOG_FIELDS_HEADERS_DEFAULTMODE : Default mode for fields: keep | drop | redact (Default: drop ) TRAEFIK_ACCESSLOG_FIELDS_HEADERS_NAMES_<NAME> : Override mode for headers TRAEFIK_ACCESSLOG_FIELDS_NAMES_<NAME> : Override mode for fields TRAEFIK_ACCESSLOG_FILEPATH : Access log file path. Stdout is used when omitted or empty. TRAEFIK_ACCESSLOG_FILTERS_MINDURATION : Keep access logs when request took longer than the specified duration. (Default: 0 ) TRAEFIK_ACCESSLOG_FILTERS_RETRYATTEMPTS : Keep access logs when at least one retry happened. (Default: false ) TRAEFIK_ACCESSLOG_FILTERS_STATUSCODES : Keep access logs with status codes in the specified range. TRAEFIK_ACCESSLOG_FORMAT : Access log format: json | common (Default: common ) TRAEFIK_API : Enable api/dashboard. (Default: false ) TRAEFIK_API_DASHBOARD : Activate dashboard. (Default: true ) TRAEFIK_API_DEBUG : Enable additional endpoints for debugging and profiling. (Default: false ) TRAEFIK_API_INSECURE : Activate API directly on the entryPoint named traefik. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME> : Certificates resolvers configuration. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_CASERVER : CA server to use. (Default: https://acme-v02.api.letsencrypt.org/directory ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE : Activate DNS-01 Challenge. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_DELAYBEFORECHECK : Assume DNS propagates after a delay in seconds rather than finding and querying nameservers. (Default: 0 ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_DISABLEPROPAGATIONCHECK : Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. [not recommended] (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_PROVIDER : Use a DNS-01 based challenge provider rather than HTTPS. TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_RESOLVERS : Use following DNS servers to resolve the FQDN authority. TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_EMAIL : Email address used for registration. TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_HTTPCHALLENGE : Activate HTTP-01 Challenge. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_HTTPCHALLENGE_ENTRYPOINT : HTTP challenge EntryPoint TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_KEYTYPE : KeyType used for generating certificate private key. Allow value 'EC256', 'EC384', 'RSA2048', 'RSA4096', 'RSA8192'. (Default: RSA4096 ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_STORAGE : Storage to use. (Default: acme.json ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_TLSCHALLENGE : Activate TLS-ALPN-01 Challenge. (Default: true ) TRAEFIK_ENTRYPOINTS_<NAME> : Entry points definition. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_ADDRESS : Entry point address. TRAEFIK_ENTRYPOINTS_<NAME>_FORWARDEDHEADERS_INSECURE : Trust all forwarded headers. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_FORWARDEDHEADERS_TRUSTEDIPS : Trust only forwarded headers from selected IPs. TRAEFIK_ENTRYPOINTS_<NAME>_PROXYPROTOCOL : Proxy-Protocol configuration. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_PROXYPROTOCOL_INSECURE : Trust all. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_PROXYPROTOCOL_TRUSTEDIPS : Trust only selected IPs. TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_LIFECYCLE_GRACETIMEOUT : Duration to give active requests a chance to finish before Traefik stops. (Default: 10 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_LIFECYCLE_REQUESTACCEPTGRACETIMEOUT : Duration to keep accepting requests before Traefik initiates the graceful shutdown procedure. (Default: 0 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_IDLETIMEOUT : IdleTimeout is the maximum amount duration an idle (keep-alive) connection will remain idle before closing itself. If zero, no timeout is set. (Default: 180 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_READTIMEOUT : ReadTimeout is the maximum duration for reading the entire request, including the body. If zero, no timeout is set. (Default: 0 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_WRITETIMEOUT : WriteTimeout is the maximum duration before timing out writes of the response. If zero, no timeout is set. (Default: 0 ) TRAEFIK_GLOBAL_CHECKNEWVERSION : Periodically check if a new version has been released. (Default: false ) TRAEFIK_GLOBAL_SENDANONYMOUSUSAGE : Periodically send anonymous usage statistics. If the option is not specified, it will be enabled by default. (Default: false ) TRAEFIK_HOSTRESOLVER : Enable CNAME Flattening. (Default: false ) TRAEFIK_HOSTRESOLVER_CNAMEFLATTENING : A flag to enable/disable CNAME flattening (Default: false ) TRAEFIK_HOSTRESOLVER_RESOLVCONFIG : resolv.conf used for DNS resolving (Default: /etc/resolv.conf ) TRAEFIK_HOSTRESOLVER_RESOLVDEPTH : The maximal depth of DNS recursive resolving (Default: 5 ) TRAEFIK_LOG : Traefik log settings. (Default: false ) TRAEFIK_LOG_FILEPATH : Traefik log file path. Stdout is used when omitted or empty. TRAEFIK_LOG_FORMAT : Traefik log format: json | common (Default: common ) TRAEFIK_LOG_LEVEL : Log level set to traefik logs. (Default: ERROR ) TRAEFIK_METRICS_DATADOG : Datadog metrics exporter type. (Default: false ) TRAEFIK_METRICS_DATADOG_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_DATADOG_ADDRESS : Datadog's address. (Default: localhost:8125 ) TRAEFIK_METRICS_DATADOG_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_DATADOG_PUSHINTERVAL : Datadog push interval. (Default: 10 ) TRAEFIK_METRICS_INFLUXDB : InfluxDB metrics exporter type. (Default: false ) TRAEFIK_METRICS_INFLUXDB_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_INFLUXDB_ADDRESS : InfluxDB address. (Default: localhost:8089 ) TRAEFIK_METRICS_INFLUXDB_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_INFLUXDB_DATABASE : InfluxDB database used when protocol is http. TRAEFIK_METRICS_INFLUXDB_PASSWORD : InfluxDB password (only with http). TRAEFIK_METRICS_INFLUXDB_PROTOCOL : InfluxDB address protocol (udp or http). (Default: udp ) TRAEFIK_METRICS_INFLUXDB_PUSHINTERVAL : InfluxDB push interval. (Default: 10 ) TRAEFIK_METRICS_INFLUXDB_RETENTIONPOLICY : InfluxDB retention policy used when protocol is http. TRAEFIK_METRICS_INFLUXDB_USERNAME : InfluxDB username (only with http). TRAEFIK_METRICS_PROMETHEUS : Prometheus metrics exporter type. (Default: false ) TRAEFIK_METRICS_PROMETHEUS_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_PROMETHEUS_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_PROMETHEUS_BUCKETS : Buckets for latency metrics. (Default: 0.100000, 0.300000, 1.200000, 5.000000 ) TRAEFIK_METRICS_PROMETHEUS_ENTRYPOINT : EntryPoint (Default: traefik ) TRAEFIK_METRICS_STATSD : StatsD metrics exporter type. (Default: false ) TRAEFIK_METRICS_STATSD_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_STATSD_ADDRESS : StatsD address. (Default: localhost:8125 ) TRAEFIK_METRICS_STATSD_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_STATSD_PUSHINTERVAL : StatsD push interval. (Default: 10 ) TRAEFIK_PING : Enable ping. (Default: false ) TRAEFIK_PING_ENTRYPOINT : EntryPoint (Default: traefik ) TRAEFIK_PROVIDERS_DOCKER : Enable Docker backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_DOCKER_CONSTRAINTS : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. TRAEFIK_PROVIDERS_DOCKER_DEFAULTRULE : Default rule. (Default: Host(`{{ normalize .Name }}`) ) TRAEFIK_PROVIDERS_DOCKER_ENDPOINT : Docker server endpoint. Can be a tcp or a unix socket endpoint. (Default: unix:///var/run/docker.sock ) TRAEFIK_PROVIDERS_DOCKER_EXPOSEDBYDEFAULT : Expose containers by default. (Default: true ) TRAEFIK_PROVIDERS_DOCKER_NETWORK : Default Docker network used. TRAEFIK_PROVIDERS_DOCKER_SWARMMODE : Use Docker on Swarm Mode. (Default: false ) TRAEFIK_PROVIDERS_DOCKER_SWARMMODEREFRESHSECONDS : Polling interval for swarm mode. (Default: 15 ) TRAEFIK_PROVIDERS_DOCKER_TLS_CA : TLS CA TRAEFIK_PROVIDERS_DOCKER_TLS_CAOPTIONAL : TLS CA.Optional (Default: false ) TRAEFIK_PROVIDERS_DOCKER_TLS_CERT : TLS cert TRAEFIK_PROVIDERS_DOCKER_TLS_INSECURESKIPVERIFY : TLS insecure skip verify (Default: false ) TRAEFIK_PROVIDERS_DOCKER_TLS_KEY : TLS key TRAEFIK_PROVIDERS_DOCKER_USEBINDPORTIP : Use the ip address from the bound port, rather than from the inner network. (Default: false ) TRAEFIK_PROVIDERS_DOCKER_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_FILE_DEBUGLOGGENERATEDTEMPLATE : Enable debug logging of generated configuration template. (Default: false ) TRAEFIK_PROVIDERS_FILE_DIRECTORY : Load dynamic configuration from one or more .toml or .yml files in a directory. TRAEFIK_PROVIDERS_FILE_FILENAME : Load dynamic configuration from a file. TRAEFIK_PROVIDERS_FILE_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_KUBERNETESCRD : Enable Kubernetes backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESCRD_CERTAUTHFILEPATH : Kubernetes certificate authority file path (not needed for in-cluster client). TRAEFIK_PROVIDERS_KUBERNETESCRD_DISABLEPASSHOSTHEADERS : Kubernetes disable PassHost Headers. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESCRD_ENDPOINT : Kubernetes server endpoint (required for external cluster client). TRAEFIK_PROVIDERS_KUBERNETESCRD_INGRESSCLASS : Value of kubernetes.io/ingress.class annotation to watch for. TRAEFIK_PROVIDERS_KUBERNETESCRD_LABELSELECTOR : Kubernetes label selector to use. TRAEFIK_PROVIDERS_KUBERNETESCRD_NAMESPACES : Kubernetes namespaces. TRAEFIK_PROVIDERS_KUBERNETESCRD_THROTTLEDURATION : Ingress refresh throttle duration (Default: 0 ) TRAEFIK_PROVIDERS_KUBERNETESCRD_TOKEN : Kubernetes bearer token (not needed for in-cluster client). TRAEFIK_PROVIDERS_KUBERNETESINGRESS : Enable Kubernetes backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESINGRESS_CERTAUTHFILEPATH : Kubernetes certificate authority file path (not needed for in-cluster client). TRAEFIK_PROVIDERS_KUBERNETESINGRESS_DISABLEPASSHOSTHEADERS : Kubernetes disable PassHost Headers. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESINGRESS_ENDPOINT : Kubernetes server endpoint (required for external cluster client). TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSCLASS : Value of kubernetes.io/ingress.class annotation to watch for. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_HOSTNAME : Hostname used for Kubernetes Ingress endpoints. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_IP : IP used for Kubernetes Ingress endpoints. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_PUBLISHEDSERVICE : Published Kubernetes Service to copy status from. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_LABELSELECTOR : Kubernetes Ingress label selector to use. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_NAMESPACES : Kubernetes namespaces. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_THROTTLEDURATION : Ingress refresh throttle duration (Default: 0 ) TRAEFIK_PROVIDERS_KUBERNETESINGRESS_TOKEN : Kubernetes bearer token (not needed for in-cluster client). TRAEFIK_PROVIDERS_MARATHON : Enable Marathon backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_BASIC_HTTPBASICAUTHUSER : Basic authentication User. TRAEFIK_PROVIDERS_MARATHON_BASIC_HTTPBASICPASSWORD : Basic authentication Password. TRAEFIK_PROVIDERS_MARATHON_CONSTRAINTS : Constraints is an expression that Traefik matches against the application's labels to determine whether to create any route for that application. TRAEFIK_PROVIDERS_MARATHON_DCOSTOKEN : DCOSToken for DCOS environment, This will override the Authorization header. TRAEFIK_PROVIDERS_MARATHON_DEFAULTRULE : Default rule. (Default: Host(`{{ normalize .Name }}`) ) TRAEFIK_PROVIDERS_MARATHON_DIALERTIMEOUT : Set a dialer timeout for Marathon. (Default: 5 ) TRAEFIK_PROVIDERS_MARATHON_ENDPOINT : Marathon server endpoint. You can also specify multiple endpoint for Marathon. (Default: http://127.0.0.1:8080 ) TRAEFIK_PROVIDERS_MARATHON_EXPOSEDBYDEFAULT : Expose Marathon apps by default. (Default: true ) TRAEFIK_PROVIDERS_MARATHON_FORCETASKHOSTNAME : Force to use the task's hostname. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_KEEPALIVE : Set a TCP Keep Alive time. (Default: 10 ) TRAEFIK_PROVIDERS_MARATHON_RESPECTREADINESSCHECKS : Filter out tasks with non-successful readiness checks during deployments. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_RESPONSEHEADERTIMEOUT : Set a response header timeout for Marathon. (Default: 60 ) TRAEFIK_PROVIDERS_MARATHON_TLSHANDSHAKETIMEOUT : Set a TLS handshake timeout for Marathon. (Default: 5 ) TRAEFIK_PROVIDERS_MARATHON_TLS_CA : TLS CA TRAEFIK_PROVIDERS_MARATHON_TLS_CAOPTIONAL : TLS CA.Optional (Default: false ) TRAEFIK_PROVIDERS_MARATHON_TLS_CERT : TLS cert TRAEFIK_PROVIDERS_MARATHON_TLS_INSECURESKIPVERIFY : TLS insecure skip verify (Default: false ) TRAEFIK_PROVIDERS_MARATHON_TLS_KEY : TLS key TRAEFIK_PROVIDERS_MARATHON_TRACE : Display additional provider logs. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_PROVIDERSTHROTTLEDURATION : Backends throttle duration: minimum duration between 2 events from providers before applying a new configuration. It avoids unnecessary reloads if multiples events are sent in a short amount of time. (Default: 0 ) TRAEFIK_PROVIDERS_RANCHER : Enable Rancher backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_RANCHER_CONSTRAINTS : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. TRAEFIK_PROVIDERS_RANCHER_DEFAULTRULE : Default rule. (Default: Host(`{{ normalize .Name }}`) ) TRAEFIK_PROVIDERS_RANCHER_ENABLESERVICEHEALTHFILTER : Filter services with unhealthy states and inactive states. (Default: true ) TRAEFIK_PROVIDERS_RANCHER_EXPOSEDBYDEFAULT : Expose containers by default. (Default: true ) TRAEFIK_PROVIDERS_RANCHER_INTERVALPOLL : Poll the Rancher metadata service every 'rancher.refreshseconds' (less accurate). (Default: false ) TRAEFIK_PROVIDERS_RANCHER_PREFIX : Prefix used for accessing the Rancher metadata service. (Default: latest ) TRAEFIK_PROVIDERS_RANCHER_REFRESHSECONDS : Defines the polling interval in seconds. (Default: 15 ) TRAEFIK_PROVIDERS_RANCHER_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_REST : Enable Rest backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_REST_INSECURE : Activate REST Provider directly on the entryPoint named traefik. (Default: false ) TRAEFIK_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_DIALTIMEOUT : The amount of time to wait until a connection to a backend server can be established. If zero, no timeout exists. (Default: 30 ) TRAEFIK_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_IDLECONNTIMEOUT : The maximum period for which an idle HTTP keep-alive connection will remain open before closing itself (Default: 90 ) TRAEFIK_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_RESPONSEHEADERTIMEOUT : The amount of time to wait for a server's response headers after fully writing the request (including its body, if any). If zero, no timeout exists. (Default: 0 ) TRAEFIK_SERVERSTRANSPORT_INSECURESKIPVERIFY : Disable SSL certificate verification. (Default: false ) TRAEFIK_SERVERSTRANSPORT_MAXIDLECONNSPERHOST : If non-zero, controls the maximum idle (keep-alive) to keep per-host. If zero, DefaultMaxIdleConnsPerHost is used (Default: 0 ) TRAEFIK_SERVERSTRANSPORT_ROOTCAS : Add cert file for self-signed certificate. TRAEFIK_TRACING : OpenTracing configuration. (Default: false ) TRAEFIK_TRACING_DATADOG : Settings for Datadog. (Default: false ) TRAEFIK_TRACING_DATADOG_BAGAGEPREFIXHEADERNAME : Specifies the header name prefix that will be used to store baggage items in a map. TRAEFIK_TRACING_DATADOG_DEBUG : Enable Datadog debug. (Default: false ) TRAEFIK_TRACING_DATADOG_GLOBALTAG : Key:Value tag to be set on all the spans. TRAEFIK_TRACING_DATADOG_LOCALAGENTHOSTPORT : Set datadog-agent's host:port that the reporter will used. (Default: localhost:8126 ) TRAEFIK_TRACING_DATADOG_PARENTIDHEADERNAME : Specifies the header name that will be used to store the parent ID. TRAEFIK_TRACING_DATADOG_PRIORITYSAMPLING : Enable priority sampling. When using distributed tracing, this option must be enabled in order to get all the parts of a distributed trace sampled. (Default: false ) TRAEFIK_TRACING_DATADOG_SAMPLINGPRIORITYHEADERNAME : Specifies the header name that will be used to store the sampling priority. TRAEFIK_TRACING_DATADOG_TRACEIDHEADERNAME : Specifies the header name that will be used to store the trace ID. TRAEFIK_TRACING_HAYSTACK : Settings for Haystack. (Default: false ) TRAEFIK_TRACING_HAYSTACK_BAGGAGEPREFIXHEADERNAME : Specifies the header name prefix that will be used to store baggage items in a map. TRAEFIK_TRACING_HAYSTACK_GLOBALTAG : Key:Value tag to be set on all the spans. TRAEFIK_TRACING_HAYSTACK_LOCALAGENTHOST : Set haystack-agent's host that the reporter will used. (Default: LocalAgentHost ) TRAEFIK_TRACING_HAYSTACK_LOCALAGENTPORT : Set haystack-agent's port that the reporter will used. (Default: 35000 ) TRAEFIK_TRACING_HAYSTACK_PARENTIDHEADERNAME : Specifies the header name that will be used to store the parent ID. TRAEFIK_TRACING_HAYSTACK_SPANIDHEADERNAME : Specifies the header name that will be used to store the span ID. TRAEFIK_TRACING_HAYSTACK_TRACEIDHEADERNAME : Specifies the header name that will be used to store the trace ID. TRAEFIK_TRACING_INSTANA : Settings for Instana. (Default: false ) TRAEFIK_TRACING_INSTANA_LOCALAGENTHOST : Set instana-agent's host that the reporter will used. TRAEFIK_TRACING_INSTANA_LOCALAGENTPORT : Set instana-agent's port that the reporter will used. (Default: 42699 ) TRAEFIK_TRACING_INSTANA_LOGLEVEL : Set instana-agent's log level. ('error','warn','info','debug') (Default: info ) TRAEFIK_TRACING_JAEGER : Settings for Jaeger. (Default: false ) TRAEFIK_TRACING_JAEGER_COLLECTOR_ENDPOINT : Instructs reporter to send spans to jaeger-collector at this URL. TRAEFIK_TRACING_JAEGER_COLLECTOR_PASSWORD : Password for basic http authentication when sending spans to jaeger-collector. TRAEFIK_TRACING_JAEGER_COLLECTOR_USER : User for basic http authentication when sending spans to jaeger-collector. TRAEFIK_TRACING_JAEGER_GEN128BIT : Generate 128 bit span IDs. (Default: false ) TRAEFIK_TRACING_JAEGER_LOCALAGENTHOSTPORT : Set jaeger-agent's host:port that the reporter will used. (Default: 127.0.0.1:6831 ) TRAEFIK_TRACING_JAEGER_PROPAGATION : Which propagation format to use (jaeger/b3). (Default: jaeger ) TRAEFIK_TRACING_JAEGER_SAMPLINGPARAM : Set the sampling parameter. (Default: 1.000000 ) TRAEFIK_TRACING_JAEGER_SAMPLINGSERVERURL : Set the sampling server url. (Default: http://localhost:5778/sampling ) TRAEFIK_TRACING_JAEGER_SAMPLINGTYPE : Set the sampling type. (Default: const ) TRAEFIK_TRACING_JAEGER_TRACECONTEXTHEADERNAME : Set the header to use for the trace-id. (Default: uber-trace-id ) TRAEFIK_TRACING_SERVICENAME : Set the name for this service. (Default: traefik ) TRAEFIK_TRACING_SPANNAMELIMIT : Set the maximum character limit for Span names (default 0 = no limit). (Default: 0 ) TRAEFIK_TRACING_ZIPKIN : Settings for Zipkin. (Default: false ) TRAEFIK_TRACING_ZIPKIN_HTTPENDPOINT : HTTP Endpoint to report traces to. (Default: http://localhost:9411/api/v2/spans ) TRAEFIK_TRACING_ZIPKIN_ID128BIT : Use Zipkin 128 bit root span IDs. (Default: true ) TRAEFIK_TRACING_ZIPKIN_SAMESPAN : Use Zipkin SameSpan RPC style traces. (Default: false ) TRAEFIK_TRACING_ZIPKIN_SAMPLERATE : The rate between 0.0 and 1.0 of requests to trace. (Default: 1.000000 )","title":"Environment variables"},{"location":"reference/static-configuration/env/#static-configuration-environment-variables","text":"TRAEFIK_ACCESSLOG : Access log settings. (Default: false ) TRAEFIK_ACCESSLOG_BUFFERINGSIZE : Number of access log lines to process in a buffered way. (Default: 0 ) TRAEFIK_ACCESSLOG_FIELDS_DEFAULTMODE : Default mode for fields: keep | drop (Default: keep ) TRAEFIK_ACCESSLOG_FIELDS_HEADERS_DEFAULTMODE : Default mode for fields: keep | drop | redact (Default: drop ) TRAEFIK_ACCESSLOG_FIELDS_HEADERS_NAMES_<NAME> : Override mode for headers TRAEFIK_ACCESSLOG_FIELDS_NAMES_<NAME> : Override mode for fields TRAEFIK_ACCESSLOG_FILEPATH : Access log file path. Stdout is used when omitted or empty. TRAEFIK_ACCESSLOG_FILTERS_MINDURATION : Keep access logs when request took longer than the specified duration. (Default: 0 ) TRAEFIK_ACCESSLOG_FILTERS_RETRYATTEMPTS : Keep access logs when at least one retry happened. (Default: false ) TRAEFIK_ACCESSLOG_FILTERS_STATUSCODES : Keep access logs with status codes in the specified range. TRAEFIK_ACCESSLOG_FORMAT : Access log format: json | common (Default: common ) TRAEFIK_API : Enable api/dashboard. (Default: false ) TRAEFIK_API_DASHBOARD : Activate dashboard. (Default: true ) TRAEFIK_API_DEBUG : Enable additional endpoints for debugging and profiling. (Default: false ) TRAEFIK_API_INSECURE : Activate API directly on the entryPoint named traefik. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME> : Certificates resolvers configuration. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_CASERVER : CA server to use. (Default: https://acme-v02.api.letsencrypt.org/directory ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE : Activate DNS-01 Challenge. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_DELAYBEFORECHECK : Assume DNS propagates after a delay in seconds rather than finding and querying nameservers. (Default: 0 ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_DISABLEPROPAGATIONCHECK : Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. [not recommended] (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_PROVIDER : Use a DNS-01 based challenge provider rather than HTTPS. TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_RESOLVERS : Use following DNS servers to resolve the FQDN authority. TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_EMAIL : Email address used for registration. TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_HTTPCHALLENGE : Activate HTTP-01 Challenge. (Default: false ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_HTTPCHALLENGE_ENTRYPOINT : HTTP challenge EntryPoint TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_KEYTYPE : KeyType used for generating certificate private key. Allow value 'EC256', 'EC384', 'RSA2048', 'RSA4096', 'RSA8192'. (Default: RSA4096 ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_STORAGE : Storage to use. (Default: acme.json ) TRAEFIK_CERTIFICATESRESOLVERS_<NAME>_ACME_TLSCHALLENGE : Activate TLS-ALPN-01 Challenge. (Default: true ) TRAEFIK_ENTRYPOINTS_<NAME> : Entry points definition. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_ADDRESS : Entry point address. TRAEFIK_ENTRYPOINTS_<NAME>_FORWARDEDHEADERS_INSECURE : Trust all forwarded headers. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_FORWARDEDHEADERS_TRUSTEDIPS : Trust only forwarded headers from selected IPs. TRAEFIK_ENTRYPOINTS_<NAME>_PROXYPROTOCOL : Proxy-Protocol configuration. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_PROXYPROTOCOL_INSECURE : Trust all. (Default: false ) TRAEFIK_ENTRYPOINTS_<NAME>_PROXYPROTOCOL_TRUSTEDIPS : Trust only selected IPs. TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_LIFECYCLE_GRACETIMEOUT : Duration to give active requests a chance to finish before Traefik stops. (Default: 10 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_LIFECYCLE_REQUESTACCEPTGRACETIMEOUT : Duration to keep accepting requests before Traefik initiates the graceful shutdown procedure. (Default: 0 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_IDLETIMEOUT : IdleTimeout is the maximum amount duration an idle (keep-alive) connection will remain idle before closing itself. If zero, no timeout is set. (Default: 180 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_READTIMEOUT : ReadTimeout is the maximum duration for reading the entire request, including the body. If zero, no timeout is set. (Default: 0 ) TRAEFIK_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_WRITETIMEOUT : WriteTimeout is the maximum duration before timing out writes of the response. If zero, no timeout is set. (Default: 0 ) TRAEFIK_GLOBAL_CHECKNEWVERSION : Periodically check if a new version has been released. (Default: false ) TRAEFIK_GLOBAL_SENDANONYMOUSUSAGE : Periodically send anonymous usage statistics. If the option is not specified, it will be enabled by default. (Default: false ) TRAEFIK_HOSTRESOLVER : Enable CNAME Flattening. (Default: false ) TRAEFIK_HOSTRESOLVER_CNAMEFLATTENING : A flag to enable/disable CNAME flattening (Default: false ) TRAEFIK_HOSTRESOLVER_RESOLVCONFIG : resolv.conf used for DNS resolving (Default: /etc/resolv.conf ) TRAEFIK_HOSTRESOLVER_RESOLVDEPTH : The maximal depth of DNS recursive resolving (Default: 5 ) TRAEFIK_LOG : Traefik log settings. (Default: false ) TRAEFIK_LOG_FILEPATH : Traefik log file path. Stdout is used when omitted or empty. TRAEFIK_LOG_FORMAT : Traefik log format: json | common (Default: common ) TRAEFIK_LOG_LEVEL : Log level set to traefik logs. (Default: ERROR ) TRAEFIK_METRICS_DATADOG : Datadog metrics exporter type. (Default: false ) TRAEFIK_METRICS_DATADOG_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_DATADOG_ADDRESS : Datadog's address. (Default: localhost:8125 ) TRAEFIK_METRICS_DATADOG_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_DATADOG_PUSHINTERVAL : Datadog push interval. (Default: 10 ) TRAEFIK_METRICS_INFLUXDB : InfluxDB metrics exporter type. (Default: false ) TRAEFIK_METRICS_INFLUXDB_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_INFLUXDB_ADDRESS : InfluxDB address. (Default: localhost:8089 ) TRAEFIK_METRICS_INFLUXDB_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_INFLUXDB_DATABASE : InfluxDB database used when protocol is http. TRAEFIK_METRICS_INFLUXDB_PASSWORD : InfluxDB password (only with http). TRAEFIK_METRICS_INFLUXDB_PROTOCOL : InfluxDB address protocol (udp or http). (Default: udp ) TRAEFIK_METRICS_INFLUXDB_PUSHINTERVAL : InfluxDB push interval. (Default: 10 ) TRAEFIK_METRICS_INFLUXDB_RETENTIONPOLICY : InfluxDB retention policy used when protocol is http. TRAEFIK_METRICS_INFLUXDB_USERNAME : InfluxDB username (only with http). TRAEFIK_METRICS_PROMETHEUS : Prometheus metrics exporter type. (Default: false ) TRAEFIK_METRICS_PROMETHEUS_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_PROMETHEUS_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_PROMETHEUS_BUCKETS : Buckets for latency metrics. (Default: 0.100000, 0.300000, 1.200000, 5.000000 ) TRAEFIK_METRICS_PROMETHEUS_ENTRYPOINT : EntryPoint (Default: traefik ) TRAEFIK_METRICS_STATSD : StatsD metrics exporter type. (Default: false ) TRAEFIK_METRICS_STATSD_ADDENTRYPOINTSLABELS : Enable metrics on entry points. (Default: true ) TRAEFIK_METRICS_STATSD_ADDRESS : StatsD address. (Default: localhost:8125 ) TRAEFIK_METRICS_STATSD_ADDSERVICESLABELS : Enable metrics on services. (Default: true ) TRAEFIK_METRICS_STATSD_PUSHINTERVAL : StatsD push interval. (Default: 10 ) TRAEFIK_PING : Enable ping. (Default: false ) TRAEFIK_PING_ENTRYPOINT : EntryPoint (Default: traefik ) TRAEFIK_PROVIDERS_DOCKER : Enable Docker backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_DOCKER_CONSTRAINTS : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. TRAEFIK_PROVIDERS_DOCKER_DEFAULTRULE : Default rule. (Default: Host(`{{ normalize .Name }}`) ) TRAEFIK_PROVIDERS_DOCKER_ENDPOINT : Docker server endpoint. Can be a tcp or a unix socket endpoint. (Default: unix:///var/run/docker.sock ) TRAEFIK_PROVIDERS_DOCKER_EXPOSEDBYDEFAULT : Expose containers by default. (Default: true ) TRAEFIK_PROVIDERS_DOCKER_NETWORK : Default Docker network used. TRAEFIK_PROVIDERS_DOCKER_SWARMMODE : Use Docker on Swarm Mode. (Default: false ) TRAEFIK_PROVIDERS_DOCKER_SWARMMODEREFRESHSECONDS : Polling interval for swarm mode. (Default: 15 ) TRAEFIK_PROVIDERS_DOCKER_TLS_CA : TLS CA TRAEFIK_PROVIDERS_DOCKER_TLS_CAOPTIONAL : TLS CA.Optional (Default: false ) TRAEFIK_PROVIDERS_DOCKER_TLS_CERT : TLS cert TRAEFIK_PROVIDERS_DOCKER_TLS_INSECURESKIPVERIFY : TLS insecure skip verify (Default: false ) TRAEFIK_PROVIDERS_DOCKER_TLS_KEY : TLS key TRAEFIK_PROVIDERS_DOCKER_USEBINDPORTIP : Use the ip address from the bound port, rather than from the inner network. (Default: false ) TRAEFIK_PROVIDERS_DOCKER_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_FILE_DEBUGLOGGENERATEDTEMPLATE : Enable debug logging of generated configuration template. (Default: false ) TRAEFIK_PROVIDERS_FILE_DIRECTORY : Load dynamic configuration from one or more .toml or .yml files in a directory. TRAEFIK_PROVIDERS_FILE_FILENAME : Load dynamic configuration from a file. TRAEFIK_PROVIDERS_FILE_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_KUBERNETESCRD : Enable Kubernetes backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESCRD_CERTAUTHFILEPATH : Kubernetes certificate authority file path (not needed for in-cluster client). TRAEFIK_PROVIDERS_KUBERNETESCRD_DISABLEPASSHOSTHEADERS : Kubernetes disable PassHost Headers. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESCRD_ENDPOINT : Kubernetes server endpoint (required for external cluster client). TRAEFIK_PROVIDERS_KUBERNETESCRD_INGRESSCLASS : Value of kubernetes.io/ingress.class annotation to watch for. TRAEFIK_PROVIDERS_KUBERNETESCRD_LABELSELECTOR : Kubernetes label selector to use. TRAEFIK_PROVIDERS_KUBERNETESCRD_NAMESPACES : Kubernetes namespaces. TRAEFIK_PROVIDERS_KUBERNETESCRD_THROTTLEDURATION : Ingress refresh throttle duration (Default: 0 ) TRAEFIK_PROVIDERS_KUBERNETESCRD_TOKEN : Kubernetes bearer token (not needed for in-cluster client). TRAEFIK_PROVIDERS_KUBERNETESINGRESS : Enable Kubernetes backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESINGRESS_CERTAUTHFILEPATH : Kubernetes certificate authority file path (not needed for in-cluster client). TRAEFIK_PROVIDERS_KUBERNETESINGRESS_DISABLEPASSHOSTHEADERS : Kubernetes disable PassHost Headers. (Default: false ) TRAEFIK_PROVIDERS_KUBERNETESINGRESS_ENDPOINT : Kubernetes server endpoint (required for external cluster client). TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSCLASS : Value of kubernetes.io/ingress.class annotation to watch for. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_HOSTNAME : Hostname used for Kubernetes Ingress endpoints. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_IP : IP used for Kubernetes Ingress endpoints. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_PUBLISHEDSERVICE : Published Kubernetes Service to copy status from. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_LABELSELECTOR : Kubernetes Ingress label selector to use. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_NAMESPACES : Kubernetes namespaces. TRAEFIK_PROVIDERS_KUBERNETESINGRESS_THROTTLEDURATION : Ingress refresh throttle duration (Default: 0 ) TRAEFIK_PROVIDERS_KUBERNETESINGRESS_TOKEN : Kubernetes bearer token (not needed for in-cluster client). TRAEFIK_PROVIDERS_MARATHON : Enable Marathon backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_BASIC_HTTPBASICAUTHUSER : Basic authentication User. TRAEFIK_PROVIDERS_MARATHON_BASIC_HTTPBASICPASSWORD : Basic authentication Password. TRAEFIK_PROVIDERS_MARATHON_CONSTRAINTS : Constraints is an expression that Traefik matches against the application's labels to determine whether to create any route for that application. TRAEFIK_PROVIDERS_MARATHON_DCOSTOKEN : DCOSToken for DCOS environment, This will override the Authorization header. TRAEFIK_PROVIDERS_MARATHON_DEFAULTRULE : Default rule. (Default: Host(`{{ normalize .Name }}`) ) TRAEFIK_PROVIDERS_MARATHON_DIALERTIMEOUT : Set a dialer timeout for Marathon. (Default: 5 ) TRAEFIK_PROVIDERS_MARATHON_ENDPOINT : Marathon server endpoint. You can also specify multiple endpoint for Marathon. (Default: http://127.0.0.1:8080 ) TRAEFIK_PROVIDERS_MARATHON_EXPOSEDBYDEFAULT : Expose Marathon apps by default. (Default: true ) TRAEFIK_PROVIDERS_MARATHON_FORCETASKHOSTNAME : Force to use the task's hostname. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_KEEPALIVE : Set a TCP Keep Alive time. (Default: 10 ) TRAEFIK_PROVIDERS_MARATHON_RESPECTREADINESSCHECKS : Filter out tasks with non-successful readiness checks during deployments. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_RESPONSEHEADERTIMEOUT : Set a response header timeout for Marathon. (Default: 60 ) TRAEFIK_PROVIDERS_MARATHON_TLSHANDSHAKETIMEOUT : Set a TLS handshake timeout for Marathon. (Default: 5 ) TRAEFIK_PROVIDERS_MARATHON_TLS_CA : TLS CA TRAEFIK_PROVIDERS_MARATHON_TLS_CAOPTIONAL : TLS CA.Optional (Default: false ) TRAEFIK_PROVIDERS_MARATHON_TLS_CERT : TLS cert TRAEFIK_PROVIDERS_MARATHON_TLS_INSECURESKIPVERIFY : TLS insecure skip verify (Default: false ) TRAEFIK_PROVIDERS_MARATHON_TLS_KEY : TLS key TRAEFIK_PROVIDERS_MARATHON_TRACE : Display additional provider logs. (Default: false ) TRAEFIK_PROVIDERS_MARATHON_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_PROVIDERSTHROTTLEDURATION : Backends throttle duration: minimum duration between 2 events from providers before applying a new configuration. It avoids unnecessary reloads if multiples events are sent in a short amount of time. (Default: 0 ) TRAEFIK_PROVIDERS_RANCHER : Enable Rancher backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_RANCHER_CONSTRAINTS : Constraints is an expression that Traefik matches against the container's labels to determine whether to create any route for that container. TRAEFIK_PROVIDERS_RANCHER_DEFAULTRULE : Default rule. (Default: Host(`{{ normalize .Name }}`) ) TRAEFIK_PROVIDERS_RANCHER_ENABLESERVICEHEALTHFILTER : Filter services with unhealthy states and inactive states. (Default: true ) TRAEFIK_PROVIDERS_RANCHER_EXPOSEDBYDEFAULT : Expose containers by default. (Default: true ) TRAEFIK_PROVIDERS_RANCHER_INTERVALPOLL : Poll the Rancher metadata service every 'rancher.refreshseconds' (less accurate). (Default: false ) TRAEFIK_PROVIDERS_RANCHER_PREFIX : Prefix used for accessing the Rancher metadata service. (Default: latest ) TRAEFIK_PROVIDERS_RANCHER_REFRESHSECONDS : Defines the polling interval in seconds. (Default: 15 ) TRAEFIK_PROVIDERS_RANCHER_WATCH : Watch provider. (Default: true ) TRAEFIK_PROVIDERS_REST : Enable Rest backend with default settings. (Default: false ) TRAEFIK_PROVIDERS_REST_INSECURE : Activate REST Provider directly on the entryPoint named traefik. (Default: false ) TRAEFIK_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_DIALTIMEOUT : The amount of time to wait until a connection to a backend server can be established. If zero, no timeout exists. (Default: 30 ) TRAEFIK_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_IDLECONNTIMEOUT : The maximum period for which an idle HTTP keep-alive connection will remain open before closing itself (Default: 90 ) TRAEFIK_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_RESPONSEHEADERTIMEOUT : The amount of time to wait for a server's response headers after fully writing the request (including its body, if any). If zero, no timeout exists. (Default: 0 ) TRAEFIK_SERVERSTRANSPORT_INSECURESKIPVERIFY : Disable SSL certificate verification. (Default: false ) TRAEFIK_SERVERSTRANSPORT_MAXIDLECONNSPERHOST : If non-zero, controls the maximum idle (keep-alive) to keep per-host. If zero, DefaultMaxIdleConnsPerHost is used (Default: 0 ) TRAEFIK_SERVERSTRANSPORT_ROOTCAS : Add cert file for self-signed certificate. TRAEFIK_TRACING : OpenTracing configuration. (Default: false ) TRAEFIK_TRACING_DATADOG : Settings for Datadog. (Default: false ) TRAEFIK_TRACING_DATADOG_BAGAGEPREFIXHEADERNAME : Specifies the header name prefix that will be used to store baggage items in a map. TRAEFIK_TRACING_DATADOG_DEBUG : Enable Datadog debug. (Default: false ) TRAEFIK_TRACING_DATADOG_GLOBALTAG : Key:Value tag to be set on all the spans. TRAEFIK_TRACING_DATADOG_LOCALAGENTHOSTPORT : Set datadog-agent's host:port that the reporter will used. (Default: localhost:8126 ) TRAEFIK_TRACING_DATADOG_PARENTIDHEADERNAME : Specifies the header name that will be used to store the parent ID. TRAEFIK_TRACING_DATADOG_PRIORITYSAMPLING : Enable priority sampling. When using distributed tracing, this option must be enabled in order to get all the parts of a distributed trace sampled. (Default: false ) TRAEFIK_TRACING_DATADOG_SAMPLINGPRIORITYHEADERNAME : Specifies the header name that will be used to store the sampling priority. TRAEFIK_TRACING_DATADOG_TRACEIDHEADERNAME : Specifies the header name that will be used to store the trace ID. TRAEFIK_TRACING_HAYSTACK : Settings for Haystack. (Default: false ) TRAEFIK_TRACING_HAYSTACK_BAGGAGEPREFIXHEADERNAME : Specifies the header name prefix that will be used to store baggage items in a map. TRAEFIK_TRACING_HAYSTACK_GLOBALTAG : Key:Value tag to be set on all the spans. TRAEFIK_TRACING_HAYSTACK_LOCALAGENTHOST : Set haystack-agent's host that the reporter will used. (Default: LocalAgentHost ) TRAEFIK_TRACING_HAYSTACK_LOCALAGENTPORT : Set haystack-agent's port that the reporter will used. (Default: 35000 ) TRAEFIK_TRACING_HAYSTACK_PARENTIDHEADERNAME : Specifies the header name that will be used to store the parent ID. TRAEFIK_TRACING_HAYSTACK_SPANIDHEADERNAME : Specifies the header name that will be used to store the span ID. TRAEFIK_TRACING_HAYSTACK_TRACEIDHEADERNAME : Specifies the header name that will be used to store the trace ID. TRAEFIK_TRACING_INSTANA : Settings for Instana. (Default: false ) TRAEFIK_TRACING_INSTANA_LOCALAGENTHOST : Set instana-agent's host that the reporter will used. TRAEFIK_TRACING_INSTANA_LOCALAGENTPORT : Set instana-agent's port that the reporter will used. (Default: 42699 ) TRAEFIK_TRACING_INSTANA_LOGLEVEL : Set instana-agent's log level. ('error','warn','info','debug') (Default: info ) TRAEFIK_TRACING_JAEGER : Settings for Jaeger. (Default: false ) TRAEFIK_TRACING_JAEGER_COLLECTOR_ENDPOINT : Instructs reporter to send spans to jaeger-collector at this URL. TRAEFIK_TRACING_JAEGER_COLLECTOR_PASSWORD : Password for basic http authentication when sending spans to jaeger-collector. TRAEFIK_TRACING_JAEGER_COLLECTOR_USER : User for basic http authentication when sending spans to jaeger-collector. TRAEFIK_TRACING_JAEGER_GEN128BIT : Generate 128 bit span IDs. (Default: false ) TRAEFIK_TRACING_JAEGER_LOCALAGENTHOSTPORT : Set jaeger-agent's host:port that the reporter will used. (Default: 127.0.0.1:6831 ) TRAEFIK_TRACING_JAEGER_PROPAGATION : Which propagation format to use (jaeger/b3). (Default: jaeger ) TRAEFIK_TRACING_JAEGER_SAMPLINGPARAM : Set the sampling parameter. (Default: 1.000000 ) TRAEFIK_TRACING_JAEGER_SAMPLINGSERVERURL : Set the sampling server url. (Default: http://localhost:5778/sampling ) TRAEFIK_TRACING_JAEGER_SAMPLINGTYPE : Set the sampling type. (Default: const ) TRAEFIK_TRACING_JAEGER_TRACECONTEXTHEADERNAME : Set the header to use for the trace-id. (Default: uber-trace-id ) TRAEFIK_TRACING_SERVICENAME : Set the name for this service. (Default: traefik ) TRAEFIK_TRACING_SPANNAMELIMIT : Set the maximum character limit for Span names (default 0 = no limit). (Default: 0 ) TRAEFIK_TRACING_ZIPKIN : Settings for Zipkin. (Default: false ) TRAEFIK_TRACING_ZIPKIN_HTTPENDPOINT : HTTP Endpoint to report traces to. (Default: http://localhost:9411/api/v2/spans ) TRAEFIK_TRACING_ZIPKIN_ID128BIT : Use Zipkin 128 bit root span IDs. (Default: true ) TRAEFIK_TRACING_ZIPKIN_SAMESPAN : Use Zipkin SameSpan RPC style traces. (Default: false ) TRAEFIK_TRACING_ZIPKIN_SAMPLERATE : The rate between 0.0 and 1.0 of requests to trace. (Default: 1.000000 )","title":"Static Configuration: Environment variables"},{"location":"reference/static-configuration/file/","text":"Static Configuration: File \u00b6 TOML [global] checkNewVersion = true sendAnonymousUsage = true [serversTransport] insecureSkipVerify = true rootCAs = [\"foobar\", \"foobar\"] maxIdleConnsPerHost = 42 [serversTransport.forwardingTimeouts] dialTimeout = 42 responseHeaderTimeout = 42 idleConnTimeout = 42 [entryPoints] [entryPoints.EntryPoint0] address = \"foobar\" [entryPoints.EntryPoint0.transport] [entryPoints.EntryPoint0.transport.lifeCycle] requestAcceptGraceTimeout = 42 graceTimeOut = 42 [entryPoints.EntryPoint0.transport.respondingTimeouts] readTimeout = 42 writeTimeout = 42 idleTimeout = 42 [entryPoints.EntryPoint0.proxyProtocol] insecure = true trustedIPs = [\"foobar\", \"foobar\"] [entryPoints.EntryPoint0.forwardedHeaders] insecure = true trustedIPs = [\"foobar\", \"foobar\"] [providers] providersThrottleDuration = 42 [providers.docker] constraints = \"foobar\" watch = true endpoint = \"foobar\" defaultRule = \"foobar\" exposedByDefault = true useBindPortIP = true swarmMode = true network = \"foobar\" swarmModeRefreshSeconds = 42 [providers.docker.tls] ca = \"foobar\" caOptional = true cert = \"foobar\" key = \"foobar\" insecureSkipVerify = true [providers.file] directory = \"foobar\" watch = true filename = \"foobar\" debugLogGeneratedTemplate = true [providers.marathon] constraints = \"foobar\" trace = true watch = true endpoint = \"foobar\" defaultRule = \"foobar\" exposedByDefault = true dcosToken = \"foobar\" dialerTimeout = 42 responseHeaderTimeout = 42 tlsHandshakeTimeout = 42 keepAlive = 42 forceTaskHostname = true respectReadinessChecks = true [providers.marathon.tls] ca = \"foobar\" caOptional = true cert = \"foobar\" key = \"foobar\" insecureSkipVerify = true [providers.marathon.basic] httpBasicAuthUser = \"foobar\" httpBasicPassword = \"foobar\" [providers.kubernetesIngress] endpoint = \"foobar\" token = \"foobar\" certAuthFilePath = \"foobar\" disablePassHostHeaders = true namespaces = [\"foobar\", \"foobar\"] labelSelector = \"foobar\" ingressClass = \"foobar\" throttleDuration = \"10s\" [providers.kubernetesIngress.ingressEndpoint] ip = \"foobar\" hostname = \"foobar\" publishedService = \"foobar\" [providers.kubernetesCRD] endpoint = \"foobar\" token = \"foobar\" certAuthFilePath = \"foobar\" disablePassHostHeaders = true namespaces = [\"foobar\", \"foobar\"] labelSelector = \"foobar\" ingressClass = \"foobar\" throttleDuration = \"10s\" [providers.rest] insecure = true [providers.rancher] constraints = \"foobar\" watch = true defaultRule = \"foobar\" exposedByDefault = true enableServiceHealthFilter = true refreshSeconds = 42 intervalPoll = true prefix = \"foobar\" [api] insecure = true dashboard = true debug = true [metrics] [metrics.prometheus] buckets = [42.0, 42.0] addEntryPointsLabels = true addServicesLabels = true entryPoint = \"foobar\" [metrics.datadog] address = \"foobar\" pushInterval = \"10s\" addEntryPointsLabels = true addServicesLabels = true [metrics.statsD] address = \"foobar\" pushInterval = \"10s\" addEntryPointsLabels = true addServicesLabels = true [metrics.influxDB] address = \"foobar\" protocol = \"foobar\" pushInterval = \"10s\" database = \"foobar\" retentionPolicy = \"foobar\" username = \"foobar\" password = \"foobar\" addEntryPointsLabels = true addServicesLabels = true [ping] entryPoint = \"foobar\" [log] level = \"foobar\" filePath = \"foobar\" format = \"foobar\" [accessLog] filePath = \"foobar\" format = \"foobar\" bufferingSize = 42 [accessLog.filters] statusCodes = [\"foobar\", \"foobar\"] retryAttempts = true minDuration = 42 [accessLog.fields] defaultMode = \"foobar\" [accessLog.fields.names] name0 = \"foobar\" name1 = \"foobar\" [accessLog.fields.headers] defaultMode = \"foobar\" [accessLog.fields.headers.names] name0 = \"foobar\" name1 = \"foobar\" [tracing] serviceName = \"foobar\" spanNameLimit = 42 [tracing.jaeger] samplingServerURL = \"foobar\" samplingType = \"foobar\" samplingParam = 42.0 localAgentHostPort = \"foobar\" gen128Bit = true propagation = \"foobar\" traceContextHeaderName = \"foobar\" [tracing.jaeger.collector] endpoint = \"foobar\" user = \"foobar\" password = \"foobar\" [tracing.zipkin] httpEndpoint = \"foobar\" sameSpan = true id128Bit = true sampleRate = 42.0 [tracing.datadog] localAgentHostPort = \"foobar\" globalTag = \"foobar\" debug = true prioritySampling = true traceIDHeaderName = \"foobar\" parentIDHeaderName = \"foobar\" samplingPriorityHeaderName = \"foobar\" bagagePrefixHeaderName = \"foobar\" [tracing.instana] localAgentHost = \"foobar\" localAgentPort = 42 logLevel = \"foobar\" [tracing.haystack] localAgentHost = \"foobar\" localAgentPort = 42 globalTag = \"foobar\" traceIDHeaderName = \"foobar\" parentIDHeaderName = \"foobar\" spanIDHeaderName = \"foobar\" baggagePrefixHeaderName = \"foobar\" [hostResolver] cnameFlattening = true resolvConfig = \"foobar\" resolvDepth = 42 [certificatesResolvers] [certificatesResolvers.CertificateResolver0] [certificatesResolvers.CertificateResolver0.acme] email = \"foobar\" caServer = \"foobar\" storage = \"foobar\" keyType = \"foobar\" [certificatesResolvers.CertificateResolver0.acme.dnsChallenge] provider = \"foobar\" delayBeforeCheck = 42 resolvers = [\"foobar\", \"foobar\"] disablePropagationCheck = true [certificatesResolvers.CertificateResolver0.acme.httpChallenge] entryPoint = \"foobar\" [certificatesResolvers.CertificateResolver0.acme.tlsChallenge] [certificatesResolvers.CertificateResolver1] [certificatesResolvers.CertificateResolver1.acme] email = \"foobar\" caServer = \"foobar\" storage = \"foobar\" keyType = \"foobar\" [certificatesResolvers.CertificateResolver1.acme.dnsChallenge] provider = \"foobar\" delayBeforeCheck = 42 resolvers = [\"foobar\", \"foobar\"] disablePropagationCheck = true [certificatesResolvers.CertificateResolver1.acme.httpChallenge] entryPoint = \"foobar\" [certificatesResolvers.CertificateResolver1.acme.tlsChallenge] YAML global: checkNewVersion: true sendAnonymousUsage: true serversTransport: insecureSkipVerify: true rootCAs: - foobar - foobar maxIdleConnsPerHost: 42 forwardingTimeouts: dialTimeout: 42 responseHeaderTimeout: 42 idleConnTimeout: 42 entryPoints: EntryPoint0: address: foobar transport: lifeCycle: requestAcceptGraceTimeout: 42 graceTimeOut: 42 respondingTimeouts: readTimeout: 42 writeTimeout: 42 idleTimeout: 42 proxyProtocol: insecure: true trustedIPs: - foobar - foobar forwardedHeaders: insecure: true trustedIPs: - foobar - foobar providers: providersThrottleDuration: 42 docker: constraints: foobar watch: true endpoint: foobar defaultRule: foobar tls: ca: foobar caOptional: true cert: foobar key: foobar insecureSkipVerify: true exposedByDefault: true useBindPortIP: true swarmMode: true network: foobar swarmModeRefreshSeconds: 42 file: directory: foobar watch: true filename: foobar debugLogGeneratedTemplate: true marathon: constraints: foobar trace: true watch: true endpoint: foobar defaultRule: foobar exposedByDefault: true dcosToken: foobar tls: ca: foobar caOptional: true cert: foobar key: foobar insecureSkipVerify: true dialerTimeout: 42 responseHeaderTimeout: 42 tlsHandshakeTimeout: 42 keepAlive: 42 forceTaskHostname: true basic: httpBasicAuthUser: foobar httpBasicPassword: foobar respectReadinessChecks: true kubernetesIngress: endpoint: foobar token: foobar certAuthFilePath: foobar disablePassHostHeaders: true namespaces: - foobar - foobar labelSelector: foobar ingressClass: foobar throttleDuration: 10s ingressEndpoint: ip: foobar hostname: foobar publishedService: foobar kubernetesCRD: endpoint: foobar token: foobar certAuthFilePath: foobar disablePassHostHeaders: true namespaces: - foobar - foobar labelSelector: foobar ingressClass: foobar throttleDuration: 10s rest: insecure: true rancher: constraints: foobar watch: true defaultRule: foobar exposedByDefault: true enableServiceHealthFilter: true refreshSeconds: 42 intervalPoll: true prefix: foobar api: insecure: true dashboard: true debug: true metrics: prometheus: buckets: - 42 - 42 addEntryPointsLabels: true addServicesLabels: true entryPoint: foobar datadog: address: foobar pushInterval: 42 addEntryPointsLabels: true addServicesLabels: true statsD: address: foobar pushInterval: 42 addEntryPointsLabels: true addServicesLabels: true influxDB: address: foobar protocol: foobar pushInterval: 42 database: foobar retentionPolicy: foobar username: foobar password: foobar addEntryPointsLabels: true addServicesLabels: true ping: entryPoint: foobar log: level: foobar filePath: foobar format: foobar accessLog: filePath: foobar format: foobar filters: statusCodes: - foobar - foobar retryAttempts: true minDuration: 42 fields: defaultMode: foobar names: name0: foobar name1: foobar headers: defaultMode: foobar names: name0: foobar name1: foobar bufferingSize: 42 tracing: serviceName: foobar spanNameLimit: 42 jaeger: samplingServerURL: foobar samplingType: foobar samplingParam: 42 localAgentHostPort: foobar gen128Bit: true propagation: foobar traceContextHeaderName: foobar collector: endpoint: foobar user: foobar password: foobar zipkin: httpEndpoint: foobar sameSpan: true id128Bit: true sampleRate: 42 datadog: localAgentHostPort: foobar globalTag: foobar debug: true prioritySampling: true traceIDHeaderName: foobar parentIDHeaderName: foobar samplingPriorityHeaderName: foobar bagagePrefixHeaderName: foobar instana: localAgentHost: foobar localAgentPort: 42 logLevel: foobar haystack: localAgentHost: foobar localAgentPort: 42 globalTag: foobar traceIDHeaderName: foobar parentIDHeaderName: foobar spanIDHeaderName: foobar baggagePrefixHeaderName: foobar hostResolver: cnameFlattening: true resolvConfig: foobar resolvDepth: 42 certificatesResolvers: CertificateResolver0: acme: email: foobar caServer: foobar storage: foobar keyType: foobar dnsChallenge: provider: foobar delayBeforeCheck: 42 resolvers: - foobar - foobar disablePropagationCheck: true httpChallenge: entryPoint: foobar tlsChallenge: {} CertificateResolver1: acme: email: foobar caServer: foobar storage: foobar keyType: foobar dnsChallenge: provider: foobar delayBeforeCheck: 42 resolvers: - foobar - foobar disablePropagationCheck: true httpChallenge: entryPoint: foobar tlsChallenge: {}","title":"File"},{"location":"reference/static-configuration/file/#static-configuration-file","text":"TOML [global] checkNewVersion = true sendAnonymousUsage = true [serversTransport] insecureSkipVerify = true rootCAs = [\"foobar\", \"foobar\"] maxIdleConnsPerHost = 42 [serversTransport.forwardingTimeouts] dialTimeout = 42 responseHeaderTimeout = 42 idleConnTimeout = 42 [entryPoints] [entryPoints.EntryPoint0] address = \"foobar\" [entryPoints.EntryPoint0.transport] [entryPoints.EntryPoint0.transport.lifeCycle] requestAcceptGraceTimeout = 42 graceTimeOut = 42 [entryPoints.EntryPoint0.transport.respondingTimeouts] readTimeout = 42 writeTimeout = 42 idleTimeout = 42 [entryPoints.EntryPoint0.proxyProtocol] insecure = true trustedIPs = [\"foobar\", \"foobar\"] [entryPoints.EntryPoint0.forwardedHeaders] insecure = true trustedIPs = [\"foobar\", \"foobar\"] [providers] providersThrottleDuration = 42 [providers.docker] constraints = \"foobar\" watch = true endpoint = \"foobar\" defaultRule = \"foobar\" exposedByDefault = true useBindPortIP = true swarmMode = true network = \"foobar\" swarmModeRefreshSeconds = 42 [providers.docker.tls] ca = \"foobar\" caOptional = true cert = \"foobar\" key = \"foobar\" insecureSkipVerify = true [providers.file] directory = \"foobar\" watch = true filename = \"foobar\" debugLogGeneratedTemplate = true [providers.marathon] constraints = \"foobar\" trace = true watch = true endpoint = \"foobar\" defaultRule = \"foobar\" exposedByDefault = true dcosToken = \"foobar\" dialerTimeout = 42 responseHeaderTimeout = 42 tlsHandshakeTimeout = 42 keepAlive = 42 forceTaskHostname = true respectReadinessChecks = true [providers.marathon.tls] ca = \"foobar\" caOptional = true cert = \"foobar\" key = \"foobar\" insecureSkipVerify = true [providers.marathon.basic] httpBasicAuthUser = \"foobar\" httpBasicPassword = \"foobar\" [providers.kubernetesIngress] endpoint = \"foobar\" token = \"foobar\" certAuthFilePath = \"foobar\" disablePassHostHeaders = true namespaces = [\"foobar\", \"foobar\"] labelSelector = \"foobar\" ingressClass = \"foobar\" throttleDuration = \"10s\" [providers.kubernetesIngress.ingressEndpoint] ip = \"foobar\" hostname = \"foobar\" publishedService = \"foobar\" [providers.kubernetesCRD] endpoint = \"foobar\" token = \"foobar\" certAuthFilePath = \"foobar\" disablePassHostHeaders = true namespaces = [\"foobar\", \"foobar\"] labelSelector = \"foobar\" ingressClass = \"foobar\" throttleDuration = \"10s\" [providers.rest] insecure = true [providers.rancher] constraints = \"foobar\" watch = true defaultRule = \"foobar\" exposedByDefault = true enableServiceHealthFilter = true refreshSeconds = 42 intervalPoll = true prefix = \"foobar\" [api] insecure = true dashboard = true debug = true [metrics] [metrics.prometheus] buckets = [42.0, 42.0] addEntryPointsLabels = true addServicesLabels = true entryPoint = \"foobar\" [metrics.datadog] address = \"foobar\" pushInterval = \"10s\" addEntryPointsLabels = true addServicesLabels = true [metrics.statsD] address = \"foobar\" pushInterval = \"10s\" addEntryPointsLabels = true addServicesLabels = true [metrics.influxDB] address = \"foobar\" protocol = \"foobar\" pushInterval = \"10s\" database = \"foobar\" retentionPolicy = \"foobar\" username = \"foobar\" password = \"foobar\" addEntryPointsLabels = true addServicesLabels = true [ping] entryPoint = \"foobar\" [log] level = \"foobar\" filePath = \"foobar\" format = \"foobar\" [accessLog] filePath = \"foobar\" format = \"foobar\" bufferingSize = 42 [accessLog.filters] statusCodes = [\"foobar\", \"foobar\"] retryAttempts = true minDuration = 42 [accessLog.fields] defaultMode = \"foobar\" [accessLog.fields.names] name0 = \"foobar\" name1 = \"foobar\" [accessLog.fields.headers] defaultMode = \"foobar\" [accessLog.fields.headers.names] name0 = \"foobar\" name1 = \"foobar\" [tracing] serviceName = \"foobar\" spanNameLimit = 42 [tracing.jaeger] samplingServerURL = \"foobar\" samplingType = \"foobar\" samplingParam = 42.0 localAgentHostPort = \"foobar\" gen128Bit = true propagation = \"foobar\" traceContextHeaderName = \"foobar\" [tracing.jaeger.collector] endpoint = \"foobar\" user = \"foobar\" password = \"foobar\" [tracing.zipkin] httpEndpoint = \"foobar\" sameSpan = true id128Bit = true sampleRate = 42.0 [tracing.datadog] localAgentHostPort = \"foobar\" globalTag = \"foobar\" debug = true prioritySampling = true traceIDHeaderName = \"foobar\" parentIDHeaderName = \"foobar\" samplingPriorityHeaderName = \"foobar\" bagagePrefixHeaderName = \"foobar\" [tracing.instana] localAgentHost = \"foobar\" localAgentPort = 42 logLevel = \"foobar\" [tracing.haystack] localAgentHost = \"foobar\" localAgentPort = 42 globalTag = \"foobar\" traceIDHeaderName = \"foobar\" parentIDHeaderName = \"foobar\" spanIDHeaderName = \"foobar\" baggagePrefixHeaderName = \"foobar\" [hostResolver] cnameFlattening = true resolvConfig = \"foobar\" resolvDepth = 42 [certificatesResolvers] [certificatesResolvers.CertificateResolver0] [certificatesResolvers.CertificateResolver0.acme] email = \"foobar\" caServer = \"foobar\" storage = \"foobar\" keyType = \"foobar\" [certificatesResolvers.CertificateResolver0.acme.dnsChallenge] provider = \"foobar\" delayBeforeCheck = 42 resolvers = [\"foobar\", \"foobar\"] disablePropagationCheck = true [certificatesResolvers.CertificateResolver0.acme.httpChallenge] entryPoint = \"foobar\" [certificatesResolvers.CertificateResolver0.acme.tlsChallenge] [certificatesResolvers.CertificateResolver1] [certificatesResolvers.CertificateResolver1.acme] email = \"foobar\" caServer = \"foobar\" storage = \"foobar\" keyType = \"foobar\" [certificatesResolvers.CertificateResolver1.acme.dnsChallenge] provider = \"foobar\" delayBeforeCheck = 42 resolvers = [\"foobar\", \"foobar\"] disablePropagationCheck = true [certificatesResolvers.CertificateResolver1.acme.httpChallenge] entryPoint = \"foobar\" [certificatesResolvers.CertificateResolver1.acme.tlsChallenge] YAML global: checkNewVersion: true sendAnonymousUsage: true serversTransport: insecureSkipVerify: true rootCAs: - foobar - foobar maxIdleConnsPerHost: 42 forwardingTimeouts: dialTimeout: 42 responseHeaderTimeout: 42 idleConnTimeout: 42 entryPoints: EntryPoint0: address: foobar transport: lifeCycle: requestAcceptGraceTimeout: 42 graceTimeOut: 42 respondingTimeouts: readTimeout: 42 writeTimeout: 42 idleTimeout: 42 proxyProtocol: insecure: true trustedIPs: - foobar - foobar forwardedHeaders: insecure: true trustedIPs: - foobar - foobar providers: providersThrottleDuration: 42 docker: constraints: foobar watch: true endpoint: foobar defaultRule: foobar tls: ca: foobar caOptional: true cert: foobar key: foobar insecureSkipVerify: true exposedByDefault: true useBindPortIP: true swarmMode: true network: foobar swarmModeRefreshSeconds: 42 file: directory: foobar watch: true filename: foobar debugLogGeneratedTemplate: true marathon: constraints: foobar trace: true watch: true endpoint: foobar defaultRule: foobar exposedByDefault: true dcosToken: foobar tls: ca: foobar caOptional: true cert: foobar key: foobar insecureSkipVerify: true dialerTimeout: 42 responseHeaderTimeout: 42 tlsHandshakeTimeout: 42 keepAlive: 42 forceTaskHostname: true basic: httpBasicAuthUser: foobar httpBasicPassword: foobar respectReadinessChecks: true kubernetesIngress: endpoint: foobar token: foobar certAuthFilePath: foobar disablePassHostHeaders: true namespaces: - foobar - foobar labelSelector: foobar ingressClass: foobar throttleDuration: 10s ingressEndpoint: ip: foobar hostname: foobar publishedService: foobar kubernetesCRD: endpoint: foobar token: foobar certAuthFilePath: foobar disablePassHostHeaders: true namespaces: - foobar - foobar labelSelector: foobar ingressClass: foobar throttleDuration: 10s rest: insecure: true rancher: constraints: foobar watch: true defaultRule: foobar exposedByDefault: true enableServiceHealthFilter: true refreshSeconds: 42 intervalPoll: true prefix: foobar api: insecure: true dashboard: true debug: true metrics: prometheus: buckets: - 42 - 42 addEntryPointsLabels: true addServicesLabels: true entryPoint: foobar datadog: address: foobar pushInterval: 42 addEntryPointsLabels: true addServicesLabels: true statsD: address: foobar pushInterval: 42 addEntryPointsLabels: true addServicesLabels: true influxDB: address: foobar protocol: foobar pushInterval: 42 database: foobar retentionPolicy: foobar username: foobar password: foobar addEntryPointsLabels: true addServicesLabels: true ping: entryPoint: foobar log: level: foobar filePath: foobar format: foobar accessLog: filePath: foobar format: foobar filters: statusCodes: - foobar - foobar retryAttempts: true minDuration: 42 fields: defaultMode: foobar names: name0: foobar name1: foobar headers: defaultMode: foobar names: name0: foobar name1: foobar bufferingSize: 42 tracing: serviceName: foobar spanNameLimit: 42 jaeger: samplingServerURL: foobar samplingType: foobar samplingParam: 42 localAgentHostPort: foobar gen128Bit: true propagation: foobar traceContextHeaderName: foobar collector: endpoint: foobar user: foobar password: foobar zipkin: httpEndpoint: foobar sameSpan: true id128Bit: true sampleRate: 42 datadog: localAgentHostPort: foobar globalTag: foobar debug: true prioritySampling: true traceIDHeaderName: foobar parentIDHeaderName: foobar samplingPriorityHeaderName: foobar bagagePrefixHeaderName: foobar instana: localAgentHost: foobar localAgentPort: 42 logLevel: foobar haystack: localAgentHost: foobar localAgentPort: 42 globalTag: foobar traceIDHeaderName: foobar parentIDHeaderName: foobar spanIDHeaderName: foobar baggagePrefixHeaderName: foobar hostResolver: cnameFlattening: true resolvConfig: foobar resolvDepth: 42 certificatesResolvers: CertificateResolver0: acme: email: foobar caServer: foobar storage: foobar keyType: foobar dnsChallenge: provider: foobar delayBeforeCheck: 42 resolvers: - foobar - foobar disablePropagationCheck: true httpChallenge: entryPoint: foobar tlsChallenge: {} CertificateResolver1: acme: email: foobar caServer: foobar storage: foobar keyType: foobar dnsChallenge: provider: foobar delayBeforeCheck: 42 resolvers: - foobar - foobar disablePropagationCheck: true httpChallenge: entryPoint: foobar tlsChallenge: {}","title":"Static Configuration: File"},{"location":"reference/static-configuration/overview/","text":"Static Configuration \u00b6 File CLI Environment Variables","title":"Overview"},{"location":"reference/static-configuration/overview/#static-configuration","text":"File CLI Environment Variables","title":"Static Configuration"},{"location":"routing/entrypoints/","text":"EntryPoints \u00b6 Opening Connections for Incoming Requests EntryPoints are the network entry points into Traefik. They define the port which will receive the requests (whether HTTP or TCP). Configuration Examples \u00b6 Port 80 only File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" CLI ## Static configuration --entryPoints.web.address=:80 We define an entrypoint called web that will listen on port 80 . Port 80 & 443 File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web-secure] address = \":443\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" web-secure: address: \":443\" CLI ## Static configuration --entryPoints.web.address=:80 --entryPoints.web-secure.address=:443 Two entrypoints are defined: one called web , and the other called web-secure . web listens on port 80 , and web-secure on port 443 . Configuration \u00b6 General \u00b6 EntryPoints are part of the static configuration . You can define them using a toml file, CLI arguments, or a key-value store. See the complete reference for the list of available options File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.lifeCycle] requestAcceptGraceTimeout = 42 graceTimeOut = 42 [entryPoints.name.transport.respondingTimeouts] readTimeout = 42 writeTimeout = 42 idleTimeout = 42 [entryPoints.name.proxyProtocol] insecure = true trustedIPs = [\"127.0.0.1\", \"192.168.0.1\"] [entryPoints.name.forwardedHeaders] insecure = true trustedIPs = [\"127.0.0.1\", \"192.168.0.1\"] File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: lifeCycle: requestAcceptGraceTimeout: 42 graceTimeOut: 42 respondingTimeouts: readTimeout: 42 writeTimeout: 42 idleTimeout: 42 proxyProtocol: insecure: true trustedIPs: - \"127.0.0.1\" - \"192.168.0.1\" forwardedHeaders: insecure: true trustedIPs: - \"127.0.0.1\" - \"192.168.0.1\" CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.lifeCycle.requestAcceptGraceTimeout=42 --entryPoints.name.transport.lifeCycle.graceTimeOut=42 --entryPoints.name.transport.respondingTimeouts.readTimeout=42 --entryPoints.name.transport.respondingTimeouts.writeTimeout=42 --entryPoints.name.transport.respondingTimeouts.idleTimeout=42 --entryPoints.name.proxyProtocol.insecure=true --entryPoints.name.proxyProtocol.trustedIPs=127.0.0.1,192.168.0.1 --entryPoints.name.forwardedHeaders.insecure=true --entryPoints.name.forwardedHeaders.trustedIPs=127.0.0.1,192.168.0.1 Forwarded Header \u00b6 You can configure Traefik to trust the forwarded headers information ( X-Forwarded-* ). forwardedHeaders.trustedIPs Trusting Forwarded Headers from specific IPs. File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web.forwardedHeaders] trustedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) ## Static configuration entryPoints: web: address: \":80\" forwardedHeaders: trustedIPs: - \"127.0.0.1/32\" - \"192.168.1.7\" CLI ## Static configuration --entryPoints.web.address=:80 --entryPoints.web.forwardedHeaders.trustedIPs=127.0.0.1/32,192.168.1.7 forwardedHeaders.insecure Insecure Mode (Always Trusting Forwarded Headers). File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web.forwardedHeaders] insecure = true File (YAML) ## Static configuration entryPoints: web: address: \":80\" forwardedHeaders: insecure: true CLI ## Static configuration --entryPoints.web.address=:80 --entryPoints.web.forwardedHeaders.insecure Transport \u00b6 respondingTimeouts \u00b6 respondingTimeouts are timeouts for incoming requests to the Traefik instance. transport.respondingTimeouts.readTimeout Optional, Default=0s readTimeout is the maximum duration for reading the entire request, including the body. If zero, no timeout exists. Can be provided in a format supported by time.ParseDuration or as raw values (digits). If no units are provided, the value is parsed assuming seconds. File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.respondingTimeouts] readTimeout = 42 File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: respondingTimeouts: readTimeout: 42 CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.respondingTimeouts.readTimeout=42 transport.respondingTimeouts.writeTimeout Optional, Default=0s writeTimeout is the maximum duration before timing out writes of the response. It covers the time from the end of the request header read to the end of the response write. If zero, no timeout exists. Can be provided in a format supported by time.ParseDuration or as raw values (digits). If no units are provided, the value is parsed assuming seconds. File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.respondingTimeouts] writeTimeout = 42 File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: respondingTimeouts: writeTimeout: 42 CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.respondingTimeouts.writeTimeout=42 transport.respondingTimeouts.idleTimeout Optional, Default=180s idleTimeout is the maximum duration an idle (keep-alive) connection will remain idle before closing itself. If zero, no timeout exists. Can be provided in a format supported by time.ParseDuration or as raw values (digits). If no units are provided, the value is parsed assuming seconds. File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.respondingTimeouts] idleTimeout = 42 File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: respondingTimeouts: idleTimeout: 42 CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.respondingTimeouts.idleTimeout=42 lifeCycle \u00b6 Controls the behavior of Traefik during the shutdown phase. lifeCycle.requestAcceptGraceTimeout Optional, Default=0s Duration to keep accepting requests prior to initiating the graceful termination period (as defined by the graceTimeOut option). This option is meant to give downstream load-balancers sufficient time to take Traefik out of rotation. Can be provided in a format supported by time.ParseDuration or as raw values (digits). If no units are provided, the value is parsed assuming seconds. The zero duration disables the request accepting grace period, i.e., Traefik will immediately proceed to the grace period. File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.lifeCycle] requestAcceptGraceTimeout = 42 File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: lifeCycle: requestAcceptGraceTimeout: 42 CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.lifeCycle.requestAcceptGraceTimeout=42 lifeCycle.graceTimeOut Optional, Default=10s Duration to give active requests a chance to finish before Traefik stops. Can be provided in a format supported by time.ParseDuration or as raw values (digits). If no units are provided, the value is parsed assuming seconds. In this time frame no new requests are accepted. File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.lifeCycle] graceTimeOut = 42 File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: lifeCycle: graceTimeOut: 42 CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.lifeCycle.graceTimeOut=42 ProxyProtocol \u00b6 Traefik supports ProxyProtocol version 1 and 2. If Proxy Protocol header parsing is enabled for the entry point, this entry point can accept connections with or without Proxy Protocol headers. If the Proxy Protocol header is passed, then the version is determined automatically. proxyProtocol.trustedIPs Enabling Proxy Protocol with Trusted IPs. File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web.proxyProtocol] trustedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) ## Static configuration entryPoints: web: address: \":80\" proxyProtocol: trustedIPs: - \"127.0.0.1/32\" - \"192.168.1.7\" CLI --entryPoints.web.address=:80 --entryPoints.web.proxyProtocol.trustedIPs=127.0.0.1/32,192.168.1.7 IPs in trustedIPs only will lead to remote client address replacement: Declare load-balancer IPs or CIDR range here. proxyProtocol.insecure Insecure Mode (Testing Environment Only). In a test environments, you can configure Traefik to trust every incoming connection. Doing so, every remote client address will be replaced ( trustedIPs won't have any effect) File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web.proxyProtocol] insecure = true File (YAML) ## Static configuration entryPoints: web: address: \":80\" proxyProtocol: insecure: true CLI --entryPoints.web.address=:80 --entryPoints.web.proxyProtocol.insecure Queuing Traefik behind Another Load Balancer When queuing Traefik behind another load-balancer, make sure to configure Proxy Protocol on both sides. Not doing so could introduce a security risk in your system (enabling request forgery).","title":"EntryPoints"},{"location":"routing/entrypoints/#entrypoints","text":"Opening Connections for Incoming Requests EntryPoints are the network entry points into Traefik. They define the port which will receive the requests (whether HTTP or TCP).","title":"EntryPoints"},{"location":"routing/entrypoints/#configuration-examples","text":"Port 80 only File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" CLI ## Static configuration --entryPoints.web.address=:80 We define an entrypoint called web that will listen on port 80 . Port 80 & 443 File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web-secure] address = \":443\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" web-secure: address: \":443\" CLI ## Static configuration --entryPoints.web.address=:80 --entryPoints.web-secure.address=:443 Two entrypoints are defined: one called web , and the other called web-secure . web listens on port 80 , and web-secure on port 443 .","title":"Configuration Examples"},{"location":"routing/entrypoints/#configuration","text":"","title":"Configuration"},{"location":"routing/entrypoints/#general","text":"EntryPoints are part of the static configuration . You can define them using a toml file, CLI arguments, or a key-value store. See the complete reference for the list of available options File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.lifeCycle] requestAcceptGraceTimeout = 42 graceTimeOut = 42 [entryPoints.name.transport.respondingTimeouts] readTimeout = 42 writeTimeout = 42 idleTimeout = 42 [entryPoints.name.proxyProtocol] insecure = true trustedIPs = [\"127.0.0.1\", \"192.168.0.1\"] [entryPoints.name.forwardedHeaders] insecure = true trustedIPs = [\"127.0.0.1\", \"192.168.0.1\"] File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: lifeCycle: requestAcceptGraceTimeout: 42 graceTimeOut: 42 respondingTimeouts: readTimeout: 42 writeTimeout: 42 idleTimeout: 42 proxyProtocol: insecure: true trustedIPs: - \"127.0.0.1\" - \"192.168.0.1\" forwardedHeaders: insecure: true trustedIPs: - \"127.0.0.1\" - \"192.168.0.1\" CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.lifeCycle.requestAcceptGraceTimeout=42 --entryPoints.name.transport.lifeCycle.graceTimeOut=42 --entryPoints.name.transport.respondingTimeouts.readTimeout=42 --entryPoints.name.transport.respondingTimeouts.writeTimeout=42 --entryPoints.name.transport.respondingTimeouts.idleTimeout=42 --entryPoints.name.proxyProtocol.insecure=true --entryPoints.name.proxyProtocol.trustedIPs=127.0.0.1,192.168.0.1 --entryPoints.name.forwardedHeaders.insecure=true --entryPoints.name.forwardedHeaders.trustedIPs=127.0.0.1,192.168.0.1","title":"General"},{"location":"routing/entrypoints/#forwarded-header","text":"You can configure Traefik to trust the forwarded headers information ( X-Forwarded-* ). forwardedHeaders.trustedIPs Trusting Forwarded Headers from specific IPs. File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web.forwardedHeaders] trustedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) ## Static configuration entryPoints: web: address: \":80\" forwardedHeaders: trustedIPs: - \"127.0.0.1/32\" - \"192.168.1.7\" CLI ## Static configuration --entryPoints.web.address=:80 --entryPoints.web.forwardedHeaders.trustedIPs=127.0.0.1/32,192.168.1.7 forwardedHeaders.insecure Insecure Mode (Always Trusting Forwarded Headers). File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web.forwardedHeaders] insecure = true File (YAML) ## Static configuration entryPoints: web: address: \":80\" forwardedHeaders: insecure: true CLI ## Static configuration --entryPoints.web.address=:80 --entryPoints.web.forwardedHeaders.insecure","title":"Forwarded Header"},{"location":"routing/entrypoints/#transport","text":"","title":"Transport"},{"location":"routing/entrypoints/#respondingtimeouts","text":"respondingTimeouts are timeouts for incoming requests to the Traefik instance. transport.respondingTimeouts.readTimeout Optional, Default=0s readTimeout is the maximum duration for reading the entire request, including the body. If zero, no timeout exists. Can be provided in a format supported by time.ParseDuration or as raw values (digits). If no units are provided, the value is parsed assuming seconds. File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.respondingTimeouts] readTimeout = 42 File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: respondingTimeouts: readTimeout: 42 CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.respondingTimeouts.readTimeout=42 transport.respondingTimeouts.writeTimeout Optional, Default=0s writeTimeout is the maximum duration before timing out writes of the response. It covers the time from the end of the request header read to the end of the response write. If zero, no timeout exists. Can be provided in a format supported by time.ParseDuration or as raw values (digits). If no units are provided, the value is parsed assuming seconds. File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.respondingTimeouts] writeTimeout = 42 File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: respondingTimeouts: writeTimeout: 42 CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.respondingTimeouts.writeTimeout=42 transport.respondingTimeouts.idleTimeout Optional, Default=180s idleTimeout is the maximum duration an idle (keep-alive) connection will remain idle before closing itself. If zero, no timeout exists. Can be provided in a format supported by time.ParseDuration or as raw values (digits). If no units are provided, the value is parsed assuming seconds. File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.respondingTimeouts] idleTimeout = 42 File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: respondingTimeouts: idleTimeout: 42 CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.respondingTimeouts.idleTimeout=42","title":"respondingTimeouts"},{"location":"routing/entrypoints/#lifecycle","text":"Controls the behavior of Traefik during the shutdown phase. lifeCycle.requestAcceptGraceTimeout Optional, Default=0s Duration to keep accepting requests prior to initiating the graceful termination period (as defined by the graceTimeOut option). This option is meant to give downstream load-balancers sufficient time to take Traefik out of rotation. Can be provided in a format supported by time.ParseDuration or as raw values (digits). If no units are provided, the value is parsed assuming seconds. The zero duration disables the request accepting grace period, i.e., Traefik will immediately proceed to the grace period. File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.lifeCycle] requestAcceptGraceTimeout = 42 File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: lifeCycle: requestAcceptGraceTimeout: 42 CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.lifeCycle.requestAcceptGraceTimeout=42 lifeCycle.graceTimeOut Optional, Default=10s Duration to give active requests a chance to finish before Traefik stops. Can be provided in a format supported by time.ParseDuration or as raw values (digits). If no units are provided, the value is parsed assuming seconds. In this time frame no new requests are accepted. File (TOML) ## Static configuration [entryPoints] [entryPoints.name] address = \":8888\" [entryPoints.name.transport] [entryPoints.name.transport.lifeCycle] graceTimeOut = 42 File (YAML) ## Static configuration entryPoints: name: address: \":8888\" transport: lifeCycle: graceTimeOut: 42 CLI ## Static configuration --entryPoints.name.address=:8888 --entryPoints.name.transport.lifeCycle.graceTimeOut=42","title":"lifeCycle"},{"location":"routing/entrypoints/#proxyprotocol","text":"Traefik supports ProxyProtocol version 1 and 2. If Proxy Protocol header parsing is enabled for the entry point, this entry point can accept connections with or without Proxy Protocol headers. If the Proxy Protocol header is passed, then the version is determined automatically. proxyProtocol.trustedIPs Enabling Proxy Protocol with Trusted IPs. File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web.proxyProtocol] trustedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] File (YAML) ## Static configuration entryPoints: web: address: \":80\" proxyProtocol: trustedIPs: - \"127.0.0.1/32\" - \"192.168.1.7\" CLI --entryPoints.web.address=:80 --entryPoints.web.proxyProtocol.trustedIPs=127.0.0.1/32,192.168.1.7 IPs in trustedIPs only will lead to remote client address replacement: Declare load-balancer IPs or CIDR range here. proxyProtocol.insecure Insecure Mode (Testing Environment Only). In a test environments, you can configure Traefik to trust every incoming connection. Doing so, every remote client address will be replaced ( trustedIPs won't have any effect) File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.web.proxyProtocol] insecure = true File (YAML) ## Static configuration entryPoints: web: address: \":80\" proxyProtocol: insecure: true CLI --entryPoints.web.address=:80 --entryPoints.web.proxyProtocol.insecure Queuing Traefik behind Another Load Balancer When queuing Traefik behind another load-balancer, make sure to configure Proxy Protocol on both sides. Not doing so could introduce a security risk in your system (enabling request forgery).","title":"ProxyProtocol"},{"location":"routing/overview/","text":"Overview \u00b6 What's Happening to the Requests? Let's zoom in on Traefik's architecture and talk about the components that enable the routes to be created. First, when you start Traefik, you define entrypoints (in their most basic forms, they are port numbers). Then, connected to these entrypoints, routers analyze the incoming requests to see if they match a set of rules . If they do, the router might transform the request using pieces of middleware before forwarding them to your services . Clear Responsibilities \u00b6 Providers discover the services that live on your infrastructure (their IP, health, ...) Entrypoints listen for incoming traffic (ports, ...) Routers analyse the requests (host, path, headers, SSL, ...) Services forward the request to your services (load balancing, ...) Middlewares may update the request or make decisions based on the request (authentication, rate limiting, headers, ...) Example with a File Provider \u00b6 Below is an example of a full configuration file for the file provider that forwards http://domain/whoami/ requests to a service reachable on http://private/whoami-service/ . In the process, Traefik will make sure that the user is authenticated (using the BasicAuth middleware ). Static configuration: File (TOML) [entryPoints] [entryPoints.web] # Listen on port 8081 for incoming requests address = \":8081\" [providers] # Enable the file provider to define routers / middlewares / services in file [providers.file] directory = \"/path/to/dynamic/conf\" File (YAML) entryPoints: web: # Listen on port 8081 for incoming requests address: :8081 providers: # Enable the file provider to define routers / middlewares / services in file file: directory: /path/to/dynamic/conf CLI # Listen on port 8081 for incoming requests --entryPoints.web.address=:8081 # Enable the file provider to define routers / middlewares / services in file --providers.file.directory=/path/to/dynamic/conf Dynamic configuration: TOML # http routing section [http] [http.routers] # Define a connection between requests and services [http.routers.to-whoami] rule = \"Host(`domain`) && PathPrefix(`/whoami/`)\" # If the rule matches, applies the middleware middlewares = [\"test-user\"] # If the rule matches, forward to the whoami service (declared below) service = \"whoami\" [http.middlewares] # Define an authentication mechanism [http.middlewares.test-user.basicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.services] # Define how to reach an existing service on our infrastructure [http.services.whoami.loadBalancer] [[http.services.whoami.loadBalancer.servers]] url = \"http://private/whoami-service\" YAML # http routing section http: routers: # Define a connection between requests and services to-whoami: rule: \"Host(`domain`) && PathPrefix(`/whoami/`)\" # If the rule matches, applies the middleware middlewares: - test-user # If the rule matches, forward to the whoami service (declared below) service: whoami middlewares: # Define an authentication mechanism test-user: basicAuth: users: - test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ services: # Define how to reach an existing service on our infrastructure whoami: loadBalancer: servers: - url: http://private/whoami-service In this example, we use the file provider . Even if it is one of the least magical way of configuring Traefik, it explicitly describes every available notion. HTTP / TCP In this example, we've defined routing rules for http requests only. Traefik also supports TCP requests. To add TCP routers and TCP services , declare them in a TCP section like in the following. Adding a TCP route for TLS requests on whoami.traefik.io Static Configuration File (TOML) [entryPoints] [entryPoints.web] # Listen on port 8081 for incoming requests address = \":8081\" [providers] # Enable the file provider to define routers / middlewares / services in file [providers.file] directory = \"/path/to/dynamic/conf\" File (YAML) entryPoints: web: # Listen on port 8081 for incoming requests address: :8081 providers: # Enable the file provider to define routers / middlewares / services in file file: directory: /path/to/dynamic/conf CLI # Listen on port 8081 for incoming requests --entryPoints.web.address=:8081 # Enable the file provider to define routers / middlewares / services in file --providers.file.directory=/path/to/dynamic/conf Dynamic Configuration TOML # http routing section [http] [http.routers] # Define a connection between requests and services [http.routers.to-whoami] rule = \"Host(`domain`) && PathPrefix(`/whoami/`)\" # If the rule matches, applies the middleware middlewares = [\"test-user\"] # If the rule matches, forward to the whoami service (declared below) service = \"whoami\" [http.middlewares] # Define an authentication mechanism [http.middlewares.test-user.basicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.services] # Define how to reach an existing service on our infrastructure [http.services.whoami.loadBalancer] [[http.services.whoami.loadBalancer.servers]] url = \"http://private/whoami-service\" [tcp] [tcp.routers] [tcp.routers.to-whoami-tcp] rule = \"HostSNI(`whoami-tcp.traefik.io`)\" service = \"whoami-tcp\" [tcp.routers.to-whoami-tcp.tls] [tcp.services] [tcp.services.whoami-tcp.loadBalancer] [[tcp.services.whoami-tcp.loadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" YAML # http routing section http: routers: # Define a connection between requests and services to-whoami: rule: Host(`domain`) && PathPrefix(`/whoami/`) # If the rule matches, applies the middleware middlewares: - test-user # If the rule matches, forward to the whoami service (declared below) service: whoami middlewares: # Define an authentication mechanism test-user: basicAuth: users: - test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ services: # Define how to reach an existing service on our infrastructure whoami: loadBalancer: servers: - url: http://private/whoami-service tcp: routers: to-whoami-tcp: service: whoami-tcp rule: HostSNI(`whoami-tcp.traefik.io`) services: whoami-tcp: loadBalancer: servers: - address: xx.xx.xx.xx:xx Transport configuration \u00b6 Most of what happens to the connection between the clients and Traefik, and then between Traefik and the backend servers, is configured through the entrypoints and the routers . In addition, a few parameters are dedicated to configuring globally what happens with the connections between Traefik and the backends. This is done through the serversTransport section of the configuration, which features these options: insecureSkipVerify \u00b6 Optional, Default=false insecureSkipVerify disables SSL certificate verification. File (TOML) ## Static configuration [serversTransport] insecureSkipVerify = true File (YAML) ## Static configuration serversTransport: insecureSkipVerify: true CLI ## Static configuration --serversTransport.insecureSkipVerify=true rootCAs \u00b6 Optional rootCAs is the list of certificates (as file paths, or data bytes) that will be set as Root Certificate Authorities when using a self-signed TLS certificate. File (TOML) ## Static configuration [serversTransport] rootCAs = [\"foo.crt\", \"bar.crt\"] File (YAML) ## Static configuration serversTransport: rootCAs: - foo.crt - bar.crt CLI ## Static configuration --serversTransport.rootCAs=foo.crt,bar.crt maxIdleConnsPerHost \u00b6 Optional, Default=2 If non-zero, maxIdleConnsPerHost controls the maximum idle (keep-alive) connections to keep per-host. File (TOML) ## Static configuration [serversTransport] maxIdleConnsPerHost = 7 File (YAML) ## Static configuration serversTransport: maxIdleConnsPerHost: 7 CLI ## Static configuration --serversTransport.maxIdleConnsPerHost=7 forwardingTimeouts \u00b6 forwardingTimeouts is about a number of timeouts relevant to when forwarding requests to the backend servers. forwardingTimeouts.dialTimeout` \u00b6 Optional, Default=30s dialTimeout is the maximum duration allowed for a connection to a backend server to be established. Zero means no timeout. File (TOML) ## Static configuration [serversTransport.forwardingTimeouts] dialTimeout = \"1s\" File (YAML) ## Static configuration serversTransport: forwardingTimeouts: dialTimeout: 1s CLI ## Static configuration --serversTransport.forwardingTimeouts.dialTimeout=1s forwardingTimeouts.responseHeaderTimeout` \u00b6 Optional, Default=0s responseHeaderTimeout , if non-zero, specifies the amount of time to wait for a server's response headers after fully writing the request (including its body, if any). This time does not include the time to read the response body. Zero means no timeout. File (TOML) ## Static configuration [serversTransport.forwardingTimeouts] responseHeaderTimeout = \"1s\" File (YAML) ## Static configuration serversTransport: forwardingTimeouts: responseHeaderTimeout: 1s CLI ## Static configuration --serversTransport.forwardingTimeouts.responseHeaderTimeout=1s forwardingTimeouts.idleConnTimeout` \u00b6 Optional, Default=90s idleConnTimeout , is the maximum amount of time an idle (keep-alive) connection will remain idle before closing itself. Zero means no limit. File (TOML) ## Static configuration [serversTransport.forwardingTimeouts] idleConnTimeout = \"1s\" File (YAML) ## Static configuration serversTransport: forwardingTimeouts: idleConnTimeout: 1s CLI ## Static configuration --serversTransport.forwardingTimeouts.idleConnTimeout=1s","title":"Overview"},{"location":"routing/overview/#overview","text":"What's Happening to the Requests? Let's zoom in on Traefik's architecture and talk about the components that enable the routes to be created. First, when you start Traefik, you define entrypoints (in their most basic forms, they are port numbers). Then, connected to these entrypoints, routers analyze the incoming requests to see if they match a set of rules . If they do, the router might transform the request using pieces of middleware before forwarding them to your services .","title":"Overview"},{"location":"routing/overview/#clear-responsibilities","text":"Providers discover the services that live on your infrastructure (their IP, health, ...) Entrypoints listen for incoming traffic (ports, ...) Routers analyse the requests (host, path, headers, SSL, ...) Services forward the request to your services (load balancing, ...) Middlewares may update the request or make decisions based on the request (authentication, rate limiting, headers, ...)","title":"Clear Responsibilities"},{"location":"routing/overview/#example-with-a-file-provider","text":"Below is an example of a full configuration file for the file provider that forwards http://domain/whoami/ requests to a service reachable on http://private/whoami-service/ . In the process, Traefik will make sure that the user is authenticated (using the BasicAuth middleware ). Static configuration: File (TOML) [entryPoints] [entryPoints.web] # Listen on port 8081 for incoming requests address = \":8081\" [providers] # Enable the file provider to define routers / middlewares / services in file [providers.file] directory = \"/path/to/dynamic/conf\" File (YAML) entryPoints: web: # Listen on port 8081 for incoming requests address: :8081 providers: # Enable the file provider to define routers / middlewares / services in file file: directory: /path/to/dynamic/conf CLI # Listen on port 8081 for incoming requests --entryPoints.web.address=:8081 # Enable the file provider to define routers / middlewares / services in file --providers.file.directory=/path/to/dynamic/conf Dynamic configuration: TOML # http routing section [http] [http.routers] # Define a connection between requests and services [http.routers.to-whoami] rule = \"Host(`domain`) && PathPrefix(`/whoami/`)\" # If the rule matches, applies the middleware middlewares = [\"test-user\"] # If the rule matches, forward to the whoami service (declared below) service = \"whoami\" [http.middlewares] # Define an authentication mechanism [http.middlewares.test-user.basicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.services] # Define how to reach an existing service on our infrastructure [http.services.whoami.loadBalancer] [[http.services.whoami.loadBalancer.servers]] url = \"http://private/whoami-service\" YAML # http routing section http: routers: # Define a connection between requests and services to-whoami: rule: \"Host(`domain`) && PathPrefix(`/whoami/`)\" # If the rule matches, applies the middleware middlewares: - test-user # If the rule matches, forward to the whoami service (declared below) service: whoami middlewares: # Define an authentication mechanism test-user: basicAuth: users: - test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ services: # Define how to reach an existing service on our infrastructure whoami: loadBalancer: servers: - url: http://private/whoami-service In this example, we use the file provider . Even if it is one of the least magical way of configuring Traefik, it explicitly describes every available notion. HTTP / TCP In this example, we've defined routing rules for http requests only. Traefik also supports TCP requests. To add TCP routers and TCP services , declare them in a TCP section like in the following. Adding a TCP route for TLS requests on whoami.traefik.io Static Configuration File (TOML) [entryPoints] [entryPoints.web] # Listen on port 8081 for incoming requests address = \":8081\" [providers] # Enable the file provider to define routers / middlewares / services in file [providers.file] directory = \"/path/to/dynamic/conf\" File (YAML) entryPoints: web: # Listen on port 8081 for incoming requests address: :8081 providers: # Enable the file provider to define routers / middlewares / services in file file: directory: /path/to/dynamic/conf CLI # Listen on port 8081 for incoming requests --entryPoints.web.address=:8081 # Enable the file provider to define routers / middlewares / services in file --providers.file.directory=/path/to/dynamic/conf Dynamic Configuration TOML # http routing section [http] [http.routers] # Define a connection between requests and services [http.routers.to-whoami] rule = \"Host(`domain`) && PathPrefix(`/whoami/`)\" # If the rule matches, applies the middleware middlewares = [\"test-user\"] # If the rule matches, forward to the whoami service (declared below) service = \"whoami\" [http.middlewares] # Define an authentication mechanism [http.middlewares.test-user.basicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.services] # Define how to reach an existing service on our infrastructure [http.services.whoami.loadBalancer] [[http.services.whoami.loadBalancer.servers]] url = \"http://private/whoami-service\" [tcp] [tcp.routers] [tcp.routers.to-whoami-tcp] rule = \"HostSNI(`whoami-tcp.traefik.io`)\" service = \"whoami-tcp\" [tcp.routers.to-whoami-tcp.tls] [tcp.services] [tcp.services.whoami-tcp.loadBalancer] [[tcp.services.whoami-tcp.loadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" YAML # http routing section http: routers: # Define a connection between requests and services to-whoami: rule: Host(`domain`) && PathPrefix(`/whoami/`) # If the rule matches, applies the middleware middlewares: - test-user # If the rule matches, forward to the whoami service (declared below) service: whoami middlewares: # Define an authentication mechanism test-user: basicAuth: users: - test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ services: # Define how to reach an existing service on our infrastructure whoami: loadBalancer: servers: - url: http://private/whoami-service tcp: routers: to-whoami-tcp: service: whoami-tcp rule: HostSNI(`whoami-tcp.traefik.io`) services: whoami-tcp: loadBalancer: servers: - address: xx.xx.xx.xx:xx","title":"Example with a File Provider"},{"location":"routing/overview/#transport-configuration","text":"Most of what happens to the connection between the clients and Traefik, and then between Traefik and the backend servers, is configured through the entrypoints and the routers . In addition, a few parameters are dedicated to configuring globally what happens with the connections between Traefik and the backends. This is done through the serversTransport section of the configuration, which features these options:","title":"Transport configuration"},{"location":"routing/overview/#insecureskipverify","text":"Optional, Default=false insecureSkipVerify disables SSL certificate verification. File (TOML) ## Static configuration [serversTransport] insecureSkipVerify = true File (YAML) ## Static configuration serversTransport: insecureSkipVerify: true CLI ## Static configuration --serversTransport.insecureSkipVerify=true","title":"insecureSkipVerify"},{"location":"routing/overview/#rootcas","text":"Optional rootCAs is the list of certificates (as file paths, or data bytes) that will be set as Root Certificate Authorities when using a self-signed TLS certificate. File (TOML) ## Static configuration [serversTransport] rootCAs = [\"foo.crt\", \"bar.crt\"] File (YAML) ## Static configuration serversTransport: rootCAs: - foo.crt - bar.crt CLI ## Static configuration --serversTransport.rootCAs=foo.crt,bar.crt","title":"rootCAs"},{"location":"routing/overview/#maxidleconnsperhost","text":"Optional, Default=2 If non-zero, maxIdleConnsPerHost controls the maximum idle (keep-alive) connections to keep per-host. File (TOML) ## Static configuration [serversTransport] maxIdleConnsPerHost = 7 File (YAML) ## Static configuration serversTransport: maxIdleConnsPerHost: 7 CLI ## Static configuration --serversTransport.maxIdleConnsPerHost=7","title":"maxIdleConnsPerHost"},{"location":"routing/overview/#forwardingtimeouts","text":"forwardingTimeouts is about a number of timeouts relevant to when forwarding requests to the backend servers.","title":"forwardingTimeouts"},{"location":"routing/overview/#forwardingtimeoutsdialtimeout","text":"Optional, Default=30s dialTimeout is the maximum duration allowed for a connection to a backend server to be established. Zero means no timeout. File (TOML) ## Static configuration [serversTransport.forwardingTimeouts] dialTimeout = \"1s\" File (YAML) ## Static configuration serversTransport: forwardingTimeouts: dialTimeout: 1s CLI ## Static configuration --serversTransport.forwardingTimeouts.dialTimeout=1s","title":"forwardingTimeouts.dialTimeout`"},{"location":"routing/overview/#forwardingtimeoutsresponseheadertimeout","text":"Optional, Default=0s responseHeaderTimeout , if non-zero, specifies the amount of time to wait for a server's response headers after fully writing the request (including its body, if any). This time does not include the time to read the response body. Zero means no timeout. File (TOML) ## Static configuration [serversTransport.forwardingTimeouts] responseHeaderTimeout = \"1s\" File (YAML) ## Static configuration serversTransport: forwardingTimeouts: responseHeaderTimeout: 1s CLI ## Static configuration --serversTransport.forwardingTimeouts.responseHeaderTimeout=1s","title":"forwardingTimeouts.responseHeaderTimeout`"},{"location":"routing/overview/#forwardingtimeoutsidleconntimeout","text":"Optional, Default=90s idleConnTimeout , is the maximum amount of time an idle (keep-alive) connection will remain idle before closing itself. Zero means no limit. File (TOML) ## Static configuration [serversTransport.forwardingTimeouts] idleConnTimeout = \"1s\" File (YAML) ## Static configuration serversTransport: forwardingTimeouts: idleConnTimeout: 1s CLI ## Static configuration --serversTransport.forwardingTimeouts.idleConnTimeout=1s","title":"forwardingTimeouts.idleConnTimeout`"},{"location":"routing/providers/docker/","text":"Traefik & Docker \u00b6 A Story of Labels & Containers Attach labels to your containers and let Traefik do the rest! Configuration Examples \u00b6 Configuring Docker & Deploying / Exposing Services Enabling the docker provider File (TOML) [providers.docker] File (YAML) providers: docker: {} CLI --providers.docker=true Attaching labels to containers (in your docker compose file) version: \"3\" services: my-container: # ... labels: - traefik.http.routers.my-container.rule=Host(`mydomain.com`) Specify a Custom Port for the Container Forward requests for http://mydomain.com to http://<private IP of container>:12345 : version: \"3\" services: my-container: # ... labels: - traefik.http.routers.my-container.rule=Host(`mydomain.com`) # Tell Traefik to use the port 12345 to connect to `my-container` - traefik.http.services.my-service.loadbalancer.server.port=12345 Traefik Connecting to the Wrong Port: HTTP/502 Gateway Error By default, Traefik uses the first exposed port of a container. Setting the label traefik.http.services.xxx.loadbalancer.server.port overrides that behavior. Configuring Docker Swarm & Deploying / Exposing Services Enabling the docker provider (Swarm Mode) File (TOML) [providers.docker] # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint = \"tcp://127.0.0.1:2377\" swarmMode = true File (YAML) providers: docker: # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint: \"tcp://127.0.0.1:2375\" swarmMode: true CLI --providers.docker.endpoint=tcp://127.0.0.1:2375 --providers.docker.swarmMode=true Attach labels to services (not to containers) while in Swarm mode (in your docker compose file) version: \"3\" services: my-container: deploy: labels: - traefik.http.routers.my-container.rule=Host(`mydomain.com`) - traefik.http.services.my-container-service.loadbalancer.server.port=8080 Labels in Docker Swarm Mode While in Swarm Mode, Traefik uses labels found on services, not on individual containers. Therefore, if you use a compose file with Swarm Mode, labels should be defined in the deploy part of your service. This behavior is only enabled for docker-compose version 3+ ( Compose file reference ). Routing Configuration \u00b6 Labels Labels are case insensitive. The complete list of labels can be found in the reference page . General \u00b6 Traefik creates, for each container, a corresponding service and router . The Service automatically gets a server per instance of the container, and the router automatically gets a rule defined by defaultRule (if no rule for it was defined in labels). Service definition \u00b6 In general when configuring a Traefik provider, a service assigned to one (or several) router(s) must be defined as well for the routing to be functional. There are, however, exceptions when using label-based configurations: If a label defines a router (e.g. through a router Rule) and a label defines a service (e.g. implicitly through a loadbalancer server port value), but the router does not specify any service, then that service is automatically assigned to the router. If a label defines a router (e.g. through a router Rule) but no service is defined, then a service is automatically created and assigned to the router. As one would expect, in either of these cases, if in addition a service is specified for the router, then that service is the one assigned, regardless of whether it actually is defined or whatever else other services are defined. Automatic service assignment with labels With labels in a compose file labels: - \"traefik.http.routers.myproxy.rule=Host(`foo.com`)\" # service myservice gets automatically assigned to router myproxy - \"traefik.http.services.myservice.loadbalancer.server.port=80\" Automatic service creation and assignment with labels With labels in a compose file labels: # no service specified or defined and yet one gets automatically created # and assigned to router myproxy. - \"traefik.http.routers.myproxy.rule=Host(`foo.com`)\" Routers \u00b6 To update the configuration of the Router automatically attached to the container, add labels starting with traefik.http.routers.<name-of-your-choice>. and followed by the option you want to change. For example, to change the rule, you could add the label traefik.http.routers.my-container.rule=Host(`mydomain.com`) . The character @ is not authorized in the router name <router_name> . traefik.http.routers.<router_name>.rule See rule for more information. - \"traefik.http.routers.myrouter.rule=Host(`mydomain.com`)\" traefik.http.routers.<router_name>.entrypoints See entry points for more information. - \"traefik.http.routers.myrouter.entrypoints=ep1,ep2\" traefik.http.routers.<router_name>.middlewares See middlewares and middlewares overview for more information. - \"traefik.http.routers.myrouter.middlewares=auth,prefix,cb\" traefik.http.routers.<router_name>.service See rule for more information. - \"traefik.http.routers.myrouter.service=myservice\" traefik.http.routers.<router_name>.tls See tls for more information. - \"traefik.http.routers.myrouter.tls=true\" traefik.http.routers.<router_name>.tls.certresolver See certResolver for more information. - \"traefik.http.routers.myrouter.tls.certresolver=myresolver\" traefik.http.routers.<router_name>.tls.domains[n].main See domains for more information. - \"traefik.http.routers.myrouter.tls.domains[0].main=foobar.com\" traefik.http.routers.<router_name>.tls.domains[n].sans See domains for more information. - \"traefik.http.routers.myrouter.tls.domains[0].sans=test.foobar.com,dev.foobar.com\" traefik.http.routers.<router_name>.tls.options See options for more information. - \"traefik.http.routers.myrouter.tls.options=foobar\" traefik.http.routers.<router_name>.priority See priority for more information. - \"traefik.http.routers.myrouter.priority=42\" Services \u00b6 To update the configuration of the Service automatically attached to the container, add labels starting with traefik.http.services.<name-of-your-choice>. , followed by the option you want to change. For example, to change the passHostHeader behavior, you'd add the label traefik.http.services.<name-of-your-choice>.loadbalancer.passhostheader=false . The character @ is not authorized in the service name <service_name> . traefik.http.services.<service_name>.loadbalancer.server.port Registers a port. Useful when the container exposes multiples ports. Mandatory for Docker Swarm (see the section \"Port Detection with Docker Swarm\" ). - \"traefik.http.services.myservice.loadbalancer.server.port=8080\" traefik.http.services.<service_name>.loadbalancer.server.scheme Overrides the default scheme. - \"traefik.http.services.myservice.loadbalancer.server.scheme=http\" traefik.http.services.<service_name>.loadbalancer.passhostheader See pass Host header for more information. - \"traefik.http.services.myservice.loadbalancer.passhostheader=true\" traefik.http.services.<service_name>.loadbalancer.healthcheck.headers.<header_name> See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.headers.X-Foo=foobar\" traefik.http.services.<service_name>.loadbalancer.healthcheck.hostname See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.hostname=foobar.com\" traefik.http.services.<service_name>.loadbalancer.healthcheck.interval See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.interval=10\" traefik.http.services.<service_name>.loadbalancer.healthcheck.path See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.path=/foo\" traefik.http.services.<service_name>.loadbalancer.healthcheck.port See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.port=42\" traefik.http.services.<service_name>.loadbalancer.healthcheck.scheme See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.scheme=http\" traefik.http.services.<service_name>.loadbalancer.healthcheck.timeout See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.timeout=10\" traefik.http.services.<service_name>.loadbalancer.sticky See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky=true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.httponly See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.httponly=true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.name See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.name=foobar\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.secure See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.secure=true\" traefik.http.services.<service_name>.loadbalancer.responseforwarding.flushinterval See response forwarding for more information. - \"traefik.http.services.myservice.loadbalancer.responseforwarding.flushinterval=10\" Middleware \u00b6 You can declare pieces of middleware using labels starting with traefik.http.middlewares.<name-of-your-choice>. , followed by the middleware type/options. For example, to declare a middleware redirectscheme named my-redirect , you'd write traefik.http.middlewares.my-redirect.redirectscheme.scheme=https . More information about available middlewares in the dedicated middlewares section . The character @ is not authorized in the middleware name. Declaring and Referencing a Middleware services: my-container: # ... labels: # Declaring a middleware - traefik.http.middlewares.my-redirect.redirectscheme.scheme=https # Referencing a middleware - traefik.http.routers.my-container.middlewares=my-redirect Conflicts in Declaration If you declare multiple middleware with the same name but with different parameters, the middleware fails to be declared. TCP \u00b6 You can declare TCP Routers and/or Services using labels. Declaring TCP Routers and Services services: my-container: # ... labels: - \"traefik.tcp.routers.my-router.rule=HostSNI(`my-host.com`)\" - \"traefik.tcp.routers.my-router.tls=true\" - \"traefik.tcp.services.my-service.loadbalancer.server.port=4123\" TCP and HTTP If you declare a TCP Router/Service, it will prevent Traefik from automatically creating an HTTP Router/Service (like it does by default if no TCP Router/Service is defined). You can declare both a TCP Router/Service and an HTTP Router/Service for the same container (but you have to do so manually). TCP Routers \u00b6 traefik.tcp.routers.<router_name>.entrypoints See entry points for more information. - \"traefik.tcp.routers.mytcprouter.entrypoints=ep1,ep2\" traefik.tcp.routers.<router_name>.rule See rule for more information. - \"traefik.tcp.routers.mytcprouter.rule=HostSNI(`myhost.com`)\" traefik.tcp.routers.<router_name>.service See service for more information. - \"traefik.tcp.routers.mytcprouter.service=myservice\" traefik.tcp.routers.<router_name>.tls See TLS for more information. - \"traefik.tcp.routers.mytcprouter.tls=true\" traefik.tcp.routers.<router_name>.tls.certresolver See certResolver for more information. - \"traefik.tcp.routers.mytcprouter.tls.certresolver=myresolver\" traefik.tcp.routers.<router_name>.tls.domains[n].main See domains for more information. - \"traefik.tcp.routers.mytcprouter.tls.domains[0].main=foobar.com\" traefik.tcp.routers.<router_name>.tls.domains[n].sans See domains for more information. - \"traefik.tcp.routers.mytcprouter.tls.domains[0].sans=test.foobar.com,dev.foobar.com\" traefik.tcp.routers.<router_name>.tls.options See options for more information. - \"traefik.tcp.routers.mytcprouter.tls.options=mysoptions\" traefik.tcp.routers.<router_name>.tls.passthrough See TLS for more information. - \"traefik.tcp.routers.mytcprouter.tls.passthrough=true\" TCP Services \u00b6 traefik.tcp.services.<service_name>.loadbalancer.server.port Registers a port of the application. - \"traefik.tcp.services.mytcpservice.loadbalancer.server.port=423\" traefik.tcp.services.<service_name>.loadbalancer.terminationdelay See termination delay for more information. - \"traefik.tcp.services.mytcpservice.loadbalancer.terminationdelay=100\" Specific Provider Options \u00b6 traefik.enable \u00b6 - \"traefik.enable=true\" You can tell Traefik to consider (or not) the container by setting traefik.enable to true or false. This option overrides the value of exposedByDefault . traefik.docker.network \u00b6 - \"traefik.docker.network=mynetwork\" Overrides the default docker network to use for connections to the container. If a container is linked to several networks, be sure to set the proper network name (you can check this with docker inspect <container_id> ), otherwise it will randomly pick one (depending on how docker is returning them). Warning When deploying a stack from a compose file stack , the networks defined are prefixed with stack . traefik.docker.lbswarm \u00b6 - \"traefik.docker.lbswarm=true\" Enables Swarm's inbuilt load balancer (only relevant in Swarm Mode). If you enable this option, Traefik will use the virtual IP provided by docker swarm instead of the containers IPs. Which means that Traefik will not perform any kind of load balancing and will delegate this task to swarm.","title":"Docker"},{"location":"routing/providers/docker/#traefik-docker","text":"A Story of Labels & Containers Attach labels to your containers and let Traefik do the rest!","title":"Traefik &amp; Docker"},{"location":"routing/providers/docker/#configuration-examples","text":"Configuring Docker & Deploying / Exposing Services Enabling the docker provider File (TOML) [providers.docker] File (YAML) providers: docker: {} CLI --providers.docker=true Attaching labels to containers (in your docker compose file) version: \"3\" services: my-container: # ... labels: - traefik.http.routers.my-container.rule=Host(`mydomain.com`) Specify a Custom Port for the Container Forward requests for http://mydomain.com to http://<private IP of container>:12345 : version: \"3\" services: my-container: # ... labels: - traefik.http.routers.my-container.rule=Host(`mydomain.com`) # Tell Traefik to use the port 12345 to connect to `my-container` - traefik.http.services.my-service.loadbalancer.server.port=12345 Traefik Connecting to the Wrong Port: HTTP/502 Gateway Error By default, Traefik uses the first exposed port of a container. Setting the label traefik.http.services.xxx.loadbalancer.server.port overrides that behavior. Configuring Docker Swarm & Deploying / Exposing Services Enabling the docker provider (Swarm Mode) File (TOML) [providers.docker] # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint = \"tcp://127.0.0.1:2377\" swarmMode = true File (YAML) providers: docker: # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint: \"tcp://127.0.0.1:2375\" swarmMode: true CLI --providers.docker.endpoint=tcp://127.0.0.1:2375 --providers.docker.swarmMode=true Attach labels to services (not to containers) while in Swarm mode (in your docker compose file) version: \"3\" services: my-container: deploy: labels: - traefik.http.routers.my-container.rule=Host(`mydomain.com`) - traefik.http.services.my-container-service.loadbalancer.server.port=8080 Labels in Docker Swarm Mode While in Swarm Mode, Traefik uses labels found on services, not on individual containers. Therefore, if you use a compose file with Swarm Mode, labels should be defined in the deploy part of your service. This behavior is only enabled for docker-compose version 3+ ( Compose file reference ).","title":"Configuration Examples"},{"location":"routing/providers/docker/#routing-configuration","text":"Labels Labels are case insensitive. The complete list of labels can be found in the reference page .","title":"Routing Configuration"},{"location":"routing/providers/docker/#general","text":"Traefik creates, for each container, a corresponding service and router . The Service automatically gets a server per instance of the container, and the router automatically gets a rule defined by defaultRule (if no rule for it was defined in labels).","title":"General"},{"location":"routing/providers/docker/#service-definition","text":"In general when configuring a Traefik provider, a service assigned to one (or several) router(s) must be defined as well for the routing to be functional. There are, however, exceptions when using label-based configurations: If a label defines a router (e.g. through a router Rule) and a label defines a service (e.g. implicitly through a loadbalancer server port value), but the router does not specify any service, then that service is automatically assigned to the router. If a label defines a router (e.g. through a router Rule) but no service is defined, then a service is automatically created and assigned to the router. As one would expect, in either of these cases, if in addition a service is specified for the router, then that service is the one assigned, regardless of whether it actually is defined or whatever else other services are defined. Automatic service assignment with labels With labels in a compose file labels: - \"traefik.http.routers.myproxy.rule=Host(`foo.com`)\" # service myservice gets automatically assigned to router myproxy - \"traefik.http.services.myservice.loadbalancer.server.port=80\" Automatic service creation and assignment with labels With labels in a compose file labels: # no service specified or defined and yet one gets automatically created # and assigned to router myproxy. - \"traefik.http.routers.myproxy.rule=Host(`foo.com`)\"","title":"Service definition"},{"location":"routing/providers/docker/#routers","text":"To update the configuration of the Router automatically attached to the container, add labels starting with traefik.http.routers.<name-of-your-choice>. and followed by the option you want to change. For example, to change the rule, you could add the label traefik.http.routers.my-container.rule=Host(`mydomain.com`) . The character @ is not authorized in the router name <router_name> . traefik.http.routers.<router_name>.rule See rule for more information. - \"traefik.http.routers.myrouter.rule=Host(`mydomain.com`)\" traefik.http.routers.<router_name>.entrypoints See entry points for more information. - \"traefik.http.routers.myrouter.entrypoints=ep1,ep2\" traefik.http.routers.<router_name>.middlewares See middlewares and middlewares overview for more information. - \"traefik.http.routers.myrouter.middlewares=auth,prefix,cb\" traefik.http.routers.<router_name>.service See rule for more information. - \"traefik.http.routers.myrouter.service=myservice\" traefik.http.routers.<router_name>.tls See tls for more information. - \"traefik.http.routers.myrouter.tls=true\" traefik.http.routers.<router_name>.tls.certresolver See certResolver for more information. - \"traefik.http.routers.myrouter.tls.certresolver=myresolver\" traefik.http.routers.<router_name>.tls.domains[n].main See domains for more information. - \"traefik.http.routers.myrouter.tls.domains[0].main=foobar.com\" traefik.http.routers.<router_name>.tls.domains[n].sans See domains for more information. - \"traefik.http.routers.myrouter.tls.domains[0].sans=test.foobar.com,dev.foobar.com\" traefik.http.routers.<router_name>.tls.options See options for more information. - \"traefik.http.routers.myrouter.tls.options=foobar\" traefik.http.routers.<router_name>.priority See priority for more information. - \"traefik.http.routers.myrouter.priority=42\"","title":"Routers"},{"location":"routing/providers/docker/#services","text":"To update the configuration of the Service automatically attached to the container, add labels starting with traefik.http.services.<name-of-your-choice>. , followed by the option you want to change. For example, to change the passHostHeader behavior, you'd add the label traefik.http.services.<name-of-your-choice>.loadbalancer.passhostheader=false . The character @ is not authorized in the service name <service_name> . traefik.http.services.<service_name>.loadbalancer.server.port Registers a port. Useful when the container exposes multiples ports. Mandatory for Docker Swarm (see the section \"Port Detection with Docker Swarm\" ). - \"traefik.http.services.myservice.loadbalancer.server.port=8080\" traefik.http.services.<service_name>.loadbalancer.server.scheme Overrides the default scheme. - \"traefik.http.services.myservice.loadbalancer.server.scheme=http\" traefik.http.services.<service_name>.loadbalancer.passhostheader See pass Host header for more information. - \"traefik.http.services.myservice.loadbalancer.passhostheader=true\" traefik.http.services.<service_name>.loadbalancer.healthcheck.headers.<header_name> See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.headers.X-Foo=foobar\" traefik.http.services.<service_name>.loadbalancer.healthcheck.hostname See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.hostname=foobar.com\" traefik.http.services.<service_name>.loadbalancer.healthcheck.interval See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.interval=10\" traefik.http.services.<service_name>.loadbalancer.healthcheck.path See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.path=/foo\" traefik.http.services.<service_name>.loadbalancer.healthcheck.port See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.port=42\" traefik.http.services.<service_name>.loadbalancer.healthcheck.scheme See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.scheme=http\" traefik.http.services.<service_name>.loadbalancer.healthcheck.timeout See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.timeout=10\" traefik.http.services.<service_name>.loadbalancer.sticky See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky=true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.httponly See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.httponly=true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.name See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.name=foobar\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.secure See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.secure=true\" traefik.http.services.<service_name>.loadbalancer.responseforwarding.flushinterval See response forwarding for more information. - \"traefik.http.services.myservice.loadbalancer.responseforwarding.flushinterval=10\"","title":"Services"},{"location":"routing/providers/docker/#middleware","text":"You can declare pieces of middleware using labels starting with traefik.http.middlewares.<name-of-your-choice>. , followed by the middleware type/options. For example, to declare a middleware redirectscheme named my-redirect , you'd write traefik.http.middlewares.my-redirect.redirectscheme.scheme=https . More information about available middlewares in the dedicated middlewares section . The character @ is not authorized in the middleware name. Declaring and Referencing a Middleware services: my-container: # ... labels: # Declaring a middleware - traefik.http.middlewares.my-redirect.redirectscheme.scheme=https # Referencing a middleware - traefik.http.routers.my-container.middlewares=my-redirect Conflicts in Declaration If you declare multiple middleware with the same name but with different parameters, the middleware fails to be declared.","title":"Middleware"},{"location":"routing/providers/docker/#tcp","text":"You can declare TCP Routers and/or Services using labels. Declaring TCP Routers and Services services: my-container: # ... labels: - \"traefik.tcp.routers.my-router.rule=HostSNI(`my-host.com`)\" - \"traefik.tcp.routers.my-router.tls=true\" - \"traefik.tcp.services.my-service.loadbalancer.server.port=4123\" TCP and HTTP If you declare a TCP Router/Service, it will prevent Traefik from automatically creating an HTTP Router/Service (like it does by default if no TCP Router/Service is defined). You can declare both a TCP Router/Service and an HTTP Router/Service for the same container (but you have to do so manually).","title":"TCP"},{"location":"routing/providers/docker/#tcp-routers","text":"traefik.tcp.routers.<router_name>.entrypoints See entry points for more information. - \"traefik.tcp.routers.mytcprouter.entrypoints=ep1,ep2\" traefik.tcp.routers.<router_name>.rule See rule for more information. - \"traefik.tcp.routers.mytcprouter.rule=HostSNI(`myhost.com`)\" traefik.tcp.routers.<router_name>.service See service for more information. - \"traefik.tcp.routers.mytcprouter.service=myservice\" traefik.tcp.routers.<router_name>.tls See TLS for more information. - \"traefik.tcp.routers.mytcprouter.tls=true\" traefik.tcp.routers.<router_name>.tls.certresolver See certResolver for more information. - \"traefik.tcp.routers.mytcprouter.tls.certresolver=myresolver\" traefik.tcp.routers.<router_name>.tls.domains[n].main See domains for more information. - \"traefik.tcp.routers.mytcprouter.tls.domains[0].main=foobar.com\" traefik.tcp.routers.<router_name>.tls.domains[n].sans See domains for more information. - \"traefik.tcp.routers.mytcprouter.tls.domains[0].sans=test.foobar.com,dev.foobar.com\" traefik.tcp.routers.<router_name>.tls.options See options for more information. - \"traefik.tcp.routers.mytcprouter.tls.options=mysoptions\" traefik.tcp.routers.<router_name>.tls.passthrough See TLS for more information. - \"traefik.tcp.routers.mytcprouter.tls.passthrough=true\"","title":"TCP Routers"},{"location":"routing/providers/docker/#tcp-services","text":"traefik.tcp.services.<service_name>.loadbalancer.server.port Registers a port of the application. - \"traefik.tcp.services.mytcpservice.loadbalancer.server.port=423\" traefik.tcp.services.<service_name>.loadbalancer.terminationdelay See termination delay for more information. - \"traefik.tcp.services.mytcpservice.loadbalancer.terminationdelay=100\"","title":"TCP Services"},{"location":"routing/providers/docker/#specific-provider-options","text":"","title":"Specific Provider Options"},{"location":"routing/providers/docker/#traefikenable","text":"- \"traefik.enable=true\" You can tell Traefik to consider (or not) the container by setting traefik.enable to true or false. This option overrides the value of exposedByDefault .","title":"traefik.enable"},{"location":"routing/providers/docker/#traefikdockernetwork","text":"- \"traefik.docker.network=mynetwork\" Overrides the default docker network to use for connections to the container. If a container is linked to several networks, be sure to set the proper network name (you can check this with docker inspect <container_id> ), otherwise it will randomly pick one (depending on how docker is returning them). Warning When deploying a stack from a compose file stack , the networks defined are prefixed with stack .","title":"traefik.docker.network"},{"location":"routing/providers/docker/#traefikdockerlbswarm","text":"- \"traefik.docker.lbswarm=true\" Enables Swarm's inbuilt load balancer (only relevant in Swarm Mode). If you enable this option, Traefik will use the virtual IP provided by docker swarm instead of the containers IPs. Which means that Traefik will not perform any kind of load balancing and will delegate this task to swarm.","title":"traefik.docker.lbswarm"},{"location":"routing/providers/kubernetes-crd/","text":"Traefik & Kubernetes \u00b6 The Kubernetes Ingress Controller, The Custom Resource Way. Resource Configuration \u00b6 If you're in a hurry, maybe you'd rather go through the dynamic configuration reference. Traefik IngressRoute definition \u00b6 apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutetcps.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRouteTCP plural: ingressroutetcps singular: ingressroutetcp scope: Namespaced That IngressRoute kind can then be used to define an IngressRoute object, such as in: apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutefoo spec: entryPoints: - web routes: # Match is the rule corresponding to an underlying router. # Later on, match could be the simple form of a path prefix, e.g. just \"/bar\", # but for now we only support a traefik style matching rule. - match: Host(`foo.com`) && PathPrefix(`/bar`) # kind could eventually be one of \"Rule\", \"Path\", \"Host\", \"Method\", \"Header\", # \"Parameter\", etc, to support simpler forms of rule matching, but for now we # only support \"Rule\". kind: Rule # (optional) Priority disambiguates rules of the same length, for route matching. priority: 12 services: - name: whoami port: 80 # (default 1) A weight used by the weighted round-robin strategy (WRR). weight: 1 # (default true) PassHostHeader controls whether to leave the request's Host # Header as it was before it reached the proxy, or whether to let the proxy set it # to the destination (backend) host. passHostHeader: true responseForwarding: # (default 100ms) Interval between flushes of the buffered response body to the client. flushInterval: 100ms --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRouteTCP metadata: name: ingressroutetcpfoo.crd spec: entryPoints: - footcp routes: # Match is the rule corresponding to an underlying router. - match: HostSNI(`*`) services: - name: whoamitcp port: 8080 Middleware \u00b6 Additionally, to allow for the use of middlewares in an IngressRoute , we defined the CRD below for the Middleware kind. apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced Once the Middleware kind has been registered with the Kubernetes cluster, it can then be used in IngressRoute definitions, such as: apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: stripprefix namespace: foo spec: stripPrefix: prefixes: - /stripit --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutebar spec: entryPoints: - web routes: - match: Host(`bar.com`) && PathPrefix(`/stripit`) kind: Rule services: - name: whoami port: 80 middlewares: - name: stripprefix namespace: foo Cross-provider namespace As Kubernetes also has its own notion of namespace, one should not confuse the kubernetes namespace of a resource (in the reference to the middleware) with the provider namespace , when the definition of the middleware is from another provider. In this context, specifying a namespace when referring to the resource does not make any sense, and will be ignored. More information about available middlewares in the dedicated middlewares section . TLS Option \u00b6 Additionally, to allow for the use of TLS options in an IngressRoute, we defined the CRD below for the TLSOption kind. More information about TLS Options is available in the dedicated TLS Configuration Options . apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: tlsoptions.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: TLSOption plural: tlsoptions singular: tlsoption scope: Namespaced Once the TLSOption kind has been registered with the Kubernetes cluster or defined in the File Provider, it can then be used in IngressRoute definitions, such as: apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: mytlsoption namespace: default spec: minVersion: VersionTLS12 --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutebar spec: entryPoints: - web routes: - match: Host(`bar.com`) && PathPrefix(`/stripit`) kind: Rule services: - name: whoami port: 80 tls: options: name: mytlsoption namespace: default References and namespaces If the optional namespace attribute is not set, the configuration will be applied with the namespace of the IngressRoute. Additionally, when the definition of the TLS option is from another provider, the cross-provider syntax ( middlewarename@provider ) should be used to refer to the TLS option, just as in the middleware case . Specifying a namespace attribute in this case would not make any sense, and will be ignored. TLS \u00b6 To allow for TLS, we made use of the Secret kind, as it was already defined, and it can be directly used in an IngressRoute : apiVersion: v1 kind: Secret metadata: name: supersecret data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0= tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0= --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutetls spec: entryPoints: - websecure routes: - match: Host(`foo.com`) && PathPrefix(`/bar`) kind: Rule services: - name: whoami port: 443 tls: secretName: supersecret Further \u00b6 Also see the full example with Let's Encrypt.","title":"Kubernetes IngressRoute"},{"location":"routing/providers/kubernetes-crd/#traefik-kubernetes","text":"The Kubernetes Ingress Controller, The Custom Resource Way.","title":"Traefik &amp; Kubernetes"},{"location":"routing/providers/kubernetes-crd/#resource-configuration","text":"If you're in a hurry, maybe you'd rather go through the dynamic configuration reference.","title":"Resource Configuration"},{"location":"routing/providers/kubernetes-crd/#traefik-ingressroute-definition","text":"apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutetcps.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRouteTCP plural: ingressroutetcps singular: ingressroutetcp scope: Namespaced That IngressRoute kind can then be used to define an IngressRoute object, such as in: apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutefoo spec: entryPoints: - web routes: # Match is the rule corresponding to an underlying router. # Later on, match could be the simple form of a path prefix, e.g. just \"/bar\", # but for now we only support a traefik style matching rule. - match: Host(`foo.com`) && PathPrefix(`/bar`) # kind could eventually be one of \"Rule\", \"Path\", \"Host\", \"Method\", \"Header\", # \"Parameter\", etc, to support simpler forms of rule matching, but for now we # only support \"Rule\". kind: Rule # (optional) Priority disambiguates rules of the same length, for route matching. priority: 12 services: - name: whoami port: 80 # (default 1) A weight used by the weighted round-robin strategy (WRR). weight: 1 # (default true) PassHostHeader controls whether to leave the request's Host # Header as it was before it reached the proxy, or whether to let the proxy set it # to the destination (backend) host. passHostHeader: true responseForwarding: # (default 100ms) Interval between flushes of the buffered response body to the client. flushInterval: 100ms --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRouteTCP metadata: name: ingressroutetcpfoo.crd spec: entryPoints: - footcp routes: # Match is the rule corresponding to an underlying router. - match: HostSNI(`*`) services: - name: whoamitcp port: 8080","title":"Traefik IngressRoute definition"},{"location":"routing/providers/kubernetes-crd/#middleware","text":"Additionally, to allow for the use of middlewares in an IngressRoute , we defined the CRD below for the Middleware kind. apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced Once the Middleware kind has been registered with the Kubernetes cluster, it can then be used in IngressRoute definitions, such as: apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: stripprefix namespace: foo spec: stripPrefix: prefixes: - /stripit --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutebar spec: entryPoints: - web routes: - match: Host(`bar.com`) && PathPrefix(`/stripit`) kind: Rule services: - name: whoami port: 80 middlewares: - name: stripprefix namespace: foo Cross-provider namespace As Kubernetes also has its own notion of namespace, one should not confuse the kubernetes namespace of a resource (in the reference to the middleware) with the provider namespace , when the definition of the middleware is from another provider. In this context, specifying a namespace when referring to the resource does not make any sense, and will be ignored. More information about available middlewares in the dedicated middlewares section .","title":"Middleware"},{"location":"routing/providers/kubernetes-crd/#tls-option","text":"Additionally, to allow for the use of TLS options in an IngressRoute, we defined the CRD below for the TLSOption kind. More information about TLS Options is available in the dedicated TLS Configuration Options . apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: tlsoptions.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: TLSOption plural: tlsoptions singular: tlsoption scope: Namespaced Once the TLSOption kind has been registered with the Kubernetes cluster or defined in the File Provider, it can then be used in IngressRoute definitions, such as: apiVersion: traefik.containo.us/v1alpha1 kind: TLSOption metadata: name: mytlsoption namespace: default spec: minVersion: VersionTLS12 --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutebar spec: entryPoints: - web routes: - match: Host(`bar.com`) && PathPrefix(`/stripit`) kind: Rule services: - name: whoami port: 80 tls: options: name: mytlsoption namespace: default References and namespaces If the optional namespace attribute is not set, the configuration will be applied with the namespace of the IngressRoute. Additionally, when the definition of the TLS option is from another provider, the cross-provider syntax ( middlewarename@provider ) should be used to refer to the TLS option, just as in the middleware case . Specifying a namespace attribute in this case would not make any sense, and will be ignored.","title":"TLS Option"},{"location":"routing/providers/kubernetes-crd/#tls","text":"To allow for TLS, we made use of the Secret kind, as it was already defined, and it can be directly used in an IngressRoute : apiVersion: v1 kind: Secret metadata: name: supersecret data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0= tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0= --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutetls spec: entryPoints: - websecure routes: - match: Host(`foo.com`) && PathPrefix(`/bar`) kind: Rule services: - name: whoami port: 443 tls: secretName: supersecret","title":"TLS"},{"location":"routing/providers/kubernetes-crd/#further","text":"Also see the full example with Let's Encrypt.","title":"Further"},{"location":"routing/providers/marathon/","text":"Traefik & Marathon \u00b6 Traefik can be configured to use Marathon as a provider. See also Marathon user guide . Routing Configuration \u00b6 Labels Labels are case insensitive. The complete list of labels can be found in the reference page . General \u00b6 Traefik creates, for each Marathon application, a corresponding service and router . The Service automatically gets a server per instance of the application, and the router automatically gets a rule defined by defaultRule (if no rule for it was defined in labels). Service definition \u00b6 In general when configuring a Traefik provider, a service assigned to one (or several) router(s) must be defined as well for the routing to be functional. There are, however, exceptions when using label-based configurations: If a label defines a router (e.g. through a router Rule) and a label defines a service (e.g. implicitly through a loadbalancer server port value), but the router does not specify any service, then that service is automatically assigned to the router. If a label defines a router (e.g. through a router Rule) but no service is defined, then a service is automatically created and assigned to the router. As one would expect, in either of these cases, if in addition a service is specified for the router, then that service is the one assigned, regardless of whether it actually is defined or whatever else other services are defined. Automatic service assignment with labels Service myservice gets automatically assigned to router myproxy. labels: { \"traefik.http.routers.myproxy.rule\": \"Host(`foo.com`)\", \"traefik.http.services.myservice.loadbalancer.server.port\": \"80\" } Automatic service creation and assignment with labels No service specified or defined, and yet one gets automatically created. and assigned to router myproxy. labels: { \"traefik.http.routers.myproxy.rule\": \"Host(`foo.com`)\" } Routers \u00b6 To update the configuration of the Router automatically attached to the application, add labels starting with traefik.http.routers.{router-name-of-your-choice}. and followed by the option you want to change. For example, to change the routing rule, you could add the label \"traefik.http.routers.routername.rule\": \"Host(`mydomain.com`)\" . The character @ is not authorized in the router name <router_name> . traefik.http.routers.<router_name>.rule See rule for more information. \"traefik.http.routers.myrouter.rule\": \"Host(`mydomain.com`)\" traefik.http.routers.<router_name>.entrypoints See entry points for more information. \"traefik.http.routers.myrouter.entrypoints\": \"ep1,ep2\" traefik.http.routers.<router_name>.middlewares See middlewares and middlewares overview for more information. \"traefik.http.routers.myrouter.middlewares\": \"auth,prefix,cb\" traefik.http.routers.<router_name>.service See rule for more information. \"traefik.http.routers.myrouter.service\": \"myservice\" traefik.http.routers.<router_name>.tls See tls for more information. \"traefik.http.routers.myrouter.tls\": \"true\" traefik.http.routers.<router_name>.tls.certresolver See certResolver for more information. \"traefik.http.routers.myrouter.tls.certresolver\": \"myresolver\" traefik.http.routers.<router_name>.tls.domains[n].main See domains for more information. \"traefik.http.routers.myrouter.tls.domains[0].main\": \"foobar.com\" traefik.http.routers.<router_name>.tls.domains[n].sans See domains for more information. \"traefik.http.routers.myrouter.tls.domains[0].sans\": \"test.foobar.com,dev.foobar.com\" traefik.http.routers.<router_name>.tls.options See options for more information. \"traefik.http.routers.myrouter.tls.options\": \"foobar\" traefik.http.routers.<router_name>.priority See priority for more information. \"traefik.http.routers.myrouter.priority\": \"42\" Services \u00b6 To update the configuration of the Service automatically attached to the container, add labels starting with traefik.http.services.{service-name-of-your-choice}. , followed by the option you want to change. For example, to change the passHostHeader behavior, you'd add the label \"traefik.http.services.servicename.loadbalancer.passhostheader\": \"false\" . The character @ is not authorized in the service name <service_name> . traefik.http.services.<service_name>.loadbalancer.server.port Registers a port. Useful when the container exposes multiples ports. \"traefik.http.services.myservice.loadbalancer.server.port\": \"8080\" traefik.http.services.<service_name>.loadbalancer.server.scheme Overrides the default scheme. \"traefik.http.services.myservice.loadbalancer.server.scheme\": \"http\" traefik.http.services.<service_name>.loadbalancer.passhostheader See pass Host header for more information. \"traefik.http.services.myservice.loadbalancer.passhostheader\": \"true\" traefik.http.services.<service_name>.loadbalancer.healthcheck.headers.<header_name> See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.headers.X-Foo\": \"foobar\" traefik.http.services.<service_name>.loadbalancer.healthcheck.hostname See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.hostname\": \"foobar.com\" traefik.http.services.<service_name>.loadbalancer.healthcheck.interval See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.interval\": \"10\" traefik.http.services.<service_name>.loadbalancer.healthcheck.path See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.path\": \"/foo\" traefik.http.services.<service_name>.loadbalancer.healthcheck.port See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.port\": \"42\" traefik.http.services.<service_name>.loadbalancer.healthcheck.scheme See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.scheme\": \"http\" traefik.http.services.<service_name>.loadbalancer.healthcheck.timeout See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.timeout\": \"10\" traefik.http.services.<service_name>.loadbalancer.sticky See sticky sessions for more information. \"traefik.http.services.myservice.loadbalancer.sticky\": \"true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.httponly See sticky sessions for more information. \"traefik.http.services.myservice.loadbalancer.sticky.cookie.httponly\": \"true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.name See sticky sessions for more information. \"traefik.http.services.myservice.loadbalancer.sticky.cookie.name\": \"foobar\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.secure See sticky sessions for more information. \"traefik.http.services.myservice.loadbalancer.sticky.cookie.secure\": \"true\" traefik.http.services.<service_name>.loadbalancer.responseforwarding.flushinterval See response forwarding for more information. \"traefik.http.services.myservice.loadbalancer.responseforwarding.flushinterval\": \"10\" Middleware \u00b6 You can declare pieces of middleware using labels starting with traefik.http.middlewares.{middleware-name-of-your-choice}. , followed by the middleware type/options. For example, to declare a middleware redirectscheme named my-redirect , you'd write \"traefik.http.middlewares.my-redirect.redirectscheme.scheme\": \"https\" . More information about available middlewares in the dedicated middlewares section . The character @ is not authorized in the middleware name. Declaring and Referencing a Middleware { ... \"labels\": { \"traefik.http.middlewares.my-redirect.redirectscheme.scheme\": \"https\", \"traefik.http.routers.my-container.middlewares\": \"my-redirect\" } } Conflicts in Declaration If you declare multiple middleware with the same name but with different parameters, the middleware fails to be declared. TCP \u00b6 You can declare TCP Routers and/or Services using labels. Declaring TCP Routers and Services { ... \"labels\": { \"traefik.tcp.routers.my-router.rule\": \"HostSNI(`my-host.com`)\", \"traefik.tcp.routers.my-router.tls\": \"true\", \"traefik.tcp.services.my-service.loadbalancer.server.port\": \"4123\" } } TCP and HTTP If you declare a TCP Router/Service, it will prevent Traefik from automatically creating an HTTP Router/Service (like it does by default if no TCP Router/Service is defined). You can declare both a TCP Router/Service and an HTTP Router/Service for the same container (but you have to do so manually). TCP Routers \u00b6 traefik.tcp.routers.<router_name>.entrypoints See entry points for more information. \"traefik.tcp.routers.mytcprouter.entrypoints\": \"ep1,ep2\" traefik.tcp.routers.<router_name>.rule See rule for more information. \"traefik.tcp.routers.mytcprouter.rule\": \"HostSNI(`myhost.com`)\" traefik.tcp.routers.<router_name>.service See service for more information. \"traefik.tcp.routers.mytcprouter.service\": \"myservice\" traefik.tcp.routers.<router_name>.tls See TLS for more information. \"traefik.tcp.routers.mytcprouter.tls\": \"true traefik.tcp.routers.<router_name>.tls.certresolver See certResolver for more information. \"traefik.tcp.routers.mytcprouter.tls.certresolver\": \"myresolver\" traefik.tcp.routers.<router_name>.tls.domains[n].main See domains for more information. \"traefik.tcp.routers.mytcprouter.tls.domains[0].main\": \"foobar.com\" traefik.tcp.routers.<router_name>.tls.domains[n].sans See domains for more information. \"traefik.tcp.routers.mytcprouter.tls.domains[0].sans\": \"test.foobar.com,dev.foobar.com\" traefik.tcp.routers.<router_name>.tls.options See options for more information. \"traefik.tcp.routers.mytcprouter.tls.options\": \"mysoptions\" traefik.tcp.routers.<router_name>.tls.passthrough See TLS for more information. \"traefik.tcp.routers.mytcprouter.tls.passthrough\": \"true\" TCP Services \u00b6 traefik.tcp.services.<service_name>.loadbalancer.server.port Registers a port of the application. \"traefik.tcp.services.mytcpservice.loadbalancer.server.port\": \"423\" traefik.tcp.services.<service_name>.loadbalancer.terminationdelay See termination delay for more information. \"traefik.tcp.services.mytcpservice.loadbalancer.terminationdelay\": \"100\" Specific Provider Options \u00b6 traefik.enable \u00b6 \"traefik.enable\": \"true\" Setting this option controls whether Traefik exposes the application. It overrides the value of exposedByDefault . traefik.marathon.ipadressidx \u00b6 \"traefik.marathon.ipadressidx\": \"1\" If a task has several IP addresses, this option specifies which one, in the list of available addresses, to select.","title":"Marathon"},{"location":"routing/providers/marathon/#traefik-marathon","text":"Traefik can be configured to use Marathon as a provider. See also Marathon user guide .","title":"Traefik &amp; Marathon"},{"location":"routing/providers/marathon/#routing-configuration","text":"Labels Labels are case insensitive. The complete list of labels can be found in the reference page .","title":"Routing Configuration"},{"location":"routing/providers/marathon/#general","text":"Traefik creates, for each Marathon application, a corresponding service and router . The Service automatically gets a server per instance of the application, and the router automatically gets a rule defined by defaultRule (if no rule for it was defined in labels).","title":"General"},{"location":"routing/providers/marathon/#service-definition","text":"In general when configuring a Traefik provider, a service assigned to one (or several) router(s) must be defined as well for the routing to be functional. There are, however, exceptions when using label-based configurations: If a label defines a router (e.g. through a router Rule) and a label defines a service (e.g. implicitly through a loadbalancer server port value), but the router does not specify any service, then that service is automatically assigned to the router. If a label defines a router (e.g. through a router Rule) but no service is defined, then a service is automatically created and assigned to the router. As one would expect, in either of these cases, if in addition a service is specified for the router, then that service is the one assigned, regardless of whether it actually is defined or whatever else other services are defined. Automatic service assignment with labels Service myservice gets automatically assigned to router myproxy. labels: { \"traefik.http.routers.myproxy.rule\": \"Host(`foo.com`)\", \"traefik.http.services.myservice.loadbalancer.server.port\": \"80\" } Automatic service creation and assignment with labels No service specified or defined, and yet one gets automatically created. and assigned to router myproxy. labels: { \"traefik.http.routers.myproxy.rule\": \"Host(`foo.com`)\" }","title":"Service definition"},{"location":"routing/providers/marathon/#routers","text":"To update the configuration of the Router automatically attached to the application, add labels starting with traefik.http.routers.{router-name-of-your-choice}. and followed by the option you want to change. For example, to change the routing rule, you could add the label \"traefik.http.routers.routername.rule\": \"Host(`mydomain.com`)\" . The character @ is not authorized in the router name <router_name> . traefik.http.routers.<router_name>.rule See rule for more information. \"traefik.http.routers.myrouter.rule\": \"Host(`mydomain.com`)\" traefik.http.routers.<router_name>.entrypoints See entry points for more information. \"traefik.http.routers.myrouter.entrypoints\": \"ep1,ep2\" traefik.http.routers.<router_name>.middlewares See middlewares and middlewares overview for more information. \"traefik.http.routers.myrouter.middlewares\": \"auth,prefix,cb\" traefik.http.routers.<router_name>.service See rule for more information. \"traefik.http.routers.myrouter.service\": \"myservice\" traefik.http.routers.<router_name>.tls See tls for more information. \"traefik.http.routers.myrouter.tls\": \"true\" traefik.http.routers.<router_name>.tls.certresolver See certResolver for more information. \"traefik.http.routers.myrouter.tls.certresolver\": \"myresolver\" traefik.http.routers.<router_name>.tls.domains[n].main See domains for more information. \"traefik.http.routers.myrouter.tls.domains[0].main\": \"foobar.com\" traefik.http.routers.<router_name>.tls.domains[n].sans See domains for more information. \"traefik.http.routers.myrouter.tls.domains[0].sans\": \"test.foobar.com,dev.foobar.com\" traefik.http.routers.<router_name>.tls.options See options for more information. \"traefik.http.routers.myrouter.tls.options\": \"foobar\" traefik.http.routers.<router_name>.priority See priority for more information. \"traefik.http.routers.myrouter.priority\": \"42\"","title":"Routers"},{"location":"routing/providers/marathon/#services","text":"To update the configuration of the Service automatically attached to the container, add labels starting with traefik.http.services.{service-name-of-your-choice}. , followed by the option you want to change. For example, to change the passHostHeader behavior, you'd add the label \"traefik.http.services.servicename.loadbalancer.passhostheader\": \"false\" . The character @ is not authorized in the service name <service_name> . traefik.http.services.<service_name>.loadbalancer.server.port Registers a port. Useful when the container exposes multiples ports. \"traefik.http.services.myservice.loadbalancer.server.port\": \"8080\" traefik.http.services.<service_name>.loadbalancer.server.scheme Overrides the default scheme. \"traefik.http.services.myservice.loadbalancer.server.scheme\": \"http\" traefik.http.services.<service_name>.loadbalancer.passhostheader See pass Host header for more information. \"traefik.http.services.myservice.loadbalancer.passhostheader\": \"true\" traefik.http.services.<service_name>.loadbalancer.healthcheck.headers.<header_name> See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.headers.X-Foo\": \"foobar\" traefik.http.services.<service_name>.loadbalancer.healthcheck.hostname See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.hostname\": \"foobar.com\" traefik.http.services.<service_name>.loadbalancer.healthcheck.interval See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.interval\": \"10\" traefik.http.services.<service_name>.loadbalancer.healthcheck.path See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.path\": \"/foo\" traefik.http.services.<service_name>.loadbalancer.healthcheck.port See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.port\": \"42\" traefik.http.services.<service_name>.loadbalancer.healthcheck.scheme See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.scheme\": \"http\" traefik.http.services.<service_name>.loadbalancer.healthcheck.timeout See health check for more information. \"traefik.http.services.myservice.loadbalancer.healthcheck.timeout\": \"10\" traefik.http.services.<service_name>.loadbalancer.sticky See sticky sessions for more information. \"traefik.http.services.myservice.loadbalancer.sticky\": \"true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.httponly See sticky sessions for more information. \"traefik.http.services.myservice.loadbalancer.sticky.cookie.httponly\": \"true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.name See sticky sessions for more information. \"traefik.http.services.myservice.loadbalancer.sticky.cookie.name\": \"foobar\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.secure See sticky sessions for more information. \"traefik.http.services.myservice.loadbalancer.sticky.cookie.secure\": \"true\" traefik.http.services.<service_name>.loadbalancer.responseforwarding.flushinterval See response forwarding for more information. \"traefik.http.services.myservice.loadbalancer.responseforwarding.flushinterval\": \"10\"","title":"Services"},{"location":"routing/providers/marathon/#middleware","text":"You can declare pieces of middleware using labels starting with traefik.http.middlewares.{middleware-name-of-your-choice}. , followed by the middleware type/options. For example, to declare a middleware redirectscheme named my-redirect , you'd write \"traefik.http.middlewares.my-redirect.redirectscheme.scheme\": \"https\" . More information about available middlewares in the dedicated middlewares section . The character @ is not authorized in the middleware name. Declaring and Referencing a Middleware { ... \"labels\": { \"traefik.http.middlewares.my-redirect.redirectscheme.scheme\": \"https\", \"traefik.http.routers.my-container.middlewares\": \"my-redirect\" } } Conflicts in Declaration If you declare multiple middleware with the same name but with different parameters, the middleware fails to be declared.","title":"Middleware"},{"location":"routing/providers/marathon/#tcp","text":"You can declare TCP Routers and/or Services using labels. Declaring TCP Routers and Services { ... \"labels\": { \"traefik.tcp.routers.my-router.rule\": \"HostSNI(`my-host.com`)\", \"traefik.tcp.routers.my-router.tls\": \"true\", \"traefik.tcp.services.my-service.loadbalancer.server.port\": \"4123\" } } TCP and HTTP If you declare a TCP Router/Service, it will prevent Traefik from automatically creating an HTTP Router/Service (like it does by default if no TCP Router/Service is defined). You can declare both a TCP Router/Service and an HTTP Router/Service for the same container (but you have to do so manually).","title":"TCP"},{"location":"routing/providers/marathon/#tcp-routers","text":"traefik.tcp.routers.<router_name>.entrypoints See entry points for more information. \"traefik.tcp.routers.mytcprouter.entrypoints\": \"ep1,ep2\" traefik.tcp.routers.<router_name>.rule See rule for more information. \"traefik.tcp.routers.mytcprouter.rule\": \"HostSNI(`myhost.com`)\" traefik.tcp.routers.<router_name>.service See service for more information. \"traefik.tcp.routers.mytcprouter.service\": \"myservice\" traefik.tcp.routers.<router_name>.tls See TLS for more information. \"traefik.tcp.routers.mytcprouter.tls\": \"true traefik.tcp.routers.<router_name>.tls.certresolver See certResolver for more information. \"traefik.tcp.routers.mytcprouter.tls.certresolver\": \"myresolver\" traefik.tcp.routers.<router_name>.tls.domains[n].main See domains for more information. \"traefik.tcp.routers.mytcprouter.tls.domains[0].main\": \"foobar.com\" traefik.tcp.routers.<router_name>.tls.domains[n].sans See domains for more information. \"traefik.tcp.routers.mytcprouter.tls.domains[0].sans\": \"test.foobar.com,dev.foobar.com\" traefik.tcp.routers.<router_name>.tls.options See options for more information. \"traefik.tcp.routers.mytcprouter.tls.options\": \"mysoptions\" traefik.tcp.routers.<router_name>.tls.passthrough See TLS for more information. \"traefik.tcp.routers.mytcprouter.tls.passthrough\": \"true\"","title":"TCP Routers"},{"location":"routing/providers/marathon/#tcp-services","text":"traefik.tcp.services.<service_name>.loadbalancer.server.port Registers a port of the application. \"traefik.tcp.services.mytcpservice.loadbalancer.server.port\": \"423\" traefik.tcp.services.<service_name>.loadbalancer.terminationdelay See termination delay for more information. \"traefik.tcp.services.mytcpservice.loadbalancer.terminationdelay\": \"100\"","title":"TCP Services"},{"location":"routing/providers/marathon/#specific-provider-options","text":"","title":"Specific Provider Options"},{"location":"routing/providers/marathon/#traefikenable","text":"\"traefik.enable\": \"true\" Setting this option controls whether Traefik exposes the application. It overrides the value of exposedByDefault .","title":"traefik.enable"},{"location":"routing/providers/marathon/#traefikmarathonipadressidx","text":"\"traefik.marathon.ipadressidx\": \"1\" If a task has several IP addresses, this option specifies which one, in the list of available addresses, to select.","title":"traefik.marathon.ipadressidx"},{"location":"routing/providers/rancher/","text":"Traefik & Rancher \u00b6 A Story of Labels, Services & Containers Attach labels to your services and let Traefik do the rest! This provider is specific to Rancher 1.x. Rancher 2.x requires Kubernetes and does not have a metadata endpoint of its own for Traefik to query. As such, Rancher 2.x users should utilize the Kubernetes provider directly. Routing Configuration \u00b6 Labels Labels are case insensitive. The complete list of labels can be found in the reference page . General \u00b6 Traefik creates, for each rancher service, a corresponding service and router . The Service automatically gets a server per container in this rancher service, and the router gets a default rule attached to it, based on the service name. Service definition \u00b6 In general when configuring a Traefik provider, a service assigned to one (or several) router(s) must be defined as well for the routing to be functional. There are, however, exceptions when using label-based configurations: If a label defines a router (e.g. through a router Rule) and a label defines a service (e.g. implicitly through a loadbalancer server port value), but the router does not specify any service, then that service is automatically assigned to the router. If a label defines a router (e.g. through a router Rule) but no service is defined, then a service is automatically created and assigned to the router. As one would expect, in either of these cases, if in addition a service is specified for the router, then that service is the one assigned, regardless of whether it actually is defined or whatever else other services are defined. Automatic service assignment with labels With labels in a compose file labels: - \"traefik.http.routers.myproxy.rule=Host(`foo.com`)\" # service myservice gets automatically assigned to router myproxy - \"traefik.http.services.myservice.loadbalancer.server.port=80\" Automatic service creation and assignment with labels With labels in a compose file labels: # no service specified or defined and yet one gets automatically created # and assigned to router myproxy. - \"traefik.http.routers.myproxy.rule=Host(`foo.com`)\" Routers \u00b6 To update the configuration of the Router automatically attached to the container, add labels starting with traefik.routers.{name-of-your-choice}. and followed by the option you want to change. For example, to change the rule, you could add the label traefik.http.routers.my-container.rule=Host(`mydomain.com`) . The character @ is not authorized in the router name <router_name> . traefik.http.routers.<router_name>.rule See rule for more information. - \"traefik.http.routers.myrouter.rule=Host(`mydomain.com`)\" traefik.http.routers.<router_name>.entrypoints See entry points for more information. - \"traefik.http.routers.myrouter.entrypoints=ep1,ep2\" traefik.http.routers.<router_name>.middlewares See middlewares and middlewares overview for more information. - \"traefik.http.routers.myrouter.middlewares=auth,prefix,cb\" traefik.http.routers.<router_name>.service See rule for more information. - \"traefik.http.routers.myrouter.service=myservice\" traefik.http.routers.<router_name>.tls See tls for more information. - \"traefik.http.routers.myrouter>.tls=true\" traefik.http.routers.<router_name>.tls.certresolver See certResolver for more information. - \"traefik.http.routers.myrouter.tls.certresolver=myresolver\" traefik.http.routers.<router_name>.tls.domains[n].main See domains for more information. - \"traefik.http.routers.myrouter.tls.domains[0].main=foobar.com\" traefik.http.routers.<router_name>.tls.domains[n].sans See domains for more information. - \"traefik.http.routers.myrouter.tls.domains[0].sans=test.foobar.com,dev.foobar.com\" traefik.http.routers.<router_name>.tls.options See options for more information. - \"traefik.http.routers.myrouter.tls.options=foobar\" traefik.http.routers.<router_name>.priority See priority for more information. - \"traefik.http.routers.myrouter.priority=42\" Services \u00b6 To update the configuration of the Service automatically attached to the container, add labels starting with traefik.http.services.{name-of-your-choice}. , followed by the option you want to change. For example, to change the passHostHeader behavior, you'd add the label traefik.http.services.{name-of-your-choice}.loadbalancer.passhostheader=false . The character @ is not authorized in the service name <service_name> . traefik.http.services.<service_name>.loadbalancer.server.port Registers a port. Useful when the container exposes multiples ports. - \"traefik.http.services.myservice.loadbalancer.server.port=8080\" traefik.http.services.<service_name>.loadbalancer.server.scheme Overrides the default scheme. - \"traefik.http.services.myservice.loadbalancer.server.scheme=http\" traefik.http.services.<service_name>.loadbalancer.passhostheader See pass Host header for more information. - \"traefik.http.services.myservice.loadbalancer.passhostheader=true\" traefik.http.services.<service_name>.loadbalancer.healthcheck.headers.<header_name> See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.headers.X-Foo=foobar\" traefik.http.services.<service_name>.loadbalancer.healthcheck.hostname See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.hostname=foobar.com\" traefik.http.services.<service_name>.loadbalancer.healthcheck.interval See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.interval=10\" traefik.http.services.<service_name>.loadbalancer.healthcheck.path See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.path=/foo\" traefik.http.services.<service_name>.loadbalancer.healthcheck.port See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.port=42\" traefik.http.services.<service_name>.loadbalancer.healthcheck.scheme See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.scheme=http\" traefik.http.services.<service_name>.loadbalancer.healthcheck.timeout See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.timeout=10\" traefik.http.services.<service_name>.loadbalancer.sticky See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky=true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.httponly See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.httponly=true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.name See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.name=foobar\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.secure See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.secure=true\" traefik.http.services.<service_name>.loadbalancer.responseforwarding.flushinterval See response forwarding for more information. - \"traefik.http.services.myservice.loadbalancer.responseforwarding.flushinterval=10\" Middleware \u00b6 You can declare pieces of middleware using labels starting with traefik.http.middlewares.{name-of-your-choice}. , followed by the middleware type/options. For example, to declare a middleware redirectscheme named my-redirect , you'd write traefik.http.middlewares.my-redirect.redirectscheme.scheme: https . More information about available middlewares in the dedicated middlewares section . The character @ is not authorized in the middleware name. Declaring and Referencing a Middleware # ... labels: # Declaring a middleware - traefik.http.middlewares.my-redirect.redirectscheme.scheme=https # Referencing a middleware - traefik.http.routers.my-container.middlewares=my-redirect Conflicts in Declaration If you declare multiple middleware with the same name but with different parameters, the middleware fails to be declared. TCP \u00b6 You can declare TCP Routers and/or Services using labels. Declaring TCP Routers and Services services: my-container: # ... labels: - \"traefik.tcp.routers.my-router.rule=HostSNI(`my-host.com`)\" - \"traefik.tcp.routers.my-router.tls=true\" - \"traefik.tcp.services.my-service.loadbalancer.server.port=4123\" TCP and HTTP If you declare a TCP Router/Service, it will prevent Traefik from automatically creating an HTTP Router/Service (like it does by default if no TCP Router/Service is defined). You can declare both a TCP Router/Service and an HTTP Router/Service for the same container (but you have to do so manually). TCP Routers \u00b6 traefik.tcp.routers.<router_name>.entrypoints See entry points for more information. - \"traefik.tcp.routers.mytcprouter.entrypoints=ep1,ep2\" traefik.tcp.routers.<router_name>.rule See rule for more information. - \"traefik.tcp.routers.mytcprouter.rule=HostSNI(`myhost.com`)\" traefik.tcp.routers.<router_name>.service See service for more information. - \"traefik.tcp.routers.mytcprouter.service=myservice\" traefik.tcp.routers.<router_name>.tls See TLS for more information. - \"traefik.tcp.routers.mytcprouter.tls=true\" traefik.tcp.routers.<router_name>.tls.certresolver See certResolver for more information. - \"traefik.tcp.routers.mytcprouter.tls.certresolver=myresolver\" traefik.tcp.routers.<router_name>.tls.domains[n].main See domains for more information. - \"traefik.tcp.routers.mytcprouter.tls.domains[0].main=foobar.com\" traefik.tcp.routers.<router_name>.tls.domains[n].sans See domains for more information. - \"traefik.tcp.routers.mytcprouter.tls.domains[0].sans=test.foobar.com,dev.foobar.com\" traefik.tcp.routers.<router_name>.tls.options See options for more information. - \"traefik.tcp.routers.mytcprouter.tls.options=mysoptions\" traefik.tcp.routers.<router_name>.tls.passthrough See TLS for more information. - \"traefik.tcp.routers.mytcprouter.tls.passthrough=true\" TCP Services \u00b6 traefik.tcp.services.<service_name>.loadbalancer.server.port Registers a port of the application. - \"traefik.tcp.services.mytcpservice.loadbalancer.server.port=423\" traefik.tcp.services.<service_name>.loadbalancer.terminationdelay See termination delay for more information. - \"traefik.tcp.services.mytcpservice.loadbalancer.terminationdelay=100\" Specific Provider Options \u00b6 traefik.enable \u00b6 - \"traefik.enable=true\" You can tell Traefik to consider (or not) the container by setting traefik.enable to true or false. This option overrides the value of exposedByDefault . Port Lookup \u00b6 Traefik is capable of detecting the port to use, by following the default rancher flow. That means, if you just expose lets say port :1337 on the rancher ui, traefik will pick up this port and use it.","title":"Rancher"},{"location":"routing/providers/rancher/#traefik-rancher","text":"A Story of Labels, Services & Containers Attach labels to your services and let Traefik do the rest! This provider is specific to Rancher 1.x. Rancher 2.x requires Kubernetes and does not have a metadata endpoint of its own for Traefik to query. As such, Rancher 2.x users should utilize the Kubernetes provider directly.","title":"Traefik &amp; Rancher"},{"location":"routing/providers/rancher/#routing-configuration","text":"Labels Labels are case insensitive. The complete list of labels can be found in the reference page .","title":"Routing Configuration"},{"location":"routing/providers/rancher/#general","text":"Traefik creates, for each rancher service, a corresponding service and router . The Service automatically gets a server per container in this rancher service, and the router gets a default rule attached to it, based on the service name.","title":"General"},{"location":"routing/providers/rancher/#service-definition","text":"In general when configuring a Traefik provider, a service assigned to one (or several) router(s) must be defined as well for the routing to be functional. There are, however, exceptions when using label-based configurations: If a label defines a router (e.g. through a router Rule) and a label defines a service (e.g. implicitly through a loadbalancer server port value), but the router does not specify any service, then that service is automatically assigned to the router. If a label defines a router (e.g. through a router Rule) but no service is defined, then a service is automatically created and assigned to the router. As one would expect, in either of these cases, if in addition a service is specified for the router, then that service is the one assigned, regardless of whether it actually is defined or whatever else other services are defined. Automatic service assignment with labels With labels in a compose file labels: - \"traefik.http.routers.myproxy.rule=Host(`foo.com`)\" # service myservice gets automatically assigned to router myproxy - \"traefik.http.services.myservice.loadbalancer.server.port=80\" Automatic service creation and assignment with labels With labels in a compose file labels: # no service specified or defined and yet one gets automatically created # and assigned to router myproxy. - \"traefik.http.routers.myproxy.rule=Host(`foo.com`)\"","title":"Service definition"},{"location":"routing/providers/rancher/#routers","text":"To update the configuration of the Router automatically attached to the container, add labels starting with traefik.routers.{name-of-your-choice}. and followed by the option you want to change. For example, to change the rule, you could add the label traefik.http.routers.my-container.rule=Host(`mydomain.com`) . The character @ is not authorized in the router name <router_name> . traefik.http.routers.<router_name>.rule See rule for more information. - \"traefik.http.routers.myrouter.rule=Host(`mydomain.com`)\" traefik.http.routers.<router_name>.entrypoints See entry points for more information. - \"traefik.http.routers.myrouter.entrypoints=ep1,ep2\" traefik.http.routers.<router_name>.middlewares See middlewares and middlewares overview for more information. - \"traefik.http.routers.myrouter.middlewares=auth,prefix,cb\" traefik.http.routers.<router_name>.service See rule for more information. - \"traefik.http.routers.myrouter.service=myservice\" traefik.http.routers.<router_name>.tls See tls for more information. - \"traefik.http.routers.myrouter>.tls=true\" traefik.http.routers.<router_name>.tls.certresolver See certResolver for more information. - \"traefik.http.routers.myrouter.tls.certresolver=myresolver\" traefik.http.routers.<router_name>.tls.domains[n].main See domains for more information. - \"traefik.http.routers.myrouter.tls.domains[0].main=foobar.com\" traefik.http.routers.<router_name>.tls.domains[n].sans See domains for more information. - \"traefik.http.routers.myrouter.tls.domains[0].sans=test.foobar.com,dev.foobar.com\" traefik.http.routers.<router_name>.tls.options See options for more information. - \"traefik.http.routers.myrouter.tls.options=foobar\" traefik.http.routers.<router_name>.priority See priority for more information. - \"traefik.http.routers.myrouter.priority=42\"","title":"Routers"},{"location":"routing/providers/rancher/#services","text":"To update the configuration of the Service automatically attached to the container, add labels starting with traefik.http.services.{name-of-your-choice}. , followed by the option you want to change. For example, to change the passHostHeader behavior, you'd add the label traefik.http.services.{name-of-your-choice}.loadbalancer.passhostheader=false . The character @ is not authorized in the service name <service_name> . traefik.http.services.<service_name>.loadbalancer.server.port Registers a port. Useful when the container exposes multiples ports. - \"traefik.http.services.myservice.loadbalancer.server.port=8080\" traefik.http.services.<service_name>.loadbalancer.server.scheme Overrides the default scheme. - \"traefik.http.services.myservice.loadbalancer.server.scheme=http\" traefik.http.services.<service_name>.loadbalancer.passhostheader See pass Host header for more information. - \"traefik.http.services.myservice.loadbalancer.passhostheader=true\" traefik.http.services.<service_name>.loadbalancer.healthcheck.headers.<header_name> See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.headers.X-Foo=foobar\" traefik.http.services.<service_name>.loadbalancer.healthcheck.hostname See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.hostname=foobar.com\" traefik.http.services.<service_name>.loadbalancer.healthcheck.interval See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.interval=10\" traefik.http.services.<service_name>.loadbalancer.healthcheck.path See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.path=/foo\" traefik.http.services.<service_name>.loadbalancer.healthcheck.port See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.port=42\" traefik.http.services.<service_name>.loadbalancer.healthcheck.scheme See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.scheme=http\" traefik.http.services.<service_name>.loadbalancer.healthcheck.timeout See health check for more information. - \"traefik.http.services.myservice.loadbalancer.healthcheck.timeout=10\" traefik.http.services.<service_name>.loadbalancer.sticky See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky=true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.httponly See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.httponly=true\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.name See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.name=foobar\" traefik.http.services.<service_name>.loadbalancer.sticky.cookie.secure See sticky sessions for more information. - \"traefik.http.services.myservice.loadbalancer.sticky.cookie.secure=true\" traefik.http.services.<service_name>.loadbalancer.responseforwarding.flushinterval See response forwarding for more information. - \"traefik.http.services.myservice.loadbalancer.responseforwarding.flushinterval=10\"","title":"Services"},{"location":"routing/providers/rancher/#middleware","text":"You can declare pieces of middleware using labels starting with traefik.http.middlewares.{name-of-your-choice}. , followed by the middleware type/options. For example, to declare a middleware redirectscheme named my-redirect , you'd write traefik.http.middlewares.my-redirect.redirectscheme.scheme: https . More information about available middlewares in the dedicated middlewares section . The character @ is not authorized in the middleware name. Declaring and Referencing a Middleware # ... labels: # Declaring a middleware - traefik.http.middlewares.my-redirect.redirectscheme.scheme=https # Referencing a middleware - traefik.http.routers.my-container.middlewares=my-redirect Conflicts in Declaration If you declare multiple middleware with the same name but with different parameters, the middleware fails to be declared.","title":"Middleware"},{"location":"routing/providers/rancher/#tcp","text":"You can declare TCP Routers and/or Services using labels. Declaring TCP Routers and Services services: my-container: # ... labels: - \"traefik.tcp.routers.my-router.rule=HostSNI(`my-host.com`)\" - \"traefik.tcp.routers.my-router.tls=true\" - \"traefik.tcp.services.my-service.loadbalancer.server.port=4123\" TCP and HTTP If you declare a TCP Router/Service, it will prevent Traefik from automatically creating an HTTP Router/Service (like it does by default if no TCP Router/Service is defined). You can declare both a TCP Router/Service and an HTTP Router/Service for the same container (but you have to do so manually).","title":"TCP"},{"location":"routing/providers/rancher/#tcp-routers","text":"traefik.tcp.routers.<router_name>.entrypoints See entry points for more information. - \"traefik.tcp.routers.mytcprouter.entrypoints=ep1,ep2\" traefik.tcp.routers.<router_name>.rule See rule for more information. - \"traefik.tcp.routers.mytcprouter.rule=HostSNI(`myhost.com`)\" traefik.tcp.routers.<router_name>.service See service for more information. - \"traefik.tcp.routers.mytcprouter.service=myservice\" traefik.tcp.routers.<router_name>.tls See TLS for more information. - \"traefik.tcp.routers.mytcprouter.tls=true\" traefik.tcp.routers.<router_name>.tls.certresolver See certResolver for more information. - \"traefik.tcp.routers.mytcprouter.tls.certresolver=myresolver\" traefik.tcp.routers.<router_name>.tls.domains[n].main See domains for more information. - \"traefik.tcp.routers.mytcprouter.tls.domains[0].main=foobar.com\" traefik.tcp.routers.<router_name>.tls.domains[n].sans See domains for more information. - \"traefik.tcp.routers.mytcprouter.tls.domains[0].sans=test.foobar.com,dev.foobar.com\" traefik.tcp.routers.<router_name>.tls.options See options for more information. - \"traefik.tcp.routers.mytcprouter.tls.options=mysoptions\" traefik.tcp.routers.<router_name>.tls.passthrough See TLS for more information. - \"traefik.tcp.routers.mytcprouter.tls.passthrough=true\"","title":"TCP Routers"},{"location":"routing/providers/rancher/#tcp-services","text":"traefik.tcp.services.<service_name>.loadbalancer.server.port Registers a port of the application. - \"traefik.tcp.services.mytcpservice.loadbalancer.server.port=423\" traefik.tcp.services.<service_name>.loadbalancer.terminationdelay See termination delay for more information. - \"traefik.tcp.services.mytcpservice.loadbalancer.terminationdelay=100\"","title":"TCP Services"},{"location":"routing/providers/rancher/#specific-provider-options","text":"","title":"Specific Provider Options"},{"location":"routing/providers/rancher/#traefikenable","text":"- \"traefik.enable=true\" You can tell Traefik to consider (or not) the container by setting traefik.enable to true or false. This option overrides the value of exposedByDefault .","title":"traefik.enable"},{"location":"routing/providers/rancher/#port-lookup","text":"Traefik is capable of detecting the port to use, by following the default rancher flow. That means, if you just expose lets say port :1337 on the rancher ui, traefik will pick up this port and use it.","title":"Port Lookup"},{"location":"routing/providers/service-by-label/","text":"In general when configuring a Traefik provider, a service assigned to one (or several) router(s) must be defined as well for the routing to be functional. There are, however, exceptions when using label-based configurations: If a label defines a router (e.g. through a router Rule) and a label defines a service (e.g. implicitly through a loadbalancer server port value), but the router does not specify any service, then that service is automatically assigned to the router. If a label defines a router (e.g. through a router Rule) but no service is defined, then a service is automatically created and assigned to the router. As one would expect, in either of these cases, if in addition a service is specified for the router, then that service is the one assigned, regardless of whether it actually is defined or whatever else other services are defined.","title":"Service by label"},{"location":"routing/routers/","text":"Routers \u00b6 Connecting Requests to Services A router is in charge of connecting incoming requests to the services that can handle them. In the process, routers may use pieces of middleware to update the request, or act before forwarding the request to the service. Configuration Example \u00b6 Requests /foo are Handled by service-foo -- Using the File Provider TOML ## Dynamic configuration [http.routers] [http.routers.my-router] rule = \"Path(`/foo`)\" service = \"service-foo\" YAML ## Dynamic configuration http: routers: my-router: rule: \"Path(`/foo`)\" service: service-foo Forwarding all (non-tls) requests on port 3306 to a database service Dynamic Configuration File (TOML) ## Dynamic configuration [tcp] [tcp.routers] [tcp.routers.to-database] entryPoints = [\"mysql\"] # Catch every request (only available rule for non-tls routers. See below.) rule = \"HostSNI(`*`)\" service = \"database\" File (YAML) ## Dynamic configuration tcp: routers: to-database: entryPoints: - \"mysql\" # Catch every request (only available rule for non-tls routers. See below.) rule: \"HostSNI(`*`)\" service: database Static Configuration File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.mysql] address = \":3306\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" mysql: address: \":3306\" CLI ## Static configuration --entryPoints.web.address=:80 --entryPoints.mysql.address=:3306 Configuring HTTP Routers \u00b6 The character @ is not authorized in the router name EntryPoints \u00b6 If not specified, HTTP routers will accept requests from all defined entry points. If you want to limit the router scope to a set of entry points, set the entryPoints option. Listens to Every EntryPoint Dynamic Configuration File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] # By default, routers listen to every entry points rule = \"Host(`traefik.io`)\" service = \"service-1\" File (YAML) ## Dynamic configuration http: routers: Router-1: # By default, routers listen to every entry points rule: \"Host(`traefik.io`)\" service: \"service-1\" Static Configuration File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.websecure] address = \":443\" [entryPoints.other] address = \":9090\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" websecure: address: \":443\" other: address: \":9090\" CLI ## Static configuration --entrypoints.web.address=:80 --entrypoints.websecure.address=:443 --entrypoints.other.address=:9090 Listens to Specific EntryPoints Dynamic Configuration File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] # won't listen to entry point web entryPoints = [\"websecure\", \"other\"] rule = \"Host(`traefik.io`)\" service = \"service-1\" File (YAML) ## Dynamic configuration http: routers: Router-1: # won't listen to entry point web entryPoints: - \"websecure\" - \"other\" rule: \"Host(`traefik.io`)\" service: \"service-1\" Static Configuration File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.websecure] address = \":443\" [entryPoints.other] address = \":9090\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" websecure: address: \":443\" other: address: \":9090\" CLI ## Static configuration --entrypoints.web.address=:80 --entrypoints.websecure.address=:443 --entrypoints.other.address=:9090 Rule \u00b6 Rules are a set of matchers configured with values, that determine if a particular request matches specific criteria. If the rule is verified, the router becomes active, calls middlewares, and then forwards the request to the service. Backticks or Quotes? To set the value of a rule, use backticks ` or escaped double-quotes \\\" . Single quotes ' are not accepted as values are Golang's String Literals . Host is traefik.io rule = \"Host(`traefik.io`)\" Host is traefik.io OR Host is containo.us AND path is /traefik rule = \"Host(`traefik.io`) || (Host(`containo.us`) && Path(`/traefik`))\" The table below lists all the available matchers: Rule Description Headers(`key`, `value`) Check if there is a key key defined in the headers, with the value value HeadersRegexp(`key`, `regexp`) Check if there is a key key defined in the headers, with a value that matches the regular expression regexp Host(`domain-1`, ...) Check if the request domain targets one of the given domains . HostRegexp(`traefik.io`, `{subdomain:[a-z]+}.traefik.io`, ...) Check if the request domain matches the given regexp . Method(`GET`, ...) Check if the request method is one of the given methods ( GET , POST , PUT , DELETE , PATCH ) Path(`/path`, `/articles/{category}/{id:[0-9]+}`, ...) Match exact request path. It accepts a sequence of literal and regular expression paths. PathPrefix(`/products/`, `/articles/{category}/{id:[0-9]+}`) Match request prefix path. It accepts a sequence of literal and regular expression prefix paths. Query(`foo=bar`, `bar=baz`) Match Query String parameters. It accepts a sequence of key=value pairs. Regexp Syntax In order to use regular expressions with Host and Path expressions, you must declare an arbitrarily named variable followed by the colon-separated regular expression, all enclosed in curly braces. Any pattern supported by Go's regexp package may be used (example: /posts/{id:[0-9]+} ). Combining Matchers Using Operators and Parenthesis You can combine multiple matchers using the AND ( && ) and OR ( || ) operators. You can also use parenthesis. Rule, Middleware, and Services The rule is evaluated \"before\" any middleware has the opportunity to work, and \"before\" the request is forwarded to the service. Path Vs PathPrefix Use Path if your service listens on the exact path only. For instance, Path: /products would match /products but not /products/shoes . Use a *Prefix* matcher if your service listens on a particular base path but also serves requests on sub-paths. For instance, PathPrefix: /products would match /products but also /products/shoes and /products/shirts . Since the path is forwarded as-is, your service is expected to listen on /products . Priority \u00b6 To avoid path overlap, routes are sorted, by default, in descending order using rules length. The priority is directly equal to the length of the rule, and so the longest length has the highest priority. A value of 0 for the priority is ignored: priority = 0 means that the default rules length sorting is used. How default priorities are computed File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] rule = \"HostRegexp(`.*\\.traefik\\.com`)\" # ... [http.routers.Router-2] rule = \"Host(`foobar.traefik.com`)\" # ... File (YAML) ## Dynamic configuration http: routers: Router-1: rule: \"HostRegexp(`.*\\.traefik\\.com`)\" # ... Router-2: rule: \"Host(`foobar.traefik.com`)\" # ... In this case, all requests with host foobar.traefik.com will be routed through Router-1 instead of Router-2 . Name Rule Priority Router-1 HostRegexp(`.*\\.traefik\\.com`) 30 Router-2 Host(`foobar.traefik.com`) 26 The previous table shows that Router-1 has a higher priority than Router-2 . To solve this issue, the priority must be set. Set priorities -- using the File Provider File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] rule = \"HostRegexp(`.*\\.traefik\\.com`)\" entryPoints = [\"web\"] service = \"service-1\" priority = 1 [http.routers.Router-2] rule = \"Host(`foobar.traefik.com`)\" entryPoints = [\"web\"] priority = 2 service = \"service-2\" File (YAML) ## Dynamic configuration http: routers: Router-1: rule: \"HostRegexp(`.*\\.traefik\\.com`)\" entryPoints: - \"web\" service: service-1 priority: 1 Router-2: rule: \"Host(`foobar.traefik.com`)\" entryPoints: - \"web\" priority: 2 service: service-2 In this configuration, the priority is configured to allow Router-2 to handle requests with the foobar.traefik.com host. Middlewares \u00b6 You can attach a list of middlewares to each HTTP router. The middlewares will take effect only if the rule matches, and before forwarding the request to the service. The character @ is not authorized in the middleware name. Middlewares order Middlewares are applied in the same order as their declaration in router . With a middleware -- using the File Provider TOML ## Dynamic configuration [http.routers] [http.routers.my-router] rule = \"Path(`/foo`)\" # declared elsewhere middlewares = [\"authentication\"] service = \"service-foo\" YAML ## Dynamic configuration http: routers: my-router: rule: \"Path(`/foo`)\" # declared elsewhere middlewares: - authentication service: service-foo Service \u00b6 Each request must eventually be handled by a service , which is why each router definition should include a service target, which is basically where the request will be passed along to. In general, a service assigned to a router should have been defined, but there are exceptions for label-based providers. See the specific docker , rancher , or marathon documentation. The character @ is not authorized in the middleware name. HTTP routers can only target HTTP services (not TCP services). TLS \u00b6 General \u00b6 When a TLS section is specified, it instructs Traefik that the current router is dedicated to HTTPS requests only (and that the router should ignore HTTP (non TLS) requests). Traefik will terminate the SSL connections (meaning that it will send decrypted data to the services). Configuring the router to accept HTTPS requests only File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" # will terminate the TLS request [http.routers.Router-1.tls] File (YAML) ## Dynamic configuration http: routers: Router-1: rule: \"Host(`foo-domain`) && Path(`/foo-path/`)\" service: service-id # will terminate the TLS request tls: {} Routers for HTTP & HTTPS If you need to define the same route for both HTTP and HTTPS requests, you will need to define two different routers: one with the tls section, one without. HTTP & HTTPS routes File (TOML) ## Dynamic configuration [http.routers] [http.routers.my-https-router] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" # will terminate the TLS request [http.routers.my-https-router.tls] [http.routers.my-http-router] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" File (YAML) ## Dynamic configuration http: routers: my-https-router: rule: \"Host(`foo-domain`) && Path(`/foo-path/`)\" service: service-id # will terminate the TLS request tls: {} my-http-router: rule: \"Host(`foo-domain`) && Path(`/foo-path/`)\" service: service-id options \u00b6 The options field enables fine-grained control of the TLS parameters. It refers to a TLS Options and will be applied only if a Host rule is defined. Server Name Association Even though one might get the impression that a TLS options reference is mapped to a router, or a router rule, one should realize that it is actually mapped only to the host name found in the Host part of the rule. Of course, there could also be several Host parts in a rule, in which case the TLS options reference would be mapped to as many host names. Another thing to keep in mind is: the TLS option is picked from the mapping mentioned above and based on the server name provided during the TLS handshake, and it all happens before routing actually occurs. Configuring the TLS options File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" # will terminate the TLS request [http.routers.Router-1.tls] options = \"foo\" [tls.options] [tls.options.foo] minVersion = \"VersionTLS12\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", ] File (YAML) ## Dynamic configuration http: routers: Router-1: rule: \"Host(`foo-domain`) && Path(`/foo-path/`)\" service: service-id # will terminate the TLS request tls: options: foo tls: options: foo: minVersion: VersionTLS12 cipherSuites: - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 Conflicting TLS Options Since a TLS options reference is mapped to a host name, if a configuration introduces a situation where the same host name (from a Host rule) gets matched with two TLS options references, a conflict occurs, such as in the example below: File (TOML) ## Dynamic configuration [http.routers] [http.routers.routerfoo] rule = \"Host(`snitest.com`) && Path(`/foo`)\" [http.routers.routerfoo.tls] options = \"foo\" [http.routers] [http.routers.routerbar] rule = \"Host(`snitest.com`) && Path(`/bar`)\" [http.routers.routerbar.tls] options = \"bar\" File (YAML) ## Dynamic configuration http: routers: routerfoo: rule: \"Host(`snitest.com`) && Path(`/foo`)\" tls: options: foo routerbar: rule: \"Host(`snitest.com`) && Path(`/bar`)\" tls: options: bar If that happens, both mappings are discarded, and the host name ( snitest.com in this case) for these routers gets associated with the default TLS options instead. certResolver \u00b6 If certResolver is defined, Traefik will try to generate certificates based on routers Host & HostSNI rules. File (TOML) ## Dynamic configuration [http.routers] [http.routers.routerfoo] rule = \"Host(`snitest.com`) && Path(`/foo`)\" [http.routers.routerfoo.tls] certResolver = \"foo\" File (YAML) ## Dynamic configuration http: routers: routerfoo: rule: \"Host(`snitest.com`) && Path(`/foo`)\" tls: certResolver: foo Multiple Hosts in a Rule The rule Host(`test1.traefik.io`,`test2.traefik.io`) will request a certificate with the main domain test1.traefik.io and SAN test2.traefik.io . domains \u00b6 You can set SANs (alternative domains) for each main domain. Every domain must have A/AAAA records pointing to Traefik. Each domain & SAN will lead to a certificate request. File (TOML) ## Dynamic configuration [http.routers] [http.routers.routerbar] rule = \"Host(`snitest.com`) && Path(`/bar`)\" [http.routers.routerbar.tls] certResolver = \"bar\" [[http.routers.routerbar.tls.domains]] main = \"snitest.com\" sans = [\"*.snitest.com\"] File (YAML) ## Dynamic configuration http: routers: routerbar: rule: \"Host(`snitest.com`) && Path(`/bar`)\" tls: certResolver: \"bar\" domains: - main: \"snitest.com\" sans: - \"*.snitest.com\" ACME v2 supports wildcard certificates. As described in Let's Encrypt's post wildcard certificates can only be generated through a DNS-01 challenge . Most likely the root domain should receive a certificate too, so it needs to be specified as SAN and 2 DNS-01 challenges are executed. In this case the generated DNS TXT record for both domains is the same. Even though this behavior is DNS RFC compliant, it can lead to problems as all DNS providers keep DNS records cached for a given time (TTL) and this TTL can be greater than the challenge timeout making the DNS-01 challenge fail. The Traefik ACME client library lego supports some but not all DNS providers to work around this issue. The supported provider table indicates if they allow generating certificates for a wildcard domain and its root domain. Wildcard certificates can only be verified through a DNS-01 challenge . Double Wildcard Certificates It is not possible to request a double wildcard certificate for a domain (for example *.*.local.com ). Configuring TCP Routers \u00b6 The character @ is not authorized in the router name General \u00b6 If both HTTP routers and TCP routers listen to the same entry points, the TCP routers will apply before the HTTP routers. If no matching route is found for the TCP routers, then the HTTP routers will take over. EntryPoints \u00b6 If not specified, TCP routers will accept requests from all defined entry points. If you want to limit the router scope to a set of entry points, set the entry points option. Listens to Every Entry Point Dynamic Configuration File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.Router-1] # By default, routers listen to every entrypoints rule = \"HostSNI(`traefik.io`)\" service = \"service-1\" # will route TLS requests (and ignore non tls requests) [tcp.routers.Router-1.tls] File (YAML) ## Dynamic configuration tcp: routers: Router-1: # By default, routers listen to every entrypoints rule: \"HostSNI(`traefik.io`)\" service: \"service-1\" # will route TLS requests (and ignore non tls requests) tls: {} Static Configuration File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.websecure] address = \":443\" [entryPoints.other] address = \":9090\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" websecure: address: \":443\" other: address: \":9090\" CLI ## Static configuration --entrypoints.web.address=:80 --entrypoints.websecure.address=:443 --entrypoints.other.address=:9090 Listens to Specific Entry Points Dynamic Configuration File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.Router-1] # won't listen to entry point web entryPoints = [\"websecure\", \"other\"] rule = \"HostSNI(`traefik.io`)\" service = \"service-1\" # will route TLS requests (and ignore non tls requests) [tcp.routers.Router-1.tls] File (YAML) ## Dynamic configuration tcp: routers: Router-1: # won't listen to entry point web entryPoints: - \"websecure\" - \"other\" rule: \"HostSNI(`traefik.io`)\" service: \"service-1\" # will route TLS requests (and ignore non tls requests) tls: {} Static Configuration File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.websecure] address = \":443\" [entryPoints.other] address = \":9090\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" websecure: address: \":443\" other: address: \":9090\" CLI ## Static configuration --entrypoints.web.address=:80 --entrypoints.websecure.address=:443 --entrypoints.other.address=:9090 Rule \u00b6 Rule Description HostSNI(`domain-1`, ...) Check if the Server Name Indication corresponds to the given domains . HostSNI & TLS It is important to note that the Server Name Indication is an extension of the TLS protocol. Hence, only TLS routers will be able to specify a domain name with that rule. However, non-TLS routers will have to explicitly use that rule with * (every domain) to state that every non-TLS request will be handled by the router. Services \u00b6 You must attach a TCP service per TCP router. Services are the target for the router. TCP routers can only target TCP services (not HTTP services). TLS \u00b6 General \u00b6 When a TLS section is specified, it instructs Traefik that the current router is dedicated to TLS requests only (and that the router should ignore non-TLS requests). By default, Traefik will terminate the SSL connections (meaning that it will send decrypted data to the services), but Traefik can be configured in order to let the requests pass through (keeping the data encrypted), and be forwarded to the service \"as is\". Configuring TLS Termination File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.Router-1] rule = \"HostSNI(`foo-domain`)\" service = \"service-id\" # will terminate the TLS request by default [tcp.routers.Router-1.tls] File (YAML) ## Dynamic configuration tcp: routers: Router-1: rule: \"HostSNI(`foo-domain`)\" service: service-id # will terminate the TLS request by default tls: {} Configuring passthrough File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.Router-1] rule = \"HostSNI(`foo-domain`)\" service = \"service-id\" [tcp.routers.Router-1.tls] passthrough = true File (YAML) ## Dynamic configuration tcp: routers: Router-1: rule: \"HostSNI(`foo-domain`)\" service: service-id tls: passthrough: true options \u00b6 The options field enables fine-grained control of the TLS parameters. It refers to a TLS Options and will be applied only if a HostSNI rule is defined. Configuring the tls options File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.Router-1] rule = \"HostSNI(`foo-domain`)\" service = \"service-id\" # will terminate the TLS request [tcp.routers.Router-1.tls] options = \"foo\" [tls.options] [tls.options.foo] minVersion = \"VersionTLS12\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", ] File (YAML) ## Dynamic configuration tcp: routers: Router-1: rule: \"HostSNI(`foo-domain`)\" service: service-id # will terminate the TLS request tls: options: foo tls: options: foo: minVersion: VersionTLS12 cipherSuites: - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 certResolver \u00b6 See certResolver for HTTP router for more information. File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.routerfoo] rule = \"HostSNI(`snitest.com`)\" [tcp.routers.routerfoo.tls] certResolver = \"foo\" File (YAML) ## Dynamic configuration tcp: routers: routerfoo: rule: \"HostSNI(`snitest.com`)\" tls: certResolver: foo domains \u00b6 See domains for HTTP router for more information. File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.routerbar] rule = \"HostSNI(`snitest.com`)\" [tcp.routers.routerbar.tls] certResolver = \"bar\" [[tcp.routers.routerbar.tls.domains]] main = \"snitest.com\" sans = [\"*.snitest.com\"] File (YAML) ## Dynamic configuration tcp: routers: routerbar: rule: \"HostSNI(`snitest.com`)\" tls: certResolver: \"bar\" domains: - main: \"snitest.com\" sans: - \"*.snitest.com\"","title":"Routers"},{"location":"routing/routers/#routers","text":"Connecting Requests to Services A router is in charge of connecting incoming requests to the services that can handle them. In the process, routers may use pieces of middleware to update the request, or act before forwarding the request to the service.","title":"Routers"},{"location":"routing/routers/#configuration-example","text":"Requests /foo are Handled by service-foo -- Using the File Provider TOML ## Dynamic configuration [http.routers] [http.routers.my-router] rule = \"Path(`/foo`)\" service = \"service-foo\" YAML ## Dynamic configuration http: routers: my-router: rule: \"Path(`/foo`)\" service: service-foo Forwarding all (non-tls) requests on port 3306 to a database service Dynamic Configuration File (TOML) ## Dynamic configuration [tcp] [tcp.routers] [tcp.routers.to-database] entryPoints = [\"mysql\"] # Catch every request (only available rule for non-tls routers. See below.) rule = \"HostSNI(`*`)\" service = \"database\" File (YAML) ## Dynamic configuration tcp: routers: to-database: entryPoints: - \"mysql\" # Catch every request (only available rule for non-tls routers. See below.) rule: \"HostSNI(`*`)\" service: database Static Configuration File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.mysql] address = \":3306\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" mysql: address: \":3306\" CLI ## Static configuration --entryPoints.web.address=:80 --entryPoints.mysql.address=:3306","title":"Configuration Example"},{"location":"routing/routers/#configuring-http-routers","text":"The character @ is not authorized in the router name","title":"Configuring HTTP Routers"},{"location":"routing/routers/#entrypoints","text":"If not specified, HTTP routers will accept requests from all defined entry points. If you want to limit the router scope to a set of entry points, set the entryPoints option. Listens to Every EntryPoint Dynamic Configuration File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] # By default, routers listen to every entry points rule = \"Host(`traefik.io`)\" service = \"service-1\" File (YAML) ## Dynamic configuration http: routers: Router-1: # By default, routers listen to every entry points rule: \"Host(`traefik.io`)\" service: \"service-1\" Static Configuration File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.websecure] address = \":443\" [entryPoints.other] address = \":9090\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" websecure: address: \":443\" other: address: \":9090\" CLI ## Static configuration --entrypoints.web.address=:80 --entrypoints.websecure.address=:443 --entrypoints.other.address=:9090 Listens to Specific EntryPoints Dynamic Configuration File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] # won't listen to entry point web entryPoints = [\"websecure\", \"other\"] rule = \"Host(`traefik.io`)\" service = \"service-1\" File (YAML) ## Dynamic configuration http: routers: Router-1: # won't listen to entry point web entryPoints: - \"websecure\" - \"other\" rule: \"Host(`traefik.io`)\" service: \"service-1\" Static Configuration File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.websecure] address = \":443\" [entryPoints.other] address = \":9090\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" websecure: address: \":443\" other: address: \":9090\" CLI ## Static configuration --entrypoints.web.address=:80 --entrypoints.websecure.address=:443 --entrypoints.other.address=:9090","title":"EntryPoints"},{"location":"routing/routers/#rule","text":"Rules are a set of matchers configured with values, that determine if a particular request matches specific criteria. If the rule is verified, the router becomes active, calls middlewares, and then forwards the request to the service. Backticks or Quotes? To set the value of a rule, use backticks ` or escaped double-quotes \\\" . Single quotes ' are not accepted as values are Golang's String Literals . Host is traefik.io rule = \"Host(`traefik.io`)\" Host is traefik.io OR Host is containo.us AND path is /traefik rule = \"Host(`traefik.io`) || (Host(`containo.us`) && Path(`/traefik`))\" The table below lists all the available matchers: Rule Description Headers(`key`, `value`) Check if there is a key key defined in the headers, with the value value HeadersRegexp(`key`, `regexp`) Check if there is a key key defined in the headers, with a value that matches the regular expression regexp Host(`domain-1`, ...) Check if the request domain targets one of the given domains . HostRegexp(`traefik.io`, `{subdomain:[a-z]+}.traefik.io`, ...) Check if the request domain matches the given regexp . Method(`GET`, ...) Check if the request method is one of the given methods ( GET , POST , PUT , DELETE , PATCH ) Path(`/path`, `/articles/{category}/{id:[0-9]+}`, ...) Match exact request path. It accepts a sequence of literal and regular expression paths. PathPrefix(`/products/`, `/articles/{category}/{id:[0-9]+}`) Match request prefix path. It accepts a sequence of literal and regular expression prefix paths. Query(`foo=bar`, `bar=baz`) Match Query String parameters. It accepts a sequence of key=value pairs. Regexp Syntax In order to use regular expressions with Host and Path expressions, you must declare an arbitrarily named variable followed by the colon-separated regular expression, all enclosed in curly braces. Any pattern supported by Go's regexp package may be used (example: /posts/{id:[0-9]+} ). Combining Matchers Using Operators and Parenthesis You can combine multiple matchers using the AND ( && ) and OR ( || ) operators. You can also use parenthesis. Rule, Middleware, and Services The rule is evaluated \"before\" any middleware has the opportunity to work, and \"before\" the request is forwarded to the service. Path Vs PathPrefix Use Path if your service listens on the exact path only. For instance, Path: /products would match /products but not /products/shoes . Use a *Prefix* matcher if your service listens on a particular base path but also serves requests on sub-paths. For instance, PathPrefix: /products would match /products but also /products/shoes and /products/shirts . Since the path is forwarded as-is, your service is expected to listen on /products .","title":"Rule"},{"location":"routing/routers/#priority","text":"To avoid path overlap, routes are sorted, by default, in descending order using rules length. The priority is directly equal to the length of the rule, and so the longest length has the highest priority. A value of 0 for the priority is ignored: priority = 0 means that the default rules length sorting is used. How default priorities are computed File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] rule = \"HostRegexp(`.*\\.traefik\\.com`)\" # ... [http.routers.Router-2] rule = \"Host(`foobar.traefik.com`)\" # ... File (YAML) ## Dynamic configuration http: routers: Router-1: rule: \"HostRegexp(`.*\\.traefik\\.com`)\" # ... Router-2: rule: \"Host(`foobar.traefik.com`)\" # ... In this case, all requests with host foobar.traefik.com will be routed through Router-1 instead of Router-2 . Name Rule Priority Router-1 HostRegexp(`.*\\.traefik\\.com`) 30 Router-2 Host(`foobar.traefik.com`) 26 The previous table shows that Router-1 has a higher priority than Router-2 . To solve this issue, the priority must be set. Set priorities -- using the File Provider File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] rule = \"HostRegexp(`.*\\.traefik\\.com`)\" entryPoints = [\"web\"] service = \"service-1\" priority = 1 [http.routers.Router-2] rule = \"Host(`foobar.traefik.com`)\" entryPoints = [\"web\"] priority = 2 service = \"service-2\" File (YAML) ## Dynamic configuration http: routers: Router-1: rule: \"HostRegexp(`.*\\.traefik\\.com`)\" entryPoints: - \"web\" service: service-1 priority: 1 Router-2: rule: \"Host(`foobar.traefik.com`)\" entryPoints: - \"web\" priority: 2 service: service-2 In this configuration, the priority is configured to allow Router-2 to handle requests with the foobar.traefik.com host.","title":"Priority"},{"location":"routing/routers/#middlewares","text":"You can attach a list of middlewares to each HTTP router. The middlewares will take effect only if the rule matches, and before forwarding the request to the service. The character @ is not authorized in the middleware name. Middlewares order Middlewares are applied in the same order as their declaration in router . With a middleware -- using the File Provider TOML ## Dynamic configuration [http.routers] [http.routers.my-router] rule = \"Path(`/foo`)\" # declared elsewhere middlewares = [\"authentication\"] service = \"service-foo\" YAML ## Dynamic configuration http: routers: my-router: rule: \"Path(`/foo`)\" # declared elsewhere middlewares: - authentication service: service-foo","title":"Middlewares"},{"location":"routing/routers/#service","text":"Each request must eventually be handled by a service , which is why each router definition should include a service target, which is basically where the request will be passed along to. In general, a service assigned to a router should have been defined, but there are exceptions for label-based providers. See the specific docker , rancher , or marathon documentation. The character @ is not authorized in the middleware name. HTTP routers can only target HTTP services (not TCP services).","title":"Service"},{"location":"routing/routers/#tls","text":"","title":"TLS"},{"location":"routing/routers/#general","text":"When a TLS section is specified, it instructs Traefik that the current router is dedicated to HTTPS requests only (and that the router should ignore HTTP (non TLS) requests). Traefik will terminate the SSL connections (meaning that it will send decrypted data to the services). Configuring the router to accept HTTPS requests only File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" # will terminate the TLS request [http.routers.Router-1.tls] File (YAML) ## Dynamic configuration http: routers: Router-1: rule: \"Host(`foo-domain`) && Path(`/foo-path/`)\" service: service-id # will terminate the TLS request tls: {} Routers for HTTP & HTTPS If you need to define the same route for both HTTP and HTTPS requests, you will need to define two different routers: one with the tls section, one without. HTTP & HTTPS routes File (TOML) ## Dynamic configuration [http.routers] [http.routers.my-https-router] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" # will terminate the TLS request [http.routers.my-https-router.tls] [http.routers.my-http-router] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" File (YAML) ## Dynamic configuration http: routers: my-https-router: rule: \"Host(`foo-domain`) && Path(`/foo-path/`)\" service: service-id # will terminate the TLS request tls: {} my-http-router: rule: \"Host(`foo-domain`) && Path(`/foo-path/`)\" service: service-id","title":"General"},{"location":"routing/routers/#options","text":"The options field enables fine-grained control of the TLS parameters. It refers to a TLS Options and will be applied only if a Host rule is defined. Server Name Association Even though one might get the impression that a TLS options reference is mapped to a router, or a router rule, one should realize that it is actually mapped only to the host name found in the Host part of the rule. Of course, there could also be several Host parts in a rule, in which case the TLS options reference would be mapped to as many host names. Another thing to keep in mind is: the TLS option is picked from the mapping mentioned above and based on the server name provided during the TLS handshake, and it all happens before routing actually occurs. Configuring the TLS options File (TOML) ## Dynamic configuration [http.routers] [http.routers.Router-1] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" # will terminate the TLS request [http.routers.Router-1.tls] options = \"foo\" [tls.options] [tls.options.foo] minVersion = \"VersionTLS12\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", ] File (YAML) ## Dynamic configuration http: routers: Router-1: rule: \"Host(`foo-domain`) && Path(`/foo-path/`)\" service: service-id # will terminate the TLS request tls: options: foo tls: options: foo: minVersion: VersionTLS12 cipherSuites: - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 Conflicting TLS Options Since a TLS options reference is mapped to a host name, if a configuration introduces a situation where the same host name (from a Host rule) gets matched with two TLS options references, a conflict occurs, such as in the example below: File (TOML) ## Dynamic configuration [http.routers] [http.routers.routerfoo] rule = \"Host(`snitest.com`) && Path(`/foo`)\" [http.routers.routerfoo.tls] options = \"foo\" [http.routers] [http.routers.routerbar] rule = \"Host(`snitest.com`) && Path(`/bar`)\" [http.routers.routerbar.tls] options = \"bar\" File (YAML) ## Dynamic configuration http: routers: routerfoo: rule: \"Host(`snitest.com`) && Path(`/foo`)\" tls: options: foo routerbar: rule: \"Host(`snitest.com`) && Path(`/bar`)\" tls: options: bar If that happens, both mappings are discarded, and the host name ( snitest.com in this case) for these routers gets associated with the default TLS options instead.","title":"options"},{"location":"routing/routers/#certresolver","text":"If certResolver is defined, Traefik will try to generate certificates based on routers Host & HostSNI rules. File (TOML) ## Dynamic configuration [http.routers] [http.routers.routerfoo] rule = \"Host(`snitest.com`) && Path(`/foo`)\" [http.routers.routerfoo.tls] certResolver = \"foo\" File (YAML) ## Dynamic configuration http: routers: routerfoo: rule: \"Host(`snitest.com`) && Path(`/foo`)\" tls: certResolver: foo Multiple Hosts in a Rule The rule Host(`test1.traefik.io`,`test2.traefik.io`) will request a certificate with the main domain test1.traefik.io and SAN test2.traefik.io .","title":"certResolver"},{"location":"routing/routers/#domains","text":"You can set SANs (alternative domains) for each main domain. Every domain must have A/AAAA records pointing to Traefik. Each domain & SAN will lead to a certificate request. File (TOML) ## Dynamic configuration [http.routers] [http.routers.routerbar] rule = \"Host(`snitest.com`) && Path(`/bar`)\" [http.routers.routerbar.tls] certResolver = \"bar\" [[http.routers.routerbar.tls.domains]] main = \"snitest.com\" sans = [\"*.snitest.com\"] File (YAML) ## Dynamic configuration http: routers: routerbar: rule: \"Host(`snitest.com`) && Path(`/bar`)\" tls: certResolver: \"bar\" domains: - main: \"snitest.com\" sans: - \"*.snitest.com\" ACME v2 supports wildcard certificates. As described in Let's Encrypt's post wildcard certificates can only be generated through a DNS-01 challenge . Most likely the root domain should receive a certificate too, so it needs to be specified as SAN and 2 DNS-01 challenges are executed. In this case the generated DNS TXT record for both domains is the same. Even though this behavior is DNS RFC compliant, it can lead to problems as all DNS providers keep DNS records cached for a given time (TTL) and this TTL can be greater than the challenge timeout making the DNS-01 challenge fail. The Traefik ACME client library lego supports some but not all DNS providers to work around this issue. The supported provider table indicates if they allow generating certificates for a wildcard domain and its root domain. Wildcard certificates can only be verified through a DNS-01 challenge . Double Wildcard Certificates It is not possible to request a double wildcard certificate for a domain (for example *.*.local.com ).","title":"domains"},{"location":"routing/routers/#configuring-tcp-routers","text":"The character @ is not authorized in the router name","title":"Configuring TCP Routers"},{"location":"routing/routers/#general_1","text":"If both HTTP routers and TCP routers listen to the same entry points, the TCP routers will apply before the HTTP routers. If no matching route is found for the TCP routers, then the HTTP routers will take over.","title":"General"},{"location":"routing/routers/#entrypoints_1","text":"If not specified, TCP routers will accept requests from all defined entry points. If you want to limit the router scope to a set of entry points, set the entry points option. Listens to Every Entry Point Dynamic Configuration File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.Router-1] # By default, routers listen to every entrypoints rule = \"HostSNI(`traefik.io`)\" service = \"service-1\" # will route TLS requests (and ignore non tls requests) [tcp.routers.Router-1.tls] File (YAML) ## Dynamic configuration tcp: routers: Router-1: # By default, routers listen to every entrypoints rule: \"HostSNI(`traefik.io`)\" service: \"service-1\" # will route TLS requests (and ignore non tls requests) tls: {} Static Configuration File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.websecure] address = \":443\" [entryPoints.other] address = \":9090\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" websecure: address: \":443\" other: address: \":9090\" CLI ## Static configuration --entrypoints.web.address=:80 --entrypoints.websecure.address=:443 --entrypoints.other.address=:9090 Listens to Specific Entry Points Dynamic Configuration File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.Router-1] # won't listen to entry point web entryPoints = [\"websecure\", \"other\"] rule = \"HostSNI(`traefik.io`)\" service = \"service-1\" # will route TLS requests (and ignore non tls requests) [tcp.routers.Router-1.tls] File (YAML) ## Dynamic configuration tcp: routers: Router-1: # won't listen to entry point web entryPoints: - \"websecure\" - \"other\" rule: \"HostSNI(`traefik.io`)\" service: \"service-1\" # will route TLS requests (and ignore non tls requests) tls: {} Static Configuration File (TOML) ## Static configuration [entryPoints] [entryPoints.web] address = \":80\" [entryPoints.websecure] address = \":443\" [entryPoints.other] address = \":9090\" File (YAML) ## Static configuration entryPoints: web: address: \":80\" websecure: address: \":443\" other: address: \":9090\" CLI ## Static configuration --entrypoints.web.address=:80 --entrypoints.websecure.address=:443 --entrypoints.other.address=:9090","title":"EntryPoints"},{"location":"routing/routers/#rule_1","text":"Rule Description HostSNI(`domain-1`, ...) Check if the Server Name Indication corresponds to the given domains . HostSNI & TLS It is important to note that the Server Name Indication is an extension of the TLS protocol. Hence, only TLS routers will be able to specify a domain name with that rule. However, non-TLS routers will have to explicitly use that rule with * (every domain) to state that every non-TLS request will be handled by the router.","title":"Rule"},{"location":"routing/routers/#services","text":"You must attach a TCP service per TCP router. Services are the target for the router. TCP routers can only target TCP services (not HTTP services).","title":"Services"},{"location":"routing/routers/#tls_1","text":"","title":"TLS"},{"location":"routing/routers/#general_2","text":"When a TLS section is specified, it instructs Traefik that the current router is dedicated to TLS requests only (and that the router should ignore non-TLS requests). By default, Traefik will terminate the SSL connections (meaning that it will send decrypted data to the services), but Traefik can be configured in order to let the requests pass through (keeping the data encrypted), and be forwarded to the service \"as is\". Configuring TLS Termination File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.Router-1] rule = \"HostSNI(`foo-domain`)\" service = \"service-id\" # will terminate the TLS request by default [tcp.routers.Router-1.tls] File (YAML) ## Dynamic configuration tcp: routers: Router-1: rule: \"HostSNI(`foo-domain`)\" service: service-id # will terminate the TLS request by default tls: {} Configuring passthrough File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.Router-1] rule = \"HostSNI(`foo-domain`)\" service = \"service-id\" [tcp.routers.Router-1.tls] passthrough = true File (YAML) ## Dynamic configuration tcp: routers: Router-1: rule: \"HostSNI(`foo-domain`)\" service: service-id tls: passthrough: true","title":"General"},{"location":"routing/routers/#options_1","text":"The options field enables fine-grained control of the TLS parameters. It refers to a TLS Options and will be applied only if a HostSNI rule is defined. Configuring the tls options File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.Router-1] rule = \"HostSNI(`foo-domain`)\" service = \"service-id\" # will terminate the TLS request [tcp.routers.Router-1.tls] options = \"foo\" [tls.options] [tls.options.foo] minVersion = \"VersionTLS12\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", ] File (YAML) ## Dynamic configuration tcp: routers: Router-1: rule: \"HostSNI(`foo-domain`)\" service: service-id # will terminate the TLS request tls: options: foo tls: options: foo: minVersion: VersionTLS12 cipherSuites: - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256","title":"options"},{"location":"routing/routers/#certresolver_1","text":"See certResolver for HTTP router for more information. File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.routerfoo] rule = \"HostSNI(`snitest.com`)\" [tcp.routers.routerfoo.tls] certResolver = \"foo\" File (YAML) ## Dynamic configuration tcp: routers: routerfoo: rule: \"HostSNI(`snitest.com`)\" tls: certResolver: foo","title":"certResolver"},{"location":"routing/routers/#domains_1","text":"See domains for HTTP router for more information. File (TOML) ## Dynamic configuration [tcp.routers] [tcp.routers.routerbar] rule = \"HostSNI(`snitest.com`)\" [tcp.routers.routerbar.tls] certResolver = \"bar\" [[tcp.routers.routerbar.tls.domains]] main = \"snitest.com\" sans = [\"*.snitest.com\"] File (YAML) ## Dynamic configuration tcp: routers: routerbar: rule: \"HostSNI(`snitest.com`)\" tls: certResolver: \"bar\" domains: - main: \"snitest.com\" sans: - \"*.snitest.com\"","title":"domains"},{"location":"routing/services/","text":"Services \u00b6 Configuring How to Reach the Services The Services are responsible for configuring how to reach the actual services that will eventually handle the incoming requests. Configuration Examples \u00b6 Declaring an HTTP Service with Two Servers -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service.loadBalancer] [[http.services.my-service.loadBalancer.servers]] url = \"http://<private-ip-server-1>:<private-port-server-1>/\" [[http.services.my-service.loadBalancer.servers]] url = \"http://<private-ip-server-2>:<private-port-server-2>/\" YAML ## Dynamic configuration http: services: my-service: loadBalancer: servers: - url: \"http://<private-ip-server-1>:<private-port-server-1>/\" - url: \"http://<private-ip-server-2>:<private-port-server-2>/\" Declaring a TCP Service with Two Servers -- Using the File Provider TOML ## Dynamic configuration [tcp.services] [tcp.services.my-service.loadBalancer] [[tcp.services.my-service.loadBalancer.servers]] address = \"<private-ip-server-1>:<private-port-server-1>\" [[tcp.services.my-service.loadBalancer.servers]] address = \"<private-ip-server-2>:<private-port-server-2>\" YAML tcp: services: my-service: loadBalancer: servers: - address: \"<private-ip-server-1>:<private-port-server-1>\" - address: \"<private-ip-server-2>:<private-port-server-2>\" Configuring HTTP Services \u00b6 Servers Load Balancer \u00b6 The load balancers are able to load balance the requests between multiple instances of your programs. Each service has a load-balancer, even if there is only one server to forward traffic to. Declaring a Service with Two Servers (with Load Balancing) -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service.loadBalancer] [[http.services.my-service.loadBalancer.servers]] url = \"http://private-ip-server-1/\" [[http.services.my-service.loadBalancer.servers]] url = \"http://private-ip-server-2/\" YAML http: services: my-service: loadBalancer: servers: - url: \"http://private-ip-server-1/\" - url: \"http://private-ip-server-2/\" Servers \u00b6 Servers declare a single instance of your program. The url option point to a specific instance. Paths in the servers' url have no effect. If you want the requests to be sent to a specific path on your servers, configure your routers to use a corresponding middleware (e.g. the AddPrefix or ReplacePath ) middlewares. A Service with One Server -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service.loadBalancer] [[http.services.my-service.loadBalancer.servers]] url = \"http://private-ip-server-1/\" YAML ## Dynamic configuration http: services: my-service: loadBalancer: servers: - url: \"http://private-ip-server-1/\" Load-balancing \u00b6 For now, only round robin load balancing is supported: Load Balancing -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service.loadBalancer] [[http.services.my-service.loadBalancer.servers]] url = \"http://private-ip-server-1/\" [[http.services.my-service.loadBalancer.servers]] url = \"http://private-ip-server-2/\" YAML ## Dynamic configuration http: services: my-service: loadBalancer: servers: - url: \"http://private-ip-server-1/\" - url: \"http://private-ip-server-2/\" Sticky sessions \u00b6 When sticky sessions are enabled, a cookie is set on the initial request to track which server handles the first response. On subsequent requests, the client is forwarded to the same server. Stickiness & Unhealthy Servers If the server specified in the cookie becomes unhealthy, the request will be forwarded to a new server (and the cookie will keep track of the new server). Cookie Name The default cookie name is an abbreviation of a sha1 (ex: _1d52e ). Secure & HTTPOnly flags By default, the affinity cookie is created without those flags. One however can change that through configuration. Adding Stickiness -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service] [http.services.my-service.loadBalancer.sticky.cookie] YAML ## Dynamic configuration http: services: my-service: loadBalancer: sticky: cookie: {} Adding Stickiness with custom Options -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service] [http.services.my-service.loadBalancer.sticky.cookie] name = \"my_sticky_cookie_name\" secure = true httpOnly = true YAML ## Dynamic configuration http: services: my-service: loadBalancer: sticky: cookie: name: my_sticky_cookie_name secure: true httpOnly: true Health Check \u00b6 Configure health check to remove unhealthy servers from the load balancing rotation. Traefik will consider your servers healthy as long as they return status codes between 2XX and 3XX to the health check requests (carried out every interval ). Below are the available options for the health check mechanism: path is appended to the server URL to set the health check endpoint. scheme , if defined, will replace the server URL scheme for the health check endpoint hostname , if defined, will replace the server URL hostname for the health check endpoint. port , if defined, will replace the server URL port for the health check endpoint. interval defines the frequency of the health check calls. timeout defines the maximum duration Traefik will wait for a health check request before considering the server failed (unhealthy). headers defines custom headers to be sent to the health check endpoint. Interval & Timeout Format Interval and timeout are to be given in a format understood by time.ParseDuration . The interval must be greater than the timeout. If configuration doesn't reflect this, the interval will be set to timeout + 1 second. Recovering Servers Traefik keeps monitoring the health of unhealthy servers. If a server has recovered (returning 2xx -> 3xx responses again), it will be added back to the load balacer rotation pool. Custom Interval & Timeout -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service-1] [http.services.Service-1.loadBalancer.healthCheck] path = \"/health\" interval = \"10s\" timeout = \"3s\" YAML ## Dynamic configuration http: services: Service-1: loadBalancer: healthCheck: path: /health interval: \"10s\" timeout: \"3s\" Custom Port -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service-1] [http.services.Service-1.loadBalancer.healthCheck] path = \"/health\" port = 8080 YAML ## Dynamic configuration http: services: Service-1: loadBalancer: healthCheck: path: /health port: 8080 Custom Scheme -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service-1] [http.services.Service-1.loadBalancer.healthCheck] path = \"/health\" scheme = \"http\" YAML ## Dynamic configuration http: services: Service-1: loadBalancer: healthCheck: path: /health scheme: http Additional HTTP Headers -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service-1] [http.services.Service-1.loadBalancer.healthCheck] path = \"/health\" [http.services.Service-1.loadBalancer.healthCheck.headers] My-Custom-Header = \"foo\" My-Header = \"bar\" YAML ## Dynamic configuration http: services: Service-1: loadBalancer: healthCheck: path: /health headers: My-Custom-Header: foo My-Header: bar Pass Host Header \u00b6 The passHostHeader allows to forward client Host header to server. By default, passHostHeader is true. Don't forward the host header -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service01] [http.services.Service01.loadBalancer] passHostHeader = false YAML ## Dynamic configuration http: services: Service01: loadBalancer: passHostHeader: false Response Forwarding \u00b6 This section is about configuring how Traefik forwards the response from the backend server to the client. Below are the available options for the Response Forwarding mechanism: FlushInterval specifies the interval in between flushes to the client while copying the response body. It is a duration in milliseconds, defaulting to 100. A negative value means to flush immediately after each write to the client. The FlushInterval is ignored when ReverseProxy recognizes a response as a streaming response; for such responses, writes are flushed to the client immediately. Using a custom FlushInterval -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service-1] [http.services.Service-1.loadBalancer.responseForwarding] flushInterval = \"1s\" YAML ## Dynamic configuration http: services: Service-1: loadBalancer: responseForwarding: flushInterval: 1s Weighted Round Robin (service) \u00b6 The WRR is able to load balance the requests between multiple services based on weights. This strategy is only available to load balance between services and not between servers . This strategy can be defined only with File . TOML ## Dynamic configuration [http.services] [http.services.app] [[http.services.app.weighted.services]] name = \"appv1\" weight = 3 [[http.services.app.weighted.services]] name = \"appv2\" weight = 1 [http.services.appv1] [http.services.appv1.loadBalancer] [[http.services.appv1.loadBalancer.servers]] url = \"http://private-ip-server-1/\" [http.services.appv2] [http.services.appv2.loadBalancer] [[http.services.appv2.loadBalancer.servers]] url = \"http://private-ip-server-2/\" YAML ## Dynamic configuration http: services: app: weighted: services: - name: appv1 weight: 3 - name: appv2 weight: 1 appv1: loadBalancer: servers: - url: \"http://private-ip-server-1/\" appv2: loadBalancer: servers: - url: \"http://private-ip-server-2/\" Mirroring (service) \u00b6 The mirroring is able to mirror requests sent to a service to other services. This strategy can be defined only with File . TOML ## Dynamic configuration [http.services] [http.services.mirrored-api] [http.services.mirrored-api.mirroring] service = \"appv1\" [[http.services.mirrored-api.mirroring.mirrors]] name = \"appv2\" percent = 10 [http.services.appv1] [http.services.appv1.loadBalancer] [[http.services.appv1.loadBalancer.servers]] url = \"http://private-ip-server-1/\" [http.services.appv2] [http.services.appv2.loadBalancer] [[http.services.appv2.loadBalancer.servers]] url = \"http://private-ip-server-2/\" YAML ## Dynamic configuration http: services: mirrored-api: mirroring: service: appv1 mirrors: - name: appv2 percent: 10 appv1: loadBalancer: servers: - url: \"http://private-ip-server-1/\" appv2: loadBalancer: servers: - url: \"http://private-ip-server-2/\" Configuring TCP Services \u00b6 General \u00b6 Each of the fields of the service section represents a kind of service. Which means, that for each specified service, one of the fields, and only one, has to be enabled to define what kind of service is created. Currently, the two available kinds are LoadBalancer , and Weighted . Servers Load Balancer \u00b6 The servers load balancer is in charge of balancing the requests between the servers of the same service. Declaring a Service with Two Servers -- Using the File Provider TOML ## Dynamic configuration [tcp.services] [tcp.services.my-service.loadBalancer] [[tcp.services.my-service.loadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" [[tcp.services.my-service.loadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" YAML ## Dynamic configuration tcp: services: my-service: loadBalancer: servers: - address: \"xx.xx.xx.xx:xx\" - address: \"xx.xx.xx.xx:xx\" Servers \u00b6 Servers declare a single instance of your program. The address option (IP:Port) point to a specific instance. A Service with One Server -- Using the File Provider TOML ## Dynamic configuration [tcp.services] [tcp.services.my-service.loadBalancer] [[tcp.services.my-service.loadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" YAML ## Dynamic configuration tcp: services: my-service: loadBalancer: servers: - address: \"xx.xx.xx.xx:xx\" Termination Delay \u00b6 As a proxy between a client and a server, it can happen that either side (e.g. client side) decides to terminate its writing capability on the connection (i.e. issuance of a FIN packet). The proxy needs to propagate that intent to the other side, and so when that happens, it also does the same on its connection with the other side (e.g. backend side). However, if for some reason (bad implementation, or malicious intent) the other side does not eventually do the same as well, the connection would stay half-open, which would lock resources for however long. To that end, as soon as the proxy enters this termination sequence, it sets a deadline on fully terminating the connections on both sides. The termination delay controls that deadline. It is a duration in milliseconds, defaulting to 100. A negative value means an infinite deadline (i.e. the connection is never fully terminated by the proxy itself). A Service with a termination delay -- Using the File Provider TOML ## Dynamic configuration [tcp.services] [tcp.services.my-service.loadBalancer] [[tcp.services.my-service.loadBalancer]] terminationDelay = 200 YAML ## Dynamic configuration tcp: services: my-service: loadBalancer: terminationDelay: 200 Weighted Round Robin \u00b6 The Weighted Round Robin (alias WRR ) load-balancer of services is in charge of balancing the requests between multiple services based on provided weights. This strategy is only available to load balance between services and not between servers . This strategy can only be defined with File . TOML ## Dynamic configuration [tcp.services] [tcp.services.app] [[tcp.services.app.weighted.services]] name = \"appv1\" weight = 3 [[tcp.services.app.weighted.services]] name = \"appv2\" weight = 1 [tcp.services.appv1] [tcp.services.appv1.loadBalancer] [[tcp.services.appv1.loadBalancer.servers]] address = \"private-ip-server-1:8080/\" [tcp.services.appv2] [tcp.services.appv2.loadBalancer] [[tcp.services.appv2.loadBalancer.servers]] address = \"private-ip-server-2:8080/\" YAML ## Dynamic configuration tcp: services: app: weighted: services: - name: appv1 weight: 3 - name: appv2 weight: 1 appv1: loadBalancer: servers: - address: \"xxx.xxx.xxx.xxx:8080\" appv2: loadBalancer: servers: - address: \"xxx.xxx.xxx.xxx:8080\"","title":"Services"},{"location":"routing/services/#services","text":"Configuring How to Reach the Services The Services are responsible for configuring how to reach the actual services that will eventually handle the incoming requests.","title":"Services"},{"location":"routing/services/#configuration-examples","text":"Declaring an HTTP Service with Two Servers -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service.loadBalancer] [[http.services.my-service.loadBalancer.servers]] url = \"http://<private-ip-server-1>:<private-port-server-1>/\" [[http.services.my-service.loadBalancer.servers]] url = \"http://<private-ip-server-2>:<private-port-server-2>/\" YAML ## Dynamic configuration http: services: my-service: loadBalancer: servers: - url: \"http://<private-ip-server-1>:<private-port-server-1>/\" - url: \"http://<private-ip-server-2>:<private-port-server-2>/\" Declaring a TCP Service with Two Servers -- Using the File Provider TOML ## Dynamic configuration [tcp.services] [tcp.services.my-service.loadBalancer] [[tcp.services.my-service.loadBalancer.servers]] address = \"<private-ip-server-1>:<private-port-server-1>\" [[tcp.services.my-service.loadBalancer.servers]] address = \"<private-ip-server-2>:<private-port-server-2>\" YAML tcp: services: my-service: loadBalancer: servers: - address: \"<private-ip-server-1>:<private-port-server-1>\" - address: \"<private-ip-server-2>:<private-port-server-2>\"","title":"Configuration Examples"},{"location":"routing/services/#configuring-http-services","text":"","title":"Configuring HTTP Services"},{"location":"routing/services/#servers-load-balancer","text":"The load balancers are able to load balance the requests between multiple instances of your programs. Each service has a load-balancer, even if there is only one server to forward traffic to. Declaring a Service with Two Servers (with Load Balancing) -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service.loadBalancer] [[http.services.my-service.loadBalancer.servers]] url = \"http://private-ip-server-1/\" [[http.services.my-service.loadBalancer.servers]] url = \"http://private-ip-server-2/\" YAML http: services: my-service: loadBalancer: servers: - url: \"http://private-ip-server-1/\" - url: \"http://private-ip-server-2/\"","title":"Servers Load Balancer"},{"location":"routing/services/#servers","text":"Servers declare a single instance of your program. The url option point to a specific instance. Paths in the servers' url have no effect. If you want the requests to be sent to a specific path on your servers, configure your routers to use a corresponding middleware (e.g. the AddPrefix or ReplacePath ) middlewares. A Service with One Server -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service.loadBalancer] [[http.services.my-service.loadBalancer.servers]] url = \"http://private-ip-server-1/\" YAML ## Dynamic configuration http: services: my-service: loadBalancer: servers: - url: \"http://private-ip-server-1/\"","title":"Servers"},{"location":"routing/services/#load-balancing","text":"For now, only round robin load balancing is supported: Load Balancing -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service.loadBalancer] [[http.services.my-service.loadBalancer.servers]] url = \"http://private-ip-server-1/\" [[http.services.my-service.loadBalancer.servers]] url = \"http://private-ip-server-2/\" YAML ## Dynamic configuration http: services: my-service: loadBalancer: servers: - url: \"http://private-ip-server-1/\" - url: \"http://private-ip-server-2/\"","title":"Load-balancing"},{"location":"routing/services/#sticky-sessions","text":"When sticky sessions are enabled, a cookie is set on the initial request to track which server handles the first response. On subsequent requests, the client is forwarded to the same server. Stickiness & Unhealthy Servers If the server specified in the cookie becomes unhealthy, the request will be forwarded to a new server (and the cookie will keep track of the new server). Cookie Name The default cookie name is an abbreviation of a sha1 (ex: _1d52e ). Secure & HTTPOnly flags By default, the affinity cookie is created without those flags. One however can change that through configuration. Adding Stickiness -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service] [http.services.my-service.loadBalancer.sticky.cookie] YAML ## Dynamic configuration http: services: my-service: loadBalancer: sticky: cookie: {} Adding Stickiness with custom Options -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.my-service] [http.services.my-service.loadBalancer.sticky.cookie] name = \"my_sticky_cookie_name\" secure = true httpOnly = true YAML ## Dynamic configuration http: services: my-service: loadBalancer: sticky: cookie: name: my_sticky_cookie_name secure: true httpOnly: true","title":"Sticky sessions"},{"location":"routing/services/#health-check","text":"Configure health check to remove unhealthy servers from the load balancing rotation. Traefik will consider your servers healthy as long as they return status codes between 2XX and 3XX to the health check requests (carried out every interval ). Below are the available options for the health check mechanism: path is appended to the server URL to set the health check endpoint. scheme , if defined, will replace the server URL scheme for the health check endpoint hostname , if defined, will replace the server URL hostname for the health check endpoint. port , if defined, will replace the server URL port for the health check endpoint. interval defines the frequency of the health check calls. timeout defines the maximum duration Traefik will wait for a health check request before considering the server failed (unhealthy). headers defines custom headers to be sent to the health check endpoint. Interval & Timeout Format Interval and timeout are to be given in a format understood by time.ParseDuration . The interval must be greater than the timeout. If configuration doesn't reflect this, the interval will be set to timeout + 1 second. Recovering Servers Traefik keeps monitoring the health of unhealthy servers. If a server has recovered (returning 2xx -> 3xx responses again), it will be added back to the load balacer rotation pool. Custom Interval & Timeout -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service-1] [http.services.Service-1.loadBalancer.healthCheck] path = \"/health\" interval = \"10s\" timeout = \"3s\" YAML ## Dynamic configuration http: services: Service-1: loadBalancer: healthCheck: path: /health interval: \"10s\" timeout: \"3s\" Custom Port -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service-1] [http.services.Service-1.loadBalancer.healthCheck] path = \"/health\" port = 8080 YAML ## Dynamic configuration http: services: Service-1: loadBalancer: healthCheck: path: /health port: 8080 Custom Scheme -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service-1] [http.services.Service-1.loadBalancer.healthCheck] path = \"/health\" scheme = \"http\" YAML ## Dynamic configuration http: services: Service-1: loadBalancer: healthCheck: path: /health scheme: http Additional HTTP Headers -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service-1] [http.services.Service-1.loadBalancer.healthCheck] path = \"/health\" [http.services.Service-1.loadBalancer.healthCheck.headers] My-Custom-Header = \"foo\" My-Header = \"bar\" YAML ## Dynamic configuration http: services: Service-1: loadBalancer: healthCheck: path: /health headers: My-Custom-Header: foo My-Header: bar","title":"Health Check"},{"location":"routing/services/#pass-host-header","text":"The passHostHeader allows to forward client Host header to server. By default, passHostHeader is true. Don't forward the host header -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service01] [http.services.Service01.loadBalancer] passHostHeader = false YAML ## Dynamic configuration http: services: Service01: loadBalancer: passHostHeader: false","title":"Pass Host Header"},{"location":"routing/services/#response-forwarding","text":"This section is about configuring how Traefik forwards the response from the backend server to the client. Below are the available options for the Response Forwarding mechanism: FlushInterval specifies the interval in between flushes to the client while copying the response body. It is a duration in milliseconds, defaulting to 100. A negative value means to flush immediately after each write to the client. The FlushInterval is ignored when ReverseProxy recognizes a response as a streaming response; for such responses, writes are flushed to the client immediately. Using a custom FlushInterval -- Using the File Provider TOML ## Dynamic configuration [http.services] [http.services.Service-1] [http.services.Service-1.loadBalancer.responseForwarding] flushInterval = \"1s\" YAML ## Dynamic configuration http: services: Service-1: loadBalancer: responseForwarding: flushInterval: 1s","title":"Response Forwarding"},{"location":"routing/services/#weighted-round-robin-service","text":"The WRR is able to load balance the requests between multiple services based on weights. This strategy is only available to load balance between services and not between servers . This strategy can be defined only with File . TOML ## Dynamic configuration [http.services] [http.services.app] [[http.services.app.weighted.services]] name = \"appv1\" weight = 3 [[http.services.app.weighted.services]] name = \"appv2\" weight = 1 [http.services.appv1] [http.services.appv1.loadBalancer] [[http.services.appv1.loadBalancer.servers]] url = \"http://private-ip-server-1/\" [http.services.appv2] [http.services.appv2.loadBalancer] [[http.services.appv2.loadBalancer.servers]] url = \"http://private-ip-server-2/\" YAML ## Dynamic configuration http: services: app: weighted: services: - name: appv1 weight: 3 - name: appv2 weight: 1 appv1: loadBalancer: servers: - url: \"http://private-ip-server-1/\" appv2: loadBalancer: servers: - url: \"http://private-ip-server-2/\"","title":"Weighted Round Robin (service)"},{"location":"routing/services/#mirroring-service","text":"The mirroring is able to mirror requests sent to a service to other services. This strategy can be defined only with File . TOML ## Dynamic configuration [http.services] [http.services.mirrored-api] [http.services.mirrored-api.mirroring] service = \"appv1\" [[http.services.mirrored-api.mirroring.mirrors]] name = \"appv2\" percent = 10 [http.services.appv1] [http.services.appv1.loadBalancer] [[http.services.appv1.loadBalancer.servers]] url = \"http://private-ip-server-1/\" [http.services.appv2] [http.services.appv2.loadBalancer] [[http.services.appv2.loadBalancer.servers]] url = \"http://private-ip-server-2/\" YAML ## Dynamic configuration http: services: mirrored-api: mirroring: service: appv1 mirrors: - name: appv2 percent: 10 appv1: loadBalancer: servers: - url: \"http://private-ip-server-1/\" appv2: loadBalancer: servers: - url: \"http://private-ip-server-2/\"","title":"Mirroring (service)"},{"location":"routing/services/#configuring-tcp-services","text":"","title":"Configuring TCP Services"},{"location":"routing/services/#general","text":"Each of the fields of the service section represents a kind of service. Which means, that for each specified service, one of the fields, and only one, has to be enabled to define what kind of service is created. Currently, the two available kinds are LoadBalancer , and Weighted .","title":"General"},{"location":"routing/services/#servers-load-balancer_1","text":"The servers load balancer is in charge of balancing the requests between the servers of the same service. Declaring a Service with Two Servers -- Using the File Provider TOML ## Dynamic configuration [tcp.services] [tcp.services.my-service.loadBalancer] [[tcp.services.my-service.loadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" [[tcp.services.my-service.loadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" YAML ## Dynamic configuration tcp: services: my-service: loadBalancer: servers: - address: \"xx.xx.xx.xx:xx\" - address: \"xx.xx.xx.xx:xx\"","title":"Servers Load Balancer"},{"location":"routing/services/#servers_1","text":"Servers declare a single instance of your program. The address option (IP:Port) point to a specific instance. A Service with One Server -- Using the File Provider TOML ## Dynamic configuration [tcp.services] [tcp.services.my-service.loadBalancer] [[tcp.services.my-service.loadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" YAML ## Dynamic configuration tcp: services: my-service: loadBalancer: servers: - address: \"xx.xx.xx.xx:xx\"","title":"Servers"},{"location":"routing/services/#termination-delay","text":"As a proxy between a client and a server, it can happen that either side (e.g. client side) decides to terminate its writing capability on the connection (i.e. issuance of a FIN packet). The proxy needs to propagate that intent to the other side, and so when that happens, it also does the same on its connection with the other side (e.g. backend side). However, if for some reason (bad implementation, or malicious intent) the other side does not eventually do the same as well, the connection would stay half-open, which would lock resources for however long. To that end, as soon as the proxy enters this termination sequence, it sets a deadline on fully terminating the connections on both sides. The termination delay controls that deadline. It is a duration in milliseconds, defaulting to 100. A negative value means an infinite deadline (i.e. the connection is never fully terminated by the proxy itself). A Service with a termination delay -- Using the File Provider TOML ## Dynamic configuration [tcp.services] [tcp.services.my-service.loadBalancer] [[tcp.services.my-service.loadBalancer]] terminationDelay = 200 YAML ## Dynamic configuration tcp: services: my-service: loadBalancer: terminationDelay: 200","title":"Termination Delay"},{"location":"routing/services/#weighted-round-robin","text":"The Weighted Round Robin (alias WRR ) load-balancer of services is in charge of balancing the requests between multiple services based on provided weights. This strategy is only available to load balance between services and not between servers . This strategy can only be defined with File . TOML ## Dynamic configuration [tcp.services] [tcp.services.app] [[tcp.services.app.weighted.services]] name = \"appv1\" weight = 3 [[tcp.services.app.weighted.services]] name = \"appv2\" weight = 1 [tcp.services.appv1] [tcp.services.appv1.loadBalancer] [[tcp.services.appv1.loadBalancer.servers]] address = \"private-ip-server-1:8080/\" [tcp.services.appv2] [tcp.services.appv2.loadBalancer] [[tcp.services.appv2.loadBalancer.servers]] address = \"private-ip-server-2:8080/\" YAML ## Dynamic configuration tcp: services: app: weighted: services: - name: appv1 weight: 3 - name: appv2 weight: 1 appv1: loadBalancer: servers: - address: \"xxx.xxx.xxx.xxx:8080\" appv2: loadBalancer: servers: - address: \"xxx.xxx.xxx.xxx:8080\"","title":"Weighted Round Robin"},{"location":"user-guides/grpc/","text":"gRPC Examples \u00b6 With HTTP (h2c) \u00b6 This section explains how to use Traefik as reverse proxy for gRPC application. Traefik Configuration \u00b6 Static configuration: File (TOML) [entryPoints] [entryPoints.web] address = \":80\" [api] [providers.file] directory = \"/path/to/dynamic/config\" File (YAML) entryPoints: web: address: :80 providers: file: directory: /path/to/dynamic/config api: {} CLI --entryPoints.web.address=:80 --providers.file.directory=/path/to/dynamic/config --api.insecure=true /path/to/dynamic/config/dynamic_conf.{toml,yml} : TOML ## dynamic configuration ## [http] [http.routers] [http.routers.routerTest] service = \"srv-grpc\" rule = \"Host(`frontend.local`)\" [http.services] [http.services.srv-grpc] [http.services.srv-grpc.loadBalancer] [[http.services.srv-grpc.loadBalancer.servers]] url = \"h2c://backend.local:8080\" YAML ## dynamic configuration ## http: routers: routerTest: service: srv-grpc rule: Host(`frontend.local`) services: srv-grpc: loadBalancer: servers: - url: h2c://backend.local:8080 Warning For providers with labels, you will have to specify the traefik.http.services.<my-service-name>.loadbalancer.server.scheme=h2c Conclusion \u00b6 We don't need specific configuration to use gRPC in Traefik, we just need to use h2c protocol, or use HTTPS communications to have HTTP2 with the backend. With HTTPS \u00b6 This section explains how to use Traefik as reverse proxy for gRPC application with self-signed certificates. gRPC Server Certificate \u00b6 In order to secure the gRPC server, we generate a self-signed certificate for service url: openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ./backend.key -out ./backend.cert That will prompt for information, the important answer is: Common Name (e.g. server FQDN or YOUR name) []: backend.local gRPC Client Certificate \u00b6 Generate your self-signed certificate for router url: openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ./frontend.key -out ./frontend.cert with Common Name (e.g. server FQDN or YOUR name) []: frontend.local Traefik Configuration \u00b6 At last, we configure our Traefik instance to use both self-signed certificates. Static configuration: File (TOML) [entryPoints] [entryPoints.websecure] address = \":4443\" [serversTransport] # For secure connection on backend.local rootCAs = [ \"./backend.cert\" ] [api] [provider.file] directory = \"/path/to/dynamic/config\" File (YAML) entryPoints: websecure: address: :4443 serversTransport: # For secure connection on backend.local rootCAs: - ./backend.cert providers: file: directory: /path/to/dynamic/config api: {} CLI --entryPoints.websecure.address=:4443 # For secure connection on backend.local --serversTransport.rootCAs=./backend.cert --providers.file.directory=/path/to/dynamic/config --api.insecure=true /path/to/dynamic/config/dynamic_conf.{toml,yml} : TOML ## dynamic configuration ## [http] [http.routers] [http.routers.routerTest] service = \"srv-grpc\" rule = \"Host(`frontend.local`)\" [http.services] [http.services.srv-grpc] [http.services.srv-grpc.loadBalancer] [[http.services.srv-grpc.loadBalancer.servers]] # Access on backend with HTTPS url = \"https://backend.local:8080\" [tls] # For secure connection on frontend.local [[tls.certificates]] certFile = \"./frontend.cert\" keyFile = \"./frontend.key\" YAML ## dynamic configuration ## http: routers: routerTest: service: srv-grpc rule: Host(`frontend.local`) services: srv-grpc: loadBalancer: servers: # Access on backend with HTTPS - url: https://backend.local:8080 tls: # For secure connection on frontend.local certificates: - certfile: ./frontend.cert keyfile: ./frontend.key Warning With some services, the server URLs use the IP, so you may need to configure insecureSkipVerify instead of the rootCAs to activate HTTPS without hostname verification. A gRPC example in go (modify for https) \u00b6 We use the gRPC greeter example in grpc-go Warning In order to use this gRPC example, we need to modify it to use HTTPS So we modify the \"gRPC server example\" to use our own self-signed certificate: // ... // Read cert and key file backendCert, _ := ioutil.ReadFile(\"./backend.cert\") backendKey, _ := ioutil.ReadFile(\"./backend.key\") // Generate Certificate struct cert, err := tls.X509KeyPair(backendCert, backendKey) if err != nil { log.Fatalf(\"failed to parse certificate: %v\", err) } // Create credentials creds := credentials.NewServerTLSFromCert(&cert) // Use Credentials in gRPC server options serverOption := grpc.Creds(creds) var s *grpc.Server = grpc.NewServer(serverOption) defer s.Stop() pb.RegisterGreeterServer(s, &server{}) err := s.Serve(lis) // ... Next we will modify gRPC Client to use our Traefik self-signed certificate: // ... // Read cert file frontendCert, _ := ioutil.ReadFile(\"./frontend.cert\") // Create CertPool roots := x509.NewCertPool() roots.AppendCertsFromPEM(frontendCert) // Create credentials credsClient := credentials.NewClientTLSFromCert(roots, \"\") // Dial with specific Transport (with credentials) conn, err := grpc.Dial(\"frontend.local:4443\", grpc.WithTransportCredentials(credsClient)) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() client := pb.NewGreeterClient(conn) name := \"World\" r, err := client.SayHello(context.Background(), &pb.HelloRequest{Name: name}) // ...","title":"gRPC Examples"},{"location":"user-guides/grpc/#grpc-examples","text":"","title":"gRPC Examples"},{"location":"user-guides/grpc/#with-http-h2c","text":"This section explains how to use Traefik as reverse proxy for gRPC application.","title":"With HTTP (h2c)"},{"location":"user-guides/grpc/#traefik-configuration","text":"Static configuration: File (TOML) [entryPoints] [entryPoints.web] address = \":80\" [api] [providers.file] directory = \"/path/to/dynamic/config\" File (YAML) entryPoints: web: address: :80 providers: file: directory: /path/to/dynamic/config api: {} CLI --entryPoints.web.address=:80 --providers.file.directory=/path/to/dynamic/config --api.insecure=true /path/to/dynamic/config/dynamic_conf.{toml,yml} : TOML ## dynamic configuration ## [http] [http.routers] [http.routers.routerTest] service = \"srv-grpc\" rule = \"Host(`frontend.local`)\" [http.services] [http.services.srv-grpc] [http.services.srv-grpc.loadBalancer] [[http.services.srv-grpc.loadBalancer.servers]] url = \"h2c://backend.local:8080\" YAML ## dynamic configuration ## http: routers: routerTest: service: srv-grpc rule: Host(`frontend.local`) services: srv-grpc: loadBalancer: servers: - url: h2c://backend.local:8080 Warning For providers with labels, you will have to specify the traefik.http.services.<my-service-name>.loadbalancer.server.scheme=h2c","title":"Traefik Configuration"},{"location":"user-guides/grpc/#conclusion","text":"We don't need specific configuration to use gRPC in Traefik, we just need to use h2c protocol, or use HTTPS communications to have HTTP2 with the backend.","title":"Conclusion"},{"location":"user-guides/grpc/#with-https","text":"This section explains how to use Traefik as reverse proxy for gRPC application with self-signed certificates.","title":"With HTTPS"},{"location":"user-guides/grpc/#grpc-server-certificate","text":"In order to secure the gRPC server, we generate a self-signed certificate for service url: openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ./backend.key -out ./backend.cert That will prompt for information, the important answer is: Common Name (e.g. server FQDN or YOUR name) []: backend.local","title":"gRPC Server Certificate"},{"location":"user-guides/grpc/#grpc-client-certificate","text":"Generate your self-signed certificate for router url: openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ./frontend.key -out ./frontend.cert with Common Name (e.g. server FQDN or YOUR name) []: frontend.local","title":"gRPC Client Certificate"},{"location":"user-guides/grpc/#traefik-configuration_1","text":"At last, we configure our Traefik instance to use both self-signed certificates. Static configuration: File (TOML) [entryPoints] [entryPoints.websecure] address = \":4443\" [serversTransport] # For secure connection on backend.local rootCAs = [ \"./backend.cert\" ] [api] [provider.file] directory = \"/path/to/dynamic/config\" File (YAML) entryPoints: websecure: address: :4443 serversTransport: # For secure connection on backend.local rootCAs: - ./backend.cert providers: file: directory: /path/to/dynamic/config api: {} CLI --entryPoints.websecure.address=:4443 # For secure connection on backend.local --serversTransport.rootCAs=./backend.cert --providers.file.directory=/path/to/dynamic/config --api.insecure=true /path/to/dynamic/config/dynamic_conf.{toml,yml} : TOML ## dynamic configuration ## [http] [http.routers] [http.routers.routerTest] service = \"srv-grpc\" rule = \"Host(`frontend.local`)\" [http.services] [http.services.srv-grpc] [http.services.srv-grpc.loadBalancer] [[http.services.srv-grpc.loadBalancer.servers]] # Access on backend with HTTPS url = \"https://backend.local:8080\" [tls] # For secure connection on frontend.local [[tls.certificates]] certFile = \"./frontend.cert\" keyFile = \"./frontend.key\" YAML ## dynamic configuration ## http: routers: routerTest: service: srv-grpc rule: Host(`frontend.local`) services: srv-grpc: loadBalancer: servers: # Access on backend with HTTPS - url: https://backend.local:8080 tls: # For secure connection on frontend.local certificates: - certfile: ./frontend.cert keyfile: ./frontend.key Warning With some services, the server URLs use the IP, so you may need to configure insecureSkipVerify instead of the rootCAs to activate HTTPS without hostname verification.","title":"Traefik Configuration"},{"location":"user-guides/grpc/#a-grpc-example-in-go-modify-for-https","text":"We use the gRPC greeter example in grpc-go Warning In order to use this gRPC example, we need to modify it to use HTTPS So we modify the \"gRPC server example\" to use our own self-signed certificate: // ... // Read cert and key file backendCert, _ := ioutil.ReadFile(\"./backend.cert\") backendKey, _ := ioutil.ReadFile(\"./backend.key\") // Generate Certificate struct cert, err := tls.X509KeyPair(backendCert, backendKey) if err != nil { log.Fatalf(\"failed to parse certificate: %v\", err) } // Create credentials creds := credentials.NewServerTLSFromCert(&cert) // Use Credentials in gRPC server options serverOption := grpc.Creds(creds) var s *grpc.Server = grpc.NewServer(serverOption) defer s.Stop() pb.RegisterGreeterServer(s, &server{}) err := s.Serve(lis) // ... Next we will modify gRPC Client to use our Traefik self-signed certificate: // ... // Read cert file frontendCert, _ := ioutil.ReadFile(\"./frontend.cert\") // Create CertPool roots := x509.NewCertPool() roots.AppendCertsFromPEM(frontendCert) // Create credentials credsClient := credentials.NewClientTLSFromCert(roots, \"\") // Dial with specific Transport (with credentials) conn, err := grpc.Dial(\"frontend.local:4443\", grpc.WithTransportCredentials(credsClient)) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() client := pb.NewGreeterClient(conn) name := \"World\" r, err := client.SayHello(context.Background(), &pb.HelloRequest{Name: name}) // ...","title":"A gRPC example in go (modify for https)"},{"location":"user-guides/marathon/","text":"Marathon \u00b6 This guide explains how to integrate Marathon and operate the cluster in a reliable way from Traefik's standpoint. Host detection \u00b6 Marathon offers multiple ways to run (Docker-containerized) applications, the most popular ones being BRIDGE-networked containers with dynamic high ports exposed HOST-networked containers with host machine ports containers with dedicated IP addresses ( IP-per-task ). Traefik tries to detect the configured mode and route traffic to the right IP addresses. It is possible to force using task hosts with the forceTaskHostname option. Port detection \u00b6 Traefik also attempts to determine the right port (which is a non-trivial matter in Marathon ). Following is the order by which Traefik tries to identify the port (the first one that yields a positive result will be used): A arbitrary port specified through the traefik.http.services.serviceName.loadbalancer.server.port=8080 The task port (possibly indexed through the traefik.http.services.serviceName.loadbalancer.server.port=index:0 label, otherwise the first one). The port from the application's portDefinitions field (possibly indexed through the traefik.http.services.serviceName.loadbalancer.server.port=index:0 label, otherwise the first one). The port from the application's ipAddressPerTask field (possibly indexed through the traefik.http.services.serviceName.loadbalancer.server.port=index:0 label, otherwise the first one). Achieving high availability \u00b6 Scenarios \u00b6 There are three scenarios where the availability of a Marathon application could be impaired along with the risk of losing or failing requests: During the startup phase when Traefik already routes requests to the backend even though it has not completed its bootstrapping process yet. During the shutdown phase when Traefik still routes requests to the backend while the backend is already terminating. During a failure of the application when Traefik has not yet identified the backend as being erroneous. The first two scenarios are common with every rolling upgrade of an application (i.e. a new version release or configuration update). The following sub-sections describe how to resolve or mitigate each scenario. Startup \u00b6 It is possible to define readiness checks (available since Marathon version 1.1) per application and have Marathon take these into account during the startup phase. The idea is that each application provides an HTTP endpoint that Marathon queries periodically during an ongoing deployment in order to mark the associated readiness check result as successful if and only if the endpoint returns a response within the configured HTTP code range. As long as the check keeps failing, Marathon will not proceed with the deployment (within the configured upgrade strategy bounds). Beginning with version 1.4, Traefik respects readiness check results if the Traefik option is set and checks are configured on the applications accordingly. Note Due to the way readiness check results are currently exposed by the Marathon API, ready tasks may be taken into rotation with a small delay. It is on the order of one readiness check timeout interval (as configured on the application specification) and guarantees that non-ready tasks do not receive traffic prematurely. If readiness checks are not possible, a current mitigation strategy is to enable retries and make sure that a sufficient number of healthy application tasks exist so that one retry will likely hit one of those. Apart from its probabilistic nature, the workaround comes at the price of increased latency. Shutdown \u00b6 It is possible to install a termination handler (available since Marathon version 1.3) with each application whose responsibility it is to delay the shutdown process long enough until the backend has been taken out of load-balancing rotation with reasonable confidence (i.e., Traefik has received an update from the Marathon event bus, recomputes the available Marathon backends, and applies the new configuration). Specifically, each termination handler should install a signal handler listening for a SIGTERM signal and implement the following steps on signal reception: Disable Keep-Alive HTTP connections. Keep accepting HTTP requests for a certain period of time. Stop accepting new connections. Finish serving any in-flight requests. Shut down. Traefik already ignores Marathon tasks whose state does not match TASK_RUNNING ; since terminating tasks transition into the TASK_KILLING and eventually TASK_KILLED state, there is nothing further that needs to be done on Traefik's end. How long HTTP requests should continue to be accepted in step 2 depends on how long Traefik needs to receive and process the Marathon configuration update. Under regular operational conditions, it should be on the order of seconds, with 10 seconds possibly being a good default value. Again, configuring Traefik to do retries (as discussed in the previous section) can serve as a decent workaround strategy. Paired with termination handlers, they would cover for those cases where either the termination sequence or Traefik cannot complete their part of the orchestration process in time. Failure \u00b6 A failing application always happens unexpectedly, and hence, it is very difficult or even impossible to rule out the adversal effects categorically. Failure reasons vary broadly and could stretch from unacceptable slowness, a task crash, or a network split. There are two mitigaton efforts: Configure Marathon health checks on each application. Configure Traefik health checks (possibly via the traefik.http.services.yourServiceName.loadbalancer.healthcheck.* labels) and make sure they probe with proper frequency. The Marathon health check makes sure that applications once deemed dysfunctional are being rescheduled to different slaves. However, they might take a while to get triggered and the follow-up processes to complete. For that reason, the Treafik health check provides an additional check that responds more rapidly and does not require a configuration reload to happen. Additionally, it protects from cases that the Marathon health check may not be able to cover, such as a network split. (Non-)Alternatives \u00b6 There are a few alternatives of varying quality that are frequently asked for. The remaining section is going to explore them along with a benefit/cost trade-off. Reusing Marathon health checks \u00b6 It may seem obvious to reuse the Marathon health checks as a signal to Traefik whether an application should be taken into load-balancing rotation or not. Apart from the increased latency a failing health check may have, a major problem with this is that Marathon does not persist the health check results. Consequently, if a master re-election occurs in the Marathon clusters, all health check results will revert to the unknown state, effectively causing all applications inside the cluster to become unavailable and leading to a complete cluster failure. Re-elections do not only happen during regular maintenance work (often requiring rolling upgrades of the Marathon nodes) but also when the Marathon leader fails spontaneously. As such, there is no way to handle this situation deterministically. Finally, Marathon health checks are not mandatory (the default is to use the task state as reported by Mesos), so requiring them for Traefik would raise the entry barrier for Marathon users. Traefik used to use the health check results as a strict requirement but moved away from it as users reported the dramatic consequences . Draining \u00b6 Another common approach is to let a proxy drain backends that are supposed to shut down. That is, once a backend is supposed to shut down, Traefik would stop forwarding requests. On the plus side, this would not require any modifications to the application in question. However, implementing this fully within Traefik seems like a non-trivial undertaking. Additionally, the approach is less flexible compared to a custom termination handler since only the latter allows for the implementation of custom termination sequences that go beyond simple request draining (e.g., persisting a snapshot state to disk prior to terminating). The feature is currently not implemented; a request for draining in general is at issue 41 .","title":"Marathon"},{"location":"user-guides/marathon/#marathon","text":"This guide explains how to integrate Marathon and operate the cluster in a reliable way from Traefik's standpoint.","title":"Marathon"},{"location":"user-guides/marathon/#host-detection","text":"Marathon offers multiple ways to run (Docker-containerized) applications, the most popular ones being BRIDGE-networked containers with dynamic high ports exposed HOST-networked containers with host machine ports containers with dedicated IP addresses ( IP-per-task ). Traefik tries to detect the configured mode and route traffic to the right IP addresses. It is possible to force using task hosts with the forceTaskHostname option.","title":"Host detection"},{"location":"user-guides/marathon/#port-detection","text":"Traefik also attempts to determine the right port (which is a non-trivial matter in Marathon ). Following is the order by which Traefik tries to identify the port (the first one that yields a positive result will be used): A arbitrary port specified through the traefik.http.services.serviceName.loadbalancer.server.port=8080 The task port (possibly indexed through the traefik.http.services.serviceName.loadbalancer.server.port=index:0 label, otherwise the first one). The port from the application's portDefinitions field (possibly indexed through the traefik.http.services.serviceName.loadbalancer.server.port=index:0 label, otherwise the first one). The port from the application's ipAddressPerTask field (possibly indexed through the traefik.http.services.serviceName.loadbalancer.server.port=index:0 label, otherwise the first one).","title":"Port detection"},{"location":"user-guides/marathon/#achieving-high-availability","text":"","title":"Achieving high availability"},{"location":"user-guides/marathon/#scenarios","text":"There are three scenarios where the availability of a Marathon application could be impaired along with the risk of losing or failing requests: During the startup phase when Traefik already routes requests to the backend even though it has not completed its bootstrapping process yet. During the shutdown phase when Traefik still routes requests to the backend while the backend is already terminating. During a failure of the application when Traefik has not yet identified the backend as being erroneous. The first two scenarios are common with every rolling upgrade of an application (i.e. a new version release or configuration update). The following sub-sections describe how to resolve or mitigate each scenario.","title":"Scenarios"},{"location":"user-guides/marathon/#startup","text":"It is possible to define readiness checks (available since Marathon version 1.1) per application and have Marathon take these into account during the startup phase. The idea is that each application provides an HTTP endpoint that Marathon queries periodically during an ongoing deployment in order to mark the associated readiness check result as successful if and only if the endpoint returns a response within the configured HTTP code range. As long as the check keeps failing, Marathon will not proceed with the deployment (within the configured upgrade strategy bounds). Beginning with version 1.4, Traefik respects readiness check results if the Traefik option is set and checks are configured on the applications accordingly. Note Due to the way readiness check results are currently exposed by the Marathon API, ready tasks may be taken into rotation with a small delay. It is on the order of one readiness check timeout interval (as configured on the application specification) and guarantees that non-ready tasks do not receive traffic prematurely. If readiness checks are not possible, a current mitigation strategy is to enable retries and make sure that a sufficient number of healthy application tasks exist so that one retry will likely hit one of those. Apart from its probabilistic nature, the workaround comes at the price of increased latency.","title":"Startup"},{"location":"user-guides/marathon/#shutdown","text":"It is possible to install a termination handler (available since Marathon version 1.3) with each application whose responsibility it is to delay the shutdown process long enough until the backend has been taken out of load-balancing rotation with reasonable confidence (i.e., Traefik has received an update from the Marathon event bus, recomputes the available Marathon backends, and applies the new configuration). Specifically, each termination handler should install a signal handler listening for a SIGTERM signal and implement the following steps on signal reception: Disable Keep-Alive HTTP connections. Keep accepting HTTP requests for a certain period of time. Stop accepting new connections. Finish serving any in-flight requests. Shut down. Traefik already ignores Marathon tasks whose state does not match TASK_RUNNING ; since terminating tasks transition into the TASK_KILLING and eventually TASK_KILLED state, there is nothing further that needs to be done on Traefik's end. How long HTTP requests should continue to be accepted in step 2 depends on how long Traefik needs to receive and process the Marathon configuration update. Under regular operational conditions, it should be on the order of seconds, with 10 seconds possibly being a good default value. Again, configuring Traefik to do retries (as discussed in the previous section) can serve as a decent workaround strategy. Paired with termination handlers, they would cover for those cases where either the termination sequence or Traefik cannot complete their part of the orchestration process in time.","title":"Shutdown"},{"location":"user-guides/marathon/#failure","text":"A failing application always happens unexpectedly, and hence, it is very difficult or even impossible to rule out the adversal effects categorically. Failure reasons vary broadly and could stretch from unacceptable slowness, a task crash, or a network split. There are two mitigaton efforts: Configure Marathon health checks on each application. Configure Traefik health checks (possibly via the traefik.http.services.yourServiceName.loadbalancer.healthcheck.* labels) and make sure they probe with proper frequency. The Marathon health check makes sure that applications once deemed dysfunctional are being rescheduled to different slaves. However, they might take a while to get triggered and the follow-up processes to complete. For that reason, the Treafik health check provides an additional check that responds more rapidly and does not require a configuration reload to happen. Additionally, it protects from cases that the Marathon health check may not be able to cover, such as a network split.","title":"Failure"},{"location":"user-guides/marathon/#non-alternatives","text":"There are a few alternatives of varying quality that are frequently asked for. The remaining section is going to explore them along with a benefit/cost trade-off.","title":"(Non-)Alternatives"},{"location":"user-guides/marathon/#reusing-marathon-health-checks","text":"It may seem obvious to reuse the Marathon health checks as a signal to Traefik whether an application should be taken into load-balancing rotation or not. Apart from the increased latency a failing health check may have, a major problem with this is that Marathon does not persist the health check results. Consequently, if a master re-election occurs in the Marathon clusters, all health check results will revert to the unknown state, effectively causing all applications inside the cluster to become unavailable and leading to a complete cluster failure. Re-elections do not only happen during regular maintenance work (often requiring rolling upgrades of the Marathon nodes) but also when the Marathon leader fails spontaneously. As such, there is no way to handle this situation deterministically. Finally, Marathon health checks are not mandatory (the default is to use the task state as reported by Mesos), so requiring them for Traefik would raise the entry barrier for Marathon users. Traefik used to use the health check results as a strict requirement but moved away from it as users reported the dramatic consequences .","title":"Reusing Marathon health checks"},{"location":"user-guides/marathon/#draining","text":"Another common approach is to let a proxy drain backends that are supposed to shut down. That is, once a backend is supposed to shut down, Traefik would stop forwarding requests. On the plus side, this would not require any modifications to the application in question. However, implementing this fully within Traefik seems like a non-trivial undertaking. Additionally, the approach is less flexible compared to a custom termination handler since only the latter allows for the implementation of custom termination sequences that go beyond simple request draining (e.g., persisting a snapshot state to disk prior to terminating). The feature is currently not implemented; a request for draining in general is at issue 41 .","title":"Draining"},{"location":"user-guides/crd-acme/","text":"Traefik & CRD & Let's Encrypt \u00b6 Traefik with an IngressRoute Custom Resource Definition for Kubernetes, and TLS Through Let's Encrypt. This document is intended to be a fully working example demonstrating how to set up Traefik in Kubernetes , with the dynamic configuration coming from the IngressRoute Custom Resource , and TLS setup with Let's Encrypt . However, for the sake of simplicity, we're using k3s docker image for the Kubernetes cluster setup. Please note that for this setup, given that we're going to use ACME's TLS-ALPN-01 challenge, the host you'll be running it on must be able to receive connections from the outside on port 443. And of course its internet facing IP address must match the domain name you intend to use. In the following, the Kubernetes resources defined in YAML configuration files can be applied to the setup in two different ways: the first, and usual way, is simply with the kubectl apply command. the second, which can be used for this tutorial, is to directly place the files in the directory used by the k3s docker image for such inputs ( /var/lib/rancher/k3s/server/manifests ). Kubectl Version With the rancher/k3s version used in this guide ( 0.8.0 ), the kubectl version needs to be >= 1.11 . k3s Docker-compose Configuration \u00b6 Our starting point is the docker-compose configuration file, to start the k3s cluster. You can start it with: docker-compose -f k3s.yml up server: image: rancher/k3s:v0.8.0 command: server --disable-agent --no-deploy traefik environment: - K3S_CLUSTER_SECRET=somethingtotallyrandom - K3S_KUBECONFIG_OUTPUT=/output/kubeconfig.yaml - K3S_KUBECONFIG_MODE=666 volumes: # k3s will generate a kubeconfig.yaml in this directory. This volume is mounted # on your host, so you can then 'export KUBECONFIG=/somewhere/on/your/host/out/kubeconfig.yaml', # in order for your kubectl commands to work. - /somewhere/on/your/host/out:/output # This directory is where you put all the (yaml) configuration files of # the Kubernetes resources. - /somewhere/on/your/host/in:/var/lib/rancher/k3s/server/manifests ports: - 6443:6443 node: image: rancher/k3s:v0.8.0 privileged: true links: - server environment: - K3S_URL=https://server:6443 - K3S_CLUSTER_SECRET=somethingtotallyrandom volumes: # this is where you would place a alternative traefik image (saved as a .tar file with # 'docker save'), if you want to use it, instead of the traefik:v2.0 image. - /sowewhere/on/your/host/custom-image:/var/lib/rancher/k3s/agent/images Cluster Resources \u00b6 Let's now have a look (in the order they should be applied, if using kubectl apply ) at all the required resources for the full setup. IngressRoute Definition \u00b6 First, the definition of the IngressRoute and the Middleware kinds. Also note the RBAC authorization resources; they'll be referenced through the serviceAccountName of the deployment, later on. apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutetcps.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRouteTCP plural: ingressroutetcps singular: ingressroutetcp scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: tlsoptions.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: TLSOption plural: tlsoptions singular: tlsoption scope: Namespaced --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: traefik-ingress-controller rules: - apiGroups: - \"\" resources: - services - endpoints - secrets verbs: - get - list - watch - apiGroups: - extensions resources: - ingresses verbs: - get - list - watch - apiGroups: - extensions resources: - ingresses/status verbs: - update - apiGroups: - traefik.containo.us resources: - middlewares verbs: - get - list - watch - apiGroups: - traefik.containo.us resources: - ingressroutes verbs: - get - list - watch - apiGroups: - traefik.containo.us resources: - ingressroutetcps verbs: - get - list - watch - apiGroups: - traefik.containo.us resources: - tlsoptions verbs: - get - list - watch --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: traefik-ingress-controller roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: traefik-ingress-controller subjects: - kind: ServiceAccount name: traefik-ingress-controller namespace: default Services \u00b6 Then, the services. One for Traefik itself, and one for the app it routes for, i.e. in this case our demo HTTP server: whoami . apiVersion: v1 kind: Service metadata: name: traefik spec: ports: - protocol: TCP name: web port: 8000 - protocol: TCP name: admin port: 8080 - protocol: TCP name: websecure port: 4443 selector: app: traefik --- apiVersion: v1 kind: Service metadata: name: whoami spec: ports: - protocol: TCP name: web port: 80 selector: app: whoami Deployments \u00b6 Next, the deployments, i.e. the actual pods behind the services. Again, one pod for Traefik, and one for the whoami app. apiVersion: v1 kind: ServiceAccount metadata: namespace: default name: traefik-ingress-controller --- kind: Deployment apiVersion: apps/v1 metadata: namespace: default name: traefik labels: app: traefik spec: replicas: 1 selector: matchLabels: app: traefik template: metadata: labels: app: traefik spec: serviceAccountName: traefik-ingress-controller containers: - name: traefik image: traefik:v2.0 args: - --api.insecure - --accesslog - --entrypoints.web.Address=:8000 - --entrypoints.websecure.Address=:4443 - --providers.kubernetescrd - --certificatesresolvers.default.acme.tlschallenge - --certificatesresolvers.default.acme.email=foo@you.com - --certificatesresolvers.default.acme.storage=acme.json # Please note that this is the staging Let's Encrypt server. # Once you get things working, you should remove that whole line altogether. - --certificatesresolvers.default.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory ports: - name: web containerPort: 8000 - name: websecure containerPort: 4443 - name: admin containerPort: 8080 --- kind: Deployment apiVersion: apps/v1 metadata: namespace: default name: whoami labels: app: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: containers: - name: whoami image: containous/whoami ports: - name: web containerPort: 80 Port Forwarding \u00b6 Now, as an exception to what we said above, please note that you should not let the ingressRoute resources below be applied automatically to your cluster. The reason is, as soon as the ACME provider of Traefik detects we have TLS routers, it will try to generate the certificates for the corresponding domains. And this will not work, because as it is, our Traefik pod is not reachable from the outside, which will make the ACME TLS challenge fail. Therefore, for the whole thing to work, we must delay applying the ingressRoute resources until we have port-forwarding set up properly, which is the next step. kubectl port-forward --address 0.0.0.0 service/traefik 8000:8000 8080:8080 443:4443 -n default Also, and this is out of the scope if this guide, please note that because of the privileged ports limitation on Linux, the above command might fail to listen on port 443. In which case you can use tricks such as elevating caps of kubectl with setcaps , or using authbind , or setting up a NAT between your host and the WAN. Look it up. Traefik Routers \u00b6 We can now finally apply the actual ingressRoutes, with: kubectl apply -f 04-ingressroutes.yml apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: simpleingressroute namespace: default spec: entryPoints: - web routes: - match: Host(`your.domain.com`) && PathPrefix(`/notls`) kind: Rule services: - name: whoami port: 80 --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutetls namespace: default spec: entryPoints: - websecure routes: - match: Host(`your.domain.com`) && PathPrefix(`/tls`) kind: Rule services: - name: whoami port: 80 tls: certResolver: default Give it a few seconds for the ACME TLS challenge to complete, and you should then be able to access your whoami pod (routed through Traefik), from the outside. Both with or (just for fun, do not do that in production) without TLS: curl [-k] https://your.domain.com/tls curl [-k] http://your.domain.com:8000/notls Note that you'll have to use -k as long as you're using the staging server of Let's Encrypt, since it is not an authorized certificate authority on systems where it hasn't been manually added.","title":"Kubernetes and Let's Encrypt"},{"location":"user-guides/crd-acme/#traefik-crd-lets-encrypt","text":"Traefik with an IngressRoute Custom Resource Definition for Kubernetes, and TLS Through Let's Encrypt. This document is intended to be a fully working example demonstrating how to set up Traefik in Kubernetes , with the dynamic configuration coming from the IngressRoute Custom Resource , and TLS setup with Let's Encrypt . However, for the sake of simplicity, we're using k3s docker image for the Kubernetes cluster setup. Please note that for this setup, given that we're going to use ACME's TLS-ALPN-01 challenge, the host you'll be running it on must be able to receive connections from the outside on port 443. And of course its internet facing IP address must match the domain name you intend to use. In the following, the Kubernetes resources defined in YAML configuration files can be applied to the setup in two different ways: the first, and usual way, is simply with the kubectl apply command. the second, which can be used for this tutorial, is to directly place the files in the directory used by the k3s docker image for such inputs ( /var/lib/rancher/k3s/server/manifests ). Kubectl Version With the rancher/k3s version used in this guide ( 0.8.0 ), the kubectl version needs to be >= 1.11 .","title":"Traefik &amp; CRD &amp; Let's Encrypt"},{"location":"user-guides/crd-acme/#k3s-docker-compose-configuration","text":"Our starting point is the docker-compose configuration file, to start the k3s cluster. You can start it with: docker-compose -f k3s.yml up server: image: rancher/k3s:v0.8.0 command: server --disable-agent --no-deploy traefik environment: - K3S_CLUSTER_SECRET=somethingtotallyrandom - K3S_KUBECONFIG_OUTPUT=/output/kubeconfig.yaml - K3S_KUBECONFIG_MODE=666 volumes: # k3s will generate a kubeconfig.yaml in this directory. This volume is mounted # on your host, so you can then 'export KUBECONFIG=/somewhere/on/your/host/out/kubeconfig.yaml', # in order for your kubectl commands to work. - /somewhere/on/your/host/out:/output # This directory is where you put all the (yaml) configuration files of # the Kubernetes resources. - /somewhere/on/your/host/in:/var/lib/rancher/k3s/server/manifests ports: - 6443:6443 node: image: rancher/k3s:v0.8.0 privileged: true links: - server environment: - K3S_URL=https://server:6443 - K3S_CLUSTER_SECRET=somethingtotallyrandom volumes: # this is where you would place a alternative traefik image (saved as a .tar file with # 'docker save'), if you want to use it, instead of the traefik:v2.0 image. - /sowewhere/on/your/host/custom-image:/var/lib/rancher/k3s/agent/images","title":"k3s Docker-compose Configuration"},{"location":"user-guides/crd-acme/#cluster-resources","text":"Let's now have a look (in the order they should be applied, if using kubectl apply ) at all the required resources for the full setup.","title":"Cluster Resources"},{"location":"user-guides/crd-acme/#ingressroute-definition","text":"First, the definition of the IngressRoute and the Middleware kinds. Also note the RBAC authorization resources; they'll be referenced through the serviceAccountName of the deployment, later on. apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutetcps.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRouteTCP plural: ingressroutetcps singular: ingressroutetcp scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: tlsoptions.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: TLSOption plural: tlsoptions singular: tlsoption scope: Namespaced --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: traefik-ingress-controller rules: - apiGroups: - \"\" resources: - services - endpoints - secrets verbs: - get - list - watch - apiGroups: - extensions resources: - ingresses verbs: - get - list - watch - apiGroups: - extensions resources: - ingresses/status verbs: - update - apiGroups: - traefik.containo.us resources: - middlewares verbs: - get - list - watch - apiGroups: - traefik.containo.us resources: - ingressroutes verbs: - get - list - watch - apiGroups: - traefik.containo.us resources: - ingressroutetcps verbs: - get - list - watch - apiGroups: - traefik.containo.us resources: - tlsoptions verbs: - get - list - watch --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: traefik-ingress-controller roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: traefik-ingress-controller subjects: - kind: ServiceAccount name: traefik-ingress-controller namespace: default","title":"IngressRoute Definition"},{"location":"user-guides/crd-acme/#services","text":"Then, the services. One for Traefik itself, and one for the app it routes for, i.e. in this case our demo HTTP server: whoami . apiVersion: v1 kind: Service metadata: name: traefik spec: ports: - protocol: TCP name: web port: 8000 - protocol: TCP name: admin port: 8080 - protocol: TCP name: websecure port: 4443 selector: app: traefik --- apiVersion: v1 kind: Service metadata: name: whoami spec: ports: - protocol: TCP name: web port: 80 selector: app: whoami","title":"Services"},{"location":"user-guides/crd-acme/#deployments","text":"Next, the deployments, i.e. the actual pods behind the services. Again, one pod for Traefik, and one for the whoami app. apiVersion: v1 kind: ServiceAccount metadata: namespace: default name: traefik-ingress-controller --- kind: Deployment apiVersion: apps/v1 metadata: namespace: default name: traefik labels: app: traefik spec: replicas: 1 selector: matchLabels: app: traefik template: metadata: labels: app: traefik spec: serviceAccountName: traefik-ingress-controller containers: - name: traefik image: traefik:v2.0 args: - --api.insecure - --accesslog - --entrypoints.web.Address=:8000 - --entrypoints.websecure.Address=:4443 - --providers.kubernetescrd - --certificatesresolvers.default.acme.tlschallenge - --certificatesresolvers.default.acme.email=foo@you.com - --certificatesresolvers.default.acme.storage=acme.json # Please note that this is the staging Let's Encrypt server. # Once you get things working, you should remove that whole line altogether. - --certificatesresolvers.default.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory ports: - name: web containerPort: 8000 - name: websecure containerPort: 4443 - name: admin containerPort: 8080 --- kind: Deployment apiVersion: apps/v1 metadata: namespace: default name: whoami labels: app: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: containers: - name: whoami image: containous/whoami ports: - name: web containerPort: 80","title":"Deployments"},{"location":"user-guides/crd-acme/#port-forwarding","text":"Now, as an exception to what we said above, please note that you should not let the ingressRoute resources below be applied automatically to your cluster. The reason is, as soon as the ACME provider of Traefik detects we have TLS routers, it will try to generate the certificates for the corresponding domains. And this will not work, because as it is, our Traefik pod is not reachable from the outside, which will make the ACME TLS challenge fail. Therefore, for the whole thing to work, we must delay applying the ingressRoute resources until we have port-forwarding set up properly, which is the next step. kubectl port-forward --address 0.0.0.0 service/traefik 8000:8000 8080:8080 443:4443 -n default Also, and this is out of the scope if this guide, please note that because of the privileged ports limitation on Linux, the above command might fail to listen on port 443. In which case you can use tricks such as elevating caps of kubectl with setcaps , or using authbind , or setting up a NAT between your host and the WAN. Look it up.","title":"Port Forwarding"},{"location":"user-guides/crd-acme/#traefik-routers","text":"We can now finally apply the actual ingressRoutes, with: kubectl apply -f 04-ingressroutes.yml apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: simpleingressroute namespace: default spec: entryPoints: - web routes: - match: Host(`your.domain.com`) && PathPrefix(`/notls`) kind: Rule services: - name: whoami port: 80 --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutetls namespace: default spec: entryPoints: - websecure routes: - match: Host(`your.domain.com`) && PathPrefix(`/tls`) kind: Rule services: - name: whoami port: 80 tls: certResolver: default Give it a few seconds for the ACME TLS challenge to complete, and you should then be able to access your whoami pod (routed through Traefik), from the outside. Both with or (just for fun, do not do that in production) without TLS: curl [-k] https://your.domain.com/tls curl [-k] http://your.domain.com:8000/notls Note that you'll have to use -k as long as you're using the staging server of Let's Encrypt, since it is not an authorized certificate authority on systems where it hasn't been manually added.","title":"Traefik Routers"},{"location":"user-guides/docker-compose/acme-dns/","text":"Docker-compose with let's encrypt: DNS Challenge \u00b6 This guide aim to demonstrate how to create a certificate with the let's encrypt DNS challenge to use https on a simple service exposed with Traefik. Please also read the basic example for details on how to expose such a service. Prerequisite \u00b6 For the DNS challenge, you'll need: A working provider along with the credentials allowing to create and remove DNS records. Variables may vary depending on the Provider. Please note this guide may vary depending on the provider you use. The only things changing are the names of the variables you will need to define in order to configure your provider so it can create DNS records. Please refer the list of providers given right above and replace all the environment variables with the ones described in this documentation. Setup \u00b6 Create a docker-compose.yml file with the following content: version: \"3.3\" services: traefik: image: \"traefik:v2.0.0-rc3\" container_name: \"traefik\" command: #- \"--log.level=DEBUG\" - \"--api.insecure=true\" - \"--providers.docker=true\" - \"--providers.docker.exposedbydefault=false\" - \"--entrypoints.web.address=:80\" - \"--entrypoints.websecure.address=:443\" - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge=true\" - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge.provider=ovh\" #- \"--certificatesresolvers.mydnschallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" - \"--certificatesresolvers.mydnschallenge.acme.email=postmaster@mydomain.com\" - \"--certificatesresolvers.mydnschallenge.acme.storage=/letsencrypt/acme.json\" ports: - \"80:80\" - \"443:443\" - \"8080:8080\" environment: - \"OVH_ENDPOINT=xxx\" - \"OVH_APPLICATION_KEY=xxx\" - \"OVH_APPLICATION_SECRET=xxx\" - \"OVH_CONSUMER_KEY=xxx\" volumes: - \"./letsencrypt:/letsencrypt\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: image: \"containous/whoami\" container_name: \"simple-service\" labels: - \"traefik.enable=true\" - \"traefik.http.routers.whoami.rule=Host(`whoami.mydomain.com`)\" - \"traefik.http.routers.whoami.entrypoints=websecure\" - \"traefik.http.routers.whoami.tls.certresolver=mydnschallenge\" Replace the environment variables by your own: environment: - \"OVH_ENDPOINT=[YOUR_OWN_VALUE]\" - \"OVH_APPLICATION_KEY=[YOUR_OWN_VALUE]\" - \"OVH_APPLICATION_SECRET=[YOUR_OWN_VALUE]\" - \"OVH_CONSUMER_KEY=[YOUR_OWN_VALUE]\" Replace postmaster@mydomain.com by your own email within the certificatesresolvers.mydnschallenge.acme.email command line argument of the traefik service. Replace whoami.mydomain.com by your own domain within the traefik.http.routers.whoami.rule label of the whoami service. Optionally uncomment the following lines if you want to test/debug: #- \"--log.level=DEBUG\" #- \"--certificatesresolvers.mydnschallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" Run docker-compose up -d within the folder where you created the previous file. Wait a bit and visit https://your_own_domain to confirm everything went fine. Note If you uncommented the acme.caserver line, you will get an SSL error, but if you display the certificate and see it was emitted by Fake LE Intermediate X1 then it means all is good. (It is the staging environment intermediate certificate used by let's encrypt). You can now safely comment the acme.caserver line, remove the letsencrypt/acme.json file and restart Traefik to issue a valid certificate. Explanation \u00b6 What changed between the initial setup: We configure a second entry point for the https traffic: command: # Traefik will listen to incoming request on the port 443 (https) - \"--entrypoints.websecure.address=:443\" ports: - \"443:443\" We configure the DNS let's encrypt challenge: command: # Enable a dns challenge named \"mydnschallenge\" - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge=true\" # Tell which provider to use - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge.provider=ovh\" # The email to provide to let's encrypt - \"--certificatesresolvers.mydnschallenge.acme.email=postmaster@mydomain.com\" We provide the required configuration to our provider via environment variables: environment: - \"OVH_ENDPOINT=xxx\" - \"OVH_APPLICATION_KEY=xxx\" - \"OVH_APPLICATION_SECRET=xxx\" - \"OVH_CONSUMER_KEY=xxx\" Note This is the step that may vary depending on the provider you use. Just define the variables required by your provider. (see the prerequisite for a list) We add a volume to store our certificates: volumes: # Create a letsencrypt dir within the folder where the docker-compose file is - \"./letsencrypt:/letsencrypt\" command: # Tell to store the certificate on a path under our volume - \"--certificatesresolvers.mydnschallenge.acme.storage=/letsencrypt/acme.json\" We configure the whoami service to tell Traefik to use the certificate resolver named mydnschallenge we just configured: labels: - \"traefik.http.routers.whoami.tls.certresolver=mydnschallenge\" # Uses the Host rule to define which certificate to issue Use Secrets \u00b6 To configure the provider, and avoid having the secrets exposed in plaintext within the docker-compose environment section, you could use docker secrets. The point is to manage those secret files by another mean, and read them from the docker-compose.yml file making the docker-compose file itself less sensitive. Create a directory named secrets , and create a file for each parameters required to configure you provider containing the value of the parameter: for example, the ovh_endpoint.secret file contain ovh-eu ./secrets \u251c\u2500\u2500 ovh_application_key.secret \u251c\u2500\u2500 ovh_application_secret.secret \u251c\u2500\u2500 ovh_consumer_key.secret \u2514\u2500\u2500 ovh_endpoint.secret Note You could store those secrets anywhere on the server, just make sure to use the proper path for the file directive fo the secrets definition in the docker-compose.yml file. Use this docker-compose.yml file: version: \"3.3\" secrets: ovh_endpoint: file: \"./secrets/ovh_endpoint.secret\" ovh_application_key: file: \"./secrets/ovh_application_key.secret\" ovh_application_secret: file: \"./secrets/ovh_application_secret.secret\" ovh_consumer_key: file: \"./secrets/ovh_consumer_key.secret\" services: traefik: image: \"traefik:v2.0.0-rc3\" container_name: \"traefik\" command: #- \"--log.level=DEBUG\" - \"--api.insecure=true\" - \"--providers.docker=true\" - \"--providers.docker.exposedbydefault=false\" - \"--entrypoints.web.address=:80\" - \"--entrypoints.websecure.address=:443\" - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge=true\" - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge.provider=ovh\" #- \"--certificatesresolvers.mydnschallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" - \"--certificatesresolvers.mydnschallenge.acme.email=postmaster@mydomain.com\" - \"--certificatesresolvers.mydnschallenge.acme.storage=/letsencrypt/acme.json\" ports: - \"80:80\" - \"443:443\" - \"8080:8080\" secrets: - \"ovh_endpoint\" - \"ovh_application_key\" - \"ovh_application_secret\" - \"ovh_consumer_key\" environment: - \"OVH_ENDPOINT_FILE=/run/secrets/ovh_endpoint\" - \"OVH_APPLICATION_KEY_FILE=/run/secrets/ovh_application_key\" - \"OVH_APPLICATION_SECRET_FILE=/run/secrets/ovh_application_secret\" - \"OVH_CONSUMER_KEY_FILE=/run/secrets/ovh_consumer_key\" volumes: - \"./letsencrypt:/letsencrypt\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: image: \"containous/whoami\" container_name: \"simple-service\" labels: - \"traefik.enable=true\" - \"traefik.http.routers.whoami.rule=Host(`whoami.mydomain.com`)\" - \"traefik.http.routers.whoami.entrypoints=websecure\" - \"traefik.http.routers.whoami.tls.certresolver=mydnschallenge\" Note Still think about changing postmaster@mydomain.com & whoami.mydomain.com by your own values. Let's explain a bit what we just did: The following section allow to read files on the docker host, and expose those file under /run/secrets/[NAME_OF_THE_SECRET] within the container: secrets: # secret name also used to name the file exposed within the container ovh_endpoint: # path on the host file: \"./secrets/ovh_endpoint.secret\" ovh_application_key: file: \"./secrets/ovh_application_key.secret\" ovh_application_secret: file: \"./secrets/ovh_application_secret.secret\" ovh_consumer_key: file: \"./secrets/ovh_consumer_key.secret\" services: traefik: # expose the predefined secret to the container by name secrets: - \"ovh_endpoint\" - \"ovh_application_key\" - \"ovh_application_secret\" - \"ovh_consumer_key\" The environment variable within our whoami service are suffixed by _FILE which allow us to point to files containing the value, instead of exposing the value itself. The acme client will read the content of those file to get the required configuration values. environment: # expose the path to file provided by docker containing the value we want for OVH_ENDPOINT. - \"OVH_ENDPOINT_FILE=/run/secrets/ovh_endpoint\" - \"OVH_APPLICATION_KEY_FILE=/run/secrets/ovh_application_key\" - \"OVH_APPLICATION_SECRET_FILE=/run/secrets/ovh_application_secret\" - \"OVH_CONSUMER_KEY_FILE=/run/secrets/ovh_consumer_key\"","title":"DNS Challenge"},{"location":"user-guides/docker-compose/acme-dns/#docker-compose-with-lets-encrypt-dns-challenge","text":"This guide aim to demonstrate how to create a certificate with the let's encrypt DNS challenge to use https on a simple service exposed with Traefik. Please also read the basic example for details on how to expose such a service.","title":"Docker-compose with let's encrypt: DNS Challenge"},{"location":"user-guides/docker-compose/acme-dns/#prerequisite","text":"For the DNS challenge, you'll need: A working provider along with the credentials allowing to create and remove DNS records. Variables may vary depending on the Provider. Please note this guide may vary depending on the provider you use. The only things changing are the names of the variables you will need to define in order to configure your provider so it can create DNS records. Please refer the list of providers given right above and replace all the environment variables with the ones described in this documentation.","title":"Prerequisite"},{"location":"user-guides/docker-compose/acme-dns/#setup","text":"Create a docker-compose.yml file with the following content: version: \"3.3\" services: traefik: image: \"traefik:v2.0.0-rc3\" container_name: \"traefik\" command: #- \"--log.level=DEBUG\" - \"--api.insecure=true\" - \"--providers.docker=true\" - \"--providers.docker.exposedbydefault=false\" - \"--entrypoints.web.address=:80\" - \"--entrypoints.websecure.address=:443\" - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge=true\" - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge.provider=ovh\" #- \"--certificatesresolvers.mydnschallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" - \"--certificatesresolvers.mydnschallenge.acme.email=postmaster@mydomain.com\" - \"--certificatesresolvers.mydnschallenge.acme.storage=/letsencrypt/acme.json\" ports: - \"80:80\" - \"443:443\" - \"8080:8080\" environment: - \"OVH_ENDPOINT=xxx\" - \"OVH_APPLICATION_KEY=xxx\" - \"OVH_APPLICATION_SECRET=xxx\" - \"OVH_CONSUMER_KEY=xxx\" volumes: - \"./letsencrypt:/letsencrypt\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: image: \"containous/whoami\" container_name: \"simple-service\" labels: - \"traefik.enable=true\" - \"traefik.http.routers.whoami.rule=Host(`whoami.mydomain.com`)\" - \"traefik.http.routers.whoami.entrypoints=websecure\" - \"traefik.http.routers.whoami.tls.certresolver=mydnschallenge\" Replace the environment variables by your own: environment: - \"OVH_ENDPOINT=[YOUR_OWN_VALUE]\" - \"OVH_APPLICATION_KEY=[YOUR_OWN_VALUE]\" - \"OVH_APPLICATION_SECRET=[YOUR_OWN_VALUE]\" - \"OVH_CONSUMER_KEY=[YOUR_OWN_VALUE]\" Replace postmaster@mydomain.com by your own email within the certificatesresolvers.mydnschallenge.acme.email command line argument of the traefik service. Replace whoami.mydomain.com by your own domain within the traefik.http.routers.whoami.rule label of the whoami service. Optionally uncomment the following lines if you want to test/debug: #- \"--log.level=DEBUG\" #- \"--certificatesresolvers.mydnschallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" Run docker-compose up -d within the folder where you created the previous file. Wait a bit and visit https://your_own_domain to confirm everything went fine. Note If you uncommented the acme.caserver line, you will get an SSL error, but if you display the certificate and see it was emitted by Fake LE Intermediate X1 then it means all is good. (It is the staging environment intermediate certificate used by let's encrypt). You can now safely comment the acme.caserver line, remove the letsencrypt/acme.json file and restart Traefik to issue a valid certificate.","title":"Setup"},{"location":"user-guides/docker-compose/acme-dns/#explanation","text":"What changed between the initial setup: We configure a second entry point for the https traffic: command: # Traefik will listen to incoming request on the port 443 (https) - \"--entrypoints.websecure.address=:443\" ports: - \"443:443\" We configure the DNS let's encrypt challenge: command: # Enable a dns challenge named \"mydnschallenge\" - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge=true\" # Tell which provider to use - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge.provider=ovh\" # The email to provide to let's encrypt - \"--certificatesresolvers.mydnschallenge.acme.email=postmaster@mydomain.com\" We provide the required configuration to our provider via environment variables: environment: - \"OVH_ENDPOINT=xxx\" - \"OVH_APPLICATION_KEY=xxx\" - \"OVH_APPLICATION_SECRET=xxx\" - \"OVH_CONSUMER_KEY=xxx\" Note This is the step that may vary depending on the provider you use. Just define the variables required by your provider. (see the prerequisite for a list) We add a volume to store our certificates: volumes: # Create a letsencrypt dir within the folder where the docker-compose file is - \"./letsencrypt:/letsencrypt\" command: # Tell to store the certificate on a path under our volume - \"--certificatesresolvers.mydnschallenge.acme.storage=/letsencrypt/acme.json\" We configure the whoami service to tell Traefik to use the certificate resolver named mydnschallenge we just configured: labels: - \"traefik.http.routers.whoami.tls.certresolver=mydnschallenge\" # Uses the Host rule to define which certificate to issue","title":"Explanation"},{"location":"user-guides/docker-compose/acme-dns/#use-secrets","text":"To configure the provider, and avoid having the secrets exposed in plaintext within the docker-compose environment section, you could use docker secrets. The point is to manage those secret files by another mean, and read them from the docker-compose.yml file making the docker-compose file itself less sensitive. Create a directory named secrets , and create a file for each parameters required to configure you provider containing the value of the parameter: for example, the ovh_endpoint.secret file contain ovh-eu ./secrets \u251c\u2500\u2500 ovh_application_key.secret \u251c\u2500\u2500 ovh_application_secret.secret \u251c\u2500\u2500 ovh_consumer_key.secret \u2514\u2500\u2500 ovh_endpoint.secret Note You could store those secrets anywhere on the server, just make sure to use the proper path for the file directive fo the secrets definition in the docker-compose.yml file. Use this docker-compose.yml file: version: \"3.3\" secrets: ovh_endpoint: file: \"./secrets/ovh_endpoint.secret\" ovh_application_key: file: \"./secrets/ovh_application_key.secret\" ovh_application_secret: file: \"./secrets/ovh_application_secret.secret\" ovh_consumer_key: file: \"./secrets/ovh_consumer_key.secret\" services: traefik: image: \"traefik:v2.0.0-rc3\" container_name: \"traefik\" command: #- \"--log.level=DEBUG\" - \"--api.insecure=true\" - \"--providers.docker=true\" - \"--providers.docker.exposedbydefault=false\" - \"--entrypoints.web.address=:80\" - \"--entrypoints.websecure.address=:443\" - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge=true\" - \"--certificatesresolvers.mydnschallenge.acme.dnschallenge.provider=ovh\" #- \"--certificatesresolvers.mydnschallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" - \"--certificatesresolvers.mydnschallenge.acme.email=postmaster@mydomain.com\" - \"--certificatesresolvers.mydnschallenge.acme.storage=/letsencrypt/acme.json\" ports: - \"80:80\" - \"443:443\" - \"8080:8080\" secrets: - \"ovh_endpoint\" - \"ovh_application_key\" - \"ovh_application_secret\" - \"ovh_consumer_key\" environment: - \"OVH_ENDPOINT_FILE=/run/secrets/ovh_endpoint\" - \"OVH_APPLICATION_KEY_FILE=/run/secrets/ovh_application_key\" - \"OVH_APPLICATION_SECRET_FILE=/run/secrets/ovh_application_secret\" - \"OVH_CONSUMER_KEY_FILE=/run/secrets/ovh_consumer_key\" volumes: - \"./letsencrypt:/letsencrypt\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: image: \"containous/whoami\" container_name: \"simple-service\" labels: - \"traefik.enable=true\" - \"traefik.http.routers.whoami.rule=Host(`whoami.mydomain.com`)\" - \"traefik.http.routers.whoami.entrypoints=websecure\" - \"traefik.http.routers.whoami.tls.certresolver=mydnschallenge\" Note Still think about changing postmaster@mydomain.com & whoami.mydomain.com by your own values. Let's explain a bit what we just did: The following section allow to read files on the docker host, and expose those file under /run/secrets/[NAME_OF_THE_SECRET] within the container: secrets: # secret name also used to name the file exposed within the container ovh_endpoint: # path on the host file: \"./secrets/ovh_endpoint.secret\" ovh_application_key: file: \"./secrets/ovh_application_key.secret\" ovh_application_secret: file: \"./secrets/ovh_application_secret.secret\" ovh_consumer_key: file: \"./secrets/ovh_consumer_key.secret\" services: traefik: # expose the predefined secret to the container by name secrets: - \"ovh_endpoint\" - \"ovh_application_key\" - \"ovh_application_secret\" - \"ovh_consumer_key\" The environment variable within our whoami service are suffixed by _FILE which allow us to point to files containing the value, instead of exposing the value itself. The acme client will read the content of those file to get the required configuration values. environment: # expose the path to file provided by docker containing the value we want for OVH_ENDPOINT. - \"OVH_ENDPOINT_FILE=/run/secrets/ovh_endpoint\" - \"OVH_APPLICATION_KEY_FILE=/run/secrets/ovh_application_key\" - \"OVH_APPLICATION_SECRET_FILE=/run/secrets/ovh_application_secret\" - \"OVH_CONSUMER_KEY_FILE=/run/secrets/ovh_consumer_key\"","title":"Use Secrets"},{"location":"user-guides/docker-compose/acme-http/","text":"Docker-compose with let's encrypt : HTTP Challenge \u00b6 This guide aim to demonstrate how to create a certificate with the let's encrypt HTTP challenge to use https on a simple service exposed with Traefik. Please also read the basic example for details on how to expose such a service. Prerequisite \u00b6 For the HTTP challenge you will need: A publicly accessible host allowing connections on port 80 & 443 with docker & docker-compose installed. A DNS record with the domain you want to expose pointing to this host. Setup \u00b6 Create a docker-compose.yml on your remote server with the following content: version: \"3.3\" services: traefik: image: \"traefik:v2.0.0-rc3\" container_name: \"traefik\" command: #- \"--log.level=DEBUG\" - \"--api.insecure=true\" - \"--providers.docker=true\" - \"--providers.docker.exposedbydefault=false\" - \"--entrypoints.web.address=:80\" - \"--entrypoints.websecure.address=:443\" - \"--certificatesresolvers.myhttpchallenge.acme.httpchallenge=true\" - \"--certificatesresolvers.myhttpchallenge.acme.httpchallenge.entrypoint=web\" #- \"--certificatesresolvers.myhttpchallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" - \"--certificatesresolvers.myhttpchallenge.acme.email=postmaster@mydomain.com\" - \"--certificatesresolvers.myhttpchallenge.acme.storage=/letsencrypt/acme.json\" ports: - \"80:80\" - \"443:443\" - \"8080:8080\" volumes: - \"./letsencrypt:/letsencrypt\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: image: \"containous/whoami\" container_name: \"simple-service\" labels: - \"traefik.enable=true\" - \"traefik.http.routers.whoami.rule=Host(`whoami.mydomain.com`)\" - \"traefik.http.routers.whoami.entrypoints=websecure\" - \"traefik.http.routers.whoami.tls.certresolver=myhttpchallenge\" Replace postmaster@mydomain.com by your own email within the certificatesresolvers.myhttpchallenge.acme.email command line argument of the traefik service. Replace whoami.mydomain.com by your own domain within the traefik.http.routers.whoami.rule label of the whoami service. Optionally uncomment the following lines if you want to test/debug: #- \"--log.level=DEBUG\" #- \"--certificatesresolvers.myhttpchallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" Run docker-compose up -d within the folder where you created the previous file. Wait a bit and visit https://your_own_domain to confirm everything went fine. Note If you uncommented the acme.caserver line, you will get an SSL error, but if you display the certificate and see it was emitted by Fake LE Intermediate X1 then it means all is good. (It is the staging environment intermediate certificate used by let's encrypt). You can now safely comment the acme.caserver line, remove the letsencrypt/acme.json file and restart Traefik to issue a valid certificate. Explanation \u00b6 What changed between the basic example: We configure a second entry point for the HTTPS traffic: command: # Traefik will listen to incoming request on the port 443 (https) - \"--entrypoints.websecure.address=:443\" ports: - \"443:443\" We configure the HTTPS let's encrypt challenge: command: # Enable a http challenge named \"myhttpchallenge\" - \"--certificatesresolvers.myhttpchallenge.acme.httpchallenge=true\" # Tell it to use our predefined entrypoint named \"web\" - \"--certificatesresolvers.myhttpchallenge.acme.httpchallenge.entrypoint=web\" # The email to provide to let's encrypt - \"--certificatesresolvers.myhttpchallenge.acme.email=postmaster@mydomain.com\" We add a volume to store our certificates: volumes: # Create a letsencrypt dir within the folder where the docker-compose file is - \"./letsencrypt:/letsencrypt\" command: # Tell to store the certificate on a path under our volume - \"--certificatesresolvers.myhttpchallenge.acme.storage=/letsencrypt/acme.json\" We configure the whoami service to tell Traefik to use the certificate resolver named myhttpchallenge we just configured: labels: # Uses the Host rule to define which certificate to issue - \"traefik.http.routers.whoami.tls.certresolver=myhttpchallenge\"","title":"HTTP Challenge"},{"location":"user-guides/docker-compose/acme-http/#docker-compose-with-lets-encrypt-http-challenge","text":"This guide aim to demonstrate how to create a certificate with the let's encrypt HTTP challenge to use https on a simple service exposed with Traefik. Please also read the basic example for details on how to expose such a service.","title":"Docker-compose with let's encrypt : HTTP Challenge"},{"location":"user-guides/docker-compose/acme-http/#prerequisite","text":"For the HTTP challenge you will need: A publicly accessible host allowing connections on port 80 & 443 with docker & docker-compose installed. A DNS record with the domain you want to expose pointing to this host.","title":"Prerequisite"},{"location":"user-guides/docker-compose/acme-http/#setup","text":"Create a docker-compose.yml on your remote server with the following content: version: \"3.3\" services: traefik: image: \"traefik:v2.0.0-rc3\" container_name: \"traefik\" command: #- \"--log.level=DEBUG\" - \"--api.insecure=true\" - \"--providers.docker=true\" - \"--providers.docker.exposedbydefault=false\" - \"--entrypoints.web.address=:80\" - \"--entrypoints.websecure.address=:443\" - \"--certificatesresolvers.myhttpchallenge.acme.httpchallenge=true\" - \"--certificatesresolvers.myhttpchallenge.acme.httpchallenge.entrypoint=web\" #- \"--certificatesresolvers.myhttpchallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" - \"--certificatesresolvers.myhttpchallenge.acme.email=postmaster@mydomain.com\" - \"--certificatesresolvers.myhttpchallenge.acme.storage=/letsencrypt/acme.json\" ports: - \"80:80\" - \"443:443\" - \"8080:8080\" volumes: - \"./letsencrypt:/letsencrypt\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: image: \"containous/whoami\" container_name: \"simple-service\" labels: - \"traefik.enable=true\" - \"traefik.http.routers.whoami.rule=Host(`whoami.mydomain.com`)\" - \"traefik.http.routers.whoami.entrypoints=websecure\" - \"traefik.http.routers.whoami.tls.certresolver=myhttpchallenge\" Replace postmaster@mydomain.com by your own email within the certificatesresolvers.myhttpchallenge.acme.email command line argument of the traefik service. Replace whoami.mydomain.com by your own domain within the traefik.http.routers.whoami.rule label of the whoami service. Optionally uncomment the following lines if you want to test/debug: #- \"--log.level=DEBUG\" #- \"--certificatesresolvers.myhttpchallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" Run docker-compose up -d within the folder where you created the previous file. Wait a bit and visit https://your_own_domain to confirm everything went fine. Note If you uncommented the acme.caserver line, you will get an SSL error, but if you display the certificate and see it was emitted by Fake LE Intermediate X1 then it means all is good. (It is the staging environment intermediate certificate used by let's encrypt). You can now safely comment the acme.caserver line, remove the letsencrypt/acme.json file and restart Traefik to issue a valid certificate.","title":"Setup"},{"location":"user-guides/docker-compose/acme-http/#explanation","text":"What changed between the basic example: We configure a second entry point for the HTTPS traffic: command: # Traefik will listen to incoming request on the port 443 (https) - \"--entrypoints.websecure.address=:443\" ports: - \"443:443\" We configure the HTTPS let's encrypt challenge: command: # Enable a http challenge named \"myhttpchallenge\" - \"--certificatesresolvers.myhttpchallenge.acme.httpchallenge=true\" # Tell it to use our predefined entrypoint named \"web\" - \"--certificatesresolvers.myhttpchallenge.acme.httpchallenge.entrypoint=web\" # The email to provide to let's encrypt - \"--certificatesresolvers.myhttpchallenge.acme.email=postmaster@mydomain.com\" We add a volume to store our certificates: volumes: # Create a letsencrypt dir within the folder where the docker-compose file is - \"./letsencrypt:/letsencrypt\" command: # Tell to store the certificate on a path under our volume - \"--certificatesresolvers.myhttpchallenge.acme.storage=/letsencrypt/acme.json\" We configure the whoami service to tell Traefik to use the certificate resolver named myhttpchallenge we just configured: labels: # Uses the Host rule to define which certificate to issue - \"traefik.http.routers.whoami.tls.certresolver=myhttpchallenge\"","title":"Explanation"},{"location":"user-guides/docker-compose/acme-tls/","text":"Docker-compose with let's encrypt: TLS Challenge \u00b6 This guide aim to demonstrate how to create a certificate with the let's encrypt TLS challenge to use https on a simple service exposed with Traefik. Please also read the basic example for details on how to expose such a service. Prerequisite \u00b6 For the TLS challenge you will need: A publicly accessible host allowing connections on port 443 with docker & docker-compose installed. A DNS record with the domain you want to expose pointing to this host. Setup \u00b6 Create a docker-compose.yml on your remote server with the following content: version: \"3.3\" services: traefik: image: \"traefik:v2.0.0-rc3\" container_name: \"traefik\" command: #- \"--log.level=DEBUG\" - \"--api.insecure=true\" - \"--providers.docker=true\" - \"--providers.docker.exposedbydefault=false\" - \"--entrypoints.websecure.address=:443\" - \"--certificatesresolvers.mytlschallenge.acme.tlschallenge=true\" #- \"--certificatesresolvers.mytlschallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" - \"--certificatesresolvers.mytlschallenge.acme.email=postmaster@mydomain.com\" - \"--certificatesresolvers.mytlschallenge.acme.storage=/letsencrypt/acme.json\" ports: - \"443:443\" - \"8080:8080\" volumes: - \"./letsencrypt:/letsencrypt\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: image: \"containous/whoami\" container_name: \"simple-service\" labels: - \"traefik.enable=true\" - \"traefik.http.routers.whoami.rule=Host(`whoami.mydomain.com`)\" - \"traefik.http.routers.whoami.entrypoints=websecure\" - \"traefik.http.routers.whoami.tls.certresolver=mytlschallenge\" Replace postmaster@mydomain.com by your own email within the certificatesresolvers.mytlschallenge.acme.email command line argument of the traefik service. Replace whoami.mydomain.com by your own domain within the traefik.http.routers.whoami.rule label of the whoami service. Optionally uncomment the following lines if you want to test/debug: #- \"--log.level=DEBUG\" #- \"--certificatesresolvers.mytlschallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" Run docker-compose up -d within the folder where you created the previous file. Wait a bit and visit https://your_own_domain to confirm everything went fine. Note If you uncommented the acme.caserver line, you will get an SSL error, but if you display the certificate and see it was emitted by Fake LE Intermediate X1 then it means all is good. (It is the staging environment intermediate certificate used by let's encrypt). You can now safely comment the acme.caserver line, remove the letsencrypt/acme.json file and restart Traefik to issue a valid certificate. Explanation \u00b6 What changed between the basic example: We replace the web entry point by one for the https traffic: command: # Traefik will listen to incoming request on the port 443 (https) - \"--entrypoints.websecure.address=:443\" ports: - \"443:443\" We configure the Https let's encrypt challenge: command: # Enable a tls challenge named \"mytlschallenge\" - \"--certificatesresolvers.mytlschallenge.acme.tlschallenge=true\" We add a volume to store our certificates: volumes: # Create a letsencrypt dir within the folder where the docker-compose file is - \"./letsencrypt:/letsencrypt\" command: # Tell to store the certificate on a path under our volume - \"--certificatesresolvers.mytlschallenge.acme.storage=/letsencrypt/acme.json\" We configure the whoami service to tell Traefik to use the certificate resolver named mytlschallenge we just configured: labels: # Uses the Host rule to define which certificate to issue - \"traefik.http.routers.whoami.tls.certresolver=mytlschallenge\"","title":"TLS Challenge"},{"location":"user-guides/docker-compose/acme-tls/#docker-compose-with-lets-encrypt-tls-challenge","text":"This guide aim to demonstrate how to create a certificate with the let's encrypt TLS challenge to use https on a simple service exposed with Traefik. Please also read the basic example for details on how to expose such a service.","title":"Docker-compose with let's encrypt: TLS Challenge"},{"location":"user-guides/docker-compose/acme-tls/#prerequisite","text":"For the TLS challenge you will need: A publicly accessible host allowing connections on port 443 with docker & docker-compose installed. A DNS record with the domain you want to expose pointing to this host.","title":"Prerequisite"},{"location":"user-guides/docker-compose/acme-tls/#setup","text":"Create a docker-compose.yml on your remote server with the following content: version: \"3.3\" services: traefik: image: \"traefik:v2.0.0-rc3\" container_name: \"traefik\" command: #- \"--log.level=DEBUG\" - \"--api.insecure=true\" - \"--providers.docker=true\" - \"--providers.docker.exposedbydefault=false\" - \"--entrypoints.websecure.address=:443\" - \"--certificatesresolvers.mytlschallenge.acme.tlschallenge=true\" #- \"--certificatesresolvers.mytlschallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" - \"--certificatesresolvers.mytlschallenge.acme.email=postmaster@mydomain.com\" - \"--certificatesresolvers.mytlschallenge.acme.storage=/letsencrypt/acme.json\" ports: - \"443:443\" - \"8080:8080\" volumes: - \"./letsencrypt:/letsencrypt\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: image: \"containous/whoami\" container_name: \"simple-service\" labels: - \"traefik.enable=true\" - \"traefik.http.routers.whoami.rule=Host(`whoami.mydomain.com`)\" - \"traefik.http.routers.whoami.entrypoints=websecure\" - \"traefik.http.routers.whoami.tls.certresolver=mytlschallenge\" Replace postmaster@mydomain.com by your own email within the certificatesresolvers.mytlschallenge.acme.email command line argument of the traefik service. Replace whoami.mydomain.com by your own domain within the traefik.http.routers.whoami.rule label of the whoami service. Optionally uncomment the following lines if you want to test/debug: #- \"--log.level=DEBUG\" #- \"--certificatesresolvers.mytlschallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\" Run docker-compose up -d within the folder where you created the previous file. Wait a bit and visit https://your_own_domain to confirm everything went fine. Note If you uncommented the acme.caserver line, you will get an SSL error, but if you display the certificate and see it was emitted by Fake LE Intermediate X1 then it means all is good. (It is the staging environment intermediate certificate used by let's encrypt). You can now safely comment the acme.caserver line, remove the letsencrypt/acme.json file and restart Traefik to issue a valid certificate.","title":"Setup"},{"location":"user-guides/docker-compose/acme-tls/#explanation","text":"What changed between the basic example: We replace the web entry point by one for the https traffic: command: # Traefik will listen to incoming request on the port 443 (https) - \"--entrypoints.websecure.address=:443\" ports: - \"443:443\" We configure the Https let's encrypt challenge: command: # Enable a tls challenge named \"mytlschallenge\" - \"--certificatesresolvers.mytlschallenge.acme.tlschallenge=true\" We add a volume to store our certificates: volumes: # Create a letsencrypt dir within the folder where the docker-compose file is - \"./letsencrypt:/letsencrypt\" command: # Tell to store the certificate on a path under our volume - \"--certificatesresolvers.mytlschallenge.acme.storage=/letsencrypt/acme.json\" We configure the whoami service to tell Traefik to use the certificate resolver named mytlschallenge we just configured: labels: # Uses the Host rule to define which certificate to issue - \"traefik.http.routers.whoami.tls.certresolver=mytlschallenge\"","title":"Explanation"},{"location":"user-guides/docker-compose/basic-example/","text":"Docker-compose basic example \u00b6 In this section we quickly go over a basic docker-compose file exposing a simple service using the docker provider. This will also be used as a starting point for the the other docker-compose guides. Setup \u00b6 Edit a docker-compose.yml file with the following content: version: \"3.3\" services: traefik: image: \"traefik:v2.0.0-rc3\" container_name: \"traefik\" command: #- \"--log.level=DEBUG\" - \"--api.insecure=true\" - \"--providers.docker=true\" - \"--providers.docker.exposedbydefault=false\" - \"--entrypoints.web.address=:80\" ports: - \"80:80\" - \"8080:8080\" volumes: - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: image: \"containous/whoami\" container_name: \"simple-service\" labels: - \"traefik.enable=true\" - \"traefik.http.routers.whoami.rule=Host(`whoami.localhost`)\" - \"traefik.http.routers.whoami.entrypoints=web\" Replace whoami.localhost by your own domain within the traefik.http.routers.whoami.rule label of the whoami service. Run docker-compose up -d within the folder where you created the previous file. Wait a bit and visit http://your_own_domain to confirm everything went fine. You should see the output of the whoami service. Something similar to: Hostname: d7f919e54651 IP: 127.0.0.1 IP: 192.168.64.2 GET / HTTP/1.1 Host: whoami.localhost User-Agent: curl/7.52.1 Accept: */* Accept-Encoding: gzip X-Forwarded-For: 192.168.64.1 X-Forwarded-Host: whoami.localhost X-Forwarded-Port: 80 X-Forwarded-Proto: http X-Forwarded-Server: 7f0c797dbc51 X-Real-Ip: 192.168.64.1 Details \u00b6 As an example we use whoami (a tiny Go server that prints os information and HTTP request to output) which was used to define our simple-service container. We define an entry point, along with the exposure of the matching port within docker-compose, which basically allow us to \"open and accept\" HTTP traffic: command: # Traefik will listen to incoming request on the port 80 (HTTP) - \"--entrypoints.web.address=:80\" ports: - \"80:80\" We expose the Traefik API to be able to check the configuration if needed: command: # Traefik will listen on port 8080 by default for API request. - \"--api.insecure=true\" ports: - \"8080:8080\" Note If you are working on a remote server, you can use the following command to display configuration (require curl & jq ): curl -s 127.0.0.1:8080/api/rawdata | jq . We allow Traefik to gather configuration from Docker: traefik: command: # Enabling docker provider - \"--providers.docker=true\" # Do not expose containers unless explicitly told so - \"--providers.docker.exposedbydefault=false\" volumes: - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: labels: # Explicitly tell Traefik to expose this container - \"traefik.enable=true\" # The domain the service will respond to - \"traefik.http.routers.whoami.rule=Host(`whoami.localhost`)\" # Allow request only from the predefined entry point named \"web\" - \"traefik.http.routers.whoami.entrypoints=web\"","title":"Basic Example"},{"location":"user-guides/docker-compose/basic-example/#docker-compose-basic-example","text":"In this section we quickly go over a basic docker-compose file exposing a simple service using the docker provider. This will also be used as a starting point for the the other docker-compose guides.","title":"Docker-compose basic example"},{"location":"user-guides/docker-compose/basic-example/#setup","text":"Edit a docker-compose.yml file with the following content: version: \"3.3\" services: traefik: image: \"traefik:v2.0.0-rc3\" container_name: \"traefik\" command: #- \"--log.level=DEBUG\" - \"--api.insecure=true\" - \"--providers.docker=true\" - \"--providers.docker.exposedbydefault=false\" - \"--entrypoints.web.address=:80\" ports: - \"80:80\" - \"8080:8080\" volumes: - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: image: \"containous/whoami\" container_name: \"simple-service\" labels: - \"traefik.enable=true\" - \"traefik.http.routers.whoami.rule=Host(`whoami.localhost`)\" - \"traefik.http.routers.whoami.entrypoints=web\" Replace whoami.localhost by your own domain within the traefik.http.routers.whoami.rule label of the whoami service. Run docker-compose up -d within the folder where you created the previous file. Wait a bit and visit http://your_own_domain to confirm everything went fine. You should see the output of the whoami service. Something similar to: Hostname: d7f919e54651 IP: 127.0.0.1 IP: 192.168.64.2 GET / HTTP/1.1 Host: whoami.localhost User-Agent: curl/7.52.1 Accept: */* Accept-Encoding: gzip X-Forwarded-For: 192.168.64.1 X-Forwarded-Host: whoami.localhost X-Forwarded-Port: 80 X-Forwarded-Proto: http X-Forwarded-Server: 7f0c797dbc51 X-Real-Ip: 192.168.64.1","title":"Setup"},{"location":"user-guides/docker-compose/basic-example/#details","text":"As an example we use whoami (a tiny Go server that prints os information and HTTP request to output) which was used to define our simple-service container. We define an entry point, along with the exposure of the matching port within docker-compose, which basically allow us to \"open and accept\" HTTP traffic: command: # Traefik will listen to incoming request on the port 80 (HTTP) - \"--entrypoints.web.address=:80\" ports: - \"80:80\" We expose the Traefik API to be able to check the configuration if needed: command: # Traefik will listen on port 8080 by default for API request. - \"--api.insecure=true\" ports: - \"8080:8080\" Note If you are working on a remote server, you can use the following command to display configuration (require curl & jq ): curl -s 127.0.0.1:8080/api/rawdata | jq . We allow Traefik to gather configuration from Docker: traefik: command: # Enabling docker provider - \"--providers.docker=true\" # Do not expose containers unless explicitly told so - \"--providers.docker.exposedbydefault=false\" volumes: - \"/var/run/docker.sock:/var/run/docker.sock:ro\" whoami: labels: # Explicitly tell Traefik to expose this container - \"traefik.enable=true\" # The domain the service will respond to - \"traefik.http.routers.whoami.rule=Host(`whoami.localhost`)\" # Allow request only from the predefined entry point named \"web\" - \"traefik.http.routers.whoami.entrypoints=web\"","title":"Details"}]}